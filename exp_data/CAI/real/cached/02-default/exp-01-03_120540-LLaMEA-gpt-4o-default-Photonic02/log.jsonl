{"id": "a5cf603e-6e42-4839-a404-e8b065f2c527", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 20\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        \n    def update_particles(self):\n        r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n        social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_component + social_component\n        self.positions += self.velocities\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n            \n            self.update_particles()\n            self.inertia = 0.9 - 0.5 * (evaluations / self.budget)  # Adapt inertia over time", "name": "AdaptivePSO", "description": "A Particle Swarm Optimization (PSO) inspired algorithm with adaptive inertia and dynamic neighborhood exploration to efficiently search complex photonic design spaces.", "configspace": "", "generation": 0, "fitness": 0.7267534686376449, "feedback": "The algorithm AdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.04.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7679375815241825, 0.6855693557511072]}, "mutation_prompt": null}
{"id": "9a642863-f06d-49a7-b82e-48ca2ead3812", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 20\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.local_search_prob = 0.1  # Probability of performing local search\n        self.local_search_radius = 0.1  # Radius for local search exploration\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        \n    def update_particles(self):\n        r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n        social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_component + social_component\n        self.positions += self.velocities\n    \n    def local_search(self, func, particle_index):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        local_pos = self.positions[particle_index] + np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)\n        local_pos = np.clip(local_pos, lb, ub)  # Ensure within bounds\n        score = func(local_pos)\n        return local_pos, score\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n                # Perform local search with some probability\n                if np.random.rand() < self.local_search_prob and evaluations < self.budget:\n                    local_pos, local_score = self.local_search(func, i)\n                    evaluations += 1\n                    if local_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_score\n                        self.personal_best_positions[i] = local_pos\n                    if local_score < self.global_best_score:\n                        self.global_best_score = local_score\n                        self.global_best_position = local_pos\n\n            self.update_particles()\n            self.inertia = 0.9 - 0.5 * (evaluations / self.budget)  # Adapt inertia over time", "name": "EnhancedAdaptivePSO", "description": "Enhanced Adaptive PSO with Local Search Exploration introduces random local search steps to boost convergence in complex photonic design spaces.", "configspace": "", "generation": 1, "fitness": 0.7312979556811703, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.04.", "error": "", "parent_id": "a5cf603e-6e42-4839-a404-e8b065f2c527", "metadata": {"aucs": [0.7762499917424048, 0.6863459196199357]}, "mutation_prompt": null}
{"id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "solution": "import numpy as np\n\nclass DynamicPSOWithAdaptiveLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 20\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.local_search_prob = 0.1  # Probability of performing local search\n        self.initial_local_search_radius = 0.1  # Initial radius for local search exploration\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        \n    def update_particles(self):\n        r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n        social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_component + social_component\n        self.positions += self.velocities\n    \n    def adaptive_local_search(self, func, particle_index, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Decrease the local search radius dynamically as evaluations increase\n        local_search_radius = self.initial_local_search_radius * (1 - evaluations / self.budget)\n        local_pos = self.positions[particle_index] + np.random.uniform(-local_search_radius, local_search_radius, self.dim)\n        local_pos = np.clip(local_pos, lb, ub)  # Ensure within bounds\n        score = func(local_pos)\n        return local_pos, score\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n                # Perform local search with some probability\n                if np.random.rand() < self.local_search_prob and evaluations < self.budget:\n                    local_pos, local_score = self.adaptive_local_search(func, i, evaluations)\n                    evaluations += 1\n                    if local_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_score\n                        self.personal_best_positions[i] = local_pos\n                    if local_score < self.global_best_score:\n                        self.global_best_score = local_score\n                        self.global_best_position = local_pos\n\n            self.update_particles()\n            self.inertia = 0.9 - 0.5 * (evaluations / self.budget)  # Adapt inertia over time", "name": "DynamicPSOWithAdaptiveLocalSearch", "description": "Dynamic Particle Swarm Optimization with Adaptive Local Search leverages adaptive inertia and dynamic local search radii to enhance convergence and exploration efficiency in complex photonic structure optimization.", "configspace": "", "generation": 2, "fitness": 0.7720012624142205, "feedback": "The algorithm DynamicPSOWithAdaptiveLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.03.", "error": "", "parent_id": "9a642863-f06d-49a7-b82e-48ca2ead3812", "metadata": {"aucs": [0.745977962891178, 0.7980245619372631]}, "mutation_prompt": null}
{"id": "c37cf418-7923-464c-9482-ab56e46788be", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 20\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.quantum_search_prob = 0.1  # Probability of performing quantum-inspired local search\n        self.quantum_amplitude_initial = 0.1  # Initial amplitude for quantum exploration\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        \n    def update_particles(self):\n        r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n        social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_component + social_component\n        self.positions += self.velocities\n    \n    def quantum_inspired_search(self, func, particle_index, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Adjust amplitude as evaluations increase\n        amplitude = self.quantum_amplitude_initial * (1 - evaluations / self.budget)\n        # Simulate quantum superposition with probabilistic local exploration\n        quantum_pos = self.positions[particle_index] + np.random.choice([-1, 1], self.dim) * np.random.rand(self.dim) * amplitude\n        quantum_pos = np.clip(quantum_pos, lb, ub)  # Ensure within bounds\n        score = func(quantum_pos)\n        return quantum_pos, score\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n                # Perform quantum-inspired local search with some probability\n                if np.random.rand() < self.quantum_search_prob and evaluations < self.budget:\n                    quantum_pos, quantum_score = self.quantum_inspired_search(func, i, evaluations)\n                    evaluations += 1\n                    if quantum_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = quantum_score\n                        self.personal_best_positions[i] = quantum_pos\n                    if quantum_score < self.global_best_score:\n                        self.global_best_score = quantum_score\n                        self.global_best_position = quantum_pos\n\n            self.update_particles()\n            self.inertia = 0.9 - 0.5 * (evaluations / self.budget)  # Adapt inertia over time", "name": "QuantumInspiredPSO", "description": "Quantum-Inspired PSO leverages quantum superposition principles to introduce probabilistic local search with adaptive amplitude, enhancing exploration and balance in optimizing complex photonic structures.", "configspace": "", "generation": 3, "fitness": 0.770326139141646, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.01.", "error": "", "parent_id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "metadata": {"aucs": [0.761275884699421, 0.7793763935838711]}, "mutation_prompt": null}
{"id": "6745f929-01bf-404a-83c8-4ac205da0dda", "solution": "import numpy as np\n\nclass QuantumInspiredEAWithEntanglement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_qubits = 50\n        self.pop_size = 20\n        self.population = None\n        self.qbits = None\n        self.best_solution = None\n        self.best_score = float('inf')\n        self.rotation_angle = np.pi / 4\n        self.entanglement_prob = 0.2\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.pop_size, self.dim))\n        self.qbits = np.random.uniform(0, np.pi, (self.num_qubits, self.dim))\n\n    def measure_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                prob = np.sin(self.qbits[i % self.num_qubits, j])**2\n                self.population[i, j] = lb[j] + (ub[j] - lb[j]) * (prob if np.random.rand() < prob else 1 - prob)\n\n    def update_qbits(self, candidate, best_candidate, bounds):\n        for j in range(self.dim):\n            if candidate[j] < best_candidate[j]:\n                self.qbits[:, j] += self.rotation_angle\n            else:\n                self.qbits[:, j] -= self.rotation_angle\n            self.qbits[:, j] = np.clip(self.qbits[:, j], 0, np.pi)\n\n    def entanglement(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        entangled_pairs = np.random.choice(self.pop_size, (self.pop_size // 2, 2), replace=False)\n        for (i, j) in entangled_pairs:\n            if np.random.rand() < self.entanglement_prob:\n                avg_position = (self.population[i] + self.population[j]) / 2\n                self.population[i] = np.clip(avg_position + np.random.uniform(-0.1, 0.1, self.dim), lb, ub)\n                self.population[j] = np.clip(avg_position - np.random.uniform(-0.1, 0.1, self.dim), lb, ub)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.measure_population(func.bounds)\n            scores = np.array([func(individual) for individual in self.population])\n            evaluations += self.pop_size\n\n            best_index = np.argmin(scores)\n            if scores[best_index] < self.best_score:\n                self.best_score = scores[best_index]\n                self.best_solution = self.population[best_index].copy()\n\n            for i in range(self.pop_size):\n                self.update_qbits(self.population[i], self.best_solution, func.bounds)\n\n            self.entanglement(func.bounds)\n\n            if evaluations >= self.budget:\n                break", "name": "QuantumInspiredEAWithEntanglement", "description": "Quantum-inspired Evolutionary Algorithm (QEA) with Multi-faceted Entanglement leverages quantum bits and entanglement mechanisms to explore and exploit complex photonic structures through probabilistic interference.", "configspace": "", "generation": 4, "fitness": 0.49545514216338576, "feedback": "The algorithm QuantumInspiredEAWithEntanglement got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.01.", "error": "", "parent_id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "metadata": {"aucs": [0.5096370106746896, 0.48127327365208195]}, "mutation_prompt": null}
{"id": "ff2f055e-08cd-47e8-94df-3d8f77376616", "solution": "import numpy as np\n\nclass QuantumEnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 20\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.local_search_prob = 0.1  # Probability of performing local search\n        self.initial_local_search_radius = 0.1  # Initial radius for local search exploration\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        \n    def update_particles(self):\n        r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n        social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_component + social_component\n        quantum_particles = self.positions + np.random.uniform(-1, 1, self.positions.shape) * self.velocities\n        self.positions = np.clip(quantum_particles, func.bounds.lb, func.bounds.ub)\n    \n    def adaptive_local_search(self, func, particle_index, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Decrease the local search radius dynamically as evaluations increase\n        local_search_radius = self.initial_local_search_radius * (1 - evaluations / self.budget)\n        local_pos = self.positions[particle_index] + np.random.uniform(-local_search_radius, local_search_radius, self.dim)\n        local_pos = np.clip(local_pos, lb, ub)  # Ensure within bounds\n        score = func(local_pos)\n        return local_pos, score\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n                # Perform local search with some probability\n                if np.random.rand() < self.local_search_prob and evaluations < self.budget:\n                    local_pos, local_score = self.adaptive_local_search(func, i, evaluations)\n                    evaluations += 1\n                    if local_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_score\n                        self.personal_best_positions[i] = local_pos\n                    if local_score < self.global_best_score:\n                        self.global_best_score = local_score\n                        self.global_best_position = local_pos\n\n            self.update_particles()\n            # Adapt inertia and coefficients over time for better exploration-exploitation balance\n            self.inertia = 0.9 - 0.5 * (evaluations / self.budget)\n            self.cognitive_coeff = 2.0 - 1.0 * (evaluations / self.budget)\n            self.social_coeff = 2.0 + 1.0 * (evaluations / self.budget)", "name": "QuantumEnhancedDynamicPSO", "description": "Quantum-Enhanced Dynamic PSO incorporates quantum-inspired position updates and adaptive coefficients to improve precision and convergence speed in photonic structure optimization.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "metadata": {}, "mutation_prompt": null}
{"id": "4feb0901-b73e-4adb-ba96-5cac96369cbb", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 20\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.local_search_prob = 0.1  # Probability of performing local search\n        self.initial_local_search_radius = 0.1  # Initial radius for local search exploration\n        self.q_coefficient = 0.1  # Coefficient for quantum-inspired exploration\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        \n    def update_particles(self):\n        r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n        social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n        quantum_jump = self.q_coefficient * (np.random.rand(self.num_particles, self.dim) - 0.5) * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_component + social_component + quantum_jump\n        self.positions += self.velocities\n    \n    def adaptive_local_search(self, func, particle_index, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        local_search_radius = self.initial_local_search_radius * (1 - evaluations / self.budget)\n        local_pos = self.positions[particle_index] + np.random.uniform(-local_search_radius, local_search_radius, self.dim)\n        local_pos = np.clip(local_pos, lb, ub)  # Ensure within bounds\n        score = func(local_pos)\n        return local_pos, score\n        \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n                if np.random.rand() < self.local_search_prob and evaluations < self.budget:\n                    local_pos, local_score = self.adaptive_local_search(func, i, evaluations)\n                    evaluations += 1\n                    if local_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_score\n                        self.personal_best_positions[i] = local_pos\n                    if local_score < self.global_best_score:\n                        self.global_best_score = local_score\n                        self.global_best_position = local_pos\n\n            self.update_particles()\n            self.inertia = 0.9 - 0.5 * (evaluations / self.budget)", "name": "QuantumInspiredDynamicPSO", "description": "Quantum-Inspired Dynamic PSO introduces quantum superposition states to enhance exploration capabilities and convergence speed in optimizing complex photonic structures.", "configspace": "", "generation": 6, "fitness": 0.5301945357812606, "feedback": "The algorithm QuantumInspiredDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.07.", "error": "", "parent_id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "metadata": {"aucs": [0.6046566348647979, 0.45573243669772334]}, "mutation_prompt": null}
{"id": "2b4eb5ea-4e7e-46c5-8877-37cba163039b", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_individuals = 20\n        self.q_population = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.alpha = 0.02  # Rotation angle parameter\n    \n    def initialize_population(self):\n        self.q_population = np.random.rand(self.num_individuals, self.dim) * 2 * np.pi  # Initialize quantum angles\n    \n    def measure(self):\n        # Convert quantum bits to binary solutions\n        return np.random.rand(self.num_individuals, self.dim) < 0.5 * (1 + np.sin(self.q_population))\n    \n    def update_quantum_population(self, measured_population, scores):\n        for i in range(self.num_individuals):\n            for d in range(self.dim):\n                prob_0 = 0.5 * (1 + np.sin(self.q_population[i, d]))\n                if measured_population[i, d] == 0:\n                    rotation_direction = 1 if np.random.rand() > prob_0 else -1\n                else:\n                    rotation_direction = -1 if np.random.rand() > prob_0 else 1\n                # Update quantum population using a rotation gate\n                self.q_population[i, d] += rotation_direction * self.alpha\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            measured_population = self.measure()\n            scores = np.array([func(measured_population[i]) for i in range(self.num_individuals)])\n            evaluations += self.num_individuals\n            \n            # Update best solution found\n            for i in range(self.num_individuals):\n                if scores[i] < self.best_score:\n                    self.best_score = scores[i]\n                    self.best_position = measured_population[i]\n            \n            self.update_quantum_population(measured_population, scores)", "name": "QuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm (QEA) utilizes quantum bit representation and a novel rotation gate updating strategy to explore and exploit photonic structure optimization effectively.", "configspace": "", "generation": 7, "fitness": 0.29357394788892793, "feedback": "The algorithm QuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "metadata": {"aucs": [0.2935005877017216, 0.29364730807613426]}, "mutation_prompt": null}
{"id": "7372a462-b124-484c-9bda-845bf1737d06", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        # Apply quantum-inspired mutation to introduce diversity\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveMutation", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation Rate utilizes quantum principles to enhance search diversity and adaptively adjusts mutation rates for improved optimization in photonic structure scenarios.", "configspace": "", "generation": 8, "fitness": 0.8910811756401005, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.00.", "error": "", "parent_id": "d75ac692-ea95-4362-bff5-3a96b75aefbe", "metadata": {"aucs": [0.8866916824375026, 0.8954706688426982]}, "mutation_prompt": null}
{"id": "d2f92c3f-5b23-429b-ad6e-756f7f61c6e4", "solution": "import numpy as np\n\nclass BioInspiredSwarmWithAdaptiveChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.chaos_factor = 0.1\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n    \n    def adaptive_chaos_search(self, individual):\n        chaos_perturbation = (np.random.rand(self.dim) - 0.5) * 2\n        chaotic_individual = individual + self.chaos_factor * chaos_perturbation\n        return chaotic_individual\n    \n    def update_velocities_and_positions(self, func):\n        w = 0.5  # inertia weight\n        c1, c2 = 1.5, 1.5  # acceleration coefficients\n        \n        for i in range(self.swarm_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_component = c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n            social_component = c2 * r2 * (self.global_best_position - self.positions[i])\n            self.velocities[i] = w * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n    \n    def evaluate_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.positions[i])\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = np.copy(self.positions[i])\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = np.copy(self.positions[i])\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.update_velocities_and_positions(func)\n            self.evaluate_swarm(func)\n            evaluations += self.swarm_size\n            \n            # Adaptive chaotic search for enhanced exploration\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                chaotic_position = self.adaptive_chaos_search(self.positions[i])\n                chaotic_position = np.clip(chaotic_position, func.bounds.lb, func.bounds.ub)\n                chaotic_score = func(chaotic_position)\n                evaluations += 1\n                \n                if chaotic_score < self.global_best_score:\n                    self.global_best_score = chaotic_score\n                    self.global_best_position = chaotic_position\n            \n            # Adjust chaos factor based on progress\n            self.chaos_factor *= (1 - evaluations / self.budget)", "name": "BioInspiredSwarmWithAdaptiveChaos", "description": "Bio-Inspired Swarm Intelligence with Adaptive Chaotic Search leverages principles of swarm behavior with adaptive chaotic perturbations to enhance global exploration and fine-tune solutions in photonic optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "210f5c4b-afac-4c32-9a31-d3c56190f0a1", "solution": "import numpy as np\n\nclass QuantumAnnealedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def update_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.clip(self.positions, lb, ub)\n    \n    def quantum_tunneling(self, position):\n        tunneling_probability = np.exp(-self.global_best_score / self.temperature)\n        if np.random.rand() < tunneling_probability:\n            return position + np.random.normal(0, 0.1, self.dim)\n        return position\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] + \n                                      cognitive_component + \n                                      social_component)\n                \n                self.positions[i] += self.velocities[i]\n                self.update_positions(func.bounds)\n                \n                # Apply quantum tunneling\n                new_position = self.quantum_tunneling(self.positions[i])\n                new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n                new_score = func(new_position)\n                evaluations += 1\n                \n                if new_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = new_score\n                    self.personal_best_positions[i] = new_position\n                \n                if new_score < self.global_best_score:\n                    self.global_best_score = new_score\n                    self.global_best_position = new_position\n                \n                # Cooling schedule for simulated annealing\n                self.temperature *= 0.99", "name": "QuantumAnnealedSwarmOptimizer", "description": "Quantum-Annealed Swarm Optimization integrates quantum tunneling concepts with swarm intelligence, allowing particles to escape local optima and adaptively tune search parameters for effective optimization of photonic structures.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "bc08651b-b068-4862-b7d4-c1e5c35c2a0d", "solution": "import numpy as np\n\nclass AdaptivePredatorPreyOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.predator_ratio = 0.2\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.learning_rate = 0.1\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def predator_prey_interaction(self, func, evaluations):\n        predators_count = int(self.population_size * self.predator_ratio)\n        predators_idx = np.random.choice(self.population_size, predators_count, replace=False)\n        prey_idx = [i for i in range(self.population_size) if i not in predators_idx]\n        \n        for predator in predators_idx:\n            if evaluations >= self.budget:\n                break\n            for prey in prey_idx:\n                if evaluations >= self.budget:\n                    break\n                \n                # Predator hunts prey\n                movement_vector = self.positions[predator] - self.positions[prey]\n                self.positions[prey] += self.learning_rate * movement_vector\n                self.positions[prey] = np.clip(self.positions[prey], func.bounds.lb, func.bounds.ub)\n                \n                prey_score = func(self.positions[prey])\n                evaluations += 1\n                \n                if prey_score < self.best_score:\n                    self.best_score = prey_score\n                    self.best_position = self.positions[prey]\n\n                    # Swap roles if prey is stronger (better score)\n                    self.positions[predator], self.positions[prey] = self.positions[prey], self.positions[predator]\n    \n    def adaptive_learning(self, individual, bounds, evaluations):\n        learning_step = self.learning_rate * (1 - evaluations / self.budget)\n        adjustment = np.random.normal(0, learning_step, self.dim)\n        individual += adjustment\n        individual = np.clip(individual, bounds.lb, bounds.ub)\n        return individual\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.predator_prey_interaction(func, evaluations)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adaptive learning phase\n                new_position = self.adaptive_learning(self.positions[i], func.bounds, evaluations)\n                new_score = func(new_position)\n                evaluations += 1\n                \n                if new_score < self.best_score:\n                    self.best_score = new_score\n                    self.best_position = new_position\n                \n                # Update if better\n                if new_score < func(self.positions[i]):\n                    self.positions[i] = new_position", "name": "AdaptivePredatorPreyOptimization", "description": "Adaptive Predator-Prey Optimization mimics ecological interactions by dynamically adjusting predator-prey roles and using adaptive learning to explore complex photonic structure landscapes.", "configspace": "", "generation": 11, "fitness": 0.7265885183009542, "feedback": "The algorithm AdaptivePredatorPreyOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.09.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8137508760601991, 0.6394261605417091]}, "mutation_prompt": null}
{"id": "61e6e066-2a63-450a-8878-29c61b53c714", "solution": "import numpy as np\n\nclass QuantumAnnealingAssistedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_annealing_update(self, position, global_best):\n        q_anneal_factor = np.random.normal(0, 1, self.dim)\n        new_position = position + q_anneal_factor * (global_best - position)\n        return new_position\n    \n    def particle_swarm_optimization(self, func, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_velocity = self.cognitive_coefficient * r1 * (self.best_positions[i] - self.positions[i])\n            social_velocity = self.social_coefficient * r2 * (self.global_best_position - self.positions[i])\n            self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            score = func(self.positions[i])\n            evaluations += 1\n            \n            if score < self.best_scores[i]:\n                self.best_scores[i] = score\n                self.best_positions[i] = self.positions[i]\n            \n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.positions[i]\n        \n        return evaluations\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            evaluations = self.particle_swarm_optimization(func, evaluations)\n            \n            # Quantum annealing inspired global update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                new_position = self.quantum_annealing_update(self.positions[i], self.global_best_position)\n                new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n                new_score = func(new_position)\n                evaluations += 1\n                \n                if new_score < self.best_scores[i]:\n                    self.best_scores[i] = new_score\n                    self.best_positions[i] = new_position\n                \n                if new_score < self.global_best_score:\n                    self.global_best_score = new_score\n                    self.global_best_position = new_position", "name": "QuantumAnnealingAssistedPSO", "description": "Quantum Annealing Assisted Particle Swarm Optimization (QAAPSO) combines principles of quantum annealing with particle swarm dynamics to enhance global exploration and convergence efficiency in optimizing photonic structures.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "22aaf317-5765-451b-a933-c1401118d72f", "solution": "import numpy as np\n\nclass QuantumEnhancedDEWithAdaptiveQuantumWalks:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_walk(self, individual):\n        # Apply a quantum-inspired walk to explore new areas\n        step_size = np.random.normal(0, 1, self.dim)\n        walk = np.sign(np.random.rand(self.dim) - 0.5) * step_size\n        new_position = individual + self.mutation_factor * walk\n        return new_position\n\n    def adaptive_mutation_factor(self, evaluations):\n        # Adjust mutation factor based on evaluation progress\n        return self.initial_mutation_factor * (1 - evaluations / self.budget)\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.adaptive_mutation_factor(evaluations)\n        \n        # Enhanced exploration with quantum walks\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            quantum_position = self.quantum_walk(self.positions[i])\n            quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n            quantum_score = func(quantum_position)\n            evaluations += 1\n            \n            if quantum_score < self.best_score:\n                self.best_score = quantum_score\n                self.best_position = quantum_position", "name": "QuantumEnhancedDEWithAdaptiveQuantumWalks", "description": "Quantum-Enhanced Differential Evolution with Adaptive Quantum Walks enhances diversity by integrating quantum walks with adaptive mutation and crossover, boosting exploration in photonic structure optimization.", "configspace": "", "generation": 13, "fitness": 0.7650390140585441, "feedback": "The algorithm QuantumEnhancedDEWithAdaptiveQuantumWalks got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7696127870017172, 0.760465241115371]}, "mutation_prompt": null}
{"id": "4efde0f2-a361-4626-8c7d-192d2b2cb2cc", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = np.zeros((self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best_positions = np.zeros((self.population_size, self.dim))\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.9   # Inertia weight\n        \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        \n    def adaptive_learning_coefficients(self, evaluations):\n        t = evaluations / self.budget\n        self.c1 = 2.5 - 1.5 * t\n        self.c2 = 0.5 + 1.5 * t\n        self.w = 0.9 - 0.7 * t\n        \n    def quantum_inspired_update(self):\n        quantum_bit = np.random.rand(self.population_size, self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        self.positions += quantum_flip\n        \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_score = func(self.positions[i])\n                evaluations += 1\n                \n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = current_score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = self.positions[i]\n        \n                # Update velocities and positions\n                self.adaptive_learning_coefficients(evaluations)\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                \n                # Bound handling\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n                \n            # Quantum-inspired global update\n            self.quantum_inspired_update()\n            self.positions = np.clip(self.positions, func.bounds.lb, func.bounds.ub)\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveQuantumInspiredPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization (AQIPSO) combines quantum principles and particle swarm behavior with adaptive learning coefficients for efficient exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 14, "fitness": 0.601398322879586, "feedback": "The algorithm AdaptiveQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6234948020188709, 0.579301843740301]}, "mutation_prompt": null}
{"id": "763994c0-821a-472c-868d-4e4406c94995", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_fraction = 0.1  # Fraction of population considered as elite\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        # Apply quantum-inspired mutation to introduce diversity\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n\n    def elite_preservation(self, evaluations):\n        # Preserve elite solutions with adaptive selection\n        elite_size = int(self.elite_fraction * self.population_size)\n        evaluations = np.array([func(self.positions[i]) for i in range(self.population_size)])\n        elite_indices = evaluations.argsort()[:elite_size]\n        return elite_indices\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        # Create mutant vector and trial vector\n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            elite_indices = self.elite_preservation(evaluations)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Ensure elite preservation\n                if i in elite_indices:\n                    continue\n\n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "HybridQuantumInspiredDE", "description": "Hybrid Quantum-Inspired Differential Evolution with Elite Preservation Strategy combines quantum principles for diversity, adaptive mutation, and preserves elite solutions to enhance convergence in optimizing photonic structures.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "261306af-8bfc-4dab-9bfa-8d5199e8a8dd", "solution": "import numpy as np\n\nclass HybridQuantumAnnealingWithAdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.annealing_rate = 0.99\n        self.simplex_size = 5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.simplex_size, self.dim))\n    \n    def quantum_annealing_step(self, individual, temperature):\n        quantum_flip = np.random.normal(0, temperature, self.dim)\n        return individual + quantum_flip\n    \n    def adaptive_nelder_mead(self, func, evaluations):\n        alpha, gamma, rho, sigma = 1, 2, 0.5, 0.5\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        scores = np.array([func(pos) for pos in self.positions])\n        evaluations += self.simplex_size\n        \n        while evaluations < self.budget:\n            # Order according to scores\n            idx = np.argsort(scores)\n            self.positions = self.positions[idx]\n            scores = scores[idx]\n            \n            centroid = np.mean(self.positions[:-1], axis=0)\n            # Reflection\n            reflection = centroid + alpha * (centroid - self.positions[-1])\n            reflection = np.clip(reflection, lb, ub)\n            reflection_score = func(reflection)\n            evaluations += 1\n            \n            if reflection_score < scores[0]:\n                # Expansion\n                expansion = centroid + gamma * (reflection - centroid)\n                expansion = np.clip(expansion, lb, ub)\n                expansion_score = func(expansion)\n                evaluations += 1\n                \n                if expansion_score < reflection_score:\n                    self.positions[-1] = expansion\n                    scores[-1] = expansion_score\n                else:\n                    self.positions[-1] = reflection\n                    scores[-1] = reflection_score\n            elif reflection_score < scores[-2]:\n                self.positions[-1] = reflection\n                scores[-1] = reflection_score\n            else:\n                # Contraction\n                contraction = centroid + rho * (self.positions[-1] - centroid)\n                contraction = np.clip(contraction, lb, ub)\n                contraction_score = func(contraction)\n                evaluations += 1\n                \n                if contraction_score < scores[-1]:\n                    self.positions[-1] = contraction\n                    scores[-1] = contraction_score\n                else:\n                    # Shrink\n                    for j in range(1, self.simplex_size):\n                        self.positions[j] = self.positions[0] + sigma * (self.positions[j] - self.positions[0])\n                        self.positions[j] = np.clip(self.positions[j], lb, ub)\n                        scores[j] = func(self.positions[j])\n                    evaluations += self.simplex_size - 1\n            \n            if scores[0] < self.best_score:\n                self.best_score = scores[0]\n                self.best_position = self.positions[0]\n            \n            # Break if meeting the budget\n            if evaluations >= self.budget:\n                break\n        \n        return evaluations\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        temperature = 1.0\n        \n        while evaluations < self.budget:\n            for i in range(self.simplex_size):\n                if evaluations >= self.budget:\n                    break\n                \n                new_position = self.quantum_annealing_step(self.positions[i], temperature)\n                new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n                new_score = func(new_position)\n                evaluations += 1\n                \n                if new_score < self.best_score:\n                    self.best_score = new_score\n                    self.best_position = new_position\n                \n                if new_score < func(self.positions[i]):\n                    self.positions[i] = new_position\n            \n            evaluations = self.adaptive_nelder_mead(func, evaluations)\n            temperature *= self.annealing_rate", "name": "HybridQuantumAnnealingWithAdaptiveNelderMead", "description": "Hybrid Quantum Annealing with Adaptive Nelder-Mead combines quantum annealing principles and adaptive Nelder-Mead simplex adjustments for exploring and exploiting the solution space efficiently in photonic structure optimization.", "configspace": "", "generation": 16, "fitness": 0.7077350230555639, "feedback": "The algorithm HybridQuantumAnnealingWithAdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.28.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.4276170376394818, 0.9878530084716459]}, "mutation_prompt": null}
{"id": "3ea24d2a-2b05-4eba-9f4f-642c5bd626a6", "solution": "import numpy as np\n\nclass HybridPSOQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.inertia_weight = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def pso_update(self, func, idx):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                self.cognitive_weight * r1 * (self.personal_best_positions[idx] - self.positions[idx]) +\n                                self.social_weight * r2 * (self.best_position - self.positions[idx]))\n        \n        self.positions[idx] = np.clip(self.positions[idx] + self.velocities[idx], func.bounds.lb, func.bounds.ub)\n        current_score = func(self.positions[idx])\n        \n        if current_score < self.personal_best_scores[idx]:\n            self.personal_best_scores[idx] = current_score\n            self.personal_best_positions[idx] = self.positions[idx].copy()\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # PSO update\n                self.pso_update(func, i)\n                evaluations += 1\n                \n                if self.personal_best_scores[i] < self.best_score:\n                    self.best_score = self.personal_best_scores[i]\n                    self.best_position = self.personal_best_positions[i].copy()\n                \n                # Differential Evolution update\n                trial_vector, trial_score = self.differential_evolution(func, i)\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                evaluations += 1\n\n        # Final Quantum-inspired mutation\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "HybridPSOQuantumDE", "description": "Hybrid Particle Swarm Optimization with Quantum-Inspired Differential Evolution enhances exploration by combining swarm intelligence and quantum principles for efficient optimization in photonic structures.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "12cc39c4-e4e8-4892-bdf1-3770873d3002", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_stochastic_walk(self, individual, bounds):\n        step_size = np.random.normal(0, 0.1, self.dim)\n        quantum_step = individual + step_size\n        return np.clip(quantum_step, bounds.lb, bounds.ub)\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget // 2:\n                self.crossover_rate = 0.9  # Increase crossover rate in later stages\n                self.population_size = max(10, self.population_size - 1)  # Dynamic resizing\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n\n        # Quantum-inspired global search with stochastic walk\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_stochastic_walk(self.positions[i], func.bounds)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired DE integrates stochastic quantum walk and dynamic population resizing to bolster exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 18, "fitness": 0.7650390140585441, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7696127870017172, 0.760465241115371]}, "mutation_prompt": null}
{"id": "a1896a9a-17ca-413a-9a69-83588e299cbc", "solution": "import numpy as np\n\nclass QuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 1.49618  # cognitive parameter\n        self.c2 = 1.49618  # social parameter\n        self.w = 0.7298    # inertia weight\n\n    def initialize_positions_and_velocities(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n\n    def quantum_operator(self, particle_position, global_best):\n        # Introduce quantum behavior by pulling particles closer to the global best\n        quantum_step = np.random.uniform(-1, 1, self.dim) * np.log(1 + np.abs(global_best - particle_position))\n        return particle_position + quantum_step\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n            social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n    def __call__(self, func):\n        self.initialize_positions_and_velocities(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            self.update_velocities_and_positions(func.bounds)\n\n            # Apply quantum operator occasionally to enhance exploration\n            if evaluations % (self.population_size // 2) == 0:\n                for i in range(self.population_size):\n                    quantum_position = self.quantum_operator(self.positions[i], self.global_best_position)\n                    quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n                    quantum_score = func(quantum_position)\n                    evaluations += 1\n\n                    if quantum_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = quantum_score\n                        self.personal_best_positions[i] = quantum_position\n\n                    if quantum_score < self.global_best_score:\n                        self.global_best_score = quantum_score\n                        self.global_best_position = quantum_position", "name": "QuantumEnhancedPSO", "description": "Hybrid Quantum-Enhanced Particle Swarm Optimization combines quantum-inspired mechanisms and adaptive search strategies to improve exploration and exploitation for optimized photonic structure configurations.", "configspace": "", "generation": 19, "fitness": 0.7703107604509696, "feedback": "The algorithm QuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.07.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.835492918612014, 0.7051286022899252]}, "mutation_prompt": null}
{"id": "c7f77861-4b49-423e-a7ae-48a10ca59d9d", "solution": "import numpy as np\n\nclass QuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.positions = None\n        self.velocities = None\n        self.pbest_positions = None\n        self.pbest_scores = None\n        self.gbest_position = None\n        self.gbest_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest_positions = np.copy(self.positions)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_superposition(self, position):\n        # Introduce quantum superposition to enhance exploration\n        superposition = np.random.rand(self.dim) * (np.random.choice([-1, 1], self.dim))\n        return position + superposition\n    \n    def update_velocity_and_position(self, func, idx, w):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = self.c1 * r1 * (self.pbest_positions[idx] - self.positions[idx])\n        social_velocity = self.c2 * r2 * (self.gbest_position - self.positions[idx])\n        new_velocity = w * self.velocities[idx] + cognitive_velocity + social_velocity\n        new_position = self.positions[idx] + new_velocity\n        \n        # Apply quantum superposition to the new position\n        quantum_position = self.quantum_superposition(new_position)\n        quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n        \n        return new_velocity, quantum_position, func(quantum_position)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                new_velocity, new_position, new_score = self.update_velocity_and_position(func, i, w)\n                evaluations += 1\n                \n                if new_score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = new_score\n                    self.pbest_positions[i] = new_position\n                \n                if new_score < self.gbest_score:\n                    self.gbest_score = new_score\n                    self.gbest_position = new_position\n                \n                self.velocities[i] = new_velocity\n                self.positions[i] = new_position", "name": "QuantumEnhancedPSO", "description": "Quantum-Enhanced Particle Swarm Optimization combines quantum superposition principles to boost exploration and employs adaptive velocity scaling for convergence control in photonic structure optimization.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "b7045bdb-54f1-499f-a40a-308b750f4a81", "solution": "import numpy as np\n\nclass QuantumCooperativeSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.position = None\n        self.velocity = None\n        self.best_personal_position = None\n        self.best_global_position = None\n        self.best_score = float('inf')\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.best_personal_position = np.copy(self.position)\n        self.best_global_position = np.copy(self.position[0])\n    \n    def quantum_flip(self, position, bounds):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        flipped_position = position + 0.1 * quantum_flip\n        return np.clip(flipped_position, bounds.lb, bounds.ub)\n    \n    def update_velocity_position(self, particle_idx):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = self.cognitive_coeff * r1 * (self.best_personal_position[particle_idx] - self.position[particle_idx])\n        social_velocity = self.social_coeff * r2 * (self.best_global_position - self.position[particle_idx])\n        \n        self.velocity[particle_idx] = self.inertia_weight * self.velocity[particle_idx] + cognitive_velocity + social_velocity\n        self.position[particle_idx] += self.velocity[particle_idx]\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.position[i] = np.clip(self.position[i], func.bounds.lb, func.bounds.ub)\n                score = func(self.position[i])\n                evaluations += 1\n                \n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_global_position = self.position[i]\n                \n                if score < func(self.best_personal_position[i]):\n                    self.best_personal_position[i] = self.position[i]\n                \n                self.update_velocity_position(i)\n            \n            # Quantum-inspired cooperative behavior\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                    \n                quantum_position = self.quantum_flip(self.position[i], func.bounds)\n                quantum_score = func(quantum_position)\n                evaluations += 1\n                \n                if quantum_score < self.best_score:\n                    self.best_score = quantum_score\n                    self.best_global_position = quantum_position", "name": "QuantumCooperativeSwarmOptimization", "description": "Quantum-Cooperative Swarm Optimization (QCSO) combines quantum-inspired particle swarm behavior with cooperative learning to efficiently navigate complex landscapes for optimizing photonic structures.", "configspace": "", "generation": 21, "fitness": 0.7383285577308443, "feedback": "The algorithm QuantumCooperativeSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.07.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8071571394391636, 0.669499976022525]}, "mutation_prompt": null}
{"id": "f1d59fc6-4d97-4232-b3db-5880cd6dfbf5", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumWalks:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def quantum_walk(self, individual, bounds):\n        step_size = self.mutation_factor * (np.random.rand(self.dim) - 0.5)\n        new_position = individual + step_size\n        new_position = np.clip(new_position, bounds.lb, bounds.ub)\n        return new_position\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            quantum_position = self.quantum_walk(self.positions[i], func.bounds)\n            quantum_score = func(quantum_position)\n            evaluations += 1\n            \n            if quantum_score < self.best_score:\n                self.best_score = quantum_score\n                self.best_position = quantum_position", "name": "QuantumInspiredDEWithAdaptiveQuantumWalks", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Walks integrates quantum walks to exploit local optima and further enhances mutation adaptability for superior optimization in photonic structure designs.", "configspace": "", "generation": 22, "fitness": 0.796558905056582, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumWalks got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8099507913976768, 0.7831670187154871]}, "mutation_prompt": null}
{"id": "10c84fc8-250c-4579-a2a0-7ea2d40ba6d6", "solution": "import numpy as np\n\nclass AdaptiveSwarmWithQuantumSpin:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 40\n        self.personal_best_positions = None\n        self.global_best_position = None\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_score = float('inf')\n        self.velocities = None\n        self.positions = None\n        self.inertia_weight = 0.9\n        self.cognitive_constant = 2.0\n        self.social_constant = 2.0\n        self.quantum_spin_constant = 0.05\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n    \n    def update_velocities_and_positions(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        for i in range(self.swarm_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_velocity = self.cognitive_constant * r1 * (self.personal_best_positions[i] - self.positions[i])\n            social_velocity = self.social_constant * r2 * (self.global_best_position - self.positions[i])\n            self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n            \n            # Quantum spin-inspired update\n            spin_flip_probability = np.random.rand(self.dim) < self.quantum_spin_constant\n            self.velocities[i] += spin_flip_probability * np.random.uniform(-1, 1, self.dim)\n            \n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], lb, ub)\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                \n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n            \n            self.update_velocities_and_positions(func)\n            \n            # Adapt inertia weight\n            self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget", "name": "AdaptiveSwarmWithQuantumSpin", "description": "Adaptive Swarm Intelligence with Quantum Spin Dynamics leverages swarm-based optimization with quantum spin-inspired dynamics for enhanced exploration and adaptive learning in global optimization of photonic structures.", "configspace": "", "generation": 23, "fitness": 0.6288753414211707, "feedback": "The algorithm AdaptiveSwarmWithQuantumSpin got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6304110732786725, 0.6273396095636689]}, "mutation_prompt": null}
{"id": "331fb8f4-f14a-4336-9a14-261b16daf71b", "solution": "import numpy as np\n\nclass QuantumInspiredDESwarmEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.velocities = None\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n\n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive_velocity = self.cognitive_coeff * r1 * (self.best_position - self.positions[i])\n            social_velocity = self.social_coeff * r2 * (self.best_position - self.positions[i])\n            \n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  cognitive_velocity + social_velocity)\n            self.positions[i] = np.clip(self.positions[i] + self.velocities[i],\n                                        func.bounds.lb, func.bounds.ub)\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n\n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n\n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n\n            # Enhance exploration-exploitation by updating velocities and positions\n            self.update_velocities_and_positions()\n\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n\n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n\n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDESwarmEnhanced", "description": "Quantum-Inspired DE with Swarm Enhancements integrates particle swarm principles for dynamic exploration-exploitation balance in photonic optimization.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "bb60a6b4-46b5-4cdb-b58d-fb97fc48aa15", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveMutationAndDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.min_population_size = 10\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n\n                # Dynamic population adjustment\n                if evaluations % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                    self.population_size -= 1\n                    self.positions = self.positions[:self.population_size]\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveMutationAndDynamicPopulation", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation and Dynamic Population utilizes quantum principles with dynamic population size adjustment and adaptive mutation for enhanced optimization in photonic structures.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "24eb3120-8b5e-4632-97f8-02d892cc05c0", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def adaptive_quantum_inspired_perturbation(self, individual):\n        # Enhanced adaptive quantum-inspired perturbation\n        perturbation_strength = self.mutation_factor * np.exp(-self.best_score)\n        quantum_bit = np.random.rand(self.dim) < perturbation_strength\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        perturbed_individual = individual + perturbation_strength * quantum_flip\n        return perturbed_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search with enhanced perturbation\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            perturbed_position = self.adaptive_quantum_inspired_perturbation(self.positions[i])\n            perturbed_position = np.clip(perturbed_position, func.bounds.lb, func.bounds.ub)\n            perturbed_score = func(perturbed_position)\n            evaluations += 1\n            \n            if perturbed_score < self.best_score:\n                self.best_score = perturbed_score\n                self.best_position = perturbed_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Quantum-Inspired Perturbation improves exploration and exploitation by dynamically integrating quantum-inspired perturbation, enhancing efficiency in challenging photonic structure optimization.", "configspace": "", "generation": 26, "fitness": 0.7269319424903782, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7002545207000154, 0.753609364280741]}, "mutation_prompt": null}
{"id": "dc4f4967-79f1-495a-b2cc-8c2cd29bf519", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.swarm_influence_factor = 0.1\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.velocities = None\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def swarm_based_reinforcement(self, individual):\n        return individual + self.swarm_influence_factor * (self.best_position - individual)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                \n                # Swarm-based reinforcement\n                self.positions[i] = self.swarm_based_reinforcement(self.positions[i])\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "HybridQuantumInspiredDE", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Mutation and Swarm-Based Reinforcement incorporates swarm intelligence principles to enhance convergence by reinforcing promising search areas while retaining quantum-inspired diversity and adaptive mutation strategies.", "configspace": "", "generation": 27, "fitness": 0.814844997119365, "feedback": "The algorithm HybridQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.04.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7798401208433576, 0.8498498733953723]}, "mutation_prompt": null}
{"id": "dc35a0ca-3adf-4db8-afe8-1b9b9b16a5e1", "solution": "import numpy as np\n\nclass QuantumParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.copy(self.positions[0])\n\n    def update_velocities_and_positions(self, func):\n        r1, r2 = np.random.rand(2, self.population_size, self.dim)\n        for i in range(self.population_size):\n            cognitive_velocity = self.cognitive_component * r1[i] * (self.personal_best_positions[i] - self.positions[i])\n            social_velocity = self.social_component * r2[i] * (self.global_best_position - self.positions[i])\n            self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n\n    def quantum_position_update(self):\n        for i in range(self.population_size):\n            random_pos = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n            offset = np.random.rand(self.dim) < 0.5\n            self.positions[i] = offset * self.positions[i] + (1 - offset) * random_pos\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n            self.update_velocities_and_positions(func)\n        \n        # Perform a quantum position update to exploit and explore\n        self.quantum_position_update()\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n\n            score = func(self.positions[i])\n            evaluations += 1\n            \n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.positions[i]", "name": "QuantumParticleSwarmOptimization", "description": "Quantum Particle Swarm Optimization (QPSO) leverages quantum mechanics-based position updating and adaptive particle interactions to optimize photonic structures efficiently.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "d4f1f4ab-c606-49be-88ad-cb1953ea9583", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.mutation_factor = self.initial_mutation_factor\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual, diversity_factor):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, diversity_factor, -diversity_factor)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def entropy_based_adaptive_diversity(self):\n        population_entropy = np.mean(np.std(self.positions, axis=0))\n        diversity_factor = min(1, max(0.1, 1 - population_entropy))\n        return diversity_factor\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                diversity_factor = self.entropy_based_adaptive_diversity()\n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n            \n            # Dynamically adjust population size\n            if evaluations > self.budget * 0.5 and self.population_size > 10:\n                self.population_size -= 1\n                self.positions = self.positions[:self.population_size]\n        \n        # Final quantum-inspired exploration\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            diversity_factor = self.entropy_based_adaptive_diversity()\n            mutated_position = self.quantum_inspired_mutation(self.positions[i], diversity_factor)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution incorporates dynamic population resizing and entropy-based exploration to improve convergence in photonic structure optimization.", "configspace": "", "generation": 29, "fitness": 0.7562418623081832, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7309863646285963, 0.7814973599877701]}, "mutation_prompt": null}
{"id": "df8b6596-df54-4b44-8124-6127fa760a1b", "solution": "import numpy as np\n\nclass QuantumSwarmAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.velocity = None\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        # Apply quantum-inspired mutation to introduce diversity\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, np.random.uniform(-1, 1, self.dim), 0)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def adaptive_swarm_update(self, best_global_position, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive_velocity = self.cognitive_constant * r1 * (self.best_position - self.positions[idx])\n        social_velocity = self.social_constant * r2 * (best_global_position - self.positions[idx])\n        self.velocity[idx] = (self.inertia_weight * self.velocity[idx] + \n                              cognitive_velocity + \n                              social_velocity)\n        self.positions[idx] += self.velocity[idx]\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n            \n            # Use swarm intelligence to update positions\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.adaptive_swarm_update(self.best_position, i)\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_position = self.positions[i]\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumSwarmAdaptiveDE", "description": "Quantum Swarm Adaptive Differential Evolution integrates quantum behavior and adaptive swarm intelligence principles to enhance exploration and exploitation for optimizing photonic structures.", "configspace": "", "generation": 30, "fitness": 0.5171589416083311, "feedback": "The algorithm QuantumSwarmAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.10.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6135705592887813, 0.4207473239278807]}, "mutation_prompt": null}
{"id": "61b1eb06-582e-414c-9a55-13af46ccf9cb", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.initial_crossover_rate = 0.7\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def adaptive_quantum_crossover(self, target, mutant):\n        quantum_bit = np.random.rand(self.dim) < self.crossover_rate\n        crossover_individual = np.where(quantum_bit, mutant, target)\n        return crossover_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = self.adaptive_quantum_crossover(self.positions[target_idx], mutant_vector)\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation and crossover factors based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                self.crossover_rate = self.initial_crossover_rate * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveQuantumCrossover", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum-Inspired Crossover leverages quantum principles to enhance both mutation and crossover operations, dynamically tuning crossover rate based on convergence progress for superior photonic structure optimization.", "configspace": "", "generation": 31, "fitness": 0.86973351084841, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8444521362579454, 0.8950148854388746]}, "mutation_prompt": null}
{"id": "c21b8960-46f1-49b6-aec9-cf8500de862c", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumRotation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_inspired_mutation(self, individual, progress_ratio):\n        # Introduce quantum rotation that adapts based on progress\n        quantum_rotation_factor = 1 - progress_ratio\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        rotated_individual = individual + self.mutation_factor * quantum_rotation_factor * quantum_flip\n        return rotated_individual\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            progress_ratio = evaluations / self.budget\n            mutated_position = self.quantum_inspired_mutation(self.positions[i], progress_ratio)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveQuantumRotation", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Rotation Strategy enhances search efficiency by integrating adaptive quantum rotation, which dynamically adjusts search direction based on current progress, for improved photonic structure optimization.", "configspace": "", "generation": 32, "fitness": 0.7594910294266211, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumRotation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7397453694852569, 0.7792366893679851]}, "mutation_prompt": null}
{"id": "9167e0e8-d70a-47b3-8d60-a7e8ff749487", "solution": "import numpy as np\n\nclass AdaptiveQuantumMimicryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mimicry_factor = 0.5\n        self.diversification_factor = 0.1\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def mimicry_step(self, base, others):\n        # Select top performers for mimicry\n        best_indices = np.argsort([o[1] for o in others])[:3]\n        chosen = others[np.random.choice(best_indices)][0]\n        mimic_vector = base + self.mimicry_factor * (chosen - base)\n        return mimic_vector\n\n    def quantum_diversification(self, candidate):\n        # Apply quantum-inspired diversification\n        quantum_flip = np.random.choice([-1, 1], self.dim)\n        diversified_candidate = candidate + self.diversification_factor * quantum_flip\n        return diversified_candidate\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        scores = [func(pos) for pos in self.positions]\n        evaluations += self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                base = self.positions[i]\n                other_positions = [(self.positions[j], scores[j]) for j in range(self.population_size) if j != i]\n                mimic_position = self.mimicry_step(base, other_positions)\n                \n                mimic_position = np.clip(mimic_position, func.bounds.lb, func.bounds.ub)\n                mimic_score = func(mimic_position)\n                evaluations += 1\n\n                # Update position if improved\n                if mimic_score < scores[i]:\n                    self.positions[i] = mimic_position\n                    scores[i] = mimic_score\n                \n                # Adaptive diversification based on progress\n                self.diversification_factor = 0.1 * (1 - evaluations / self.budget)\n                \n                # Introduce quantum diversification\n                diversified_position = self.quantum_diversification(self.positions[i])\n                diversified_position = np.clip(diversified_position, func.bounds.lb, func.bounds.ub)\n                diversified_score = func(diversified_position)\n                evaluations += 1\n                \n                if diversified_score < self.best_score:\n                    self.best_score = diversified_score\n                    self.best_position = diversified_position\n\n        return self.best_position", "name": "AdaptiveQuantumMimicryOptimization", "description": "Adaptive Quantum Mimicry Optimization (AQMO) combines adaptive learning from successful solutions with quantum-inspired diversification to tackle the optimization of photonic structures.", "configspace": "", "generation": 33, "fitness": 0.6264446342589757, "feedback": "The algorithm AdaptiveQuantumMimicryOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6571731300349601, 0.5957161384829912]}, "mutation_prompt": null}
{"id": "cbda05ac-3ad4-4b0f-8fa9-e918188824f9", "solution": "import numpy as np\n\nclass WavefunctionCollapseOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.entropy_weights = np.ones(dim)\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def collapse_wavefunction(self, individual, weights):\n        # Wavefunction collapse inspired perturbation\n        probabilities = weights / weights.sum()\n        perturbation = np.random.choice([-1, 1], size=self.dim, p=[0.5, 0.5])\n        collapsed_position = individual + probabilities * perturbation\n        return collapsed_position\n    \n    def evolutionary_step(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        # Differential evolution inspired mutation\n        mutant_vector = self.positions[a] + 0.8 * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < 0.9\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        trial_score = func(trial_vector)\n        return trial_vector, trial_score\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.evolutionary_step(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n\n                    # Adjust entropy weights based on improvement\n                    self.entropy_weights = np.maximum(self.entropy_weights * 0.9, 0.1)\n                else:\n                    self.entropy_weights = np.minimum(self.entropy_weights * 1.1, 1.0)\n        \n        # Final wavefunction collapse inspired exploration\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            collapsed_position = self.collapse_wavefunction(self.positions[i], self.entropy_weights)\n            collapsed_position = np.clip(collapsed_position, func.bounds.lb, func.bounds.ub)\n            collapsed_score = func(collapsed_position)\n            evaluations += 1\n            \n            if collapsed_score < self.best_score:\n                self.best_score = collapsed_score\n                self.best_position = collapsed_position", "name": "WavefunctionCollapseOptimization", "description": "Wavefunction Collapse Optimization (WCO) combines principles from wavefunction collapse in quantum mechanics with evolutionary strategies to achieve efficient convergence in global optimization tasks.", "configspace": "", "generation": 34, "fitness": 0.7825617829560034, "feedback": "The algorithm WavefunctionCollapseOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.05.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7354679445701159, 0.8296556213418909]}, "mutation_prompt": null}
{"id": "1b1098d8-b77d-411d-8c3b-273c7bde610d", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithHybridSelection:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions_and_velocities(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions_and_velocities(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                \n                # Hybrid selection incorporating velocities\n                inertia_weight = 0.729  # PSO-inspired inertia weight\n                cognitive_component = 1.494 * np.random.rand(self.dim) * (self.best_position - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithHybridSelection", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation and Hybrid Selection integrates quantum-inspired mutations with a hybrid selection strategy, combining differential evolution and particle swarm optimization concepts to enhance convergence and solution robustness for photonic structures.", "configspace": "", "generation": 35, "fitness": 0.7978744804524003, "feedback": "The algorithm QuantumInspiredDEWithHybridSelection got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7856434131904425, 0.8101055477143579]}, "mutation_prompt": null}
{"id": "5db25568-b237-4797-bff6-a2810f44da4e", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.tunneling_probability = 0.1\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        # Apply quantum-inspired mutation to introduce diversity\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def adaptive_quantum_tunneling(self, individual, eval_ratio):\n        # Adaptive quantum tunneling to escape local optima\n        if np.random.rand() < self.tunneling_probability * (1 - eval_ratio):\n            tunneling_step = (np.random.rand(self.dim) - 0.5) * (self.best_position - individual)\n            return individual + tunneling_step\n        return individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - eval_ratio)\n        \n        # Quantum-inspired global search with tunneling for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            tunneled_position = self.adaptive_quantum_tunneling(mutated_position, eval_ratio)\n            tunneled_position = np.clip(tunneled_position, func.bounds.lb, func.bounds.ub)\n            tunneled_score = func(tunneled_position)\n            evaluations += 1\n            \n            if tunneled_score < self.best_score:\n                self.best_score = tunneled_score\n                self.best_position = tunneled_position", "name": "QuantumInspiredDEWithAdaptiveTunneling", "description": "Quantum-Inspired DE with Adaptive Quantum Tunneling leverages dynamic mutation strategies and quantum tunneling to escape local optima and enhance convergence in photonic structure optimization.", "configspace": "", "generation": 36, "fitness": 0.7675392599281003, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7721092415409789, 0.7629692783152219]}, "mutation_prompt": null}
{"id": "7c7a5107-6c08-4e47-a8f9-89bf2218e484", "solution": "import numpy as np\n\nclass QuantumAugmentedPSOWithAdaptiveInertia:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 2.0\n        self.social_const = 2.0\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n    \n    def update_positions_and_velocities(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_velocity = self.cognitive_const * r1 * (self.best_positions[i] - self.positions[i])\n            social_velocity = self.social_const * r2 * (self.global_best_position - self.positions[i])\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], lb, ub)\n    \n    def quantum_position_update(self):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        quantum_adjustment = quantum_flip * (self.global_best_position - self.positions)\n        self.positions += 0.05 * quantum_adjustment\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                    \n                current_score = func(self.positions[i])\n                evaluations += 1\n                \n                if current_score < self.best_scores[i]:\n                    self.best_scores[i] = current_score\n                    self.best_positions[i] = self.positions[i]\n                \n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = self.positions[i]\n            \n            self.update_positions_and_velocities(func)\n            \n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - (0.8 * (evaluations / self.budget))\n        \n        # Final quantum-enhanced search\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            self.quantum_position_update()\n            quantum_score = func(self.positions[i])\n            evaluations += 1\n            \n            if quantum_score < self.global_best_score:\n                self.global_best_score = quantum_score\n                self.global_best_position = self.positions[i]", "name": "QuantumAugmentedPSOWithAdaptiveInertia", "description": "Quantum-Augmented Particle Swarm Optimization with Adaptive Inertia introduces quantum-inspired position updates and adapts inertia weights dynamically to enhance convergence in photonic structure optimization.", "configspace": "", "generation": 37, "fitness": 0.7288885907444296, "feedback": "The algorithm QuantumAugmentedPSOWithAdaptiveInertia got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7007996983136284, 0.7569774831752306]}, "mutation_prompt": null}
{"id": "cd90b162-26c2-479d-aece-65d948e4694e", "solution": "import numpy as np\n\nclass HybridQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n    \n    def quantum_inspired_perturbation(self, particle):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        perturbed_particle = particle + self.inertia_weight * quantum_flip\n        return perturbed_particle\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                \n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                    \n                # Update velocities and positions\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coefficient * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coefficient * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                \n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], func.bounds.lb, func.bounds.ub)\n            \n            # Quantum-inspired perturbation for global exploration\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                \n                perturbed_position = self.quantum_inspired_perturbation(self.positions[i])\n                perturbed_position = np.clip(perturbed_position, func.bounds.lb, func.bounds.ub)\n                perturbed_score = func(perturbed_position)\n                evaluations += 1\n                \n                if perturbed_score < self.global_best_score:\n                    self.global_best_score = perturbed_score\n                    self.global_best_position = perturbed_position", "name": "HybridQuantumInspiredPSO", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization integrates quantum principles with adaptive swarm behavior for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 38, "fitness": 0.7120721006917896, "feedback": "The algorithm HybridQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7103752613952979, 0.7137689399882812]}, "mutation_prompt": null}
{"id": "2fc0630e-e21b-44b9-8a46-cf8622e9f48a", "solution": "import numpy as np\nimport pywt\n\nclass QuantumHarmonySearchWithWavelet:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 30\n        self.harmony_consideration_rate = 0.9\n        self.pitch_adjustment_rate = 0.1\n        self.wavelet_family = 'db1'  # Daubechies(1) wavelet transformation\n        self.memory = None\n        self.best_solution = None\n        self.best_score = float('inf')\n        \n    def initialize_memory(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n    \n    def wavelet_transform(self, solution):\n        coeffs = pywt.wavedec(solution, self.wavelet_family, level=1)\n        transformed_solution = pywt.waverec(coeffs, self.wavelet_family)\n        return transformed_solution[:self.dim]\n    \n    def quantum_harmony_search(self, func, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        new_solution = np.zeros(self.dim)\n        \n        for i in range(self.dim):\n            if np.random.rand() < self.harmony_consideration_rate:\n                new_solution[i] = self.memory[np.random.randint(self.harmony_memory_size), i]\n                if np.random.rand() < self.pitch_adjustment_rate:\n                    new_solution[i] += np.random.uniform(-0.1, 0.1) * (ub[i] - lb[i])\n            else:\n                new_solution[i] = np.random.uniform(lb[i], ub[i])\n        \n        new_solution = np.clip(new_solution, lb, ub)\n        new_solution = self.wavelet_transform(new_solution)\n        new_solution = np.clip(new_solution, lb, ub)\n        \n        new_score = func(new_solution)\n        evaluations += 1\n        \n        if new_score < self.best_score:\n            self.best_score = new_score\n            self.best_solution = new_solution\n        \n        # Update memory\n        worst_idx = np.argmax([func(self.memory[j]) for j in range(self.harmony_memory_size)])\n        if new_score < func(self.memory[worst_idx]):\n            self.memory[worst_idx] = new_solution\n        \n        return evaluations\n    \n    def __call__(self, func):\n        self.initialize_memory(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            evaluations = self.quantum_harmony_search(func, evaluations)", "name": "QuantumHarmonySearchWithWavelet", "description": "Quantum Harmony Search with Wavelet Transformation leverages a harmony search framework enhanced by wavelet transformations to improve exploration and exploitation in global optimization of photonic structures.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'pywt'\").", "error": "ModuleNotFoundError(\"No module named 'pywt'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "0e7b2df6-652b-4088-a341-9c0c38e47811", "solution": "import numpy as np\n\nclass QuantumInspiredPSOWithAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.729\n        self.cognitive_coefficient = 1.49445\n        self.social_coefficient = 1.49445\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.velocities = None\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n\n    def initialize_positions_and_velocities(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(lb - ub, ub - lb, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n\n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n\n    def adaptive_differential_evolution(self, target_idx, evaluations, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n\n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        trial_vector = np.clip(trial_vector, lb, ub)\n\n        return trial_vector, func(trial_vector)\n\n    def __call__(self, func):\n        self.initialize_positions_and_velocities(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # PSO velocity and position update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      self.cognitive_coefficient * r1 * (self.personal_best_positions[i] - self.positions[i]) +\n                                      self.social_coefficient * r2 * (self.best_position - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n\n                current_score = func(self.positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = current_score\n                    self.personal_best_positions[i] = np.copy(self.positions[i])\n\n                # Update global best\n                if current_score < self.best_score:\n                    self.best_score = current_score\n                    self.best_position = np.copy(self.positions[i])\n\n                # Adaptive DE refinement\n                trial_vector, trial_score = self.adaptive_differential_evolution(i, evaluations, func)\n                evaluations += 1\n                if trial_score < current_score:\n                    self.positions[i] = trial_vector\n                    current_score = trial_score\n\n                # Adjust mutation factor\n                self.mutation_factor = 0.5 * (1 - evaluations / self.budget)\n\n        # Quantum-inspired global mutation for final exploration\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredPSOWithAdaptiveDE", "description": "Quantum-Inspired Particle Swarm with Adaptive Differential Mutation combines quantum-inspired swarm intelligence and adaptive differential evolution to enhance exploration and convergence capabilities in photonic structure optimization.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "996e6bad-a373-416a-a7dc-ae25f6f9706b", "solution": "import numpy as np\n\nclass PSOWithQuantumTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.quantum_tunneling_probability = 0.1\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n    \n    def update_velocity(self, i):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_component = self.cognitive_coefficient * r1 * (self.personal_best_positions[i] - self.positions[i])\n        social_component = self.social_coefficient * r2 * (self.best_position - self.positions[i])\n        self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                              cognitive_component + social_component)\n    \n    def quantum_tunneling(self, position, bounds):\n        if np.random.rand() < self.quantum_tunneling_probability:\n            lb, ub = bounds.lb, bounds.ub\n            # Quantum tunneling effect to escape local optima\n            new_position = np.random.uniform(lb, ub, self.dim)\n            return new_position\n        return position\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.update_velocity(i)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n                \n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_position = self.positions[i]\n            \n            # Quantum tunneling step for all particles\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                tunneled_position = self.quantum_tunneling(self.positions[i], func.bounds)\n                tunneled_score = func(tunneled_position)\n                evaluations += 1\n                \n                if tunneled_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = tunneled_score\n                    self.personal_best_positions[i] = tunneled_position\n                \n                if tunneled_score < self.best_score:\n                    self.best_score = tunneled_score\n                    self.best_position = tunneled_position", "name": "PSOWithQuantumTunneling", "description": "Particle Swarm Optimization with Quantum Tunneling for Enhanced Exploration integrates quantum tunneling to escape local optima and boost exploration in photonic structure optimization.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "b472c1ac-0c59-4338-9f0f-fe9b90800152", "solution": "import numpy as np\n\nclass SwarmInspiredQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def update_velocity_and_position(self):\n        inertia_weight = 0.5\n        cognitive_weight = 1.5\n        social_weight = 1.5\n        \n        for i in range(self.population_size):\n            cognitive_component = cognitive_weight * np.random.rand(self.dim) * (self.personal_best_positions[i] - self.positions[i])\n            social_component = social_weight * np.random.rand(self.dim) * (self.best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] = np.clip(self.positions[i] + self.velocities[i], func.bounds.lb, func.bounds.ub)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n            \n            self.update_velocity_and_position()\n            \n            self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "SwarmInspiredQuantumDE", "description": "Swarm-Inspired Quantum Differential Evolution enhances convergence by integrating particle swarm intelligence concepts with quantum mutation and adaptive mutation rate for efficient optimization of photonic structures.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "9dd37a36-f7a8-4965-a256-755e7c1f083b", "solution": "import numpy as np\n\nclass QuantumSwarmEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n    \n    def quantum_swarm_update(self, individual, personal_best):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        velocity_update = (self.inertia_weight * self.velocities[individual] + \n                           self.cognitive_coefficient * np.random.rand(self.dim) * (personal_best - self.positions[individual]) +\n                           self.social_coefficient * np.random.rand(self.dim) * (self.global_best_position - self.positions[individual]))\n        quantum_influence = quantum_flip * self.mutation_factor\n        new_velocity = velocity_update + quantum_influence\n        return new_velocity\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        personal_bests = self.positions.copy()\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Differential Evolution step\n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n\n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n\n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                    if trial_score < personal_best_scores[i]:\n                        personal_bests[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n\n                # Quantum-Swarm update\n                self.velocities[i] = self.quantum_swarm_update(i, personal_bests[i])\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n\n                # Update global best\n                if personal_best_scores[i] < self.global_best_score:\n                    self.global_best_score = personal_best_scores[i]\n                    self.global_best_position = personal_bests[i]", "name": "QuantumSwarmEnhancedDE", "description": "Quantum-Swarm Enhanced Differential Evolution synergizes principles from quantum computing and swarm intelligence to dynamically adapt search strategies for optimizing photonic structures.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "5554a38e-298a-47e8-bac5-72c2d66f2711", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.tunneling_probability = 0.1\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def adaptive_quantum_tunneling(self, individual, evaluations):\n        probability = self.tunneling_probability * (1 - evaluations / self.budget)\n        if np.random.rand() < probability:\n            tunnel_shift = np.random.normal(0, 1, self.dim)\n            return individual + tunnel_shift\n        return individual\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Adaptive quantum tunneling for enhanced exploration\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            tunneled_position = self.adaptive_quantum_tunneling(self.positions[i], evaluations)\n            tunneled_position = np.clip(tunneled_position, func.bounds.lb, func.bounds.ub)\n            tunneled_score = func(tunneled_position)\n            evaluations += 1\n            \n            if tunneled_score < self.best_score:\n                self.best_score = tunneled_score\n                self.best_position = tunneled_position", "name": "QuantumInspiredDEWithAdaptiveQuantumTunneling", "description": "Quantum-Inspired DE with Adaptive Quantum Tunneling employs adaptive quantum tunneling alongside differential evolution to enhance exploration and convergence for optimizing photonic structures.", "configspace": "", "generation": 44, "fitness": 0.784457083141315, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8056741966059832, 0.7632399696766469]}, "mutation_prompt": null}
{"id": "8c07292b-f755-4f8d-9b1e-b98a562df140", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.velocities = None\n        self.initial_population_size = 30\n        self.alpha = 0.5  # quantum-inspired update factor\n\n    def initialize_positions_and_velocities(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n    def adaptive_population_size(self, evaluations):\n        return max(5, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n    def quantum_swarm_update(self, global_best, individual_best, position):\n        quantum_prob = np.random.rand(self.dim)\n        position_update = np.where(\n            quantum_prob < 0.5,\n            position + self.alpha * (individual_best - position),\n            position + self.alpha * (global_best - position)\n        )\n        return position_update\n\n    def __call__(self, func):\n        self.initialize_positions_and_velocities(func.bounds)\n        evaluations = 0\n        individual_best_positions = np.copy(self.positions)\n        individual_best_scores = np.full(self.population_size, np.inf)\n\n        while evaluations < self.budget:\n            current_population_size = self.adaptive_population_size(evaluations)\n            for i in range(current_population_size):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < individual_best_scores[i]:\n                    individual_best_scores[i] = score\n                    individual_best_positions[i] = self.positions[i]\n\n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_position = self.positions[i]\n\n                # Quantum-inspired position update\n                self.positions[i] = self.quantum_swarm_update(\n                    self.best_position, individual_best_positions[i], self.positions[i])\n\n                # Ensure the new position is within bounds\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)", "name": "AdaptiveQuantumSwarmOptimization", "description": "Adaptive Quantum Swarm Optimization (AQSO) leverages adaptive quantum-inspired position updates and dynamic population resizing for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 45, "fitness": 0.7694428365932384, "feedback": "The algorithm AdaptiveQuantumSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.14.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.9109348280958196, 0.6279508450906572]}, "mutation_prompt": null}
{"id": "9c4653c4-f16f-4af4-93bc-e88887228e0b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def entropic_diversification(self, individual):\n        diversity_factor = np.random.rand(self.dim)\n        entropic_individual = individual + self.mutation_factor * (diversity_factor - 0.5)\n        return entropic_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position\n            \n            # Entropic diversification step\n            diversified_position = self.entropic_diversification(self.positions[i])\n            diversified_position = np.clip(diversified_position, func.bounds.lb, func.bounds.ub)\n            diversified_score = func(diversified_position)\n            evaluations += 1\n            \n            if diversified_score < self.best_score:\n                self.best_score = diversified_score\n                self.best_position = diversified_position", "name": "EnhancedQuantumInspiredDEWithAdaptiveMutation", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation and Entropic Population Diversification synergizes adaptive mutation with entropy-based diversification to optimize the search trajectory and achieve superior optimization performance in photonic structures.", "configspace": "", "generation": 46, "fitness": 0.796558905056582, "feedback": "The algorithm EnhancedQuantumInspiredDEWithAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8099507913976768, 0.7831670187154871]}, "mutation_prompt": null}
{"id": "d53685e9-7de3-48ca-ad5c-32e795b00f26", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def dynamic_population_adjustment(self, evaluations):\n        # Adjust population size dynamically based on optimization progress\n        reduction_factor = 1 - (evaluations / self.budget)\n        new_population_size = max(5, int(self.initial_population_size * reduction_factor))\n        if new_population_size < self.population_size:\n            self.population_size = new_population_size\n            self.positions = self.positions[:self.population_size]\n\n    def dimension_reduction(self):\n        # Reduce dimensionality by focusing on promising dimensions\n        # Select dimensions with high variance and drop those with low variance\n        variance_threshold = 0.1\n        variances = np.var(self.positions, axis=0)\n        selected_dims = variances >= variance_threshold\n        if np.any(selected_dims):\n            self.positions = self.positions[:, selected_dims]\n            self.dim = np.sum(selected_dims)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n            \n            self.dynamic_population_adjustment(evaluations)\n            self.dimension_reduction()\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Population and Dimension Reduction leverages adaptive population size and dimensionality reduction to boost optimization efficiency in photonic structure design.", "configspace": "", "generation": 47, "fitness": 0.5433563558009841, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5696453025952988, 0.5170674090066694]}, "mutation_prompt": null}
{"id": "8aecef94-d743-4aaa-80d5-9f86a68bc86a", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n\n    def self_adaptive_parameters(self, trial_score, current_score):\n        if trial_score < current_score:\n            self.mutation_factor = min(0.9, self.mutation_factor + 0.02)\n            self.crossover_rate = max(0.1, self.crossover_rate - 0.01)\n        else:\n            self.mutation_factor = max(0.1, self.mutation_factor - 0.02)\n            self.crossover_rate = min(0.9, self.crossover_rate + 0.01)\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.self_adaptive_parameters(trial_score, func(self.positions[i]))\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveMutation", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation and Self-Adaptive Strategies further enhances search efficiency by incorporating self-adaptive parameter adjustments alongside quantum principles for optimizing complex photonic structures.", "configspace": "", "generation": 48, "fitness": 0.5811575608189743, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5830239009419136, 0.5792912206960351]}, "mutation_prompt": null}
{"id": "5f4728df-226f-44be-b28d-6c604441fee7", "solution": "import numpy as np\n\nclass QuantumInspiredSGD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.learning_rate = 0.1\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n    \n    def quantum_inspired_stochastic_update(self, individual, gradient):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        stochastic_gradient = gradient * quantum_flip\n        return individual - self.learning_rate * stochastic_gradient\n    \n    def compute_gradient_estimate(self, func, position):\n        epsilon = 1e-8\n        gradient = np.zeros(self.dim)\n        for i in range(self.dim):\n            perturbed_position = np.copy(position)\n            perturbed_position[i] += epsilon\n            gradient[i] = (func(perturbed_position) - func(position)) / epsilon\n        return gradient\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_position = self.positions[i]\n                gradient_estimate = self.compute_gradient_estimate(func, current_position)\n                \n                updated_position = self.quantum_inspired_stochastic_update(current_position, gradient_estimate)\n                updated_position = np.clip(updated_position, func.bounds.lb, func.bounds.ub)\n                updated_score = func(updated_position)\n                evaluations += 1\n                \n                if updated_score < self.best_score:\n                    self.best_score = updated_score\n                    self.best_position = updated_position\n                \n                if updated_score < func(current_position):\n                    self.positions[i] = updated_position\n        \n        return self.best_position, self.best_score", "name": "QuantumInspiredSGD", "description": "Quantum-Inspired Stochastic Gradient Descent (QISGD) combines quantum-inspired randomness with adaptive gradient-based updates, enhancing convergence speed and exploration in optimizing photonic structures.", "configspace": "", "generation": 49, "fitness": 0.5367850553140733, "feedback": "The algorithm QuantumInspiredSGD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5555452589624394, 0.5180248516657071]}, "mutation_prompt": null}
{"id": "5c67a8c6-ad0e-4095-aa9f-807401b5ab87", "solution": "import numpy as np\n\nclass QuantumInspiredGAWithAdaptiveQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_potential_well_mutation(self, individual):\n        # Apply quantum potential well mutation to encourage exploration\n        quantum_well = np.random.normal(0, self.mutation_factor, self.dim)\n        mutated_individual = individual + quantum_well\n        return mutated_individual\n    \n    def genetic_algorithm_step(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        selected_indices = np.random.choice(self.population_size, 2, replace=False)\n        parent1, parent2 = self.positions[selected_indices]\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(crossover_mask, parent1, parent2)\n        \n        mutated_offspring = self.quantum_potential_well_mutation(offspring)\n        mutated_offspring = np.clip(mutated_offspring, lb, ub)\n        \n        return mutated_offspring, func(mutated_offspring)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.genetic_algorithm_step(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on convergence speed\n                self.mutation_factor = self.initial_mutation_factor * (1 + (self.best_score - trial_score) / (self.best_score + 1e-9))\n        \n        # Final optimization with enhanced quantum mutation\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            enhanced_mutated_position = self.quantum_potential_well_mutation(self.positions[i])\n            enhanced_mutated_position = np.clip(enhanced_mutated_position, func.bounds.lb, func.bounds.ub)\n            enhanced_mutated_score = func(enhanced_mutated_position)\n            evaluations += 1\n            \n            if enhanced_mutated_score < self.best_score:\n                self.best_score = enhanced_mutated_score\n                self.best_position = enhanced_mutated_position", "name": "QuantumInspiredGAWithAdaptiveQuantumMutation", "description": "Quantum-Inspired Genetic Algorithm with Adaptive Quantum Mutation leverages quantum potential wells for population diversity and adaptively adjusts mutation rates based on convergence speed to optimize photonic structures.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "056576d3-3024-4d1c-9d64-6750b97d2d9f", "solution": "import numpy as np\n\nclass QuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.positions = np.random.rand(self.swarm_size, self.dim)\n        self.velocities = np.random.rand(self.swarm_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n    def initialize_positions_and_velocities(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        vel_range = (ub - lb) * 0.1\n        self.velocities = np.random.uniform(-vel_range, vel_range, (self.swarm_size, self.dim))\n\n    def quantum_behavior(self, position):\n        # Simulate quantum behavior by introducing random phase shift\n        random_phase = np.random.uniform(-np.pi, np.pi, self.dim)\n        quantum_shift = np.sin(random_phase)\n        return position + quantum_shift\n    \n    def update_velocity(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_component = self.cognitive_coef * r1 * (self.personal_best_positions[idx] - self.positions[idx])\n        social_component = self.social_coef * r2 * (self.global_best_position - self.positions[idx])\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] \n                                + cognitive_component + social_component)\n        velocity_clipping_bound = (func.bounds.ub - func.bounds.lb) * 0.2\n        self.velocities[idx] = np.clip(self.velocities[idx], -velocity_clipping_bound, velocity_clipping_bound)\n\n    def __call__(self, func):\n        self.initialize_positions_and_velocities(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                self.update_velocity(i, func)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n\n                current_score = func(self.positions[i])\n                evaluations += 1\n\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = current_score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = self.positions[i]\n            \n            # Quantum-enhanced global search\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                quantum_position = self.quantum_behavior(self.positions[i])\n                quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n                quantum_score = func(quantum_position)\n                evaluations += 1\n\n                if quantum_score < self.global_best_score:\n                    self.global_best_score = quantum_score\n                    self.global_best_position = quantum_position", "name": "QuantumEnhancedPSO", "description": "Quantum-Enhanced Particle Swarm Optimization with Adaptive Velocity utilizes quantum behavior and adaptive velocity control for enhanced exploration and convergence in photonic structure optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "213a0145-56b7-49f0-ae8a-a6875d3f2f75", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n    \n    def initialize_positions_and_velocities(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def update_velocity_and_position(self, index, func, evaluations):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = self.cognitive_coefficient * r1 * (self.personal_best_positions[index] - self.positions[index])\n        social_velocity = self.social_coefficient * r2 * (self.global_best_position - self.positions[index])\n        \n        self.velocities[index] = (\n            self.inertia_weight * self.velocities[index] +\n            cognitive_velocity +\n            social_velocity\n        )\n        \n        self.positions[index] += self.velocities[index]\n        self.positions[index] = np.clip(self.positions[index], func.bounds.lb, func.bounds.ub)\n        \n        current_score = func(self.positions[index])\n        if current_score < self.personal_best_scores[index]:\n            self.personal_best_scores[index] = current_score\n            self.personal_best_positions[index] = np.copy(self.positions[index])\n        \n        return current_score\n    \n    def quantum_inspired_update(self, index, func):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        self.positions[index] += quantum_flip * (np.random.rand(self.dim) - 0.5)\n        self.positions[index] = np.clip(self.positions[index], func.bounds.lb, func.bounds.ub)\n        current_score = func(self.positions[index])\n        \n        if current_score < self.personal_best_scores[index]:\n            self.personal_best_scores[index] = current_score\n            self.personal_best_positions[index] = np.copy(self.positions[index])\n        \n        return current_score\n    \n    def __call__(self, func):\n        self.initialize_positions_and_velocities(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_score = self.update_velocity_and_position(i, func, evaluations)\n                evaluations += 1\n                \n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = np.copy(self.positions[i])\n            \n            if evaluations < self.budget:\n                # Adjust inertia weight based on progress\n                self.inertia_weight = self.inertia_weight_max - (evaluations / self.budget) * (self.inertia_weight_max - self.inertia_weight_min)\n            \n            # Quantum-inspired global search phase\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_score = self.quantum_inspired_update(i, func)\n                evaluations += 1\n                \n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = np.copy(self.positions[i])\n\n        return self.global_best_position", "name": "AdaptiveQuantumSwarmOptimization", "description": "Adaptive Quantum Swarm Optimization integrates quantum-inspired particles with adaptive inertia weights to dynamically balance exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "c21faba3-f0bd-4304-9316-698eb149fae7", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.elite_fraction = 0.2\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n\n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n\n    def resize_population_and_preserve_elite(self, evaluations):\n        elite_size = int(self.elite_fraction * self.population_size)\n        sorted_indices = np.argsort([func(pos) for pos in self.positions])[:elite_size]\n        self.positions = self.positions[sorted_indices]\n        self.population_size = len(self.positions)\n        self.population_size += int((self.budget - evaluations) / (self.budget / 10))\n        self.positions = np.vstack([self.positions, np.random.uniform(func.bounds.lb, func.bounds.ub, \n                                     (self.population_size - elite_size, self.dim))])\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n\n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n\n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n\n            self.resize_population_and_preserve_elite(evaluations)\n\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n\n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n\n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation incorporates dynamic population resizing and elite preservation to boost convergence speed and accuracy in optimizing photonic structures.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "15b9baa9-6638-47c6-a9bb-92e035ca7d7d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.inertia_weight = 0.5\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def particle_swarm_update(self, i):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = self.cognitive_component * r1 * (self.best_position - self.positions[i])\n        social_velocity = self.social_component * r2 * (self.best_position - self.positions[i])\n        self.velocities[i] = (self.inertia_weight * self.velocities[i] + \n                              cognitive_velocity + social_velocity)\n        self.positions[i] += self.velocities[i]\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                self.particle_swarm_update(i)\n            \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution integrates particle swarm dynamics to reinforce exploration and exploitative capabilities, balancing these strategies for optimal photonic structure optimization.", "configspace": "", "generation": 54, "fitness": 0.8152211348865803, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.04.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7795400968957726, 0.850902172877388]}, "mutation_prompt": null}
{"id": "a34a6a0c-e501-4d4c-a756-69a1fccd68be", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def adaptive_quantum_walk(self, individual, progress):\n        step_size = (1 - progress) * np.random.rand(self.dim)\n        direction = np.random.choice([-1, 1], size=self.dim)\n        return individual + step_size * direction\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                progress = evaluations / self.budget\n                self.mutation_factor = self.initial_mutation_factor * (1 - progress)\n                \n                # Dynamically adjust population size based on progress\n                self.population_size = int(30 * (1 - progress)) + 1\n        \n        # Adaptive quantum walk for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position\n            \n            adapted_position = self.adaptive_quantum_walk(self.positions[i], progress)\n            adapted_position = np.clip(adapted_position, func.bounds.lb, func.bounds.ub)\n            adapted_score = func(adapted_position)\n            evaluations += 1\n            \n            if adapted_score < self.best_score:\n                self.best_score = adapted_score\n                self.best_position = adapted_position", "name": "QuantumInspiredDEWithAdaptiveQuantumWalk", "description": "Quantum-Inspired DE with Adaptive Quantum Walk and Dynamic Population exploits quantum-inspired mutation and adaptive quantum walk to maintain diversity and adaptively adjust the population size for enhanced photonic structure optimization.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "5a015a17-96de-44a3-8aaa-6082030d6fd6", "solution": "import numpy as np\n\nclass HybridQuantumAdaptiveDEWithDynamicNiching:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def dynamic_niching(self, func, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        niche_radius = 0.1 * (ub - lb) * (1 - evaluations / self.budget)\n        niche_centers = np.random.uniform(lb, ub, (5, self.dim))\n        \n        for i in range(self.population_size):\n            for center in niche_centers:\n                if np.linalg.norm(self.positions[i] - center) < np.linalg.norm(niche_radius):\n                    new_pos = self.positions[i] + np.random.uniform(-niche_radius, niche_radius)\n                    new_pos = np.clip(new_pos, lb, ub)\n                    new_score = func(new_pos)\n                    \n                    if new_score < self.best_score:\n                        self.best_score = new_score\n                        self.best_position = new_pos\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n            \n            self.dynamic_niching(func, evaluations)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "HybridQuantumAdaptiveDEWithDynamicNiching", "description": "Hybrid Quantum-Adaptive Differential Evolution with Dynamic Niching integrates quantum-inspired mutation, adaptive mutation rates, and dynamic niching to enhance exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 56, "fitness": 0.7005421383765229, "feedback": "The algorithm HybridQuantumAdaptiveDEWithDynamicNiching got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6718436412390788, 0.7292406355139671]}, "mutation_prompt": null}
{"id": "4fccebb2-cf98-47da-a947-65bef6e18a79", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumRotation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_rotation(self, individual):\n        # Apply quantum-inspired rotation to further diversify the population\n        rotation_angle = np.random.uniform(-np.pi, np.pi, self.dim)\n        rotated_individual = individual + self.mutation_factor * np.sin(rotation_angle)\n        return rotated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired rotation for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            rotated_position = self.quantum_inspired_rotation(self.positions[i])\n            rotated_position = np.clip(rotated_position, func.bounds.lb, func.bounds.ub)\n            rotated_score = func(rotated_position)\n            evaluations += 1\n            \n            if rotated_score < self.best_score:\n                self.best_score = rotated_score\n                self.best_position = rotated_position", "name": "QuantumInspiredDEWithAdaptiveQuantumRotation", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Rotation integrates quantum rotation gates for enhanced diversity in mutation and employs adaptive scaling of the mutation factor to improve convergence in photonic structure optimization tasks.", "configspace": "", "generation": 57, "fitness": 0.8334460664007235, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumRotation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8359033120282, 0.830988820773247]}, "mutation_prompt": null}
{"id": "1e4b6fb5-a977-4b04-9079-76b399c85e40", "solution": "import numpy as np\n\nclass SwarmQuantumAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.temperatures = np.linspace(1.0, 0.01, self.budget)\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia_weight = 0.7\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_annealed_update(self, position, velocity, temperature, bounds):\n        # Quantum-inspired perturbation using temperature\n        perturbation = np.random.uniform(-1, 1, self.dim) * temperature\n        new_position = position + velocity + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_score = func(self.positions[i])\n                evaluations += 1\n                \n                # Update personal best\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = current_score\n                    self.personal_best_positions[i] = self.positions[i]\n                \n                # Update global best\n                if current_score < self.best_score:\n                    self.best_score = current_score\n                    self.best_position = self.positions[i]\n            \n            # Temperature-based evolution\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Velocity update using swarm intelligence\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.c2 * r2 * (self.best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                \n                # Position update with quantum annealing\n                temperature = self.temperatures[evaluations]\n                self.positions[i] = self.quantum_annealed_update(self.positions[i], self.velocities[i], temperature, func.bounds)\n                \n                annealed_score = func(self.positions[i])\n                evaluations += 1\n                \n                # Update global best with annealed score\n                if annealed_score < self.best_score:\n                    self.best_score = annealed_score\n                    self.best_position = self.positions[i]", "name": "SwarmQuantumAnnealing", "description": "Swarm Quantum Annealing (SQA) combines swarm intelligence with quantum annealing principles to explore the search space efficiently and escape local optima in photonic structure optimization.", "configspace": "", "generation": 58, "fitness": 0.6041586302797697, "feedback": "The algorithm SwarmQuantumAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6232793434355207, 0.5850379171240188]}, "mutation_prompt": null}
{"id": "bebadab4-e55d-4f50-9911-30c2cea208a1", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumPotential:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.quantum_potential = 0.1\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual, global_best):\n        # Introduce an adaptive quantum potential to modify the mutation\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        potential_influence = self.quantum_potential * (global_best - individual)\n        mutated_individual = individual + self.mutation_factor * quantum_flip + potential_influence\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        global_best = self.best_position\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                    global_best = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n            \n            # Update quantum potential to emphasize convergence\n            self.quantum_potential = 0.1 + 0.9 * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i], global_best)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveQuantumPotential", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Potential incorporates an adaptive quantum potential mechanism to dynamically influence individual trajectories, enhancing convergence speed and solution quality for photonic structure optimization.", "configspace": "", "generation": 59, "fitness": 0.7741950181266192, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumPotential got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7595474087607972, 0.7888426274924412]}, "mutation_prompt": null}
{"id": "0cb3b5f0-0a6d-4614-a2c9-28b7fd0e3d15", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 30\n        self.harmony_memory_consideration_rate = 0.9\n        self.pitch_adjustment_rate = 0.3\n        self.bandwidth = 0.05\n        self.harmonies = None\n        self.best_harmony = None\n        self.best_score = float('inf')\n    \n    def initialize_harmonies(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.harmonies = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n    \n    def quantum_harmony_adjustment(self, harmony, index):\n        # Apply quantum-inspired pitch adjustment\n        quantum_flip = np.random.choice([-1, 1], size=self.dim) * self.bandwidth\n        if np.random.rand() < self.pitch_adjustment_rate:\n            adjusted_harmony = harmony + quantum_flip\n            return np.clip(adjusted_harmony, func.bounds.lb, func.bounds.ub)\n        return harmony\n    \n    def generate_new_harmony(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.harmony_memory_consideration_rate:\n                random_harmony = self.harmonies[np.random.randint(self.harmony_memory_size)]\n                new_harmony[i] = random_harmony[i]\n            else:\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        return new_harmony\n    \n    def __call__(self, func):\n        self.initialize_harmonies(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(func.bounds)\n            new_harmony = self.quantum_harmony_adjustment(new_harmony, evaluations)\n            new_score = func(new_harmony)\n            evaluations += 1\n            \n            if new_score < self.best_score:\n                self.best_score = new_score\n                self.best_harmony = new_harmony\n            \n            if new_score < func(self.harmonies[np.argmax([func(h) for h in self.harmonies])]):\n                worst_idx = np.argmax([func(h) for h in self.harmonies])\n                self.harmonies[worst_idx] = new_harmony\n            \n            # Adjusting pitch rate based on budget usage\n            self.pitch_adjustment_rate *= (1 - evaluations / self.budget)", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search (AQHS) leverages quantum-inspired harmonics and adaptive pitch adjustments to enhance search efficacy and robustness in optimizing photonic structures.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "bd9e920e-1713-4426-8c5e-dd8a29338b23", "solution": "import numpy as np\n\nclass QuantumLevyFlightDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def levy_flight(self, individual):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (abs(v) ** (1 / beta))\n        return individual + step\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            if np.random.rand() < 0.5:\n                mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            else:\n                mutated_position = self.levy_flight(self.positions[i])\n            \n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumLevyFlightDE", "description": "Quantum-Levy Flight Differential Evolution combines quantum-inspired mutation and Levy flights for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 61, "fitness": 0.7897969477706439, "feedback": "The algorithm QuantumLevyFlightDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7715085767271216, 0.8080853188141661]}, "mutation_prompt": null}
{"id": "d71ddd6a-c28d-4e4b-9392-dd0b5a07cb6a", "solution": "import numpy as np\n\nclass QuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_personal_positions = None\n        self.best_personal_scores = None\n        self.best_global_position = None\n        self.best_global_score = float('inf')\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n\n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.positions)\n        self.best_personal_scores = np.full(self.population_size, float('inf'))\n\n    def quantum_perturbation(self, position):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        perturbed_position = position + 0.1 * quantum_flip\n        return perturbed_position\n\n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        while evaluations < self.budget:\n            inertia_weight = self.initial_inertia_weight - (self.initial_inertia_weight - self.final_inertia_weight) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.positions[i]\n\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.positions[i]\n\n            for i in range(self.population_size):\n                cognitive_velocity = self.cognitive_coefficient * np.random.rand(self.dim) * (self.best_personal_positions[i] - self.positions[i])\n                social_velocity = self.social_coefficient * np.random.rand(self.dim) * (self.best_global_position - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n            # Quantum perturbation for diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                perturbed_position = self.quantum_perturbation(self.positions[i])\n                perturbed_position = np.clip(perturbed_position, lb, ub)\n                perturbed_score = func(perturbed_position)\n                evaluations += 1\n\n                if perturbed_score < self.best_global_score:\n                    self.best_global_score = perturbed_score\n                    self.best_global_position = perturbed_position\n\n        return self.best_global_position, self.best_global_score", "name": "QuantumEnhancedPSO", "description": "Quantum-Enhanced Particle Swarm Optimization with Adaptive Inertia and Quantum Perturbations utilizes quantum perturbations and adaptive inertia weights to balance exploration and exploitation, optimizing photonic structures efficiently.", "configspace": "", "generation": 62, "fitness": 0.7204228301894533, "feedback": "The algorithm QuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.04.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6816913907037127, 0.759154269675194]}, "mutation_prompt": null}
{"id": "d7f1efd0-2430-4c0a-9364-72dd7c029f46", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithMultiLeader:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_positions = []\n        self.best_scores = []\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = [float('inf')] * self.population_size\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        # Select multiple leaders for diverse guidance\n        leader_idx = np.random.choice(range(self.population_size), 2, replace=False)\n        leader_1, leader_2 = self.best_positions[leader_idx[0]], self.best_positions[leader_idx[1]]\n        \n        mutant_vector = leader_1 + self.mutation_factor * (self.positions[b] - self.positions[c]) + self.mutation_factor * (leader_2 - self.positions[a])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_scores[i]:\n                    self.best_scores[i] = trial_score\n                    self.best_positions[i] = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < min(self.best_scores):\n                best_idx = np.argmin(self.best_scores)\n                self.best_scores[best_idx] = mutated_score\n                self.best_positions[best_idx] = mutated_position", "name": "EnhancedQuantumInspiredDEWithMultiLeader", "description": "Enhanced Quantum-Inspired DE with Adaptive Mutation and Quantum Multi-Leader Strategy incorporates multiple leader guidance leveraging quantum principles for diversified search and enhanced convergence in optimizing photonic structures.", "configspace": "", "generation": 63, "fitness": 0.8840169211481658, "feedback": "The algorithm EnhancedQuantumInspiredDEWithMultiLeader got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8760674467822533, 0.8919663955140782]}, "mutation_prompt": null}
{"id": "1a52f588-de38-472f-8182-0a7d708c563a", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithMultiScaleAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_mutation_factor = 0.5\n        self.mutation_factor_min = 0.1\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.mutation_factors = np.full(self.population_size, self.initial_mutation_factor)\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factors * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factors[target_idx] * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def adapt_mutation_factor(self, eval_ratio):\n        return self.initial_mutation_factor * (1 - eval_ratio) + self.mutation_factor_min\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                eval_ratio = evaluations / self.budget\n                self.mutation_factors[i] = self.adapt_mutation_factor(eval_ratio)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithMultiScaleAdaptiveMutation", "description": "Quantum-Inspired Differential Evolution with Multi-Scale Adaptive Mutation leverages quantum principles and multi-scale mutation strategies to enhance exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 64, "fitness": 0.840027075570313, "feedback": "The algorithm QuantumInspiredDEWithMultiScaleAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8673777069871149, 0.8126764441535111]}, "mutation_prompt": null}
{"id": "0e8be133-088b-4866-901b-40fc04ea7fa6", "solution": "import numpy as np\n\nclass DualLevelQuantumInspiredSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_individual_position = None\n        self.best_individual_score = np.full(self.population_size, float('inf'))\n        self.best_position = None\n        self.best_score = float('inf')\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.quantum_exploration_factor = 0.5\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n    \n    def update_velocity_and_position(self, idx, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        \n        # Update velocity with cognitive and social components\n        cognitive_component = r1 * self.cognitive_coefficient * (self.best_individual_position[idx] - self.positions[idx])\n        social_component = r2 * self.social_coefficient * (self.best_position - self.positions[idx])\n        \n        self.velocities[idx] = (\n            self.inertia_weight * self.velocities[idx] +\n            cognitive_component +\n            social_component\n        )\n        \n        # Update position\n        self.positions[idx] += self.velocities[idx]\n        self.positions[idx] = np.clip(self.positions[idx], lb, ub)\n    \n    def quantum_inspired_search(self, idx, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_flip = np.random.uniform(-self.quantum_exploration_factor, self.quantum_exploration_factor, self.dim)\n        quantum_position = self.positions[idx] + quantum_flip\n        quantum_position = np.clip(quantum_position, lb, ub)\n        return quantum_position, func(quantum_position)\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.update_velocity_and_position(i, func)\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.best_individual_score[i]:\n                    self.best_individual_score[i] = score\n                    self.best_individual_position = self.positions[i].copy()\n                \n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_position = self.positions[i].copy()\n            \n            # Quantum-inspired global search\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                quantum_position, quantum_score = self.quantum_inspired_search(i, func)\n                evaluations += 1\n                \n                if quantum_score < self.best_score:\n                    self.best_score = quantum_score\n                    self.best_position = quantum_position.copy()", "name": "DualLevelQuantumInspiredSwarm", "description": "Dual-Level Quantum-Inspired Swarm Optimization combines swarm intelligence with quantum principles to explore and exploit the search space efficiently, using dual-level search to balance global exploration and local exploitation for photonic structure optimization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'NoneType' object is not subscriptable\").", "error": "TypeError(\"'NoneType' object is not subscriptable\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "9fd1657f-9111-4b7e-ad23-525957a6862b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def dynamic_quantum_rotation(self, individual, generation_ratio):\n        # Apply dynamic quantum rotation to enhance exploration\n        rotation_angle = np.pi * generation_ratio * (np.random.rand(self.dim) - 0.5)\n        rotated_individual = individual * np.cos(rotation_angle) + np.sin(rotation_angle)\n        return rotated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            generation_ratio = evaluations / self.budget\n            self.mutation_factor = self.initial_mutation_factor * (1 - generation_ratio)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n        \n        # Dynamic quantum rotation for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            dynamic_rotated_position = self.dynamic_quantum_rotation(self.positions[i], generation_ratio)\n            dynamic_rotated_position = np.clip(dynamic_rotated_position, func.bounds.lb, func.bounds.ub)\n            rotated_score = func(dynamic_rotated_position)\n            evaluations += 1\n            \n            if rotated_score < self.best_score:\n                self.best_score = rotated_score\n                self.best_position = dynamic_rotated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Quantum Rotation incorporates dynamic quantum rotations and adaptive selection pressure to improve convergence speed and solution quality in photonic optimization.", "configspace": "", "generation": 66, "fitness": 0.7944549284187534, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8252240109116499, 0.7636858459258569]}, "mutation_prompt": null}
{"id": "2774d4f2-9f40-42bc-9124-5e162b8e0466", "solution": "import numpy as np\n\nclass QuantumGuidedPSOWithDynamicInertia:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.initial_inertia_weight = self.inertia_weight\n    \n    def initialize_particles(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_guided_update(self, position):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        return position + 0.1 * quantum_flip\n    \n    def update_velocities_and_positions(self, func, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            inertia_velocity = self.inertia_weight * self.velocities[i]\n            cognitive_component = self.cognitive_coefficient * np.random.rand(self.dim) * (self.personal_best_positions[i] - self.positions[i])\n            social_component = self.social_coefficient * np.random.rand(self.dim) * (self.global_best_position - self.positions[i])\n            \n            self.velocities[i] = inertia_velocity + cognitive_component + social_component\n            self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n            \n            current_score = func(self.positions[i])\n            evaluations += 1\n            \n            if current_score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = current_score\n                self.personal_best_positions[i] = self.positions[i]\n            \n            if current_score < self.global_best_score:\n                self.global_best_score = current_score\n                self.global_best_position = self.positions[i]\n    \n    def __call__(self, func):\n        self.initialize_particles(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.update_velocities_and_positions(func, evaluations)\n            \n            # Update inertia weight dynamically\n            self.inertia_weight = self.initial_inertia_weight * (1 - evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Quantum-guided position update\n                quantum_position = self.quantum_guided_update(self.positions[i])\n                quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n                quantum_score = func(quantum_position)\n                evaluations += 1\n                \n                if quantum_score < self.global_best_score:\n                    self.global_best_score = quantum_score\n                    self.global_best_position = quantum_position", "name": "QuantumGuidedPSOWithDynamicInertia", "description": "Quantum-Guided Particle Swarm Optimization with Dynamic Inertia integrates quantum behaviors into particle swarm optimization and dynamically adjusts inertia weight for robust global optimization.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "defd3fe5-b61b-4077-b107-49beb84aa209", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def adaptive_quantum_mutation(self, individual, evaluations):\n        # Adaptive quantum mutation based on remaining budget\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutation_intensity = self.mutation_factor * (1 - evaluations / self.budget)\n        mutated_individual = individual + mutation_intensity * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                \n                # Dynamic population size adjustment\n                if evaluations % (self.budget // 10) == 0 and self.population_size > 10:\n                    self.population_size -= 1\n                    self.positions = self.positions[:self.population_size]\n\n        # Quantum-inspired global search with adaptive mutation\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.adaptive_quantum_mutation(self.positions[i], evaluations)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Population and Adaptive Quantum Mutation incorporates dynamic population resizing and adaptive quantum mutation strategies to achieve superior optimization performance in photonic structures.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "e9249307-0b1a-4b26-bdbb-f7f517bfe0e8", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n    def quantum_swarm_mutation(self, individual, personal_best):\n        # Apply swarm intelligence to enhance diversity\n        inertia_weight = 0.5\n        cognitive_component = 2.05 * np.random.rand() * (personal_best - individual)\n        social_component = 2.05 * np.random.rand() * (self.best_position - individual)\n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        mutated_individual = individual + self.velocities\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_swarm_mutation(self.positions[i], self.personal_best_positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDEWithAdaptiveSwarm", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Quantum Swarm Dynamics integrates swarm intelligence principles to dynamically adjust quantum-inspired mutations, improving search efficiency and solution convergence in photonic structures optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'NoneType' object does not support item assignment\").", "error": "TypeError(\"'NoneType' object does not support item assignment\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "579ca12a-f450-4e7c-94c9-25614cbea079", "solution": "import numpy as np\n\nclass QuantumHarmonySearchWithAdaptiveFrequency:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 30\n        self.harmony_memory = None\n        self.best_harmony = None\n        self.best_score = float('inf')\n        self.harmony_consideration_rate = 0.9\n        self.adaptive_pitch_adjustment_rate = 0.5\n        self.frequency_range = 0.01\n\n    def initialize_harmony_memory(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n    \n    def quantum_inspired_movement(self, harmony):\n        quantum_shift = np.random.uniform(-self.frequency_range, self.frequency_range, self.dim)\n        return harmony + quantum_shift\n    \n    def create_new_harmony(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        new_harmony = np.copy(self.harmony_memory[np.random.choice(self.harmony_memory_size)])\n        \n        for i in range(self.dim):\n            if np.random.rand() < self.harmony_consideration_rate:\n                new_harmony[i] = self.harmony_memory[np.random.choice(self.harmony_memory_size)][i]\n            if np.random.rand() < self.adaptive_pitch_adjustment_rate:\n                new_harmony[i] = new_harmony[i] + np.random.uniform(-self.frequency_range, self.frequency_range)\n\n        new_harmony = np.clip(new_harmony, lb, ub)\n        return new_harmony, func(new_harmony)\n\n    def __call__(self, func):\n        self.initialize_harmony_memory(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            new_harmony, new_score = self.create_new_harmony(func)\n            evaluations += 1\n            \n            if new_score < self.best_score:\n                self.best_score = new_score\n                self.best_harmony = new_harmony\n            \n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if new_score < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n            \n            # Adaptive frequency adjustment\n            self.adaptive_pitch_adjustment_rate = 0.5 * (1 - evaluations / self.budget)\n        \n        # Final quantum-inspired tuning\n        for i in range(self.harmony_memory_size):\n            if evaluations >= self.budget:\n                break\n            \n            quantum_harmony = self.quantum_inspired_movement(self.harmony_memory[i])\n            quantum_harmony = np.clip(quantum_harmony, func.bounds.lb, func.bounds.ub)\n            quantum_score = func(quantum_harmony)\n            evaluations += 1\n            \n            if quantum_score < self.best_score:\n                self.best_score = quantum_score\n                self.best_harmony = quantum_harmony", "name": "QuantumHarmonySearchWithAdaptiveFrequency", "description": "Quantum Harmony Search with Adaptive Frequency Adjustments utilizes quantum-inspired diversity and self-adaptive harmony adjustments to enhance global exploration and fine-tune local search in optimizing photonic structures.", "configspace": "", "generation": 70, "fitness": 0.5015605321865861, "feedback": "The algorithm QuantumHarmonySearchWithAdaptiveFrequency got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5059500694029766, 0.4971709949701957]}, "mutation_prompt": null}
{"id": "5123a694-524e-4d60-b623-2e2d227a5c71", "solution": "import numpy as np\n\nclass QuantumTunnelingDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_tunneling(self, individual, func, evaluations):\n        # Apply quantum tunneling to help escape local optima\n        lb, ub = func.bounds.lb, func.bounds.ub\n        tunneling_prob = np.exp(-abs(func(individual) - self.best_score))\n        if np.random.rand() < tunneling_prob:\n            return np.random.uniform(lb, ub, self.dim)\n        return individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def feedback_enhanced_mutation(self, evaluations):\n        return self.initial_mutation_factor * (1 - evaluations / self.budget) * (self.best_score / self.budget)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor with feedback\n                self.mutation_factor = self.feedback_enhanced_mutation(evaluations)\n        \n        # Quantum tunneling for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            tunneled_position = self.quantum_tunneling(self.positions[i], func, evaluations)\n            tunneled_position = np.clip(tunneled_position, func.bounds.lb, func.bounds.ub)\n            tunneled_score = func(tunneled_position)\n            evaluations += 1\n            \n            if tunneled_score < self.best_score:\n                self.best_score = tunneled_score\n                self.best_position = tunneled_position", "name": "QuantumTunnelingDE", "description": "Quantum-Tunneling Differential Evolution blends quantum tunneling concepts for escaping local optima with adaptive mutation and feedback-driven enhancement to optimize photonic structures more effectively.", "configspace": "", "generation": 71, "fitness": 0.5161477718547876, "feedback": "The algorithm QuantumTunnelingDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5326060037922844, 0.4996895399172907]}, "mutation_prompt": null}
{"id": "fb02241a-65fa-4153-95d1-74bbab64a0eb", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.memory_size = 5\n        self.adaptive_memory = np.full((self.memory_size, self.dim), float('inf'))\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def update_memory(self, position):\n        if func(position) < np.max([func(pos) for pos in self.adaptive_memory]):\n            worst_idx = np.argmax([func(pos) for pos in self.adaptive_memory])\n            self.adaptive_memory[worst_idx] = position\n    \n    def dynamic_population_resizing(self, evaluations):\n        new_size = self.population_size + (self.budget - evaluations) // (2*self.budget/self.population_size)\n        if new_size > self.population_size:\n            lb, ub = func.bounds.lb, func.bounds.ub\n            new_positions = np.random.uniform(lb, ub, (new_size - self.population_size, self.dim))\n            self.positions = np.vstack((self.positions, new_positions))\n        self.population_size = new_size\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_population_resizing(evaluations)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                self.update_memory(self.positions[i])\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDEWithDynamicPopulation", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Population and Adaptive Memory integrates dynamic population resizing and adaptive memory mechanisms to better explore and exploit the search space for optimizing photonic structures.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "cc6bef7d-3707-4f8b-b594-708c3951bd39", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.mutation_rates = np.full(self.population_size, 0.5)\n        self.crossover_rates = np.full(self.population_size, 0.7)\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual, mutation_rate):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + mutation_rate * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_rates[target_idx] * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rates[target_idx]\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def self_adaptive_control(self, trial_score, current_score, idx):\n        if trial_score < current_score:\n            self.mutation_rates[idx] = min(1.0, self.mutation_rates[idx] * 1.1)\n            self.crossover_rates[idx] = min(1.0, self.crossover_rates[idx] * 1.1)\n        else:\n            self.mutation_rates[idx] = max(0.1, self.mutation_rates[idx] * 0.9)\n            self.crossover_rates[idx] = max(0.1, self.crossover_rates[idx] * 0.9)\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Self-adaptive parameter control\n                self.self_adaptive_control(trial_score, func(self.positions[i]), i)\n        \n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i], self.mutation_rates[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation and Self-Adaptive Parameter Control optimizes photonic structures by incorporating a self-adaptive control mechanism for mutation and crossover rates, enhancing convergence speed and solution quality.", "configspace": "", "generation": 73, "fitness": 0.7033481259090777, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7009891721860534, 0.7057070796321021]}, "mutation_prompt": null}
{"id": "5ecc25af-1820-4cda-b6e6-af78a89b2506", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.initial_crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_rate = self.initial_crossover_rate * (1 - evaluations / self.budget)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position += self.levy_flight()\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution integrates Lvy flights for exploiting high-dimensional spaces efficiently and dynamically adjusts crossover rates to balance exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 74, "fitness": 0.7775949138304126, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7579045257415765, 0.7972853019192487]}, "mutation_prompt": null}
{"id": "4ce6f038-8487-4248-8c4a-c6884bb25b6e", "solution": "import numpy as np\n\nclass EntropyGuidedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.5\n        self.c2 = 2.5\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def entropy_based_coefficients(self, evaluations):\n        entropy = -np.sum(self.personal_best_scores * np.log(self.personal_best_scores + 1e-10))\n        relative_entropy = entropy / np.log(self.population_size)\n        w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n        c1_adaptive = self.c1 * (1 - relative_entropy)\n        c2_adaptive = self.c2 * relative_entropy\n        return w, c1_adaptive, c2_adaptive\n    \n    def update_particle(self, func, idx, w, c1_adaptive, c2_adaptive):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_component = c1_adaptive * r1 * (self.personal_best_positions[idx] - self.positions[idx])\n        social_component = c2_adaptive * r2 * (self.best_position - self.positions[idx])\n        self.velocities[idx] = w * self.velocities[idx] + cognitive_component + social_component\n        self.positions[idx] += self.velocities[idx]\n        self.positions[idx] = np.clip(self.positions[idx], func.bounds.lb, func.bounds.ub)\n    \n    def update_personal_best(self, idx, score):\n        if score < self.personal_best_scores[idx]:\n            self.personal_best_scores[idx] = score\n            self.personal_best_positions[idx] = np.copy(self.positions[idx])\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Evaluate particle fitness\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                self.update_personal_best(i, score)\n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_position = np.copy(self.positions[i])\n            \n            # Adaptive coefficients\n            w, c1_adaptive, c2_adaptive = self.entropy_based_coefficients(evaluations)\n            \n            # Update particles\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                self.update_particle(func, i, w, c1_adaptive, c2_adaptive)", "name": "EntropyGuidedPSO", "description": "Entropy-Guided Particle Swarm Optimization balances exploration and exploitation by using entropy-based adaptive inertia and attraction coefficients to dynamically adjust search behavior for effective optimization of photonic structures.", "configspace": "", "generation": 75, "fitness": 0.7764408012952081, "feedback": "The algorithm EntropyGuidedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7826910567928829, 0.7701905457975333]}, "mutation_prompt": null}
{"id": "08caa79f-d6e4-4426-9dc1-38c501049993", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 30\n        self.harmony_memory = None\n        self.best_harmony = None\n        self.best_score = float('inf')\n        self.hmcr = 0.9  # Harmony Memory Consideration Rate\n        self.par = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05\n        \n    def initialize_harmony_memory(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        \n    def quantum_inspired_pitch_adjustment(self, harmony):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        adjusted_harmony = harmony + self.bandwidth * quantum_flip\n        return adjusted_harmony\n    \n    def generate_new_harmony(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        new_harmony = np.zeros(self.dim)\n        \n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                # Use harmony memory\n                new_harmony[i] = np.random.choice(self.harmony_memory[:, i])\n                if np.random.rand() < self.par:\n                    # Apply quantum-inspired pitch adjustment\n                    new_harmony[i] += self.bandwidth * (2 * np.random.rand() - 1)\n            else:\n                # Random selection\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        \n        new_harmony = np.clip(new_harmony, lb, ub)\n        return new_harmony\n    \n    def __call__(self, func):\n        self.initialize_harmony_memory(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(func.bounds)\n            new_score = func(new_harmony)\n            evaluations += 1\n            \n            if new_score < self.best_score:\n                self.best_score = new_score\n                self.best_harmony = new_harmony\n                \n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if new_score < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n        \n            # Apply quantum-inspired pitch adjustment globally\n            for i in range(self.harmony_memory_size):\n                if evaluations >= self.budget:\n                    break\n                adjusted_harmony = self.quantum_inspired_pitch_adjustment(self.harmony_memory[i])\n                adjusted_harmony = np.clip(adjusted_harmony, func.bounds.lb, func.bounds.ub)\n                adjusted_score = func(adjusted_harmony)\n                evaluations += 1\n                \n                if adjusted_score < self.best_score:\n                    self.best_score = adjusted_score\n                    self.best_harmony = adjusted_harmony", "name": "QuantumHarmonySearch", "description": "Quantum Harmony Search integrates quantum-inspired principles with harmony search to balance exploration and exploitation for optimizing photonic structures.", "configspace": "", "generation": 76, "fitness": 0.6279053458531336, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6572497050201178, 0.5985609866861493]}, "mutation_prompt": null}
{"id": "ea52e93b-ca62-4850-821e-32e124e88928", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptivePSOWithDifferentialLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n    \n    def quantum_inspired_update(self, position, global_best):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_shift = np.where(quantum_bit, 1, -1)\n        return position + self.w * quantum_shift * (global_best - position)\n    \n    def adaptive_velocity_update(self, particle_idx):\n        r1, r2 = np.random.rand(), np.random.rand()\n        personal_best_attraction = self.c1 * r1 * (self.best_positions[particle_idx] - self.positions[particle_idx])\n        global_best_attraction = self.c2 * r2 * (self.global_best_position - self.positions[particle_idx])\n        self.velocities[particle_idx] = self.w * self.velocities[particle_idx] + personal_best_attraction + global_best_attraction\n    \n    def apply_differential_learning(self, position, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        diff_learning_factor = 0.5\n        a, b, c = np.random.choice(self.swarm_size, 3, replace=False)\n        differential_position = self.positions[a] + diff_learning_factor * (self.positions[b] - self.positions[c])\n        new_position = position + differential_position\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                self.adaptive_velocity_update(i)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n\n                current_score = func(self.positions[i])\n                evaluations += 1\n\n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = self.positions[i]\n                \n                if current_score < func(self.best_positions[i]):\n                    self.best_positions[i] = self.positions[i]\n            \n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                quantum_position = self.quantum_inspired_update(self.positions[i], self.global_best_position)\n                quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n                quantum_score = func(quantum_position)\n                evaluations += 1\n\n                if quantum_score < self.global_best_score:\n                    self.global_best_score = quantum_score\n                    self.global_best_position = quantum_position\n\n                diff_position = self.apply_differential_learning(self.positions[i], func.bounds)\n                diff_score = func(diff_position)\n                evaluations += 1\n\n                if diff_score < self.global_best_score:\n                    self.global_best_score = diff_score\n                    self.global_best_position = diff_position", "name": "QuantumInspiredAdaptivePSOWithDifferentialLearning", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Differential Learning combines quantum-inspired adaptations and differential learning within a Particle Swarm Optimization framework for enhanced exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
{"id": "ae26504a-682e-4281-82ef-d03ef118a125", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumAmplitude:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def adaptive_quantum_amplitude_mutation(self, individual, progress_ratio):\n        # Adapt quantum amplitude based on optimization progress\n        quantum_amplitude = 0.5 * (1 - progress_ratio)\n        quantum_bit = np.random.rand(self.dim) < quantum_amplitude\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search with adaptive amplitude\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                progress_ratio = evaluations / self.budget\n                mutated_position = self.adaptive_quantum_amplitude_mutation(self.positions[i], progress_ratio)\n                mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n                mutated_score = func(mutated_position)\n                evaluations += 1\n                \n                if mutated_score < self.best_score:\n                    self.best_score = mutated_score\n                    self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveQuantumAmplitude", "description": "Quantum-Inspired DE with Adaptive Quantum Amplitude integrates adaptive quantum amplitude modulation into DE for enhanced exploration and convergence in photonic structure optimization.", "configspace": "", "generation": 78, "fitness": 0.8472398939038099, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumAmplitude got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8489763327481765, 0.8455034550594434]}, "mutation_prompt": null}
{"id": "b6db282d-c64a-491a-b135-576793218d53", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithHybridAdaptiveStrategies:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.epsilon = 1e-8\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, np.random.uniform(-1, 1, self.dim), 0)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate + self.epsilon*np.random.rand(self.dim)\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def adaptive_crossover_mutation(self, trial_vector, target_vector):\n        dist = np.linalg.norm(trial_vector - target_vector)\n        return self.crossover_rate + (1 - self.crossover_rate) * np.exp(-dist)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n                \n            # Quantum-inspired global search for final optimization\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutated_position = self.quantum_inspired_mutation(self.positions[i])\n                mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n                mutated_score = func(mutated_position)\n                evaluations += 1\n                \n                if mutated_score < self.best_score:\n                    self.best_score = mutated_score\n                    self.best_position = mutated_position", "name": "QuantumInspiredDEWithHybridAdaptiveStrategies", "description": "Quantum-Inspired DE with Hybrid Adaptive Strategies integrates quantum principles with a hybrid mutation and crossover strategy to improve search efficiency and adaptability in optimizing complex photonic structures.", "configspace": "", "generation": 79, "fitness": 0.6794202621185086, "feedback": "The algorithm QuantumInspiredDEWithHybridAdaptiveStrategies got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.04.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7201173414729609, 0.6387231827640564]}, "mutation_prompt": null}
{"id": "815f4af4-0dfb-446b-ae91-1f1d9ef5a592", "solution": "import numpy as np\n\nclass QuantumInspiredBiogeographyOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.immigration_rate = 0.7\n        self.emigration_rate = 0.3\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def habitat_migration(self, habitat, other_habitat):\n        migration_mask = np.random.rand(self.dim) < self.immigration_rate\n        new_habitat = np.copy(habitat)\n        new_habitat[migration_mask] = other_habitat[migration_mask]\n        return new_habitat\n    \n    def quantum_inspired_mutation(self, habitat):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_habitat = habitat + self.emigration_rate * quantum_flip\n        return mutated_habitat\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Select two random habitats for migration\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                other_habitat_idx = np.random.choice(indices)\n                \n                # Perform habitat migration\n                trial_habitat = self.habitat_migration(self.positions[i], self.positions[other_habitat_idx])\n                trial_habitat = np.clip(trial_habitat, func.bounds.lb, func.bounds.ub)\n                trial_score = func(trial_habitat)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_habitat\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_habitat\n            \n            # Quantum-inspired mutation for enhanced exploration\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutated_habitat = self.quantum_inspired_mutation(self.positions[i])\n                mutated_habitat = np.clip(mutated_habitat, func.bounds.lb, func.bounds.ub)\n                mutated_score = func(mutated_habitat)\n                evaluations += 1\n                \n                if mutated_score < self.best_score:\n                    self.best_score = mutated_score\n                    self.best_position = mutated_habitat", "name": "QuantumInspiredBiogeographyOptimization", "description": "Quantum-Inspired Biogeography-Based Optimization utilizes concepts from quantum mechanics and biogeography to enhance exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 80, "fitness": 0.6083261997123306, "feedback": "The algorithm QuantumInspiredBiogeographyOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.03.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6406816721403035, 0.5759707272843576]}, "mutation_prompt": null}
{"id": "615e5201-589d-48bf-82c7-a88ecacfb20e", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearchWithQuantumTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 30\n        self.harmony_memory_consideration_rate = 0.9\n        self.adjustment_rate = 0.5\n        self.tunneling_probability = 0.1\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n    \n    def quantum_tunneling(self, position, bounds):\n        # Implement quantum tunneling to escape local minima\n        if np.random.rand() < self.tunneling_probability:\n            lb, ub = bounds.lb, bounds.ub\n            tunneled_position = np.random.uniform(lb, ub, self.dim)\n            return tunneled_position\n        return position\n    \n    def adaptive_parameters(self, evaluations):\n        # Adaptively adjust parameters based on the progress\n        self.harmony_memory_consideration_rate = 0.9 - 0.4 * (evaluations / self.budget)\n        self.adjustment_rate = 0.5 - 0.3 * (evaluations / self.budget)\n        self.tunneling_probability = 0.1 + 0.4 * (evaluations / self.budget)\n    \n    def generate_new_harmony(self, bounds):\n        new_harmony = np.empty(self.dim)\n        lb, ub = bounds.lb, bounds.ub\n\n        for i in range(self.dim):\n            if np.random.rand() < self.harmony_memory_consideration_rate:\n                # Choose from harmony memory\n                new_harmony[i] = self.positions[np.random.randint(self.harmony_memory_size)][i]\n                if np.random.rand() < self.adjustment_rate:\n                    new_harmony[i] += np.random.uniform(-1, 1) * (ub[i] - lb[i]) * 0.05\n            else:\n                # Random selection\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n        return np.clip(new_harmony, lb, ub)\n\n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(func.bounds)\n            new_harmony = self.quantum_tunneling(new_harmony, func.bounds)\n            new_score = func(new_harmony)\n            evaluations += 1\n            \n            if new_score < self.best_score:\n                self.best_score = new_score\n                self.best_position = new_harmony\n            \n            worst_idx = np.argmax([func(harmony) for harmony in self.positions])\n            if new_score < func(self.positions[worst_idx]):\n                self.positions[worst_idx] = new_harmony\n            \n            self.adaptive_parameters(evaluations)", "name": "AdaptiveHarmonySearchWithQuantumTunneling", "description": "Adaptive Harmony Search with Quantum Tunneling enhances the classical harmony search by incorporating adaptive parameter tuning and quantum tunneling to explore the search space more effectively for photonic structure optimization.", "configspace": "", "generation": 81, "fitness": 0.5150080385009113, "feedback": "The algorithm AdaptiveHarmonySearchWithQuantumTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5019168480335074, 0.5280992289683151]}, "mutation_prompt": null}
{"id": "d9a0f182-db2b-4216-abd5-585a84152a19", "solution": "import numpy as np\n\nclass QuantumInspiredDESelfAdaptiveQBC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.mutation_factor = self.initial_mutation_factor\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_bit_collapse(self, individual):\n        # Dynamic quantum bit collapse for refined exploration\n        quantum_bit = np.random.rand(self.dim) < (self.mutation_factor * 0.5 + 0.5)\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        collapsed_individual = individual + self.mutation_factor * quantum_flip\n        return collapsed_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Self-adapting mutation factor based on convergence\n                convergence_factor = np.tanh(evaluations / self.budget)\n                self.mutation_factor = self.initial_mutation_factor * (1 - convergence_factor)\n        \n        # Quantum-inspired search with dynamic collapse\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            collapsed_position = self.quantum_bit_collapse(self.positions[i])\n            collapsed_position = np.clip(collapsed_position, func.bounds.lb, func.bounds.ub)\n            collapsed_score = func(collapsed_position)\n            evaluations += 1\n            \n            if collapsed_score < self.best_score:\n                self.best_score = collapsed_score\n                self.best_position = collapsed_position", "name": "QuantumInspiredDESelfAdaptiveQBC", "description": "Quantum-Inspired Differential Evolution with Self-Adaptive Quantum Bit Collapse refines search effectiveness by dynamic quantum bit collapse and self-adapting exploration-exploitation balance for enhanced optimization in photonic structure tasks.", "configspace": "", "generation": 82, "fitness": 0.7649845740312257, "feedback": "The algorithm QuantumInspiredDESelfAdaptiveQBC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76 with standard deviation 0.05.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7143331934399246, 0.8156359546225267]}, "mutation_prompt": null}
{"id": "b103621f-cab6-411c-8702-fa4eec7fab73", "solution": "import numpy as np\n\nclass QuantumPSOWithAdaptiveVelocity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def update_velocity(self, idx):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[idx] - self.positions[idx])\n        social_velocity = self.social_coeff * r2 * (self.best_position - self.positions[idx])\n        quantum_tunneling = np.random.normal(0, 0.1, self.dim)\n        return self.inertia_weight * self.velocities[idx] + cognitive_velocity + social_velocity + quantum_tunneling\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_score = func(self.positions[i])\n                evaluations += 1\n                \n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = current_score\n                    self.personal_best_positions[i] = np.copy(self.positions[i])\n                    \n                if current_score < self.best_score:\n                    self.best_score = current_score\n                    self.best_position = np.copy(self.positions[i])\n                \n                self.velocities[i] = self.update_velocity(i)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n                \n                # Adapt inertia weight based on progress\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n        \n        # Perform quantum tunneling for the final set of optimizations\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            quantum_position = self.positions[i] + np.random.normal(0, 0.1, self.dim)\n            quantum_position = np.clip(quantum_position, func.bounds.lb, func.bounds.ub)\n            quantum_score = func(quantum_position)\n            evaluations += 1\n            \n            if quantum_score < self.best_score:\n                self.best_score = quantum_score\n                self.best_position = quantum_position", "name": "QuantumPSOWithAdaptiveVelocity", "description": "Quantum Particle Swarm Optimization with Adaptive Velocity and Quantum Tunneling uses quantum tunneling for escaping local optima and adaptively adjusts velocities to balance exploration and exploitation in photonic optimization.", "configspace": "", "generation": 83, "fitness": 0.7318919844747116, "feedback": "The algorithm QuantumPSOWithAdaptiveVelocity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7349841681132561, 0.7287998008361671]}, "mutation_prompt": null}
{"id": "79ef2aba-2899-4fc1-8a7a-dacc652b26d9", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.local_best_positions = None\n        self.local_best_scores = None\n        self.global_influence = 0.5\n        self.personal_influence = 0.5\n        self.quantum_influence = 0.3\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.local_best_positions = np.copy(self.positions)\n        self.local_best_scores = np.full(self.swarm_size, float('inf'))\n    \n    def quantum_perturbation(self, position):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        perturbed_position = position + self.quantum_influence * quantum_flip\n        return perturbed_position\n    \n    def update_velocity_and_position(self):\n        r1 = np.random.rand(self.swarm_size, self.dim)\n        r2 = np.random.rand(self.swarm_size, self.dim)\n        \n        cognitive_component = self.personal_influence * r1 * (self.local_best_positions - self.positions)\n        social_component = self.global_influence * r2 * (self.best_position - self.positions)\n        \n        self.velocities += cognitive_component + social_component\n        self.positions += self.velocities\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                \n                current_position = np.clip(self.positions[i], func.bounds.lb, func.bounds.ub)\n                current_score = func(current_position)\n                evaluations += 1\n                \n                if current_score < self.local_best_scores[i]:\n                    self.local_best_scores[i] = current_score\n                    self.local_best_positions[i] = current_position\n                \n                if current_score < self.best_score:\n                    self.best_score = current_score\n                    self.best_position = current_position\n            \n            self.update_velocity_and_position()\n            \n            # Quantum-inspired search for diversity enhancement\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n                \n                perturbed_position = self.quantum_perturbation(self.positions[i])\n                perturbed_position = np.clip(perturbed_position, func.bounds.lb, func.bounds.ub)\n                perturbed_score = func(perturbed_position)\n                evaluations += 1\n                \n                if perturbed_score < self.local_best_scores[i]:\n                    self.local_best_scores[i] = perturbed_score\n                    self.local_best_positions[i] = perturbed_position\n                \n                if perturbed_score < self.best_score:\n                    self.best_score = perturbed_score\n                    self.best_position = perturbed_position", "name": "AdaptiveQuantumSwarmOptimization", "description": "Adaptive Quantum-Swarm Optimization (AQSO) combines swarm intelligence with quantum-inspired perturbations to dynamically adapt search behavior and enhance exploration in photonic optimization tasks.", "configspace": "", "generation": 84, "fitness": 0.7220811676653117, "feedback": "The algorithm AdaptiveQuantumSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7465945128281869, 0.6975678225024365]}, "mutation_prompt": null}
{"id": "7f3a479a-ac86-4d65-b3bb-a2a92f62a032", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithChaoticSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.chaos_sequence = self.generate_chaos_sequence(self.budget)\n    \n    def generate_chaos_sequence(self, length):\n        # Generate a chaotic sequence using Logistic Map\n        sequence = np.zeros(length)\n        sequence[0] = 0.7  # initial value\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i - 1] * (1 - sequence[i - 1])\n        return sequence\n\n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def chaotic_search(self, individual, iteration, bounds):\n        # Perturb individual using chaotic sequence\n        chaos_factor = self.chaos_sequence[iteration] * (bounds.ub - bounds.lb)\n        return np.clip(individual + chaos_factor * (np.random.rand(self.dim) - 0.5), bounds.lb, bounds.ub)\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Chaotic search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            chaotic_position = self.chaotic_search(self.positions[i], evaluations, func.bounds)\n            chaotic_score = func(chaotic_position)\n            evaluations += 1\n            \n            if chaotic_score < self.best_score:\n                self.best_score = chaotic_score\n                self.best_position = chaotic_position", "name": "QuantumInspiredDEWithChaoticSearch", "description": "Quantum-Inspired Differential Evolution with Chaotic Search utilizes quantum principles combined with chaos theory to escape local optima and adaptively enhances mutation rates for superior optimization in photonic structures.", "configspace": "", "generation": 85, "fitness": 0.8850885335715062, "feedback": "The algorithm QuantumInspiredDEWithChaoticSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.04.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.9264580945421065, 0.8437189726009059]}, "mutation_prompt": null}
{"id": "3aef627f-ad03-47ea-927e-79733e4cacf9", "solution": "import numpy as np\n\nclass QuantumInspiredPSOWithAdaptiveVelocity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n    \n    def quantum_inspired_update(self, velocity, position, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        new_velocity = velocity * quantum_flip\n        new_position = position + new_velocity\n        new_position = np.clip(new_position, lb, ub)\n        return new_position, new_velocity\n    \n    def update_velocity_and_position(self, idx, bounds):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = self.cognitive_coefficient * r1 * (self.personal_best_positions[idx] - self.positions[idx])\n        social_velocity = self.social_coefficient * r2 * (self.global_best_position - self.positions[idx])\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] + cognitive_velocity + social_velocity)\n        \n        # Adaptive velocity control\n        self.velocities[idx] *= (1 - np.linalg.norm(self.positions[idx] - self.global_best_position) / np.linalg.norm(bounds.ub - bounds.lb))\n        \n        self.positions[idx] += self.velocities[idx]\n        self.positions[idx] = np.clip(self.positions[idx], bounds.lb, bounds.ub)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                current_score = func(self.positions[i])\n                evaluations += 1\n\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = current_score\n                    self.personal_best_positions[i] = np.copy(self.positions[i])\n\n                if current_score < self.global_best_score:\n                    self.global_best_score = current_score\n                    self.global_best_position = np.copy(self.positions[i])\n\n                self.update_velocity_and_position(i, func.bounds)\n\n        # Quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n\n            new_position, new_velocity = self.quantum_inspired_update(self.velocities[i], self.positions[i], func.bounds)\n            new_score = func(new_position)\n            evaluations += 1\n\n            if new_score < self.global_best_score:\n                self.global_best_score = new_score\n                self.global_best_position = new_position", "name": "QuantumInspiredPSOWithAdaptiveVelocity", "description": "Quantum-Inspired Particle Swarm Optimization with Adaptive Velocity Control leverages quantum principles for enhanced exploration and adaptively adjusts velocity based on convergence to effectively optimize photonic structures.", "configspace": "", "generation": 86, "fitness": 0.8705794705958236, "feedback": "The algorithm QuantumInspiredPSOWithAdaptiveVelocity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8651437298492142, 0.8760152113424332]}, "mutation_prompt": null}
{"id": "145ffa4c-9112-4381-b9f1-23e9a0e45b26", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_mutation_factor = 0.5\n        self.mutation_factor = self.initial_mutation_factor\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual, evaluations):\n        # Adaptive quantum-inspired mutation with dynamic mutation\n        dynamic_factor = 1.0 - evaluations / self.budget\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip * dynamic_factor\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Enhanced quantum-inspired global search for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i], evaluations)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveQuantumMutation", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Mutation leverages quantum principles to adaptively enhance mutation strategies, aiming to balance exploration and exploitation for superior photonic structure optimization.", "configspace": "", "generation": 87, "fitness": 0.7856646232353621, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7934834426586039, 0.7778458038121202]}, "mutation_prompt": null}
{"id": "2ff63211-1345-4448-989b-f399713e7194", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.mutation_adapt_rate = 0.1\n        self.crossover_adapt_rate = 0.05\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def update_parameters(self, trial_score, current_score):\n        if trial_score < current_score:\n            self.mutation_factor += self.mutation_adapt_rate * (1 - self.mutation_factor)\n            self.crossover_rate += self.crossover_adapt_rate * (1 - self.crossover_rate)\n        else:\n            self.mutation_factor -= self.mutation_adapt_rate * self.mutation_factor\n            self.crossover_rate -= self.crossover_adapt_rate * self.crossover_rate\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                current_score = func(self.positions[i])\n                if trial_score < current_score:\n                    self.positions[i] = trial_vector\n                \n                self.update_parameters(trial_score, current_score)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDEWithLearning", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation and Learning Mechanism incorporates a learning component to dynamically adjust crossover and mutation parameters, leveraging previous successful trials to better navigate complex search spaces.", "configspace": "", "generation": 88, "fitness": 0.5078118242651857, "feedback": "The algorithm EnhancedQuantumInspiredDEWithLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5042245083671104, 0.5113991401632608]}, "mutation_prompt": null}
{"id": "59e6379b-4e6e-4a92-9e63-361843fae4a1", "solution": "import numpy as np\n\nclass QuantumInspiredSelfAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 30\n        self.positions = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n    \n    def initialize_swarm(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n\n    def quantum_inspired_velocity_update(self, velocity, position, global_best):\n        # Quantum-inspired influence on velocity\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        return velocity + quantum_flip * (global_best - position)\n    \n    def __call__(self, func):\n        self.initialize_swarm(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            \n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate particle fitness\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n                \n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (w * self.velocities[i] + cognitive_component + social_component)\n                \n                # Quantum-inspired velocity adjustment\n                self.velocities[i] = self.quantum_inspired_velocity_update(self.velocities[i], self.positions[i], self.global_best_position)\n                \n                # Update position\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], func.bounds.lb, func.bounds.ub)\n        \n        # Return best solution found\n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredSelfAdaptivePSO", "description": "Quantum-Inspired Self-Adaptive Particle Swarm Optimization integrates quantum principles with self-adaptive strategies to dynamically adjust swarm behavior for enhanced exploration and exploitation in complex photonic structure optimizations.", "configspace": "", "generation": 89, "fitness": 0.5667954145634376, "feedback": "The algorithm QuantumInspiredSelfAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.04.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.5263096342035971, 0.6072811949232781]}, "mutation_prompt": null}
{"id": "54c9fba5-dafb-4c46-b741-a89a7af52047", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_mutation_factor = 0.5\n        self.mutation_factor = self.initial_mutation_factor\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.memory = []  # For storing successful strategies\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        trial_score = func(trial_vector)\n        \n        return trial_vector, trial_score\n    \n    def adapt_strategy(self, success):\n        if success:\n            self.memory.append((self.mutation_factor, self.crossover_rate))\n            if len(self.memory) > 5:\n                self.memory.pop(0)\n            if np.random.rand() < 0.2 and self.memory:  # Occasionally explore successful past strategies\n                self.mutation_factor, self.crossover_rate = self.memory[np.random.randint(len(self.memory))]\n        else:\n            self.mutation_factor *= 0.95  # Gradually reduce the mutation factor if not successful\n            self.crossover_rate = 0.7  # Reset to default\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                    self.adapt_strategy(success=True)\n                else:\n                    self.adapt_strategy(success=False)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithAdaptiveLearning", "description": "Quantum-Inspired Differential Evolution with Adaptive Learning and Memory Integration enhances exploration and convergence by incorporating historical memory to adaptively adjust mutation and crossover rates based on past successes.", "configspace": "", "generation": 90, "fitness": 0.6575077865801054, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6774575455417027, 0.6375580276185082]}, "mutation_prompt": null}
{"id": "e0fca1fd-a9a7-4370-9d25-fc4ccea47d6f", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithEntanglement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        entanglement_factor = np.random.uniform(-0.1, 0.1, self.dim)\n        mutated_individual = individual + self.mutation_factor * (quantum_flip + entanglement_factor)\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDEWithEntanglement", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation and Quantum Entanglement leverages quantum entanglement principles to enhance diversity and convergence through dynamically-adapted mutation factors and collaboration between quantum-inspired vectors.", "configspace": "", "generation": 91, "fitness": 0.8736967809237217, "feedback": "The algorithm EnhancedQuantumInspiredDEWithEntanglement got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8529585902201934, 0.89443497162725]}, "mutation_prompt": null}
{"id": "1fb0cd5d-4fc0-4e8e-993f-f706a6928465", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.learning_factor = 0.5\n        self.inertia_weight = 0.7\n        self.initial_inertia_weight = 0.7\n    \n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n    \n    def update_velocities_and_positions(self, func, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_component = self.learning_factor * r1 * (self.personal_best_positions[i] - self.positions[i])\n            social_component = self.learning_factor * r2 * (self.best_position - self.positions[i])\n            quantum_component = self.quantum_component()\n\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                  + cognitive_component + social_component + quantum_component)\n            self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n    \n    def quantum_component(self):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        return self.learning_factor * quantum_flip\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n                \n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_position = self.positions[i].copy()\n            \n            self.update_velocities_and_positions(func, evaluations)\n            \n            # Adaptive inertia weight based on progress\n            self.inertia_weight = self.initial_inertia_weight * (1 - evaluations / self.budget)", "name": "QuantumInspiredAdaptivePSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization integrates quantum principles with adaptive learning rates to enhance exploration and convergence efficiency in optimizing photonic structures.", "configspace": "", "generation": 92, "fitness": 0.6704252592057719, "feedback": "The algorithm QuantumInspiredAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6562622189306477, 0.6845882994808961]}, "mutation_prompt": null}
{"id": "a113554e-2ef2-46ea-a93e-2763b9f7ca2c", "solution": "import numpy as np\n\nclass SwarmEnhancedQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_swarm_mutation(self, individual, global_best):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        inertia_weight = 0.5\n        cognitive_component = 2 * np.random.rand(self.dim) * (self.personal_best_positions[individual] - self.positions[individual])\n        social_component = 2 * np.random.rand(self.dim) * (global_best - self.positions[individual])\n        self.velocities[individual] = (inertia_weight * self.velocities[individual] + \n                                       cognitive_component + social_component)\n        new_position = self.positions[individual] + self.velocities[individual] + self.mutation_factor * quantum_flip\n        return new_position\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n        \n        # Swarm-enhanced quantum mutation for final optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_swarm_mutation(i, self.best_position)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "SwarmEnhancedQuantumDE", "description": "Swarm-enhanced Quantum Differential Evolution integrates swarm intelligence principles with quantum mutation to foster cooperative optimization and enhance convergence for complex photonic structures.", "configspace": "", "generation": 93, "fitness": 0.8404496717379953, "feedback": "The algorithm SwarmEnhancedQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84 with standard deviation 0.02.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8559077520034444, 0.8249915914725463]}, "mutation_prompt": null}
{"id": "ed8c39de-f18c-4bee-9fd6-abf8b080ec25", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveArchiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.archive_size = 5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.archive = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.archive = np.empty((0, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n\n    def update_archive(self, candidate):\n        # Add new candidate to archive based on performance\n        if self.archive.shape[0] < self.archive_size:\n            self.archive = np.vstack([self.archive, candidate])\n        else:\n            worst_idx = np.argmax([self.func(cand) for cand in self.archive])\n            if self.func(candidate) < self.func(self.archive[worst_idx]):\n                self.archive[worst_idx] = candidate\n\n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        if self.archive.shape[0] > 0:\n            archive_idx = np.random.randint(self.archive.shape[0])\n            mutant_vector += self.mutation_factor * (self.archive[archive_idx] - self.positions[a])\n        \n        trial_vector = np.copy(self.positions[target_idx])\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.func = func\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                    self.update_archive(trial_vector)\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position\n                self.update_archive(mutated_position)", "name": "QuantumInspiredAdaptiveArchiveDE", "description": "Quantum-Inspired Adaptive Archive DE integrates an archive of elite solutions and adaptive mutation strategy to intensify exploration and exploitation, enhancing robustness and convergence speed in optimizing photonic structures.", "configspace": "", "generation": 94, "fitness": 0.7146248611517666, "feedback": "The algorithm QuantumInspiredAdaptiveArchiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.00.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7117924490002474, 0.7174572733032858]}, "mutation_prompt": null}
{"id": "75fc7f00-b3f8-4737-a3db-b8f325b03191", "solution": "import numpy as np\n\nclass QuantumInspiredGuidedEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.mutation_strength = 0.1\n        self.crossover_rate = 0.8\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_guided_mutation(self, individual, global_best):\n        # Introduce quantum-inspired randomization and guide towards the global best\n        random_flip = np.random.uniform(-1, 1, self.dim) * self.mutation_strength\n        guided_move = (global_best - individual) * np.random.rand()\n        mutated_individual = individual + random_flip + guided_move\n        return mutated_individual\n    \n    def guided_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b = np.random.choice(indices, 2, replace=False)\n        \n        trial_vector = np.copy(self.positions[target_idx])\n        if np.random.rand() < self.crossover_rate:\n            trial_vector = self.positions[a] + np.random.rand(self.dim) * (self.positions[b] - trial_vector)\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.guided_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n        \n        # Final quantum-inspired global optimization\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_guided_mutation(self.positions[i], self.best_position)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredGuidedEvolutionStrategy", "description": "Quantum-Inspired Guided Evolution Strategy combines quantum-inspired randomization with guided evolution strategies for balancing exploration and exploitation in high-dimensional optimization tasks.", "configspace": "", "generation": 95, "fitness": 0.8399483089458606, "feedback": "The algorithm QuantumInspiredGuidedEvolutionStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.852633147963656, 0.8272634699280652]}, "mutation_prompt": null}
{"id": "d96cc68a-2814-4b8b-af50-7be131cbfb02", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithDynamicQuantumRotation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_rotation_mutation(self, individual, evaluations):\n        # Apply quantum-inspired rotation to diversify search\n        quantum_rotation_angle = np.pi * (1 - evaluations / self.budget)\n        rotation_matrix = np.array([[np.cos(quantum_rotation_angle), -np.sin(quantum_rotation_angle)],\n                                    [np.sin(quantum_rotation_angle), np.cos(quantum_rotation_angle)]])\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        rotated_vector = np.dot(rotation_matrix, quantum_flip)\n        mutated_individual = individual + self.mutation_factor * rotated_vector\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                # Adaptive mutation factor based on progress\n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        # Quantum-inspired global search with dynamic rotation\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_rotation_mutation(self.positions[i], evaluations)\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumInspiredDEWithDynamicQuantumRotation", "description": "Quantum-Inspired Differential Evolution with Dynamic Quantum Rotation integrates dynamic quantum rotation mechanisms to diversify search pathways and refine mutation processes, aiming for enhanced convergence in photonic structure optimization.", "configspace": "", "generation": 96, "fitness": 0.810113212139782, "feedback": "The algorithm QuantumInspiredDEWithDynamicQuantumRotation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.8000004728288653, 0.8202259514506989]}, "mutation_prompt": null}
{"id": "58aa5533-372a-4ae9-8d86-45f89c4083f9", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDEWithAdaptiveCognitiveAcceleration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.cognitive_factor = 0.8\n        self.positions = None\n        self.velocities = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.initial_mutation_factor = 0.5\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        for i in range(self.population_size):\n            cognitive_component = self.cognitive_factor * np.random.rand(self.dim) * (self.personal_best_positions[i] - self.positions[i])\n            self.velocities[i] += cognitive_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], lb, ub)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n                \n                self.update_velocities_and_positions(func.bounds)\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "EnhancedQuantumInspiredDEWithAdaptiveCognitiveAcceleration", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Cognitive Acceleration improves exploration by introducing dynamic cognitive components inspired by particle swarm optimization principles, tailored for complex photonic structure optimization.", "configspace": "", "generation": 97, "fitness": 0.6319716483371345, "feedback": "The algorithm EnhancedQuantumInspiredDEWithAdaptiveCognitiveAcceleration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.6453188156650245, 0.6186244810092446]}, "mutation_prompt": null}
{"id": "b4ffa317-3317-48b4-8253-50252156e21c", "solution": "import numpy as np\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF, ConstantKernel as C\n\nclass HybridQuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.initial_mutation_factor = 0.5\n        self.kernel = C(1.0, (1e-3, 1e3)) * RBF(1.0, (1e-2, 1e2))\n        self.gp = GaussianProcessRegressor(kernel=self.kernel, n_restarts_optimizer=10)\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def quantum_inspired_mutation(self, individual):\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def surrogate_assisted_selection(self, func, evaluations):\n        try:\n            self.gp.fit(self.positions, np.array([func(pos) for pos in self.positions]))\n            predicted_scores = self.gp.predict(self.positions)\n            candidate_idx = np.argmin(predicted_scores)\n            candidate_position = self.positions[candidate_idx]\n            candidate_score = func(candidate_position)\n            evaluations += 1\n            return candidate_position, candidate_score\n        except Exception as e:\n            return None, float('inf')\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n                self.mutation_factor = self.initial_mutation_factor * (1 - evaluations / self.budget)\n            \n            candidate_position, candidate_score = self.surrogate_assisted_selection(func, evaluations)\n            if candidate_position is not None and candidate_score < self.best_score:\n                self.best_score = candidate_score\n                self.best_position = candidate_position\n        \n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "HybridQuantumInspiredADE", "description": "Hybrid Quantum-Inspired Adaptive Differential Evolution integrates a kernel-based surrogate model with quantum-inspired adaptive mutation to efficiently explore and exploit the search space, improving convergence in photonic structure optimization.", "configspace": "", "generation": 98, "fitness": 0.6915740073279026, "feedback": "The algorithm HybridQuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.01.", "error": "", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {"aucs": [0.7009703262917555, 0.6821776883640499]}, "mutation_prompt": null}
{"id": "70d81d39-4c51-414f-9433-329e972b7f20", "solution": "import numpy as np\n\nclass QuantumLevyEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.positions = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        \n    def levy_flight(self, scale=0.1):\n        # Generate a Levy flight step\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return scale * step\n    \n    def quantum_inspired_mutation(self, individual):\n        # Apply quantum-inspired mutation to introduce diversity\n        quantum_bit = np.random.rand(self.dim) < 0.5\n        quantum_flip = np.where(quantum_bit, 1, -1)\n        mutated_individual = individual + self.mutation_factor * quantum_flip\n        return mutated_individual\n    \n    def differential_evolution(self, func, target_idx, evaluations):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        trial_vector = np.copy(self.positions[target_idx])\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n        \n        trial_vector = np.clip(trial_vector, lb, ub)\n        return trial_vector, func(trial_vector)\n    \n    def __call__(self, func):\n        self.initialize_positions(func.bounds)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                trial_vector, trial_score = self.differential_evolution(func, i, evaluations)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n                \n            # Perform Lvy flight for enhanced exploration\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                levy_step = self.levy_flight()\n                trial_vector = self.positions[i] + levy_step\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_position = trial_vector\n                \n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = trial_vector\n        \n        # Quantum-inspired final optimization phase\n        for i in range(self.population_size):\n            if evaluations >= self.budget:\n                break\n            \n            mutated_position = self.quantum_inspired_mutation(self.positions[i])\n            mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n            mutated_score = func(mutated_position)\n            evaluations += 1\n            \n            if mutated_score < self.best_score:\n                self.best_score = mutated_score\n                self.best_position = mutated_position", "name": "QuantumLevyEnhancedDE", "description": "Quantum-Lvy Enhanced Differential Evolution leverages quantum-inspired mechanisms and Lvy flight distribution to enhance global exploration and avoid local optima in photonic structure optimization.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "7372a462-b124-484c-9bda-845bf1737d06", "metadata": {}, "mutation_prompt": null}
