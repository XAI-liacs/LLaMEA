{"id": "af48eba2-2dff-4ad0-bc6a-45d306048adf", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.5  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.99  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-1, 1, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "A hybrid Particle Swarm-Based Simulated Annealing algorithm that combines the global search capability of Particle Swarm Optimization (PSO) with the local search refinement of Simulated Annealing (SA) to enhance exploration and exploitation in optimizing complex photonic structures.", "configspace": "", "generation": 0, "fitness": 0.3250551351044432, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.01.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3201318730056032, 0.33755084968794813, 0.3174826826197783]}, "mutation_prompt": null}
{"id": "43fdc050-d4c3-42b6-90cb-040837d6dbc5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.9  # Adjusted inertia weight for improved exploration\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.5  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.995  # Adjusted cooling rate for improved exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-1, 1, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced the inertia weight and cooling rate dynamism to improve convergence speed and solution quality.", "configspace": "", "generation": 1, "fitness": 0.233837930317073, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.01.", "error": "", "parent_id": "af48eba2-2dff-4ad0-bc6a-45d306048adf", "metadata": {"aucs": [0.22496469018864496, 0.24501330666151167, 0.2315357941010624]}, "mutation_prompt": null}
{"id": "63a33861-3285-4034-a55e-6d32e9930991", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.5  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "A refined hybrid Particle Swarm Optimization with Simulated Annealing, enhancing velocity update and annealing process to improve convergence in photonic structure optimization.", "configspace": "", "generation": 2, "fitness": 0.3381018574642202, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.02.", "error": "", "parent_id": "af48eba2-2dff-4ad0-bc6a-45d306048adf", "metadata": {"aucs": [0.35892210007863146, 0.34797529948020245, 0.3074081728338266]}, "mutation_prompt": null}
{"id": "22d76d9f-9eca-45bc-bd08-edf451d6c5e5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.8  # social weight, increased from 1.5 to 1.8\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "An enhanced HybridPSO_SA with an increased social weight to accelerate convergence towards the global best in photonic structure optimization.", "configspace": "", "generation": 3, "fitness": 0.34003515957219504, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.01.", "error": "", "parent_id": "63a33861-3285-4034-a55e-6d32e9930991", "metadata": {"aucs": [0.3527395016161188, 0.34578537381436725, 0.32158060328609894]}, "mutation_prompt": null}
{"id": "f03f4d02-ccbe-4562-9d80-058c5f31c150", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Further enhanced HybridPSO_SA by slightly increasing the cognitive weight to improve individual exploration.", "configspace": "", "generation": 4, "fitness": 0.3357284418965221, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.01.", "error": "", "parent_id": "22d76d9f-9eca-45bc-bd08-edf451d6c5e5", "metadata": {"aucs": [0.3192636785749289, 0.34538209731093605, 0.3425395498037015]}, "mutation_prompt": null}
{"id": "22167354-f300-489d-b036-1eb9b9e2da3c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.6  # inertia weight, increased from 0.5 to 0.6\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA, changed from 0.98 to 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by adjusting cooling rate and inertia weight to enhance convergence stability.", "configspace": "", "generation": 5, "fitness": 0.3722869344377541, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.01.", "error": "", "parent_id": "22d76d9f-9eca-45bc-bd08-edf451d6c5e5", "metadata": {"aucs": [0.38116885543771817, 0.3645960263276836, 0.37109592154786053]}, "mutation_prompt": null}
{"id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Refined the PSO component by slightly increasing the cognitive weight to enhance individual learning and exploration capabilities.", "configspace": "", "generation": 6, "fitness": 0.3728111919182841, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.01.", "error": "", "parent_id": "22167354-f300-489d-b036-1eb9b9e2da3c", "metadata": {"aucs": [0.3911851061676106, 0.3629509881039339, 0.36429748148330765]}, "mutation_prompt": null}
{"id": "0a70ef31-eba9-48c4-bece-1c54b168f0c0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.96  # cooling rate for SA, increased from 0.95 to 0.96\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced the cooling schedule by increasing the cooling rate slightly to stabilize searches and improve convergence.", "configspace": "", "generation": 7, "fitness": 0.2730211990593785, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.02.", "error": "", "parent_id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "metadata": {"aucs": [0.25800922341051635, 0.2995687128954544, 0.26148566087216474]}, "mutation_prompt": null}
{"id": "ee461a93-c46e-4acf-ae06-4560af319e5f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Further refine the particle velocities update by adjusting the inertia weight to enhance exploration. ", "configspace": "", "generation": 8, "fitness": 0.1787156027762878, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.00.", "error": "", "parent_id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "metadata": {"aucs": [0.1778910387509427, 0.18020653028598577, 0.17804923929193495]}, "mutation_prompt": null}
{"id": "447d2690-09ae-4022-9057-c8fcb196ac95", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * (evals / self.budget)  # Adaptive inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Incorporated adaptive inertia weight to improve convergence speed and avoid local optima.", "configspace": "", "generation": 9, "fitness": 0.3605643140902977, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.03.", "error": "", "parent_id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "metadata": {"aucs": [0.34082881101321494, 0.34281270962134747, 0.3980514216363308]}, "mutation_prompt": null}
{"id": "f23905f6-dd69-4c76-92d2-d0704d6ddb51", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.6  # inertia weight\n        self.c1_init = 1.6  # initial cognitive weight\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update cognitive weight dynamically\n            c1 = self.c1_init * (1 - evals / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced a dynamic cognitive weight that decreases over iterations to balance exploration and exploitation in the PSO component.", "configspace": "", "generation": 10, "fitness": 0.09915576775614283, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.01.", "error": "", "parent_id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "metadata": {"aucs": [0.11012961694138279, 0.08889017251810305, 0.09844751380894268]}, "mutation_prompt": null}
{"id": "d6ad23e3-86a1-409d-82a7-f1312323671b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight\n        self.c2 = 1.9  # social weight, increased from 1.8 to 1.9\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the social weight slightly to enhance swarm convergence towards global best.", "configspace": "", "generation": 11, "fitness": 0.3500622658446429, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.01.", "error": "", "parent_id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "metadata": {"aucs": [0.346113320183398, 0.33689583975077253, 0.3671776375997581]}, "mutation_prompt": null}
{"id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increased the population size to improve the diversity of the solution pool and enhance exploration capability.", "configspace": "", "generation": 12, "fitness": 0.3964791020924534, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.02.", "error": "", "parent_id": "63a9ab73-6fa8-47ad-85a4-f2e2c9e08090", "metadata": {"aucs": [0.37281708278846015, 0.41366200180785295, 0.402958221681047]}, "mutation_prompt": null}
{"id": "a911c02f-0795-4a8e-8c78-80f04835279f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.9  # adjusted cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Update inertia weight dynamically\n            w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down with nonlinear schedule\n            self.temperature *= self.cooling_rate ** (evals / self.budget)\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by adapting inertia weight dynamically and adding a nonlinear cooling schedule for Simulated Annealing.", "configspace": "", "generation": 13, "fitness": 0.3458381911559431, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.03.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.39272599327584057, 0.33291584489142567, 0.31187273530056303]}, "mutation_prompt": null}
{"id": "cdf2d67d-dbe9-4b68-bc82-f3a483748492", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved the exploration by slightly adjusting the inertia weight to balance exploitation and exploration.", "configspace": "", "generation": 14, "fitness": 0.31591087235595866, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.01.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.3356953426843936, 0.301033723852033, 0.31100355053144935]}, "mutation_prompt": null}
{"id": "877e52e0-202d-483a-b395-727830b43e57", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.6\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.93  # slightly adjusted cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions) +\n                                0.01 * np.random.standard_normal((self.population_size, self.dim)))  # Lvy flight perturbation\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved global exploration by introducing Lvy flight perturbation in the PSO update and adjusted simulated annealing parameters for enhanced convergence.", "configspace": "", "generation": 15, "fitness": 0.2536699585285102, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.02.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.2420332056784339, 0.2753470375815934, 0.2436296323255034]}, "mutation_prompt": null}
{"id": "d7a894c6-9c66-4ad1-b34d-a2d9bc16e5a6", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.9  # dynamically adjusted inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 150  # initial temperature for SA, increased from 100\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced exploration by adjusting the inertia weight dynamically and increasing the initial temperature for better global search.", "configspace": "", "generation": 16, "fitness": 0.3816313881397875, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.04.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.3956095981922406, 0.3230918598158439, 0.42619270641127793]}, "mutation_prompt": null}
{"id": "43edea0c-c85d-4426-8afa-0872374ebb3c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.c1, self.c2 = 2.0 * np.random.rand(), 2.0 * np.random.rand()  # Dynamic weights adjustment\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introducing dynamic social and cognitive weights to balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.04953780742200905, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.03.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.04644438019128827, 0.018768798403766773, 0.0834002436709721]}, "mutation_prompt": null}
{"id": "aa8c1950-c6ad-4b09-abcc-3bdcca57baba", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, slightly increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "A small tweak to the inertia weight improves convergence speed and solution quality.", "configspace": "", "generation": 18, "fitness": 0.3869564976346391, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.02.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.37054562327813845, 0.4083014165711685, 0.38202245305461036]}, "mutation_prompt": null}
{"id": "34801a89-d6ca-4f1f-be06-8a7af298fd4f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.93  # cooling rate for SA, adjusted from 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly adjusted the cooling rate to enhance the simulated annealing component's exploration capability.", "configspace": "", "generation": 19, "fitness": 0.3138188819889411, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.02.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.33559258036470807, 0.2999114633550587, 0.30595260224705645]}, "mutation_prompt": null}
{"id": "a4a31a03-dc37-4582-b545-b88c11363079", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.7  # inertia weight, increased from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.95  # cooling rate for SA\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_velocities = np.clip(swarm_velocities, -0.5, 0.5)  # velocity clamping\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tuned the inertia weight and added a velocity clamping mechanism to enhance convergence.", "configspace": "", "generation": 20, "fitness": 0.30396834013469576, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.02.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.33703353239753964, 0.2822843455833529, 0.2925871424231947]}, "mutation_prompt": null}
{"id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Reduce the cooling rate to enhance exploitation via more gradual temperature reduction.", "configspace": "", "generation": 21, "fitness": 0.4273247204011996, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.09.", "error": "", "parent_id": "bbd94a2e-02ec-4b6f-a1c1-5b538f886e80", "metadata": {"aucs": [0.380124254973519, 0.34953220144047326, 0.5523177047896065]}, "mutation_prompt": null}
{"id": "eb392f08-cfb1-47d9-b6d9-1b1d04fa15df", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 22, "fitness": 0.14315866059018348, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.15483296088791665, 0.11652578339972519, 0.15811723748290862]}, "mutation_prompt": null}
{"id": "8aea5544-74d3-432b-a0f1-b511216e5314", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.9  # social weight, increased from 1.8 to 1.9\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tune the social weight from 1.8 to 1.9 to enhance convergence by strengthening the influence of the global best position.", "configspace": "", "generation": 23, "fitness": 0.3124465255666677, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.30891720884748797, 0.3189280067589392, 0.309494361093576]}, "mutation_prompt": null}
{"id": "f795e143-f733-4cf7-b65c-14e906b77f4d", "solution": "import numpy as np\n\nclass HybridPSO_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.9  # adaptive start inertia weight, increased from 0.6\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.99  # increased cooling rate from 0.98 to 0.99\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Update inertia weight adaptively\n            self.w = self.w_min + (0.9 - self.w_min) * ((self.budget - evals) / self.budget)\n\n            # Update velocities and positions with adaptive inertia\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA_Improved", "description": "Leverage adaptive inertia weighting and accelerated cooling to optimize global exploration and local exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.32086775419746955, "feedback": "The algorithm HybridPSO_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3001284158874098, 0.3229117420908404, 0.3395631046141585]}, "mutation_prompt": null}
{"id": "bf5fa90e-508d-4ba5-8120-09273da76d41", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.5  # cognitive weight, adjusted from 1.6 to 1.5\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tune the cognitive weight for improved exploration and convergence balance.", "configspace": "", "generation": 25, "fitness": 0.26247664588373726, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.23105886285467414, 0.28783808526536836, 0.26853298953116933]}, "mutation_prompt": null}
{"id": "cfaff991-4090-41d1-9e4a-8fd4da1ee31f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.9  # initial inertia weight increased \n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * (evals / self.budget)  # adaptive inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 26, "fitness": 0.2610970312343551, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2534802573869954, 0.25502261420658234, 0.2747882221094876]}, "mutation_prompt": null}
{"id": "7faf8a92-5d68-41e0-934b-d862e4886127", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, adjusted from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Refine inertia weight to improve exploration and convergence balance.", "configspace": "", "generation": 27, "fitness": 0.41284440799769, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.389069871857571, 0.4429633457682428, 0.40650000636725614]}, "mutation_prompt": null}
{"id": "03c6f057-9c62-4019-bf71-c4b535d65a5d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.7  # cognitive weight, increased from 1.6 to 1.7\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the cognitive weight to 1.7 to enhance personal exploration and potentially accelerate convergence.", "configspace": "", "generation": 28, "fitness": 0.31126504221829643, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.06.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.27132652632860466, 0.4011132435143593, 0.26135535681192534]}, "mutation_prompt": null}
{"id": "850348c4-523c-4101-af2e-2b3059fdcbe1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Update inertia weight dynamically\n            self.w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand() * 1.2:  # stochastic acceptance\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and stochastic acceptance probability to enhance exploration and convergence balance.", "configspace": "", "generation": 29, "fitness": 0.2905380835809543, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3367436148494031, 0.27920019067607504, 0.2556704452173848]}, "mutation_prompt": null}
{"id": "31fd870c-1008-43ab-9f3e-c273f700f06a", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100 \n        self.temperature_min = 1  # minimum temperature\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Adaptive Inertia Weight\n            w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Dynamic Cooling\n            self.temperature = max(self.temperature * self.cooling_rate, self.temperature_min)\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance exploration by introducing adaptive inertia weight and dynamic temperature adjustment.", "configspace": "", "generation": 30, "fitness": 0.3564781647927218, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3582985660180813, 0.364305213485803, 0.3468307148742812]}, "mutation_prompt": null}
{"id": "23e0117a-d42b-487a-9cee-5b9172341294", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.initial_w = 0.9  # initial inertia weight\n        self.final_w = 0.4  # final inertia weight\n        self.c1 = 1.5  # cognitive weight, reverted to 1.5\n        self.c2 = 1.5  # social weight, reduced from 1.8 to 1.5 for balance\n        self.temperature = 100\n        self.initial_cooling_rate = 0.98  # starts with 0.98\n        self.final_cooling_rate = 0.92  # decreases to 0.92\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Adaptive inertia weight and cooling rate\n            progress = evals / self.budget\n            w = self.initial_w - progress * (self.initial_w - self.final_w)\n            cooling_rate = self.final_cooling_rate + (1 - progress) * (self.initial_cooling_rate - self.final_cooling_rate)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive parameters and dynamic cooling to enhance exploration and exploitation balance in HybridPSO_SA.", "configspace": "", "generation": 31, "fitness": 0.35514827419387157, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3129596566280457, 0.37470576588485216, 0.3777794000687169]}, "mutation_prompt": null}
{"id": "c42bd8fa-0384-4a8c-9c99-c53b3ee547c6", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, adjusted from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tune the inertia weight to enhance exploration and convergence speed balance.", "configspace": "", "generation": 32, "fitness": 0.2569815398574365, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2889940059479412, 0.24325121702748298, 0.23869939659688522]}, "mutation_prompt": null}
{"id": "5ffd8639-0038-418a-83cf-c42a655d5529", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.7  # inertia weight, increased from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.99  # dynamic cooling rate for SA, increased from 0.98 to 0.99\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Tune inertia weight and integrate a more dynamic cooling rate to balance exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.30054688657446005, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3096860463231934, 0.2871898075137074, 0.30476480588647936]}, "mutation_prompt": null}
{"id": "06681224-a8a7-4250-8ad4-dc93b214e10e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.85  # social weight, increased from 1.8 to 1.85\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly increase the social weight to enhance exploration capabilities.", "configspace": "", "generation": 34, "fitness": 0.25625056615877456, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.05.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2879919225513278, 0.2900482143246208, 0.19071156160037506]}, "mutation_prompt": null}
{"id": "c828b71c-0120-4034-8315-0cd881b93e9f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # increased from 55 to 60\n        self.w = 0.7  # inertia weight, increased from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight\n        self.c2 = 1.8  # social weight\n        self.temperature = 100\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance exploration by increasing the population size and adjusting parameters for better diversity.", "configspace": "", "generation": 35, "fitness": 0.36837846541570357, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3364312657712972, 0.4176389816040007, 0.3510651488718127]}, "mutation_prompt": null}
{"id": "6f85bd1c-9cb5-4006-b436-b04c1497b10e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.9  # initial inertia weight, made adaptive\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98  # initial cooling rate\n        self.cooling_rate_decrease_factor = 0.995  # new cooling rate decrease factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = self.w_min + (0.9 - self.w_min) * (self.budget - evals) / self.budget  # adaptive inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n            self.cooling_rate *= self.cooling_rate_decrease_factor  # dynamically adjust cooling rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Incorporate adaptive inertia weight and dynamic cooling rate adjustment to enhance convergence speed and solution quality.", "configspace": "", "generation": 36, "fitness": 0.07526663171439325, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.09891113376440519, 0.04485326699575187, 0.08203549438302271]}, "mutation_prompt": null}
{"id": "2ee88498-01af-472a-bfff-23b0294bf1bb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 56  # increased from 55 to 56\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the population size slightly to enhance exploration capabilities.", "configspace": "", "generation": 37, "fitness": 0.33269725740352923, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.31286064396261726, 0.31544704396052303, 0.36978408428744736]}, "mutation_prompt": null}
{"id": "20b4d562-498b-4102-8670-142b114cbec2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # increased from 55 to 60\n        self.w = 0.9  # modified inertia weight to start high for exploration\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            inertia_weight = self.w * (1 - evals / self.budget)  # dynamic inertia weight reduction\n            swarm_velocities = (inertia_weight * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjusted inertia weight dynamically and tuned population size to enhance convergence speed and precision.", "configspace": "", "generation": 38, "fitness": 0.31978655375674514, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.31879530133533607, 0.33973981123683206, 0.3008245486980673]}, "mutation_prompt": null}
{"id": "d83ce1ff-22e8-4f05-a4f7-f521356e5eb5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.6, 0.6, self.dim) * self.temperature  # changed from 0.5 to 0.6\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance global search by slightly increasing inertia weight and introducing local search diversity.", "configspace": "", "generation": 39, "fitness": 0.3743220473320188, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.36866541333850966, 0.36455816150492604, 0.3897425671526207]}, "mutation_prompt": null}
{"id": "31c2a926-70fb-4cc7-91bd-eae78e9d860b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.9  # social weight, increased from 1.8 to 1.9\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the social weight to enhance exploration by encouraging particles to follow the global best position more strongly.", "configspace": "", "generation": 40, "fitness": 0.36303538298115395, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3618016149552691, 0.40736489823206345, 0.3199396357561294]}, "mutation_prompt": null}
{"id": "d69a35c1-f6bf-4c3b-aa20-929df09b808c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.5  # inertia weight, reduced from 0.6 to 0.5\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly improve global exploration by reducing the inertia weight, which balances exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.29790830370450155, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.31181310186636413, 0.2817370897992947, 0.3001747194478458]}, "mutation_prompt": null}
{"id": "c0078638-af58-4b29-b7c3-e3198b1bba89", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.4 + 0.5 * (self.budget - evals) / self.budget  # Dynamic inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjust inertia weight dynamically to balance exploration and exploitation.", "configspace": "", "generation": 42, "fitness": 0.32729681686561246, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3502114766227973, 0.32960314566286375, 0.3020758283111764]}, "mutation_prompt": null}
{"id": "c532e22c-05ea-4e5b-b7f4-19feba7dd611", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55 \n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6  \n        self.c2 = 1.8  \n        self.temperature = 100  \n        self.cooling_rate = 0.98  \n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  \n        while evals < self.budget:\n            # Adaptive inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search with Gaussian mutation\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.normal(0, 0.1, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and integrate Gaussian mutations to enhance exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.37235629302919043, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.416223692209886, 0.3728140170720692, 0.3280311698056161]}, "mutation_prompt": null}
{"id": "25845cc8-0158-425e-836c-5b083aa385ab", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.65  # cognitive weight, increased from 1.6 to 1.65\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly increase the cognitive weight to enhance personal exploration in search space.", "configspace": "", "generation": 44, "fitness": 0.38655200843133236, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.392694299592248, 0.3362079694647504, 0.43075375623699885]}, "mutation_prompt": null}
{"id": "56a0101d-e57c-4fa2-bd39-e83371ff0479", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.6\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            adaptive_c1 = self.c1 * (1 - evals / self.budget)\n            adaptive_c2 = self.c2 * (evals / self.budget)\n            swarm_velocities = (self.w * swarm_velocities +\n                                adaptive_c1 * r1 * (personal_best_positions - swarm_positions) +\n                                adaptive_c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            opposite_positions = lb + ub - swarm_positions\n            opposite_positions = np.clip(opposite_positions, lb, ub)\n            opposite_scores = np.array([func(x) for x in opposite_positions])\n            evals += self.population_size\n\n            replace = opposite_scores < scores\n            swarm_positions[replace] = opposite_positions[replace]\n            scores[replace] = opposite_scores[replace]\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Integrate adaptive learning rates and an opposition-based learning strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.3203755985934999, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.34143890212853634, 0.30055044783103524, 0.31913744582092807]}, "mutation_prompt": null}
{"id": "a15887a6-37c8-4f63-b9ae-4c280454d6b6", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.6\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.99  # adaptive cooling scheme start\n        self.cooling_factor = 0.95  # new factor for adaptive cooling\n\n    def levy_flight(self, step_size, lb, ub):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1/3)\n        return np.clip(step_size * step, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + self.levy_flight(self.temperature, lb, ub)  # Lvy flight for exploration\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            if evals % (self.population_size * 2) == 0:  # adaptive cooling rate adjustment\n                self.cooling_rate *= self.cooling_factor\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved exploration by introducing Lvy flights and adaptive cooling scheme to balance search phases.", "configspace": "", "generation": 46, "fitness": 0.3604657298192981, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.06.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3669151586495225, 0.42465601733420344, 0.28982601347416836]}, "mutation_prompt": null}
{"id": "1e7c9123-8401-454d-a832-a72cca4851bf", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.5  # inertia weight, reduced from 0.6 to 0.5\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjust the inertia weight (w) to improve the balance between exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.30727404920306645, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2794390985427472, 0.3277601344243035, 0.31462291464214864]}, "mutation_prompt": null}
{"id": "b6f7358d-504c-4e98-a806-467558ac8d8e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            self.w = 0.9 - (0.5 * evals / self.budget)  # Dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjust inertia weight dynamically to enhance balance between exploration and exploitation.", "configspace": "", "generation": 48, "fitness": 0.34600816915149357, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3755313847489691, 0.3216288824668809, 0.3408642402386306]}, "mutation_prompt": null}
{"id": "64283e89-da53-418f-ae8c-d13510c295ad", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.7  # inertia weight, increased from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase inertia weight to enhance exploration capabilities in the initial phase.", "configspace": "", "generation": 49, "fitness": 0.3251545472856275, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3481120282865766, 0.32268271563742923, 0.30466889793287666]}, "mutation_prompt": null}
{"id": "c8601665-8b4b-4bbd-9c36-c00e1ee1cd18", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.65  # cognitive weight, increased from 1.6 to 1.65\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly increase the cognitive weight to enhance the exploration capability of particles.", "configspace": "", "generation": 50, "fitness": 0.39049515576332405, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.05.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.32365072424464336, 0.4484397892775748, 0.399394953767754]}, "mutation_prompt": null}
{"id": "93945c22-c25a-49e5-b64d-cd4330e5377f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.6\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n        self.mutation_prob = 0.1  # mutation probability added\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:  # apply mutation\n                    candidate_pos = swarm_positions[i] + np.random.normal(0, 0.1, self.dim)\n                else:\n                    candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Integrate a mutation operator to enhance exploration and improve convergence reliability.", "configspace": "", "generation": 51, "fitness": 0.3461499522552463, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.34931860000206527, 0.30745943263460906, 0.38167182412906464]}, "mutation_prompt": null}
{"id": "ae7ad65d-eb9f-4df3-9a6e-07a583b024f7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))  # increased randomness\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase swarm velocity randomness to enhance exploration capabilities.", "configspace": "", "generation": 52, "fitness": 0.3698956375814544, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.41255863888505295, 0.38203371058614544, 0.31509456327316465]}, "mutation_prompt": null}
{"id": "af3627e1-4c1d-472e-b488-e477d9e0449e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # increased from 55 to 60\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.97  # cooling rate for SA, reduced from 0.98 to 0.97\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance convergence speed by increasing the population size and fine-tuning inertia and cooling parameters.", "configspace": "", "generation": 53, "fitness": 0.30588885677446787, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3261183240381539, 0.27852940265232373, 0.313018843632926]}, "mutation_prompt": null}
{"id": "7c6c296b-3938-4175-9668-81a5eb3395a5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjust the inertia weight to improve the balance between exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.35268640292468617, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3599243154031727, 0.3638507348516308, 0.3342841585192552]}, "mutation_prompt": null}
{"id": "64834452-7e06-4ca9-bba1-8d58e0919f58", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.7  # cognitive weight, increased from 1.6 to 1.7\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Modify the cognitive weight to balance exploration and exploitation more effectively.", "configspace": "", "generation": 55, "fitness": 0.35750012808787063, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.34181930131007665, 0.40736489823206345, 0.3233161847214716]}, "mutation_prompt": null}
{"id": "a85403c9-89fa-4771-8024-fec88d6da7c9", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.9  # initial inertia weight, change line 1\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Dynamic inertia weight adjustment, change line 2\n            self.w = 0.9 - 0.5 * (evals / self.budget)  # gradually decrease inertia weight\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce dynamic inertia weight to balance exploration and exploitation better.", "configspace": "", "generation": 56, "fitness": 0.3174664500311903, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.32929162087635055, 0.3283686657523126, 0.29473906346490764]}, "mutation_prompt": null}
{"id": "bce34986-b333-412f-9147-47bd2395b46c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.85  # social weight, increased from 1.8 to 1.85\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase exploration by adjusting the social weight slightly.", "configspace": "", "generation": 57, "fitness": 0.3210912846000778, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3379484574500172, 0.3053853679965334, 0.31994002835368274]}, "mutation_prompt": null}
{"id": "d64b8a79-01e7-4302-b0f9-7d7663b1ea29", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tune the inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.2297980703545446, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.20634732639885012, 0.21912728681742488, 0.26391959784735886]}, "mutation_prompt": null}
{"id": "8bd1a310-8102-45b5-b3e6-4861ee96dfb3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.initial_temperature = 100\n        self.final_temperature = 1  # final temperature for dynamic cooling\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)  # adaptive inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            current_temperature = self.initial_temperature * ((self.final_temperature / self.initial_temperature) ** (evals / self.budget))  # dynamic temperature\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * current_temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / current_temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and dynamic temperature adjustment for balanced exploration-exploitation.", "configspace": "", "generation": 59, "fitness": 0.3514391234174414, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.39543997828770483, 0.33291584489142567, 0.3259615470731936]}, "mutation_prompt": null}
{"id": "1b387d77-86a1-43c5-b674-331be9fe6757", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.7  # inertia weight, increased from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the inertia weight to enhance global exploration, potentially improving optimization performance.", "configspace": "", "generation": 60, "fitness": 0.2796095660485817, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.26685422544521975, 0.28905453061129827, 0.2829199420892272]}, "mutation_prompt": null}
{"id": "9905edc9-d659-4695-9670-d3e348db2c0a", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.7  # cognitive weight, increased from 1.6 to 1.7\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly increase the cognitive weight to enhance individual exploration capabilities.", "configspace": "", "generation": 61, "fitness": 0.35750012808787063, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.34181930131007665, 0.40736489823206345, 0.3233161847214716]}, "mutation_prompt": null}
{"id": "785f3e48-fbf4-46a6-ab47-ac4fd4b41558", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions) +\n                                0.01 * np.random.uniform(-1, 1, (self.population_size, self.dim)))  # added random component\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance exploitation by refining the velocity update formula and increasing population diversity.", "configspace": "", "generation": 62, "fitness": 0.3256863137788106, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.33763945657261696, 0.34278472655734304, 0.2966347582064718]}, "mutation_prompt": null}
{"id": "b8e42c65-0432-4c25-a877-a9c716d7f8cf", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # increased from 55 to 60\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the population size to enhance exploration capabilities.", "configspace": "", "generation": 63, "fitness": 0.3223574207368956, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2894468624931311, 0.3429228368467959, 0.33470256287075983]}, "mutation_prompt": null}
{"id": "6af38d00-4b0d-49f0-b3eb-345cc2a96060", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.7  # inertia weight, increased from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly increase the inertia weight to enhance exploration in the early stages of the search.", "configspace": "", "generation": 64, "fitness": 0.3386198709822501, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.36902773229337116, 0.3275307983302841, 0.31930108232309506]}, "mutation_prompt": null}
{"id": "ad061f92-db94-4983-b0b0-d51e6d80a6d1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def levy_flight(self, L):\n        return np.random.normal(0, 1, self.dim) * (1.0 / (np.random.normal(0, 1, self.dim)**2))**(1.0 / L)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities + self.levy_flight(1.5), lb, ub)  # add Levy Flight\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance exploration by using Levy Flight for swarm position update.", "configspace": "", "generation": 65, "fitness": 0.353060259805378, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3179769199485559, 0.37801424850990917, 0.3631896109576689]}, "mutation_prompt": null}
{"id": "c91b2d93-f324-473f-b9d4-91cd6c988822", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.5  # inertia weight, reduced from 0.6 to 0.5\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-1.0, 1.0, self.dim) * self.temperature  # increased perturbation range\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase population diversity by adjusting swarm velocity and improve exploration by enhancing SA local search perturbation.", "configspace": "", "generation": 66, "fitness": 0.3521714912092299, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.37092669163500414, 0.3507081556980033, 0.33487962629468226]}, "mutation_prompt": null}
{"id": "b5a886b4-9fdd-4282-aac5-14dfc25d8ad9", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 2.0  # social weight, increased from 1.8 to 2.0\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjusted the social weight factor to improve exploration capability by allowing greater influence from the global best position.", "configspace": "", "generation": 67, "fitness": 0.29326602197848667, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2898902093901242, 0.2823516032542872, 0.30755625329104863]}, "mutation_prompt": null}
{"id": "2cee56cd-9ead-4867-b4bb-7e2bdf302c2a", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.5  # inertia weight, reduced from 0.6 to 0.5\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 120  # initial temperature for SA, increased from 100 to 120\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improve convergence speed by adjusting particle velocity update mechanism and initial temperature.", "configspace": "", "generation": 68, "fitness": 0.305058430462424, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.31863471408280064, 0.29975545000506987, 0.29678512729940143]}, "mutation_prompt": null}
{"id": "70a4f8a8-4bc8-4df2-970e-bb93ccf967b7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-1.0, 1.0, self.dim) * self.temperature  # change factor from 0.5 to 1.0\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjust the simulated annealing candidate generation to enhance exploration by increasing variability.", "configspace": "", "generation": 69, "fitness": 0.2861304213079618, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2886599996635051, 0.32963279282772473, 0.2400984714326555]}, "mutation_prompt": null}
{"id": "26017cdc-1286-492e-a474-9d5e3bdbe301", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w_min = 0.4  # minimum inertia weight\n        self.w_max = 0.9  # maximum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        iteration = 0\n        while evals < self.budget:\n            iteration += 1\n\n            # Dynamic inertia weight adjustment\n            w = self.w_max - (iteration / (self.budget // self.population_size)) * (self.w_max - self.w_min)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                acceptance_probability = np.exp((scores[i] - candidate_score) / (self.temperature + 1e-9))\n                if candidate_score < scores[i] or acceptance_probability > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improve exploitation by dynamically adjusting inertia weight and enhancing SA acceptance criteria based on temperature.", "configspace": "", "generation": 70, "fitness": 0.33994160544227264, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3060996799188528, 0.370077077220364, 0.34364805918760133]}, "mutation_prompt": null}
{"id": "37acee8a-8054-468f-afc6-105930489143", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            # Adaptive inertia weight for diversity\n            self.w = 0.5 + 0.5 * np.random.rand()\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down with adaptive rate\n            self.temperature *= self.cooling_rate * (0.9 + 0.2 * np.random.rand())\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive cooling and velocity adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.2829862988045228, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2807726207639917, 0.2711437773891284, 0.29704249826044826]}, "mutation_prompt": null}
{"id": "81f2e9b9-1da0-49c0-b590-928563dcf1d5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.985  # cooling rate for SA, slightly increased for balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly increase the cooling rate to 0.985 for better balance between exploration and exploitation.", "configspace": "", "generation": 72, "fitness": 0.313872423864823, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.33559258036470807, 0.30007208898270443, 0.30595260224705645]}, "mutation_prompt": null}
{"id": "cb3b9fca-a816-40c8-b61c-2ac3098467d3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 56  # increased from 55 to 56\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the population size slightly to enhance exploration capabilities.", "configspace": "", "generation": 73, "fitness": 0.3824254219788292, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.06.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3707059098415696, 0.45633998423003186, 0.32023037186488623]}, "mutation_prompt": null}
{"id": "27d70971-abf0-4829-a931-1c21db5d87dd", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.9  # dynamic inertia weight, starting high\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Dynamic inertia weight adjustment\n            self.w = self.w_min + (0.9 - self.w_min) * (self.budget - evals) / self.budget\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Adaptive cool down\n            self.temperature *= (self.cooling_rate + (0.99 - self.cooling_rate) * (evals / self.budget))\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce a dynamic inertia weight strategy and adaptive temperature control to improve exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.413722701288308, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.4536171215005159, 0.39035822748174887, 0.39719275488265926]}, "mutation_prompt": null}
{"id": "e5b68064-a2ed-4b48-a205-ee34ced2b891", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.9  # social weight, increased from 1.8 to 1.9\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance social influence by slightly increasing the social weight to improve convergence speed.", "configspace": "", "generation": 75, "fitness": 0.3089332093101438, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3173758094463627, 0.2967140411220043, 0.3127097773620644]}, "mutation_prompt": null}
{"id": "70b2c645-3b46-485c-acce-c739a731ea23", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.9  # adaptive inertia weight, changed from 0.6 to 0.9\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 120  # initial temperature for SA, increased from 100 to 120\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * (evals / self.budget)  # adaptive inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and enhanced SA strategy to balance exploration and exploitation.", "configspace": "", "generation": 76, "fitness": 0.306103306166212, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.32172731922571673, 0.29181779338644, 0.30476480588647936]}, "mutation_prompt": null}
{"id": "cb20de87-6c65-4496-8333-ca997169a309", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55 \n        self.w = 0.6  \n        self.c1 = 1.6  \n        self.c2 = 1.8  \n        self.temperature = 100  \n        self.cooling_rate = 0.985  # increased from 0.98 to 0.985\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  \n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.4 + 0.5 * (self.budget - evals) / self.budget  # Adaptive inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance convergence by introducing adaptive inertia weight and slightly increased cooling rate.", "configspace": "", "generation": 77, "fitness": 0.3702987675868628, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3947595230747961, 0.35593272511131824, 0.360204054574474]}, "mutation_prompt": null}
{"id": "4ba2e642-0816-4576-8a5d-96d09ae12da5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n        self.adaptive_w = 0.9  # adaptive inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = self.adaptive_w * (1 - evals / self.budget) + 0.4  # adaptive inertia\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions) +\n                                np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)))  # random perturbation\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Incorporate diversity preservation by introducing a random perturbation and adaptive inertia to avoid premature convergence.", "configspace": "", "generation": 78, "fitness": 0.3421932785652337, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.33569017380350485, 0.3604029322713045, 0.33048672962089154]}, "mutation_prompt": null}
{"id": "7f022e07-c6d4-4400-92db-57cd33ce2874", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.85  # social weight, increased from 1.8 to 1.85\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the social weight slightly to enhance exploration and potentially improve convergence speed.", "configspace": "", "generation": 79, "fitness": 0.374268107625711, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.37723356087914284, 0.39285521175977467, 0.35271555023821555]}, "mutation_prompt": null}
{"id": "ced11af1-c8e1-4dd0-8dca-372627fa8d0c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_velocities = np.clip(swarm_velocities, -2, 2)  # Velocity clamping for stability\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Integrate adaptive inertia weight and velocity clamping to improve convergence and exploration balance.", "configspace": "", "generation": 80, "fitness": 0.2672240538283455, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.2862153991421569, 0.26040878514140353, 0.2550479772014761]}, "mutation_prompt": null}
{"id": "70149bae-e59c-4670-9239-ec2efd88df5f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.2, 0.2, self.dim) * self.temperature  # narrower search\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= 0.99 if evals < self.budget * 0.5 else 0.97  # adaptive cooling\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Refine stochastic local search by utilizing adaptive cooling and selective global best update.", "configspace": "", "generation": 81, "fitness": 0.2616344888692152, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.254048355741182, 0.2523545572952751, 0.2785005535711884]}, "mutation_prompt": null}
{"id": "af18932c-8749-49d1-a2f3-474485d703f7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.6\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n        self.inertia_max = 0.9  # new max inertia weight\n        self.inertia_min = 0.4  # new min inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Dynamic inertia weight adjustment\n            self.w = self.inertia_max - ((self.inertia_max - self.inertia_min) * evals / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance exploration by introducing a new dynamic inertia weight adjustment.", "configspace": "", "generation": 82, "fitness": 0.14315866059018348, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.15483296088791665, 0.11652578339972519, 0.15811723748290862]}, "mutation_prompt": null}
{"id": "7f74798d-1e84-4ba7-8c29-294c3d5ce7df", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.85  # social weight, increased from 1.8 to 1.85\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the social weight `c2` from 1.8 to 1.85 to enhance global exploration capabilities.", "configspace": "", "generation": 83, "fitness": 0.2971160224347255, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.31559622634812834, 0.294239923143243, 0.28151191781280516]}, "mutation_prompt": null}
{"id": "59abfac5-2d66-48e1-ab4c-23941fd6482e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.9  # adaptive inertia weight, increased from 0.6 to 0.9\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Introduce adaptive inertia weight\n            self.w = 0.9 - (0.5 * (evals / self.budget))\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive velocity weight and elite selection to improve exploration and convergence.", "configspace": "", "generation": 84, "fitness": 0.2505933109319716, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.23615459849639742, 0.2777356366866486, 0.23788969761286882]}, "mutation_prompt": null}
{"id": "94984f21-6b02-40fb-83af-b25497fb900b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.97  # cooling rate for SA, reduced from 0.98 to 0.97\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improve local search with adaptive cooling for enhanced exploration.", "configspace": "", "generation": 85, "fitness": 0.2707540707795277, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.27045144503255647, 0.2523545572952751, 0.2894562100107514]}, "mutation_prompt": null}
{"id": "14e31aeb-47d1-4b9a-a295-4a97a440f9c0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Adaptive inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight for enhanced local and global exploration balance.", "configspace": "", "generation": 86, "fitness": 0.25942106376993745, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.301566336946094, 0.25154356127963806, 0.22515329308408027]}, "mutation_prompt": null}
{"id": "b89fdb2d-54b2-4f2b-b0fa-a2d676dcf479", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.55  # inertia weight, reduced from 0.6 to 0.55\n        self.c1 = 1.7  # cognitive weight, increased from 1.6 to 1.7\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Improve exploration by slightly increasing the cognitive weight and decreasing the inertia weight.", "configspace": "", "generation": 87, "fitness": 0.36531232318962487, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.403196443327244, 0.32848559767195595, 0.36425492856967445]}, "mutation_prompt": null}
{"id": "7cffa6c8-1e72-4870-a704-e8ea0df0a269", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - ((self.w_max - self.w_min) * (evals / self.budget))\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Utilize adaptive inertia weight to enhance exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.30856882561288923, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.30919529888685926, 0.2974720743729836, 0.3190391035788248]}, "mutation_prompt": null}
{"id": "0b3efbfb-f413-43a8-9cd8-239e1deaad2c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.7  # inertia weight, adjusted from 0.6 to 0.7\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tune inertia weight to improve balance between exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.3143548003605785, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3317272731369436, 0.2967140411220043, 0.3146230868227876]}, "mutation_prompt": null}
{"id": "8353d635-7ae0-48f7-ba1c-66c4017a39e3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w = 0.9  # adaptive inertia weight start, increased to 0.9\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Update inertia weight\n            self.w = self.w_min + 0.5 * (0.9 - self.w_min) * (self.budget - evals) / self.budget\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search with chaotic perturbation\n            for i in range(self.population_size):\n                chaotic_factor = 0.1 * (1 - np.random.rand())\n                candidate_pos = (swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * \n                                 self.temperature * chaotic_factor)\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and chaotic perturbations to improve exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.36391332840957463, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3522736551550675, 0.365218406120319, 0.3742479239533374]}, "mutation_prompt": null}
{"id": "8c4bf589-33d7-4f7c-8a1f-eaf732e8a14b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, adjusted from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Slightly adjust the inertia weight to potentially improve exploration-exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.3589338661224082, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.38784131166226543, 0.3724164387556379, 0.3165438479493212]}, "mutation_prompt": null}
{"id": "cb24d4e8-b6b5-4f39-869d-4c86acc5be2d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.c2 = 1.8 - 0.5 * (evals / self.budget)  # dynamically adjust social weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance balance between exploration and exploitation by adjusting social weight dynamically based on the iteration count.", "configspace": "", "generation": 92, "fitness": 0.27955274149012904, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.30863617024029333, 0.2667799707289684, 0.26324208350112543]}, "mutation_prompt": null}
{"id": "d08db9c6-c778-4a90-ba66-3fbad09a1489", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.9  # social weight, increased from 1.8 to 1.9\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance global exploration by increasing the social weight slightly to promote better convergence.", "configspace": "", "generation": 93, "fitness": 0.3874961644903719, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3849705317870732, 0.34500206283706303, 0.4325158988469796]}, "mutation_prompt": null}
{"id": "175a50df-345b-464b-a6ee-b7585a94a601", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.65  # inertia weight, increased from 0.6 to 0.65\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tune the balance between exploration and exploitation by adjusting the inertia weight slightly to improve convergence.", "configspace": "", "generation": 94, "fitness": 0.029805594167709188, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.028858504679443286, 0.02130583129052066, 0.03925244653316362]}, "mutation_prompt": null}
{"id": "294cd639-b58f-4576-8d4e-28b5c8494574", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.temperature = 100\n        self.cooling_rate = 0.99  # increased cooling rate for finer exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Dynamic cooling\n            self.temperature = self.temperature * self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and dynamic cooling to balance exploration and exploitation more effectively.", "configspace": "", "generation": 95, "fitness": 0.3332476131777884, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.02.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3303976288016913, 0.3125727225583227, 0.35677248817335117]}, "mutation_prompt": null}
{"id": "ea1a65e8-4b15-4566-9d20-7078ab18bf18", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.c1 = 1.4 + 0.4 * np.random.rand()  # dynamic cognitive weight\n            self.c2 = 1.4 + 0.4 * np.random.rand()  # dynamic social weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance global exploration by adjusting cognitive and social weights dynamically based on convergence.", "configspace": "", "generation": 96, "fitness": 0.27113914592985283, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.04.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.30235864997416917, 0.30353309842198095, 0.20752568939340832]}, "mutation_prompt": null}
{"id": "8b9e5c37-55d0-45b4-b8f6-8ec5d535a7b0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # unchanged\n        self.w = 0.9  # initial inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.6  # unchanged\n        self.c2 = 1.8  # unchanged\n        self.temperature = 100  # unchanged\n        self.cooling_rate = 0.98  # unchanged\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # unchanged\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = self.w_min + (0.9 - self.w_min) * (self.budget - evals) / self.budget\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            velocity_clamp = 0.2 * (ub - lb)\n            swarm_velocities = np.clip(swarm_velocities, -velocity_clamp, velocity_clamp)\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive inertia weight and velocity clamping to enhance convergence quality and stability.", "configspace": "", "generation": 97, "fitness": 0.3215514442184918, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.322796546683614, 0.30475577179250124, 0.33710201417936014]}, "mutation_prompt": null}
{"id": "dc664404-c853-4f8f-9401-2d3e99e0a6c4", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.62  # inertia weight, increased from 0.6 to 0.62\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Increase the inertia weight slightly to enhance exploration capability.", "configspace": "", "generation": 98, "fitness": 0.3177991547321506, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.01.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3209109957217169, 0.33036436577928074, 0.30212210269545414]}, "mutation_prompt": null}
{"id": "b7d0aaeb-09cb-4741-b291-6ef0376cc9ba", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # increased from 50 to 55\n        self.w = 0.6  # inertia weight\n        self.c1 = 1.6  # cognitive weight, increased from 1.5 to 1.6\n        self.c2 = 1.8  # social weight\n        self.temperature = 100  # initial temperature for SA\n        self.cooling_rate = 0.98  # cooling rate for SA, reduced from 0.95 to 0.98\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(swarm_positions)\n        personal_best_scores = np.array([func(x) for x in swarm_positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evals = self.population_size  # initial evaluations\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget)  # dynamic inertia weight\n            swarm_velocities = (self.w * swarm_velocities +\n                                self.c1 * r1 * (personal_best_positions - swarm_positions) +\n                                self.c2 * r2 * (global_best_position - swarm_positions))\n            swarm_positions = np.clip(swarm_positions + swarm_velocities, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(x) for x in swarm_positions])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = swarm_positions[improved]\n            personal_best_scores[improved] = scores[improved]\n            if min(scores) < global_best_score:\n                global_best_score = min(scores)\n                global_best_position = swarm_positions[np.argmin(scores)]\n\n            # Simulated Annealing local search\n            for i in range(self.population_size):\n                candidate_pos = swarm_positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * self.temperature\n                candidate_pos = np.clip(candidate_pos, lb, ub)\n                candidate_score = func(candidate_pos)\n                evals += 1\n                if candidate_score < scores[i] or np.exp((scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    swarm_positions[i] = candidate_pos\n                    scores[i] = candidate_score\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_positions[i] = candidate_pos\n                        personal_best_scores[i] = candidate_score\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_pos\n\n            # Cool down\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce dynamic inertia weight decay in PSO to improve exploration.", "configspace": "", "generation": 99, "fitness": 0.34137714838589783, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.03.", "error": "", "parent_id": "33e18240-f0dd-461a-ab1e-fbeacec5c94d", "metadata": {"aucs": [0.3423585356108728, 0.38296578954058225, 0.29880712000623844]}, "mutation_prompt": null}
