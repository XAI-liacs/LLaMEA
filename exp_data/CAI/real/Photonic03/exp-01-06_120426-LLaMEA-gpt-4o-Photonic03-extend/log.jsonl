{"id": "4e01a101-013c-4af0-bf85-134d489bd5b2", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a simple local search by perturbing the position\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization (AQIPSO) integrating quantum superposition and local search for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.13313865158189078, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.13134184225029033, 0.1344110274863335, 0.13366308500904855]}, "mutation_prompt": null}
{"id": "98a35fb6-7157-49b8-a888-a089b33c1592", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a simple local search by perturbing the position\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = ((0.5 + 0.5 * np.random.rand()) * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced velocity update with adaptive inertia weight to improve convergence.", "configspace": "", "generation": 1, "fitness": 0.13203381599604289, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4e01a101-013c-4af0-bf85-134d489bd5b2", "metadata": {"aucs": [0.13114955437563847, 0.13451878293058916, 0.130433110681901]}, "mutation_prompt": null}
{"id": "6400730e-3cf6-488f-a778-49fc51cb5d92", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def adaptive_local_search(self, position, bounds):\n        perturbation_scale = np.linalg.norm(self.global_best_position - position) / self.dim\n        perturbation = np.random.uniform(-perturbation_scale, perturbation_scale, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.001)  # Dynamically reduce inertia weight\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO with dynamic inertia and adaptive local search for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.1302402328281054, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4e01a101-013c-4af0-bf85-134d489bd5b2", "metadata": {"aucs": [0.12882411789952597, 0.13214335777847552, 0.12975322280631474]}, "mutation_prompt": null}
{"id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Modified AQIPSO to incorporate a more aggressive local search perturbation for enhanced fine-tuning.", "configspace": "", "generation": 3, "fitness": 0.13392176475797637, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4e01a101-013c-4af0-bf85-134d489bd5b2", "metadata": {"aucs": [0.13369789399607546, 0.13440353797850035, 0.13366386229935334]}, "mutation_prompt": null}
{"id": "dbc95f72-e309-4b30-bb24-184a4caa54ba", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.2:  # Increased probability from 0.1 to 0.2\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by increasing the probability of applying the quantum-inspired update for improved global exploration.", "configspace": "", "generation": 4, "fitness": 0.130644689249534, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.12916047140448472, 0.1312555292482892, 0.13151806709582814]}, "mutation_prompt": null}
{"id": "f086e197-2003-47e1-9aa6-bd52b6513624", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Adaptive coefficients\n                self.cognitive_coeff = 1.49445 * (1 - self.evaluations / self.budget)\n                self.social_coeff = 1.49445 * (self.evaluations / self.budget)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by introducing adaptive personal and social coefficients to dynamically balance exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.13144193923457648, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13239236115622954, 0.12950436361439122, 0.13242909293310867]}, "mutation_prompt": null}
{"id": "71e4b085-5fa0-4946-8101-8e9dfa4cffef", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Increased from 0.1 to 0.15\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by increasing quantum-inspired update probability slightly for improved exploration.", "configspace": "", "generation": 6, "fitness": 0.13156460299053827, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13299424908049373, 0.1300763322807047, 0.13162322761041634]}, "mutation_prompt": null}
{"id": "1547c08e-507a-4096-b7aa-b49e2c9f5289", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:  # Increased from 0.1 to 0.2\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced local search probability for more frequent fine-tuning.", "configspace": "", "generation": 7, "fitness": 0.1330289574481532, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.1323028746554522, 0.1331373121884618, 0.1336466855005456]}, "mutation_prompt": null}
{"id": "dc28de56-148b-456c-b32b-5fdbbb655d4e", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        perturbation = np.random.uniform(-0.15, 0.15, self.dim)  # Reduced perturbation range\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < (0.05 + 0.05 * (self.evaluations / self.budget)):  # Adapt local search\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO with adaptive parameters and strategic local search selection to improve convergence efficacy.", "configspace": "", "generation": 8, "fitness": 0.13287441568982797, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13244161199914062, 0.13461823358773506, 0.13156340148260826]}, "mutation_prompt": null}
{"id": "b7aca88d-b9bc-42ab-b22e-f01362b24d7c", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                \n                # Adaptive velocity adjustment\n                self.velocities[i] *= 0.9 + 0.1 * np.random.rand()\n                \n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Increased frequency\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.15:  # Increased frequency\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by introducing adaptive velocity control and additional local search frequency to improve convergence efficiency.", "configspace": "", "generation": 9, "fitness": 0.1303104489102541, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13049640021960784, 0.1304410742184462, 0.1299938722927082]}, "mutation_prompt": null}
{"id": "5d1ae5ec-eb90-4a49-82cc-a3dfb540e4f1", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = ((0.9 - 0.4 * self.evaluations / self.budget) * self.velocities[i] +\n                                      cognitive_component + social_component)  # Adaptive inertia weight\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO with an adaptive inertia weight strategy for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.13189274689745803, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13140567692308314, 0.134056269015973, 0.13021629475331797]}, "mutation_prompt": null}
{"id": "cc4955c3-88bb-42d7-b58f-f4db705ef24d", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update occasionally\n                if np.random.rand() < 0.2:  # Increase probability from 0.1 to 0.2\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced exploration by adjusting quantum superposition probability for improved global search. ", "configspace": "", "generation": 11, "fitness": 0.130644689249534, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.12916047140448472, 0.1312555292482892, 0.13151806709582814]}, "mutation_prompt": null}
{"id": "f6e049f4-bac0-4592-bc6e-1d82007541b7", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:  # Changed from < 0.1 to < 0.2\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by increasing the frequency of local searches to improve convergence accuracy.", "configspace": "", "generation": 12, "fitness": 0.1330289574481532, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.1323028746554522, 0.1331373121884618, 0.1336466855005456]}, "mutation_prompt": null}
{"id": "865e7825-6528-492a-b03c-26d45368a5fd", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        perturbation = np.random.uniform(-0.15, 0.15, self.dim)  # Adjusted from -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update inertia weight dynamically\n            self.inertia_weight = 0.729 - 0.5 * (self.evaluations / self.budget)  # Dynamic adjustment\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance AQIPSO by introducing dynamic adjustment of coefficients and refined local search to balance exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.13372429907249392, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13272091254000062, 0.1349414676225591, 0.133510517054922]}, "mutation_prompt": null}
{"id": "5e046230-415f-4747-80d7-f8a00a93343b", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * np.tanh(self.velocities[i]) +  # Changed to a non-linear update\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce a non-linear velocity update to balance exploration and exploitation better.", "configspace": "", "generation": 14, "fitness": 0.13284838452317838, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.132950902901116, 0.1331455152781773, 0.13244873539024182]}, "mutation_prompt": null}
{"id": "038d187b-56ce-413e-94f6-da26ff1ad020", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Increased from 0.1 to 0.15\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by increasing the probability of quantum-inspired updates for improved global exploration.", "configspace": "", "generation": 15, "fitness": 0.13156460299053827, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13299424908049373, 0.1300763322807047, 0.13162322761041634]}, "mutation_prompt": null}
{"id": "5babcb3a-6250-49bd-a25f-7783a24cd5ba", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.2:  # Increased from 0.1 to 0.2\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Modified AQIPSO by increasing the frequency of quantum-inspired updates for enhanced exploration.", "configspace": "", "generation": 16, "fitness": 0.130644689249534, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.12916047140448472, 0.1312555292482892, 0.13151806709582814]}, "mutation_prompt": null}
{"id": "7dc6f76b-2579-476c-ac49-5abd700fffbe", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.8  # Fine-tuned inertia weight for improved performance\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by finely tuning the inertia weight to balance exploration and exploitation for better convergence.", "configspace": "", "generation": 17, "fitness": 0.13121350209845872, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13089444356013247, 0.1322606785524878, 0.1304853841827559]}, "mutation_prompt": null}
{"id": "190c2794-47f3-4de3-8ce2-3afb9346b9e7", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (0.9 * self.inertia_weight * self.velocities[i] +  # Change made here\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced inertia weight adaptation in AQIPSO for dynamic balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.1333333701545566, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13313967064667254, 0.13533002802080363, 0.13153041179619362]}, "mutation_prompt": null}
{"id": "edcac6eb-f03b-4d69-823f-37c69181ca16", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                w = 0.9 - 0.7 * (self.evaluations / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (w * self.velocities[i] + cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO with adaptive inertia weight for dynamic exploration-exploitation trade-off.", "configspace": "", "generation": 19, "fitness": 0.13165898975443766, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.1305973685211108, 0.13314125484149852, 0.1312383459007036]}, "mutation_prompt": null}
{"id": "ad064f23-cba6-43c9-850e-7b174f838a92", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search more frequently\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:  # Increased frequency from 0.1 to 0.2\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced local search by increasing perturbation frequency for better convergence.", "configspace": "", "generation": 20, "fitness": 0.1330289574481532, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.1323028746554522, 0.1331373121884618, 0.1336466855005456]}, "mutation_prompt": null}
{"id": "f1bf4878-6f7c-469f-b1e3-10955b5ebfe9", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Adaptive dynamic coefficients\n                self.cognitive_coeff = 1.49445 - 0.5 * (self.evaluations / self.budget)\n                self.social_coeff = 1.49445 + 0.5 * (self.evaluations / self.budget)\n                \n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by introducing adaptive dynamic coefficients for improved exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.13237930319244595, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13170139920442048, 0.1344665855218523, 0.13096992485106507]}, "mutation_prompt": null}
{"id": "3ac4a7c2-c1b8-4b9b-bf2e-f3b6655aa34f", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Increased frequency from 0.1 to 0.15\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by adjusting the quantum superposition frequency for better exploration.", "configspace": "", "generation": 22, "fitness": 0.13156460299053827, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13299424908049373, 0.1300763322807047, 0.13162322761041634]}, "mutation_prompt": null}
{"id": "2ed61285-4683-41aa-b674-8a7129a44ee6", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.normal(0.5, 0.15, self.dim)  # Modified from np.random.rand to np.random.normal\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improved AQIPSO algorithm by fine-tuning the quantum superposition strategy to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 23, "fitness": 0.13182831585249125, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.1315111163881062, 0.13456255680142537, 0.1294112743679422]}, "mutation_prompt": null}
{"id": "62c686b7-2f86-45c8-bb94-ef4326bcce04", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        # Adaptive cognitive and social coefficients\n        self.cognitive_coeff_min = 0.5\n        self.cognitive_coeff_max = 2.5\n        self.social_coeff_min = 0.5\n        self.social_coeff_max = 2.5\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds, amplitude):\n        # Dynamic perturbation amplitude\n        perturbation = np.random.uniform(-amplitude, amplitude, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Adaptive coefficients based on current evaluations\n                self.cognitive_coeff = self.cognitive_coeff_min + \\\n                    (self.cognitive_coeff_max - self.cognitive_coeff_min) * (self.evaluations / self.budget)\n                self.social_coeff = self.social_coeff_max - \\\n                    (self.social_coeff_max - self.social_coeff_min) * (self.evaluations / self.budget)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    amplitude = 0.2 - 0.15 * (self.evaluations / self.budget)\n                    self.positions[i] = self.local_search(self.positions[i], bounds, amplitude)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced AQIPSO by introducing adaptive coefficients and dynamic local search amplitude for better convergence.", "configspace": "", "generation": 24, "fitness": 0.13220781314017746, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.1325937474940021, 0.13034445416216944, 0.1336852377643608]}, "mutation_prompt": null}
{"id": "2d3a4970-ce4b-4118-88d6-0e3f169a173d", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed from -0.1, 0.1 to -0.2, 0.2\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.2:  # Modified from 0.1 to 0.2\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced the exploitation capability by adjusting quantum superposition probability.", "configspace": "", "generation": 25, "fitness": 0.130644689249534, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.12916047140448472, 0.1312555292482892, 0.13151806709582814]}, "mutation_prompt": null}
{"id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increase perturbation range for better exploration\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced local search strategy by increasing perturbation variability to explore solution space more effectively.", "configspace": "", "generation": 26, "fitness": 0.13411048607153953, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "90a9b09c-f9b9-4fbd-ac18-1fbc886f6b6f", "metadata": {"aucs": [0.13368360811289737, 0.13498421098048252, 0.1336636391212387]}, "mutation_prompt": null}
{"id": "466d7f56-1a1f-41cc-8187-e6aa5ee99118", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Dynamic inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increase perturbation range for better exploration\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce dynamic adjustment of inertia weight to balance exploration and exploitation more effectively.", "configspace": "", "generation": 27, "fitness": 0.13411048607153953, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.13368360811289737, 0.13498421098048252, 0.1336636391212387]}, "mutation_prompt": null}
{"id": "221ec285-8b85-4cc2-8f1c-e0387eae4809", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increase perturbation range for better exploration\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Adjusted probability for quantum-inspired update\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Slightly increased the probability of quantum-inspired updates to enhance exploratory capabilities.", "configspace": "", "generation": 28, "fitness": 0.13152823360588306, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.13298501112025285, 0.12997635036331245, 0.13162333933408388]}, "mutation_prompt": null}
{"id": "488e0d2c-21a8-4003-95fb-11b752a4fea2", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increase perturbation range for better exploration\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Increased probability of quantum-inspired update\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Modify the probability of quantum-inspired updates to enhance exploration.", "configspace": "", "generation": 29, "fitness": 0.13152823360588306, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.13298501112025285, 0.12997635036331245, 0.13162333933408388]}, "mutation_prompt": null}
{"id": "f37ee394-a60a-4fe7-a282-1e933b0b917a", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increase perturbation range for better exploration\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * (r2 + 0.1) * (self.global_best_position - self.positions[i])  # Slight increase in r2\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Slightly increase social component randomness to enhance diversity and exploration.", "configspace": "", "generation": 30, "fitness": 0.13138728170824054, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.13181137035964574, 0.13135689300357667, 0.13099358176149922]}, "mutation_prompt": null}
{"id": "ef471cb0-9cc3-40cd-b597-6682de47bdd8", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increase perturbation range for better exploration\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.12:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improved global convergence by slightly increasing the probability of local search application.", "configspace": "", "generation": 31, "fitness": 0.1319089549916103, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.1306688947345389, 0.13349182824536077, 0.13156614199493122]}, "mutation_prompt": null}
{"id": "be3039ca-4a43-460a-83b1-aee3e3e991a1", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * (1 - self.evaluations / self.budget)  # Adaptive perturbation\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.4 + 0.5 * (1 - self.evaluations / self.budget)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Refined AQIPSO by adjusting inertia weight dynamically and enhancing local search with adaptive perturbations.", "configspace": "", "generation": 32, "fitness": 0.13163967569581825, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.13041717761942873, 0.1341674367629847, 0.1303344127050413]}, "mutation_prompt": null}
{"id": "1b99a7b1-79b1-456f-9b95-9c91a1fe8e37", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.1, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced perturbation variability by dynamically adjusting the range for more effective exploration.", "configspace": "", "generation": 33, "fitness": 0.13411716561733167, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ec5ae4a8-f6aa-4545-a845-b3ac3645d22c", "metadata": {"aucs": [0.13370283382786252, 0.13498283573195435, 0.13366582729217813]}, "mutation_prompt": null}
{"id": "bb02ed48-1619-4551-8dc0-ecb9f9c1ed2e", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.1, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            self.cognitive_coeff = 1.49445 + 0.1 * np.sin(0.1 * self.evaluations)  # Dynamic adjustment\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce a dynamically adjustable cognitive coefficient to enhance adaptability in dynamic environments.", "configspace": "", "generation": 34, "fitness": 0.13199436456195154, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "1b99a7b1-79b1-456f-9b95-9c91a1fe8e37", "metadata": {"aucs": [0.13150645937190109, 0.13327235767174916, 0.13120427664220435]}, "mutation_prompt": null}
{"id": "c5ef3f2a-d1af-4906-b243-7c43b9dddbfb", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Adjusted inertia weight to start higher for better exploration\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.1, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced strategy via adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 35, "fitness": 0.13051820237121634, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "1b99a7b1-79b1-456f-9b95-9c91a1fe8e37", "metadata": {"aucs": [0.13057224546166213, 0.13083018194054952, 0.13015217971143733]}, "mutation_prompt": null}
{"id": "df5a7ab8-40a5-4d3c-acf1-c41ae8c2c603", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.1, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            decay_factor = 0.99 ** (self.evaluations / self.population_size)  # Global best influence decay\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i]) * decay_factor\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce a global best influence decay factor to balance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": 0.13287246124418847, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "1b99a7b1-79b1-456f-9b95-9c91a1fe8e37", "metadata": {"aucs": [0.1320104511067598, 0.13495857347998574, 0.13164835914581985]}, "mutation_prompt": null}
{"id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improved the dynamic perturbation range for enhanced local search effectiveness.", "configspace": "", "generation": 37, "fitness": 0.13411862950628825, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "1b99a7b1-79b1-456f-9b95-9c91a1fe8e37", "metadata": {"aucs": [0.13370729603953135, 0.13498245417309207, 0.1336661383062413]}, "mutation_prompt": null}
{"id": "55f587b1-18a9-45b7-8cfb-88f07c1e21c5", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Adaptive inertia weight\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce adaptive inertia weight to balance exploration and exploitation.", "configspace": "", "generation": 38, "fitness": 0.13049326453600815, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.13050116844820714, 0.13082469565736576, 0.13015392950245153]}, "mutation_prompt": null}
{"id": "7cd7141a-a4a4-4e16-a648-07b5afa7e103", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Adjusted frequency\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced local search effectiveness by adjusting quantum-inspired update frequency.", "configspace": "", "generation": 39, "fitness": 0.13143956864879083, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.13299698020128103, 0.12970064536672754, 0.13162108037836395]}, "mutation_prompt": null}
{"id": "87c19e05-4c95-46f5-9370-c313c89d9720", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                # Modify inertia weight based on evaluations\n                self.inertia_weight = 0.9 - (0.5 * self.evaluations / self.budget)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduced adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 40, "fitness": 0.13049863945363946, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.13151664580952083, 0.12971944774137634, 0.13025982481002119]}, "mutation_prompt": null}
{"id": "1b5df651-32b2-4876-866b-6c67852d8c4c", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight_initial = 0.9  # Initial inertia weight\n        self.inertia_weight_final = 0.4  # Final inertia weight\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            inertia_weight = (self.inertia_weight_final + \n                              (self.inertia_weight_initial - self.inertia_weight_final) *\n                              ((self.budget - self.evaluations) / self.budget))\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +  \n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introducing adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 41, "fitness": 0.1316392204106944, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.130416977438627, 0.1341837751365218, 0.13031690865693435]}, "mutation_prompt": null}
{"id": "fbec4756-e7c1-44a2-9e0c-537af343daf9", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n            # Adaptive decrease of inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (self.evaluations / self.budget)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce adaptive inertia weight decreasing over iterations to balance exploration and exploitation.", "configspace": "", "generation": 42, "fitness": 0.1316392204106944, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.130416977438627, 0.1341837751365218, 0.13031690865693435]}, "mutation_prompt": null}
{"id": "40c02765-06e4-43e2-ab36-63908c0e48be", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance exploration by increasing the frequency of quantum-inspired updates.", "configspace": "", "generation": 43, "fitness": 0.13143956864879083, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.13299698020128103, 0.12970064536672754, 0.13162108037836395]}, "mutation_prompt": null}
{"id": "f83e6ecb-ef83-4492-b9e3-cd1cd58b91e5", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.35, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Adjusted the dynamic perturbation range for enhanced local search effectiveness.", "configspace": "", "generation": 44, "fitness": 0.13393308737371282, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.13365587750546415, 0.13498464204168947, 0.13315874257398486]}, "mutation_prompt": null}
{"id": "42b0d181-833a-4281-b633-4c44f3d5d544", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Fine-tuned inertia weight to balance exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        return bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.dim)\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Fine-tuned inertia weight to balance exploration and exploitation in PSO.", "configspace": "", "generation": 45, "fitness": 0.13252056143243487, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.13228141220781386, 0.13453920814410836, 0.13074106394538243]}, "mutation_prompt": null}
{"id": "d9a9a13b-a952-4392-8982-259411012fb9", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729  # Inertia weight to control exploration and exploitation\n        self.cognitive_coeff = 1.49445  # Cognitive coefficient\n        self.social_coeff = 1.49445  # Social coefficient\n        self.positions = np.random.rand(self.population_size, dim)  # Initial positions\n        self.velocities = np.zeros((self.population_size, dim))  # Initial velocities\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        # Generate a new position using quantum superposition-like strategy\n        randomness_factor = np.random.normal(size=self.dim)  # Changed line for enhanced randomness\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        # Implementing a more aggressive local search by perturbing the position\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate the fitness of each particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure positions are within bounds\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Apply quantum-inspired update and local search occasionally\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhanced exploration by adjusting quantum superposition randomness for better global search.", "configspace": "", "generation": 46, "fitness": 0.15580626742276957, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "da8465de-ab4b-4a8d-a29e-d3c52a55d408", "metadata": {"aucs": [0.1630605034478978, 0.15127006369428064, 0.15308823512613023]}, "mutation_prompt": null}
{"id": "258f42df-7e5a-4bae-844b-ff85d4891635", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)  # Modified standard deviation\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        # New method to adjust coefficients dynamically\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()  # Call new coefficient update method\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:  # Increased probability for these operations\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.15:  # Increased probability for these operations\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introducing adaptive coefficients and probabilistic exploration to enhance convergence speed and solution quality.", "configspace": "", "generation": 47, "fitness": 0.17644968065268274, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "d9a9a13b-a952-4392-8982-259411012fb9", "metadata": {"aucs": [0.1854533933214051, 0.1737614137927287, 0.17013423484391443]}, "mutation_prompt": null}
{"id": "4d577dd7-1764-4356-9997-3d3e88b37f21", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)  # Modified standard deviation\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        # New method to adjust coefficients dynamically\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.7 * (self.evaluations / self.budget)  # Dynamic inertia weight adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()  # Call new coefficient update method\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:  # Increased probability for these operations\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.15:  # Increased probability for these operations\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce dynamic inertia weight adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.1765528276140131, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "258f42df-7e5a-4bae-844b-ff85d4891635", "metadata": {"aucs": [0.1854533933214051, 0.1740708546767198, 0.17013423484391443]}, "mutation_prompt": null}
{"id": "fa8ce72f-4f32-47a1-b1d7-87baf815694a", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)  # Modified standard deviation\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        # New method to adjust coefficients dynamically\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.7 * (self.evaluations / self.budget)  # Dynamic inertia weight adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()  # Call new coefficient update method\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:  # Increased probability for these operations\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:  # Increased probability for these operations\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance local search by increasing perturbation probability for improved convergence.", "configspace": "", "generation": 49, "fitness": 0.1776104882985605, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "4d577dd7-1764-4356-9997-3d3e88b37f21", "metadata": {"aucs": [0.16852314915095545, 0.1945653546859495, 0.1697429610587765]}, "mutation_prompt": null}
{"id": "60414747-0431-4263-b2e6-5fa273659ecc", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)  # Modified standard deviation\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim)  # Slightly adjusted range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.7 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n                \n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.12:  # Fine-tuned probability\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Fine-tune perturbation probability and range for enhanced exploration and convergence.", "configspace": "", "generation": 50, "fitness": 0.1774058572861773, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "fa8ce72f-4f32-47a1-b1d7-87baf815694a", "metadata": {"aucs": [0.16710409928740877, 0.19409163016604936, 0.1710218424050738]}, "mutation_prompt": null}
{"id": "0795e930-0956-44ea-b3c3-c5255393b5ca", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.7 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 1)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improve convergence by introducing adaptive perturbation range in local search and dynamic population resizing.", "configspace": "", "generation": 51, "fitness": 0.1778125054071349, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "fa8ce72f-4f32-47a1-b1d7-87baf815694a", "metadata": {"aucs": [0.16857038265337365, 0.1950894857015113, 0.16977764786651972]}, "mutation_prompt": null}
{"id": "a891a922-c9cc-46b3-8003-d65f597e9517", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.7 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improve AQIPSO by refining dynamic population resizing for better exploration-exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.1778703069115928, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "0795e930-0956-44ea-b3c3-c5255393b5ca", "metadata": {"aucs": [0.16866929747824244, 0.19513143355726226, 0.16981018969927375]}, "mutation_prompt": null}
{"id": "04731990-8c30-455b-bc1d-3a1bf9489585", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance AQIPSO by adjusting the inertia weight update formula for improved convergence dynamics.", "configspace": "", "generation": 53, "fitness": 0.17787628736720315, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "a891a922-c9cc-46b3-8003-d65f597e9517", "metadata": {"aucs": [0.16866929747824244, 0.19514937386713338, 0.1698101907562336]}, "mutation_prompt": null}
{"id": "d232baec-1f6b-443c-892f-8b6b6fb8b9aa", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        # Modified perturbation range for dynamic local search tuning\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget) * 1.1\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce dynamic perturbation in local search to balance exploration and exploitation better.", "configspace": "", "generation": 54, "fitness": 0.1778758244208156, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "04731990-8c30-455b-bc1d-3a1bf9489585", "metadata": {"aucs": [0.16866929747824244, 0.19514797130797445, 0.16981020447622985]}, "mutation_prompt": null}
{"id": "1155e69d-ad84-4b10-aee3-30db4a511545", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.4, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Further optimize AQIPSO by enhancing the perturbation range adaptability for improved local search efficiency.", "configspace": "", "generation": 55, "fitness": 0.17787593732555454, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "04731990-8c30-455b-bc1d-3a1bf9489585", "metadata": {"aucs": [0.16866929747824244, 0.19514829342098305, 0.16981022107743815]}, "mutation_prompt": null}
{"id": "f2b1c1dd-d628-4875-9b9d-c6bd22e06d81", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if self.evaluations % (self.budget // 5) == 0:  # Additional reset condition\n                    self.personal_best_values[i] = np.inf  # Reset personal best values\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Fine-tune AQIPSO by subtly enhancing the personal best reset condition for robust exploration.", "configspace": "", "generation": 56, "fitness": 0.17787628736720315, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "04731990-8c30-455b-bc1d-3a1bf9489585", "metadata": {"aucs": [0.16866929747824244, 0.19514937386713338, 0.1698101907562336]}, "mutation_prompt": null}
{"id": "f5a9df0e-1b4b-4496-afc0-08be363e0a16", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.15:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n            if self.evaluations % (self.budget // 5) == 0:  # Random restart condition\n                self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Implement a randomized restart strategy to help escape potential local optima.", "configspace": "", "generation": 57, "fitness": 0.17787628736720315, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "04731990-8c30-455b-bc1d-3a1bf9489585", "metadata": {"aucs": [0.16866929747824244, 0.19514937386713338, 0.1698101907562336]}, "mutation_prompt": null}
{"id": "d3f33bab-0aff-4706-92b7-c6a2d7f85921", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.20:  # Increased probability from 0.15 to 0.20\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improve global exploration by increasing the probability of quantum superposition.", "configspace": "", "generation": 58, "fitness": 0.18019833198575738, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "04731990-8c30-455b-bc1d-3a1bf9489585", "metadata": {"aucs": [0.17480655503202802, 0.19502212637255256, 0.17076631455269153]}, "mutation_prompt": null}
{"id": "2f03a9dd-7d0c-482c-b708-5e6770f151a1", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.20:  # Increased probability from 0.15 to 0.20\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.3:  # Slightly increased local search probability\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance population diversity by slightly increasing the probability of local search.", "configspace": "", "generation": 59, "fitness": 0.1662912564905237, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.01.", "error": "", "parent_id": "d3f33bab-0aff-4706-92b7-c6a2d7f85921", "metadata": {"aucs": [0.17290336163560993, 0.15536086027190232, 0.17060954756405888]}, "mutation_prompt": null}
{"id": "476218e5-5e62-47ef-b939-cc1dc242ef72", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.25:  # Increased probability from 0.20 to 0.25\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance global exploration by slightly increasing inertia weight decay and quantum superposition probability.", "configspace": "", "generation": 60, "fitness": 0.18517345841067534, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "d3f33bab-0aff-4706-92b7-c6a2d7f85921", "metadata": {"aucs": [0.18045743879661824, 0.20268635659807321, 0.17237657983733456]}, "mutation_prompt": null}
{"id": "fa1522c2-f5b5-42e3-9e73-3f5720be1e38", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)  # Adaptive range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                # Adjusted quantum superposition probability dynamically\n                quantum_prob = 0.25 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < quantum_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introducing dynamic adjustment of quantum superposition probability based on evaluations to enhance exploration.", "configspace": "", "generation": 61, "fitness": 0.17952466897882782, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "476218e5-5e62-47ef-b939-cc1dc242ef72", "metadata": {"aucs": [0.17337936139364885, 0.19497225838176002, 0.17022238716107463]}, "mutation_prompt": null}
{"id": "924e8057-1d44-4f28-99a3-e583e9a5a342", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        fitness_improvement = np.abs(self.personal_best_values - self.global_best_value)  # Fitness improvement metric\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * fitness_improvement  # Adjusted range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)  # Adjusted formula\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:  # Population resizing\n                self.population_size = max(10, self.population_size - 2)  # Changed from -1 to -2\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (0.85 * self.inertia_weight * self.velocities[i] +  # Adjusted weight factor\n                                      cognitive_component + social_component)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.25:  # Increased probability from 0.20 to 0.25\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance convergence speed by adjusting perturbation range based on fitness improvement and fine-tuning velocity update.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (6,) (20,) ').", "error": "ValueError('operands could not be broadcast together with shapes (6,) (20,) ')", "parent_id": "476218e5-5e62-47ef-b939-cc1dc242ef72", "metadata": {}, "mutation_prompt": null}
{"id": "bfb97cd1-ad75-47a9-8c86-d8fdf4a5f6d0", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)  # Velocity saturation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)  # Adaptive probability\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Increase diversity by introducing an adaptive quantum probability and velocity saturation.", "configspace": "", "generation": 63, "fitness": 0.18764128393879229, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "476218e5-5e62-47ef-b939-cc1dc242ef72", "metadata": {"aucs": [0.18126568349740835, 0.20151503850620867, 0.18014312981275982]}, "mutation_prompt": null}
{"id": "dae7240f-fe94-4f72-bab5-7b383ad0ed45", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)  # Velocity saturation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * np.sin(np.pi * (1 - self.evaluations/self.budget))  # Sinusoidal adaptive probability\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance exploration by introducing a sinusoidal adaptive probability for quantum superposition.", "configspace": "", "generation": 64, "fitness": 0.18539710894520892, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "bfb97cd1-ad75-47a9-8c86-d8fdf4a5f6d0", "metadata": {"aucs": [0.1807896684639293, 0.1984433187317437, 0.17695833963995378]}, "mutation_prompt": null}
{"id": "761a0691-e5e4-4a1f-ab57-41424be45ba5", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)  # Changed line\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)  # Velocity saturation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)  # Adaptive probability\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Slightly enhance exploration by modifying the inertia weight decay factor.", "configspace": "", "generation": 65, "fitness": 0.18764128393879229, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "bfb97cd1-ad75-47a9-8c86-d8fdf4a5f6d0", "metadata": {"aucs": [0.18126568349740835, 0.20151503850620867, 0.18014312981275982]}, "mutation_prompt": null}
{"id": "af9f6cc8-fe7d-4045-9364-c5c271da7adc", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.50445  # Previously 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.50445 * (1 - self.evaluations/self.budget)  # Previously 1.49445\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)  # Velocity saturation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)  # Adaptive probability\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improve convergence by slightly increasing the cognitive component influence.", "configspace": "", "generation": 66, "fitness": 0.18764128393879229, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "bfb97cd1-ad75-47a9-8c86-d8fdf4a5f6d0", "metadata": {"aucs": [0.18126568349740835, 0.20151503850620867, 0.18014312981275982]}, "mutation_prompt": null}
{"id": "a5cb3fee-dd6d-4f50-8573-eae1d8fb4c7c", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] *= np.tanh(0.5 * self.evaluations / self.budget)  # Dynamic velocity scaling\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)  # Adaptive probability\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance convergence by incorporating a dynamically adjusted velocity scaling factor.", "configspace": "", "generation": 67, "fitness": 0.18764128393879229, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "bfb97cd1-ad75-47a9-8c86-d8fdf4a5f6d0", "metadata": {"aucs": [0.18126568349740835, 0.20151503850620867, 0.18014312981275982]}, "mutation_prompt": null}
{"id": "364fac7a-2ec2-41ac-8536-e47090532ec5", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.5, self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)  # Changed line\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)  # Velocity saturation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)  # Adaptive probability\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Refine particle update by adding a random exploration term to enhance search diversity.", "configspace": "", "generation": 68, "fitness": 0.19122169407919443, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.02.", "error": "", "parent_id": "bfb97cd1-ad75-47a9-8c86-d8fdf4a5f6d0", "metadata": {"aucs": [0.1983443493183331, 0.20506526991469132, 0.17025546300455885]}, "mutation_prompt": null}
{"id": "f4045263-8980-4ce7-8614-f5f78a72e71f", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)  # Changed line\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):  # Added function\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:  # Added line\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)  # Added line\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Enhance AQIPSO by introducing adaptive mutation and decaying random exploration to improve convergence.", "configspace": "", "generation": 69, "fitness": 0.1936199748687801, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.02.", "error": "", "parent_id": "364fac7a-2ec2-41ac-8536-e47090532ec5", "metadata": {"aucs": [0.1888420884468448, 0.22490380355987294, 0.16711403259962254]}, "mutation_prompt": null}
{"id": "c74f4128-3937-4968-9424-5892f6cef5ab", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def differential_crossover(self, pos1, pos2, pos3, bounds):  # New function\n        crossover_rate = 0.8\n        trial_vector = pos1 + 0.8 * (pos2 - pos3)\n        mask = np.random.rand(self.dim) < crossover_rate\n        new_position = np.where(mask, trial_vector, pos1)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                \n                if np.random.rand() < 0.5:  # Selective exploration condition\n                    idx1, idx2, idx3 = np.random.choice(self.population_size, 3, replace=False)\n                    self.positions[i] = self.differential_crossover(self.positions[idx1], self.positions[idx2], self.positions[idx3], bounds)\n                    \n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Improve AQIPSO by integrating differential evolution-inspired crossover and selective exploration for enhanced convergence.", "configspace": "", "generation": 70, "fitness": 0.10055172143716846, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "f4045263-8980-4ce7-8614-f5f78a72e71f", "metadata": {"aucs": [0.10243450608487792, 0.10283178346211874, 0.09638887476450875]}, "mutation_prompt": null}
{"id": "81811d9a-5e0a-431f-b351-22f2585155f1", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)  # Changed line\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.3, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.6 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):  # Added function\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        elite_fraction = 0.1\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n            \n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n\n            elite_count = int(self.population_size * elite_fraction)  # Added line\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]  # Added line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:  # Added line\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)  # Added line\n\n                # New line\n                if i in elite_indices:  # Added line\n                    self.positions[i] = (self.positions[i] + self.global_best_position) / 2  # Added line\n\n        return self.global_best_position, self.global_best_value", "name": "AQIPSO", "description": "Introduce an elite learning strategy by ensuring top performers influence the population to enhance convergence.", "configspace": "", "generation": 71, "fitness": 0.1936199748687801, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.02.", "error": "", "parent_id": "f4045263-8980-4ce7-8614-f5f78a72e71f", "metadata": {"aucs": [0.1888420884468448, 0.22490380355987294, 0.16711403259962254]}, "mutation_prompt": null}
{"id": "81e8b920-d750-4ac8-bf26-959a42bad840", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)  # Changed line\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)  # Changed line\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):  # Added function\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0  # Added line\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0  # Added line\n                else:\n                    stagnation_counter += 1  # Added line\n\n            if stagnation_counter > self.population_size * 3:  # Added condition\n                self.restart_population(bounds)  # Added line\n                stagnation_counter = 0  # Added line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Introduce a dynamic cooling schedule and employ a diversity-enhancing restart mechanism in AQIPSO to improve its exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.20604212573211234, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.03.", "error": "", "parent_id": "f4045263-8980-4ce7-8614-f5f78a72e71f", "metadata": {"aucs": [0.22614683174623174, 0.22490380355987294, 0.16707574189023233]}, "mutation_prompt": null}
{"id": "b932c0a6-907e-4837-913e-26fe872630f9", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):  # Added function\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:  # Modified line\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:  # Added line\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)  # Added line\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Enhance exploration by introducing a Lvy flight perturbation and refining the restart strategy to occur earlier in stagnation.", "configspace": "", "generation": 73, "fitness": 0.2100434922300415, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.02.", "error": "", "parent_id": "81e8b920-d750-4ac8-bf26-959a42bad840", "metadata": {"aucs": [0.19689073159685055, 0.23834123476812008, 0.19489851032515393]}, "mutation_prompt": null}
{"id": "dbf92a01-f498-4571-a3fb-ba8ed3923479", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        stagnation_factor = 1.0  # New line\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                    stagnation_factor = 1.0  # New line\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n                stagnation_factor *= 0.9  # New line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n            self.inertia_weight *= stagnation_factor  # New line\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Introduce a dynamic inertia weight decay based on stagnation to enhance convergence speed and exploration.  ", "configspace": "", "generation": 74, "fitness": 0.2100434922300415, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.02.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.19689073159685055, 0.23834123476812008, 0.19489851032515393]}, "mutation_prompt": null}
{"id": "28be6fa6-e77e-4e36-bcfc-b75be1da6092", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.03 * (1 - self.evaluations/self.budget)  # Changed line\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 1)  # Changed line\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size:  # Changed line\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.15:  # Changed line\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Enhance convergence by implementing dynamic population resizing and fine-tuning mutation strength.", "configspace": "", "generation": 75, "fitness": 0.18425386334569938, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.16977322008272855, 0.17917682899343268, 0.2038115409609369]}, "mutation_prompt": null}
{"id": "27e89c57-438f-4543-ad3b-1738e580ec63", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):  # Added function\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:  # Modified line\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:  # Modified line\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.15:  # Modified line\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:  # Added line\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)  # Added line\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Improve local search adaptability by dynamically adjusting perturbation range and enhancing mutation based on stagnation detection.", "configspace": "", "generation": 76, "fitness": 0.20059360449917654, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.02.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.2193498324969655, 0.17898883522996656, 0.2034421457705976]}, "mutation_prompt": null}
{"id": "bcb5a055-08da-4bd2-90e8-24910055059f", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):  # Added function\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:  # Modified line\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.08:  # Adjusted line\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)  # Added line\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Adjusted the Lvy flight probability to enhance exploration capabilities further, aiming to improve convergence performance.", "configspace": "", "generation": 77, "fitness": 0.19635888582333016, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.03.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.17365937261924436, 0.23838260874049, 0.17703467611025614]}, "mutation_prompt": null}
{"id": "f4fca325-3b6c-4e9e-908f-6b4fee937936", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.85 - 0.5 * (self.evaluations / self.budget)  # Changed line\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Adjusted inertia weight update formula for improved convergence behavior.", "configspace": "", "generation": 78, "fitness": 0.2100434922300415, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.02.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.19689073159685055, 0.23834123476812008, 0.19489851032515393]}, "mutation_prompt": null}
{"id": "542479cd-51c2-4999-a2c9-5d36d1782e1c", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def differential_refinement(self, idx, bounds):  # Added function\n        a, b, c = np.random.choice(self.population_size, 3, replace=False)\n        mutant_vector = self.positions[a] + 0.8 * (self.positions[b] - self.positions[c])\n        trial_vector = np.where(np.random.rand(self.dim) < 0.9, mutant_vector, self.positions[idx])\n        return np.clip(trial_vector, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n                \n                if np.random.rand() < 0.1:  # Added line\n                    self.positions[i] = self.differential_refinement(i, bounds)  # Added line\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Enhance exploitation through differential evolution-inspired local refinement, while maintaining diversity with adaptive velocity scaling.", "configspace": "", "generation": 79, "fitness": 0.17252881169831524, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.00.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.1692478274579391, 0.17135302024303867, 0.17698558739396797]}, "mutation_prompt": null}
{"id": "5c851158-afeb-4ee2-ae54-a4b140756772", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)  # Changed line\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        diversity = np.std(self.positions, axis=0).mean()  # Added line\n        if diversity < 0.1:  # Changed line\n            self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Enhance the balance between exploration and exploitation by modifying the inertia weight progression and incorporating adaptive restart based on diversity.", "configspace": "", "generation": 80, "fitness": 0.19412500030153015, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.03.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.16831748543216085, 0.23834123476812008, 0.17571628070430956]}, "mutation_prompt": null}
{"id": "e11a45a1-4255-4131-8172-0ebed8735e22", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size:  # Modified line\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.2:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Refine the restart strategy by increasing stagnation sensitivity, reducing the trigger threshold for earlier restarts.", "configspace": "", "generation": 81, "fitness": 0.20128409840441497, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.03.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.1914312055854117, 0.23834123476812008, 0.1740798548597131]}, "mutation_prompt": null}
{"id": "f827d5b0-4be5-40d2-90f8-75002629460f", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:  # Modified line to increase local search frequency\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the frequency of local search to enhance solution refinement.", "configspace": "", "generation": 82, "fitness": 0.210780582654191, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.03.", "error": "", "parent_id": "b932c0a6-907e-4837-913e-26fe872630f9", "metadata": {"aucs": [0.2193498324969655, 0.23834123476812008, 0.17465068069748746]}, "mutation_prompt": null}
{"id": "b78749f4-6313-45a1-b31b-345afbe9ea7a", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:  # Modified line to increase local search frequency\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.15:  # Increased probability of adaptive mutation\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Increase the probability of adaptive mutation to explore more diverse solutions.", "configspace": "", "generation": 83, "fitness": 0.20059360449917654, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.02.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.2193498324969655, 0.17898883522996656, 0.2034421457705976]}, "mutation_prompt": null}
{"id": "46e35474-c2e2-443c-aab6-2a27473a09a6", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.15)  # Changed from 0.1 to 0.15\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:  # Modified line to increase local search frequency\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Increase the velocity scaling factor slightly to improve global exploration.", "configspace": "", "generation": 84, "fitness": 0.210780582654191, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.03.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.2193498324969655, 0.23834123476812008, 0.17465068069748746]}, "mutation_prompt": null}
{"id": "07c70a59-98c4-4b87-a51f-f8be8cc418aa", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.15:  # Modified line to increase adaptive mutation frequency\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the frequency of adaptive mutation to explore the search space more effectively.", "configspace": "", "generation": 85, "fitness": 0.20059360449917654, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.02.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.2193498324969655, 0.17898883522996656, 0.2034421457705976]}, "mutation_prompt": null}
{"id": "0950f6fd-af98-4647-9e60-064908581872", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:  # Modified line to increase Levy flight frequency\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Increase the frequency of Levy flight to improve exploration capability.", "configspace": "", "generation": 86, "fitness": 0.19510114446094526, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.03.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.16992311888477418, 0.23838260874049, 0.17699770575757157]}, "mutation_prompt": null}
{"id": "e157fb29-639e-4682-9d74-c85d7d13571a", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n        self.chaos_param = np.random.rand()\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def chaotic_map(self):\n        self.chaos_param = 4 * self.chaos_param * (1 - self.chaos_param)\n        return self.chaos_param\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            chaos_factor = self.chaotic_map()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * chaos_factor * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * chaos_factor * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                if np.random.rand() < 0.35:  # Adjusted frequency\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.3:  # Further increase local search frequency\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.12:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.07:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Introduced adaptive chaotic maps for enhanced exploration and exploitation balance in AQIPSO.", "configspace": "", "generation": 87, "fitness": 0.17137612725761822, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.01.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.17052936763287352, 0.18298075442345352, 0.16061825971652766]}, "mutation_prompt": null}
{"id": "e021b399-1886-4c41-a8e7-b0e1792d5dc7", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.3:  # Further increase local search frequency\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Further increase the local search frequency to boost solution improvement.", "configspace": "", "generation": 88, "fitness": 0.20476563463420805, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.03.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.16595253093264184, 0.23834123476812008, 0.21000313820186223]}, "mutation_prompt": null}
{"id": "87bfdb56-825d-4eeb-9f0a-c4c0ac274116", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.15) # Increased from 0.1 to 0.15\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the random velocity perturbation for enhanced exploration.", "configspace": "", "generation": 89, "fitness": 0.210780582654191, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.03.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.2193498324969655, 0.23834123476812008, 0.17465068069748746]}, "mutation_prompt": null}
{"id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:  # Modified line to increase Levy flight frequency\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the probability of Levy flight to enhance exploration.", "configspace": "", "generation": 90, "fitness": 0.22079515973045058, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.01.", "error": "", "parent_id": "f827d5b0-4be5-40d2-90f8-75002629460f", "metadata": {"aucs": [0.2193498324969655, 0.23834123476812008, 0.20469441192626614]}, "mutation_prompt": null}
{"id": "b07a4dc0-ad56-4e62-9288-2e7c77ca2561", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:  # Modified line to increase Levy flight frequency\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the probability of Levy flight to enhance exploration.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.2193498324969655, 0.23834123476812008, 0.20469441192626614]}, "mutation_prompt": null}
{"id": "5cd45676-221a-4e92-af7d-84a0d3f36da5", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget) * 0.9\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget) * 1.1\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n\n                if np.random.rand() < 0.27:  # Increased probability for local search\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.12:  # Increased probability for adaptive mutation\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Introduce a dynamic perturbation strategy that adapts based on function evaluations to enhance exploitation and exploration balance.", "configspace": "", "generation": 92, "fitness": 0.19255426049475413, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.03.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.16554717658052898, 0.23834123476812008, 0.17377437013561337]}, "mutation_prompt": null}
{"id": "cb7a4785-6d1f-46f6-9f86-18f1f1bceb8c", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.3:  # Increased frequency of local search\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Increase the frequency of local search to improve exploitation.", "configspace": "", "generation": 93, "fitness": 0.20881453504892497, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.02.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.1794355868339662, 0.23834123476812008, 0.2086667835446886]}, "mutation_prompt": null}
{"id": "c55fb8b7-aede-4f7f-8626-8141891b083d", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.15:  # Increased probability of adaptive mutation from 0.1 to 0.15\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Increase adaptive mutation probability to enhance local exploitation.", "configspace": "", "generation": 94, "fitness": 0.21587095462069836, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.01.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.2193498324969655, 0.22491560729281745, 0.2033474240723121]}, "mutation_prompt": null}
{"id": "4692c458-a939-43c3-aa69-63e0535ef056", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * np.random.rand() * (1 - self.evaluations/self.budget)  # Adjust mutation strength\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step_size = 0.01 + 0.02 * (1 - self.evaluations/self.budget)  # Dynamic step size\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + step_size * step * (bounds.ub - bounds.lb)  # Adjusted step size usage\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Enhance population diversity using a dynamic step size for Levy flights and adaptive mutation.", "configspace": "", "generation": 95, "fitness": 0.18744110149457618, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.04.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.1679375549152069, 0.23834123476812008, 0.1560445148004016]}, "mutation_prompt": null}
{"id": "88ad89ac-21b7-4964-bd9f-fbc379882898", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 22  # Increased initial population size\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the initial population size to enhance diversity and exploration capabilities.", "configspace": "", "generation": 96, "fitness": 0.22047657065019388, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.01.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.21656320197433265, 0.2396787331992587, 0.2051877767769903]}, "mutation_prompt": null}
{"id": "c1f0b072-17b6-468c-bfbe-bbd082be4f79", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.06:  # Modified line to increase Levy flight frequency\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Slightly increase the probability of Levy flight to enhance exploration.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.2193498324969655, 0.23834123476812008, 0.20469441192626614]}, "mutation_prompt": null}
{"id": "aaeb923b-95b5-4e4a-8475-916f5dab7cfa", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step_size = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step_size * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def differential_evolution_mutation(self, target_idx, bounds):\n        a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != target_idx], 3, replace=False)\n        F = 0.5\n        mutant = np.clip(self.positions[a] + F * (self.positions[b] - self.positions[c]), bounds.lb, bounds.ub)\n        return mutant\n\n    def restart_population(self, bounds):\n        self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.restart_population(bounds)\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.2 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.25:\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.08:\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n                    \n                if np.random.rand() < 0.15:\n                    mutant = self.differential_evolution_mutation(i, bounds)\n                    if func(mutant) < self.personal_best_values[i]:\n                        self.positions[i] = mutant\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "The EnhancedAQIPSO is improved by dynamically adjusting the Levy flight probability and incorporating differential evolution strategies to enhance both exploration and exploitation abilities.", "configspace": "", "generation": 98, "fitness": 0.18981209013483, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.02.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.1846101136659224, 0.21315088197463683, 0.17167527476393074]}, "mutation_prompt": null}
{"id": "6bc33576-6852-4284-a551-be82de6bff8c", "solution": "import numpy as np\n\nclass EnhancedAQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.729\n        self.cognitive_coeff = 1.49445\n        self.social_coeff = 1.49445\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self, bounds):\n        randomness_factor = np.random.normal(0, 0.3 * (1 - self.evaluations/self.budget), self.dim)\n        return bounds.lb + (bounds.ub - bounds.lb) * randomness_factor\n\n    def local_search(self, position, bounds):\n        perturbation_range = np.linspace(0.05, 0.25, self.dim) * (1 - self.evaluations/self.budget)\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def update_coefficients(self):\n        self.cognitive_coeff = 1.49445 * (1 - self.evaluations/self.budget)\n        self.social_coeff = 1.49445 * (self.evaluations/self.budget)\n        self.inertia_weight = 0.95 - 0.5 * (self.evaluations / self.budget)\n\n    def adaptive_mutation(self, position, bounds):\n        mutation_strength = 0.05 * (1 - self.evaluations/self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n        new_position = position + mutation\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def levy_flight(self, position, bounds):\n        step = np.random.normal(size=self.dim) / (np.abs(np.random.normal())**(1/3))\n        new_position = position + 0.01 * step * (bounds.ub - bounds.lb)\n        return np.clip(new_position, bounds.lb, bounds.ub)\n\n    def dynamic_restart(self, bounds):  # Changed from restart_population\n        restart_probability = 0.1 * (1 - self.evaluations / self.budget)\n        if np.random.rand() < restart_probability:\n            self.positions = np.random.rand(self.population_size, self.dim) * (bounds.ub - bounds.lb) + bounds.lb\n\n    def __call__(self, func):\n        bounds = func.bounds\n        stagnation_counter = 0\n        while self.evaluations < self.budget:\n            self.update_coefficients()\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.population_size - 2)\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_values[i]:\n                    self.personal_best_values[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = self.positions[i]\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.population_size * 2:\n                self.dynamic_restart(bounds)  # Changed from restart_population\n                stagnation_counter = 0\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + np.random.rand(self.dim)*0.1)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], bounds.lb, bounds.ub)\n\n                dynamic_prob = 0.25 + 0.1 * (1 - self.evaluations/self.budget)\n                if np.random.rand() < dynamic_prob:\n                    self.positions[i] = self.quantum_superposition(bounds)\n                    \n                if np.random.rand() < 0.3:  # Changed probability\n                    self.positions[i] = self.local_search(self.positions[i], bounds)\n\n                if np.random.rand() < 0.15:  # Changed probability\n                    self.positions[i] = self.adaptive_mutation(self.positions[i], bounds)\n\n                if np.random.rand() < 0.1:  # Changed probability\n                    self.positions[i] = self.levy_flight(self.positions[i], bounds)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedAQIPSO", "description": "Improved Adaptive Quantum-Enhanced PSO with Dynamic Restart Strategy (Enhances exploration with adaptive restart and multi-phase dynamic adjustments).", "configspace": "", "generation": 99, "fitness": 0.19688733719432497, "feedback": "The algorithm EnhancedAQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.03.", "error": "", "parent_id": "238ecce1-7d35-484d-bf46-2d895c9c5e84", "metadata": {"aucs": [0.17468200124891864, 0.23838260874049, 0.1775974015935663]}, "mutation_prompt": null}
