{"id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with evolutionary strategy-based exploitation to efficiently optimize black box functions within limited evaluations.", "configspace": "", "generation": 0, "fitness": 0.21093567412485878, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2182818336655339, 0.21316994644633191, 0.2013552422627105], "final_y": [0.03292747543013843, 0.10376723989411833, 0.26675779846634856]}, "mutation_prompt": null}
{"id": "f9366f75-e9d8-4cef-a410-a485869c387c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.5 + (0.4 * (self.budget - eval_count) / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm incorporates a dynamic inertia weight to balance exploration and exploitation, enhancing solution convergence within limited evaluations.", "configspace": "", "generation": 1, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.2271969124304403, 0.6253058473264748]}, "mutation_prompt": null}
{"id": "c6930a67-1416-48de-9895-93ae88908ce4", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjust the influence of pbest and gbest based on the progress\n                weight = 1 - (eval_count / self.budget) \n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * weight * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploitation by dynamically adjusting the influence of personal and global best positions based on the evaluation progress.", "configspace": "", "generation": 2, "fitness": 0.18145211601254171, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.016. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16704439835458085, 0.173415879766605, 0.20389606991643927], "final_y": [0.351707187070705, 0.1985393502503193, 0.26887927869625067]}, "mutation_prompt": null}
{"id": "e4c6b08e-12c7-448a-afcc-e1bf053fd47a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.05:  # Random jump strategy\n                    population[i] = np.random.uniform(bounds[0], bounds[1], self.dim)\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a random jump strategy to enhance exploration, allowing jumps to random points within bounds to escape local optima.", "configspace": "", "generation": 3, "fitness": 0.15971275607235944, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.160 with standard deviation 0.016. And the mean value of best solutions found was 0.343 (0. is the best) with standard deviation 0.252.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13708148501276374, 0.17262715044114163, 0.1694296327631729], "final_y": [0.6730345774806049, 0.2943895424833227, 0.061136008907898616]}, "mutation_prompt": null}
{"id": "4c6edcb1-27c8-40dd-8e1f-a28661592f80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance convergence by introducing adaptive inertia weight in velocity calculation for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.17510467990163794, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.005. And the mean value of best solutions found was 0.400 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17411189075905475, 0.18161516010842693, 0.16958698883743217], "final_y": [0.3650756635222657, 0.35900112755114905, 0.47494474629923544]}, "mutation_prompt": null}
{"id": "b6fe8fba-f203-4283-a997-0985abed96d7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - ((0.9 - 0.4) * (eval_count / self.budget))  # Dynamically adjust inertia weight\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its exploration capability by introducing a dynamic inertia weight adjustment to balance exploration and exploitation phases.", "configspace": "", "generation": 5, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "67514f68-e86b-464e-b79f-a3eb54446da3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.7 + 0.3 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by dynamically adjusting the inertia weight in the velocity update of particles, fostering balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.12782333398013757, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.029. And the mean value of best solutions found was 2.113 (0. is the best) with standard deviation 1.055.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.10877539392189206, 0.1054614880512511, 0.16923311996726953], "final_y": [2.438746879166507, 3.211315034979523, 0.6883055634447593]}, "mutation_prompt": null}
{"id": "7255cf79-758a-463d-b6c9-dd6203a235c5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm introduces adaptive velocity scaling to balance exploration and exploitation phases, optimizing black box functions more effectively within limited evaluations.", "configspace": "", "generation": 7, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "d34310c9-4f1b-4248-88f9-fde36b52bc79", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = w * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines swarm intelligence-inspired exploration with evolutionary strategy-based exploitation, introducing adaptive inertia weight for improved convergence within limited evaluations.", "configspace": "", "generation": 8, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "ea5cd3ed-acca-4da8-8de3-97c5bb5cf6f1", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.5 + np.random.rand() * 0.5  # Dynamically adjust inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances local search efficiency by adjusting velocity coefficients dynamically based on performance.", "configspace": "", "generation": 9, "fitness": 0.1464833230309077, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.004. And the mean value of best solutions found was 0.936 (0. is the best) with standard deviation 0.296.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1439270834719435, 0.15219841952204372, 0.14332446609873584], "final_y": [0.8258868307756344, 0.6412558195322617, 1.341369706391506]}, "mutation_prompt": null}
{"id": "b240a674-12d3-40c8-8107-da6fb0c49cb2", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # Initial inertia weight\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm utilizes an adaptive inertia weight approach for velocity update to enhance convergence speed and solution quality.", "configspace": "", "generation": 10, "fitness": 0.15751063707011417, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.013. And the mean value of best solutions found was 0.692 (0. is the best) with standard deviation 0.180.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14580870702416782, 0.17608880531299687, 0.15063439887317787], "final_y": [0.9263159782829933, 0.48776339772534155, 0.663292441379794]}, "mutation_prompt": null}
{"id": "7f4de30d-2b41-4498-90f2-c5087df8ab03", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.5 + (0.5 - 0.1) * (self.budget - eval_count) / self.budget  # Dynamic adjustment\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploration by dynamically adjusting the velocity coefficient to improve optimization efficiency within limited evaluations.", "configspace": "", "generation": 11, "fitness": 0.14816208848247672, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.148 with standard deviation 0.019. And the mean value of best solutions found was 0.784 (0. is the best) with standard deviation 0.508.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12464856871193408, 0.1703483054055699, 0.14948939132992622], "final_y": [1.4796787355636214, 0.2784572363790426, 0.5941786603606671]}, "mutation_prompt": null}
{"id": "79090b3d-1de2-4345-b065-59dbc76a211f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + np.random.normal(0, 0.1, self.dim)  # Added mutation-based strategy\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with a mutation-based strategy to enhance convergence speed and diversify search directions for efficient optimization under a limited budget.", "configspace": "", "generation": 12, "fitness": 0.18596058919035982, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.017. And the mean value of best solutions found was 0.290 (0. is the best) with standard deviation 0.244.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16355348643900958, 0.18932208898843028, 0.20500619214363958], "final_y": [0.6330980662980192, 0.0887976902275785, 0.1474720341146653]}, "mutation_prompt": null}
{"id": "18d91e26-02f4-4cc4-aff1-d34cf71db31b", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The enhanced algorithm utilizes adaptive velocity scaling for improved convergence in black box optimization.", "configspace": "", "generation": 13, "fitness": 0.17281441860634764, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.001. And the mean value of best solutions found was 0.377 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17105393920069611, 0.17319444642124449, 0.17419487019710234], "final_y": [0.3765464677950064, 0.3774684378961005, 0.3779795274555056]}, "mutation_prompt": null}
{"id": "f5536ddb-2131-4257-afe9-b630609fc834", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # Updated line\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introduce adaptive inertia in velocity update to enhance the convergence rate and exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "e3a6fd24-bcbe-4e9f-89e6-a7f1091ccfe3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)  # Line modified to add adaptive inertia weight\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced HybridSwarmEvolution algorithm with adaptive inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.13561015223579675, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.136 with standard deviation 0.010. And the mean value of best solutions found was 0.983 (0. is the best) with standard deviation 0.278.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14352170819108323, 0.12127047877746133, 0.1420382697388457], "final_y": [0.8975755905274523, 0.6938884164428618, 1.3588773874518885]}, "mutation_prompt": null}
{"id": "24ee6a4f-7f39-46ac-9429-ee12a7b7cefb", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = np.linalg.norm(self.gbest - population[i]) / np.linalg.norm(bounds[1] - bounds[0])\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances particle diversity by adjusting inertia dynamically based on the distance to the global best, improving exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.18988317805841673, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.190 with standard deviation 0.050. And the mean value of best solutions found was 0.485 (0. is the best) with standard deviation 0.507.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17684936245347505, 0.13644825865512933, 0.25635191306664584], "final_y": [0.24059862663653214, 1.1910231958735524, 0.02266088147117256]}, "mutation_prompt": null}
{"id": "234b17fd-1c7e-4d27-a41e-b7c2a788a97d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + 0.1 * r3\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced the velocity update equation by incorporating a stochastic term to improve exploration.", "configspace": "", "generation": 17, "fitness": 0.19348682709931644, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.193 with standard deviation 0.012. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.044.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.18867022971378278, 0.2097058290973407, 0.18208442248682588], "final_y": [0.07004787756414049, 0.07887447838908879, 0.16803456272022418]}, "mutation_prompt": null}
{"id": "6d3da10b-d38e-4333-9a2a-e929896da09d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        inertia_weight = 0.7\n        c1, c2 = 1.5, 1.5  # Adaptive learning rates\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.7 - 0.5 * (eval_count / self.budget)  # Adaptive inertia\n                self.velocity[i] = inertia_weight * self.velocity[i] + c1 * r1 * (self.pbest[i] - population[i]) + c2 * r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhances exploration-exploitation balance by incorporating adaptive learning rates and dynamic neighborhood interactions.", "configspace": "", "generation": 18, "fitness": 0.20807788443095965, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.030. And the mean value of best solutions found was 0.332 (0. is the best) with standard deviation 0.210.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17387111397475252, 0.24674399932493551, 0.2036185399931909], "final_y": [0.574162730518925, 0.062054186585437494, 0.3584078621462598]}, "mutation_prompt": null}
{"id": "dfa8ce7f-0b39-4aed-9378-0e90593f446f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Added dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing exploration by adjusting velocity update with a dynamic inertia weight.", "configspace": "", "generation": 19, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "1cc4d0b4-ccf7-49ea-b0af-984098aedbaa", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                self.velocity[i] *= 0.9  # Adaptive velocity scaling for improved convergence\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates adaptive velocity scaling to improve convergence speed and solution quality in black box optimization.", "configspace": "", "generation": 20, "fitness": 0.19437348050866898, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.194 with standard deviation 0.008. And the mean value of best solutions found was 0.099 (0. is the best) with standard deviation 0.071.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1836322493276642, 0.19570969083708967, 0.20377850136125308], "final_y": [0.062252993426559, 0.03656485690677117, 0.1976918677263152]}, "mutation_prompt": null}
{"id": "e7771e5c-c400-41ae-8018-360c4af301a7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])  # Adjusted line\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances swarm exploration by adjusting the velocity update factor for improved convergence.", "configspace": "", "generation": 21, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "f8669233-427d-4792-a3a3-6555f52d124c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                improvement = func(self.pbest[i]) - func(population[i])\n                adaptive_factor = max(0.1, improvement)\n                self.velocity[i] = adaptive_factor * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm uses adaptive velocity scaling based on current improvement to balance exploration and exploitation effectively within the given budget. ", "configspace": "", "generation": 22, "fitness": 0.12484111492200696, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.035. And the mean value of best solutions found was 2.213 (0. is the best) with standard deviation 1.448.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.09440880833310439, 0.10689974845380723, 0.17321478797910927], "final_y": [3.6157627950521953, 2.80343777658231, 0.21958079260704205]}, "mutation_prompt": null}
{"id": "89a6fec1-421c-421d-9955-ba030da8b01d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Increase the influence of random components by using a factor of 0.6\n                self.velocity[i] = 0.6 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "This refined algorithm enhances global exploration by slightly increasing random influence in velocity updates for improved convergence on black box optimization tasks.", "configspace": "", "generation": 23, "fitness": 0.20645327972820127, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.206 with standard deviation 0.008. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.20778322289307805, 0.1964398935240128, 0.21513672276751294], "final_y": [0.12234499976336675, 0.32921290749446686, 0.11890109032734045]}, "mutation_prompt": null}
{"id": "1fc1dcb8-d3e8-4e46-9f07-771540cecc96", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget)) # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The improved algorithm uses dynamic inertia weight adjustment in swarm intelligence to balance exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "04b84aee-9bfa-403e-b259-8611988d9f44", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.7\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + \n                                    r2 * (self.gbest - population[i]))\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "This refined algorithm tweaks the velocity update equation to incorporate an additional inertia weight factor, enhancing the balance between exploration and exploitation.  ", "configspace": "", "generation": 25, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "54955c11-f3c9-4b71-bf04-6a6530a6a170", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing exploitation by adjusting velocity scaling factor for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "4adffc16-0abe-4830-9760-1c678eca7b80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines HybridSwarmEvolution by adjusting inertia weight dynamically based on evaluations to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "2b0fdc76-420b-4737-8c4b-de8a995fc28c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # Initializing inertia weight\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjusting the inertia weight dynamically\n                inertia_weight -= 0.4 / self.budget  \n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "This refined algorithm introduces a subtle improvement by adjusting the inertia weight dynamically to enhance the balance between exploration and exploitation, potentially improving convergence.", "configspace": "", "generation": 28, "fitness": 0.13531534892166477, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.135 with standard deviation 0.009. And the mean value of best solutions found was 0.906 (0. is the best) with standard deviation 0.412.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12353251698374856, 0.1359579940571164, 0.1464555357241294], "final_y": [1.419023900294808, 0.4100028274014208, 0.8874928941642656]}, "mutation_prompt": null}
{"id": "5bffdf80-a881-4e0e-a76b-71b86b964d26", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates adaptive inertia weight to dynamically balance exploration and exploitation in optimizing black box functions.", "configspace": "", "generation": 29, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "fb655410-5cfa-46bd-bf55-ec16e92190de", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Modified velocity update with a dynamic inertia weight for improved convergence\n                inertia_weight = 0.5 + 0.5 * (self.budget - eval_count) / self.budget\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing the velocity update mechanism in HybridSwarmEvolution for improved convergence rate in black box optimization.", "configspace": "", "generation": 30, "fitness": 0.13444848816297947, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.134 with standard deviation 0.036. And the mean value of best solutions found was 1.769 (0. is the best) with standard deviation 1.515.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12028467593090397, 0.09934757542875594, 0.18371321312927846], "final_y": [1.0105667403685505, 3.883234514966444, 0.41197564546607846]}, "mutation_prompt": null}
