{"id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with evolutionary strategy-based exploitation to efficiently optimize black box functions within limited evaluations.", "configspace": "", "generation": 0, "fitness": 0.21093567412485878, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2182818336655339, 0.21316994644633191, 0.2013552422627105], "final_y": [0.03292747543013843, 0.10376723989411833, 0.26675779846634856]}, "mutation_prompt": null}
{"id": "f9366f75-e9d8-4cef-a410-a485869c387c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.5 + (0.4 * (self.budget - eval_count) / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm incorporates a dynamic inertia weight to balance exploration and exploitation, enhancing solution convergence within limited evaluations.", "configspace": "", "generation": 1, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.2271969124304403, 0.6253058473264748]}, "mutation_prompt": null}
{"id": "c6930a67-1416-48de-9895-93ae88908ce4", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjust the influence of pbest and gbest based on the progress\n                weight = 1 - (eval_count / self.budget) \n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * weight * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploitation by dynamically adjusting the influence of personal and global best positions based on the evaluation progress.", "configspace": "", "generation": 2, "fitness": 0.18145211601254171, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.016. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16704439835458085, 0.173415879766605, 0.20389606991643927], "final_y": [0.351707187070705, 0.1985393502503193, 0.26887927869625067]}, "mutation_prompt": null}
{"id": "e4c6b08e-12c7-448a-afcc-e1bf053fd47a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.05:  # Random jump strategy\n                    population[i] = np.random.uniform(bounds[0], bounds[1], self.dim)\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a random jump strategy to enhance exploration, allowing jumps to random points within bounds to escape local optima.", "configspace": "", "generation": 3, "fitness": 0.15971275607235944, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.160 with standard deviation 0.016. And the mean value of best solutions found was 0.343 (0. is the best) with standard deviation 0.252.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13708148501276374, 0.17262715044114163, 0.1694296327631729], "final_y": [0.6730345774806049, 0.2943895424833227, 0.061136008907898616]}, "mutation_prompt": null}
{"id": "4c6edcb1-27c8-40dd-8e1f-a28661592f80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance convergence by introducing adaptive inertia weight in velocity calculation for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.17510467990163794, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.005. And the mean value of best solutions found was 0.400 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17411189075905475, 0.18161516010842693, 0.16958698883743217], "final_y": [0.3650756635222657, 0.35900112755114905, 0.47494474629923544]}, "mutation_prompt": null}
{"id": "b6fe8fba-f203-4283-a997-0985abed96d7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - ((0.9 - 0.4) * (eval_count / self.budget))  # Dynamically adjust inertia weight\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its exploration capability by introducing a dynamic inertia weight adjustment to balance exploration and exploitation phases.", "configspace": "", "generation": 5, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "67514f68-e86b-464e-b79f-a3eb54446da3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.7 + 0.3 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by dynamically adjusting the inertia weight in the velocity update of particles, fostering balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.12782333398013757, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.029. And the mean value of best solutions found was 2.113 (0. is the best) with standard deviation 1.055.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.10877539392189206, 0.1054614880512511, 0.16923311996726953], "final_y": [2.438746879166507, 3.211315034979523, 0.6883055634447593]}, "mutation_prompt": null}
{"id": "7255cf79-758a-463d-b6c9-dd6203a235c5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm introduces adaptive velocity scaling to balance exploration and exploitation phases, optimizing black box functions more effectively within limited evaluations.", "configspace": "", "generation": 7, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "d34310c9-4f1b-4248-88f9-fde36b52bc79", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = w * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines swarm intelligence-inspired exploration with evolutionary strategy-based exploitation, introducing adaptive inertia weight for improved convergence within limited evaluations.", "configspace": "", "generation": 8, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "ea5cd3ed-acca-4da8-8de3-97c5bb5cf6f1", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.5 + np.random.rand() * 0.5  # Dynamically adjust inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances local search efficiency by adjusting velocity coefficients dynamically based on performance.", "configspace": "", "generation": 9, "fitness": 0.1464833230309077, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.004. And the mean value of best solutions found was 0.936 (0. is the best) with standard deviation 0.296.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1439270834719435, 0.15219841952204372, 0.14332446609873584], "final_y": [0.8258868307756344, 0.6412558195322617, 1.341369706391506]}, "mutation_prompt": null}
{"id": "b240a674-12d3-40c8-8107-da6fb0c49cb2", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # Initial inertia weight\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm utilizes an adaptive inertia weight approach for velocity update to enhance convergence speed and solution quality.", "configspace": "", "generation": 10, "fitness": 0.15751063707011417, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.013. And the mean value of best solutions found was 0.692 (0. is the best) with standard deviation 0.180.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14580870702416782, 0.17608880531299687, 0.15063439887317787], "final_y": [0.9263159782829933, 0.48776339772534155, 0.663292441379794]}, "mutation_prompt": null}
{"id": "7f4de30d-2b41-4498-90f2-c5087df8ab03", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.5 + (0.5 - 0.1) * (self.budget - eval_count) / self.budget  # Dynamic adjustment\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploration by dynamically adjusting the velocity coefficient to improve optimization efficiency within limited evaluations.", "configspace": "", "generation": 11, "fitness": 0.14816208848247672, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.148 with standard deviation 0.019. And the mean value of best solutions found was 0.784 (0. is the best) with standard deviation 0.508.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12464856871193408, 0.1703483054055699, 0.14948939132992622], "final_y": [1.4796787355636214, 0.2784572363790426, 0.5941786603606671]}, "mutation_prompt": null}
{"id": "79090b3d-1de2-4345-b065-59dbc76a211f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + np.random.normal(0, 0.1, self.dim)  # Added mutation-based strategy\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with a mutation-based strategy to enhance convergence speed and diversify search directions for efficient optimization under a limited budget.", "configspace": "", "generation": 12, "fitness": 0.18596058919035982, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.017. And the mean value of best solutions found was 0.290 (0. is the best) with standard deviation 0.244.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16355348643900958, 0.18932208898843028, 0.20500619214363958], "final_y": [0.6330980662980192, 0.0887976902275785, 0.1474720341146653]}, "mutation_prompt": null}
{"id": "18d91e26-02f4-4cc4-aff1-d34cf71db31b", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The enhanced algorithm utilizes adaptive velocity scaling for improved convergence in black box optimization.", "configspace": "", "generation": 13, "fitness": 0.17281441860634764, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.001. And the mean value of best solutions found was 0.377 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17105393920069611, 0.17319444642124449, 0.17419487019710234], "final_y": [0.3765464677950064, 0.3774684378961005, 0.3779795274555056]}, "mutation_prompt": null}
{"id": "f5536ddb-2131-4257-afe9-b630609fc834", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # Updated line\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introduce adaptive inertia in velocity update to enhance the convergence rate and exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "e3a6fd24-bcbe-4e9f-89e6-a7f1091ccfe3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)  # Line modified to add adaptive inertia weight\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced HybridSwarmEvolution algorithm with adaptive inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.13561015223579675, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.136 with standard deviation 0.010. And the mean value of best solutions found was 0.983 (0. is the best) with standard deviation 0.278.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14352170819108323, 0.12127047877746133, 0.1420382697388457], "final_y": [0.8975755905274523, 0.6938884164428618, 1.3588773874518885]}, "mutation_prompt": null}
{"id": "24ee6a4f-7f39-46ac-9429-ee12a7b7cefb", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = np.linalg.norm(self.gbest - population[i]) / np.linalg.norm(bounds[1] - bounds[0])\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances particle diversity by adjusting inertia dynamically based on the distance to the global best, improving exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.18988317805841673, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.190 with standard deviation 0.050. And the mean value of best solutions found was 0.485 (0. is the best) with standard deviation 0.507.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17684936245347505, 0.13644825865512933, 0.25635191306664584], "final_y": [0.24059862663653214, 1.1910231958735524, 0.02266088147117256]}, "mutation_prompt": null}
{"id": "234b17fd-1c7e-4d27-a41e-b7c2a788a97d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + 0.1 * r3\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced the velocity update equation by incorporating a stochastic term to improve exploration.", "configspace": "", "generation": 17, "fitness": 0.19348682709931644, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.193 with standard deviation 0.012. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.044.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.18867022971378278, 0.2097058290973407, 0.18208442248682588], "final_y": [0.07004787756414049, 0.07887447838908879, 0.16803456272022418]}, "mutation_prompt": null}
