{"id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with evolutionary strategy-based exploitation to efficiently optimize black box functions within limited evaluations.", "configspace": "", "generation": 0, "fitness": 0.21093567412485878, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2182818336655339, 0.21316994644633191, 0.2013552422627105], "final_y": [0.03292747543013843, 0.10376723989411833, 0.26675779846634856]}, "mutation_prompt": null}
{"id": "f9366f75-e9d8-4cef-a410-a485869c387c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.5 + (0.4 * (self.budget - eval_count) / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm incorporates a dynamic inertia weight to balance exploration and exploitation, enhancing solution convergence within limited evaluations.", "configspace": "", "generation": 1, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.2271969124304403, 0.6253058473264748]}, "mutation_prompt": null}
{"id": "c6930a67-1416-48de-9895-93ae88908ce4", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjust the influence of pbest and gbest based on the progress\n                weight = 1 - (eval_count / self.budget) \n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * weight * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploitation by dynamically adjusting the influence of personal and global best positions based on the evaluation progress.", "configspace": "", "generation": 2, "fitness": 0.18145211601254171, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.016. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16704439835458085, 0.173415879766605, 0.20389606991643927], "final_y": [0.351707187070705, 0.1985393502503193, 0.26887927869625067]}, "mutation_prompt": null}
{"id": "e4c6b08e-12c7-448a-afcc-e1bf053fd47a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.05:  # Random jump strategy\n                    population[i] = np.random.uniform(bounds[0], bounds[1], self.dim)\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a random jump strategy to enhance exploration, allowing jumps to random points within bounds to escape local optima.", "configspace": "", "generation": 3, "fitness": 0.15971275607235944, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.160 with standard deviation 0.016. And the mean value of best solutions found was 0.343 (0. is the best) with standard deviation 0.252.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13708148501276374, 0.17262715044114163, 0.1694296327631729], "final_y": [0.6730345774806049, 0.2943895424833227, 0.061136008907898616]}, "mutation_prompt": null}
{"id": "4c6edcb1-27c8-40dd-8e1f-a28661592f80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance convergence by introducing adaptive inertia weight in velocity calculation for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.17510467990163794, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.005. And the mean value of best solutions found was 0.400 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17411189075905475, 0.18161516010842693, 0.16958698883743217], "final_y": [0.3650756635222657, 0.35900112755114905, 0.47494474629923544]}, "mutation_prompt": null}
{"id": "b6fe8fba-f203-4283-a997-0985abed96d7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - ((0.9 - 0.4) * (eval_count / self.budget))  # Dynamically adjust inertia weight\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its exploration capability by introducing a dynamic inertia weight adjustment to balance exploration and exploitation phases.", "configspace": "", "generation": 5, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
