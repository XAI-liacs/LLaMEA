{"id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with evolutionary strategy-based exploitation to efficiently optimize black box functions within limited evaluations.", "configspace": "", "generation": 0, "fitness": 0.21093567412485878, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2182818336655339, 0.21316994644633191, 0.2013552422627105], "final_y": [0.03292747543013843, 0.10376723989411833, 0.26675779846634856]}, "mutation_prompt": null}
{"id": "f9366f75-e9d8-4cef-a410-a485869c387c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.5 + (0.4 * (self.budget - eval_count) / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm incorporates a dynamic inertia weight to balance exploration and exploitation, enhancing solution convergence within limited evaluations.", "configspace": "", "generation": 1, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.2271969124304403, 0.6253058473264748]}, "mutation_prompt": null}
{"id": "c6930a67-1416-48de-9895-93ae88908ce4", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjust the influence of pbest and gbest based on the progress\n                weight = 1 - (eval_count / self.budget) \n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * weight * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploitation by dynamically adjusting the influence of personal and global best positions based on the evaluation progress.", "configspace": "", "generation": 2, "fitness": 0.18145211601254171, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.016. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16704439835458085, 0.173415879766605, 0.20389606991643927], "final_y": [0.351707187070705, 0.1985393502503193, 0.26887927869625067]}, "mutation_prompt": null}
{"id": "e4c6b08e-12c7-448a-afcc-e1bf053fd47a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.05:  # Random jump strategy\n                    population[i] = np.random.uniform(bounds[0], bounds[1], self.dim)\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a random jump strategy to enhance exploration, allowing jumps to random points within bounds to escape local optima.", "configspace": "", "generation": 3, "fitness": 0.15971275607235944, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.160 with standard deviation 0.016. And the mean value of best solutions found was 0.343 (0. is the best) with standard deviation 0.252.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13708148501276374, 0.17262715044114163, 0.1694296327631729], "final_y": [0.6730345774806049, 0.2943895424833227, 0.061136008907898616]}, "mutation_prompt": null}
{"id": "4c6edcb1-27c8-40dd-8e1f-a28661592f80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance convergence by introducing adaptive inertia weight in velocity calculation for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.17510467990163794, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.005. And the mean value of best solutions found was 0.400 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17411189075905475, 0.18161516010842693, 0.16958698883743217], "final_y": [0.3650756635222657, 0.35900112755114905, 0.47494474629923544]}, "mutation_prompt": null}
{"id": "b6fe8fba-f203-4283-a997-0985abed96d7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - ((0.9 - 0.4) * (eval_count / self.budget))  # Dynamically adjust inertia weight\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its exploration capability by introducing a dynamic inertia weight adjustment to balance exploration and exploitation phases.", "configspace": "", "generation": 5, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "67514f68-e86b-464e-b79f-a3eb54446da3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.7 + 0.3 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by dynamically adjusting the inertia weight in the velocity update of particles, fostering balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.12782333398013757, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.029. And the mean value of best solutions found was 2.113 (0. is the best) with standard deviation 1.055.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.10877539392189206, 0.1054614880512511, 0.16923311996726953], "final_y": [2.438746879166507, 3.211315034979523, 0.6883055634447593]}, "mutation_prompt": null}
{"id": "7255cf79-758a-463d-b6c9-dd6203a235c5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm introduces adaptive velocity scaling to balance exploration and exploitation phases, optimizing black box functions more effectively within limited evaluations.", "configspace": "", "generation": 7, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "d34310c9-4f1b-4248-88f9-fde36b52bc79", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = w * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines swarm intelligence-inspired exploration with evolutionary strategy-based exploitation, introducing adaptive inertia weight for improved convergence within limited evaluations.", "configspace": "", "generation": 8, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "ea5cd3ed-acca-4da8-8de3-97c5bb5cf6f1", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.5 + np.random.rand() * 0.5  # Dynamically adjust inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances local search efficiency by adjusting velocity coefficients dynamically based on performance.", "configspace": "", "generation": 9, "fitness": 0.1464833230309077, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.004. And the mean value of best solutions found was 0.936 (0. is the best) with standard deviation 0.296.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1439270834719435, 0.15219841952204372, 0.14332446609873584], "final_y": [0.8258868307756344, 0.6412558195322617, 1.341369706391506]}, "mutation_prompt": null}
{"id": "b240a674-12d3-40c8-8107-da6fb0c49cb2", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # Initial inertia weight\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm utilizes an adaptive inertia weight approach for velocity update to enhance convergence speed and solution quality.", "configspace": "", "generation": 10, "fitness": 0.15751063707011417, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.013. And the mean value of best solutions found was 0.692 (0. is the best) with standard deviation 0.180.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14580870702416782, 0.17608880531299687, 0.15063439887317787], "final_y": [0.9263159782829933, 0.48776339772534155, 0.663292441379794]}, "mutation_prompt": null}
