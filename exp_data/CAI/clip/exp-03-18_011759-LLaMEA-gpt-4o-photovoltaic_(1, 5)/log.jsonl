{"id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Adaptive Momentum Firefly Algorithm\" enhances traditional metaheuristics by combining adaptive step sizes with momentum-based movement to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "8c389f10-5004-4e0c-9ac8-53f5757b876e", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" improves convergence by dynamically adjusting momentum based on exploration progress.", "configspace": "", "generation": 1, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "6e5c523e-4e94-4984-86c4-01dad4365072", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        # Change: Update momentum to decrease over time\n                        velocities[i] = (self.momentum * velocities[i] * ((self.budget - evaluations) / self.budget)) + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Adaptive Momentum Firefly Algorithm\" now incorporates a dynamic momentum coefficient that decreases over time, allowing for more refined exploration as convergence improves.", "configspace": "", "generation": 1, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "ac2128cc-68a6-4e48-84b8-48fb97864a46", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.randn(self.dim) - 0.5)  # Changed rand to randn\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Momentum-Enhanced Firefly Algorithm\" refines firefly movements by adding adaptive noise to enhance exploration without increasing instability.", "configspace": "", "generation": 1, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "fd132baf-ce56-423c-9f82-5ad8e6340714", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha using nonlinear decay\n            self.alpha *= 0.95 + 0.05 * (np.sin(evaluations / self.budget * np.pi))\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Enhanced Momentum Firefly Algorithm\" incorporates nonlinear decay of the randomization parameter to balance exploration and exploitation even more effectively.", "configspace": "", "generation": 1, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "de8a19e2-3aff-428b-b8c2-164b4692fcdd", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha and adjust momentum\n            self.alpha *= 0.95\n            self.momentum *= 0.98  # Dynamically adjust momentum\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Improved AdaptiveMomentumFirefly algorithm by dynamically adjusting the momentum coefficient for better exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "c73fb39a-a6ff-45c7-8a26-cc9b2b7a8a93", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        # Adaptive gamma based on progress\n                        self.gamma = max(0.5, 1.5 - evaluations / self.budget)  \n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduced adaptive gamma to dynamically adjust the light absorption coefficient for better exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c389f10-5004-4e0c-9ac8-53f5757b876e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "521ecde2-4461-4605-946e-2935c7d60540", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n                    self.alpha *= 0.98  # Adaptive randomization parameter\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" improves convergence by dynamically adjusting momentum based on exploration progress and employing an adaptive randomization parameter.", "configspace": "", "generation": 2, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c389f10-5004-4e0c-9ac8-53f5757b876e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "0a974f46-b19e-49f1-8484-cef7ed5d41de", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i after all comparisons\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.92  # Slightly adjust momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" enhances performance by refining momentum adjustment and intensity evaluation order.", "configspace": "", "generation": 2, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c389f10-5004-4e0c-9ac8-53f5757b876e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "d1814e62-ad6b-4917-987c-b21f609ca897", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n        stagnation_counter = 0  # Counter for stagnation\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n                    stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter += 1\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Reset momentum if stagnation is detected\n                if stagnation_counter > self.budget * 0.1:  # If stagnation persists\n                    self.momentum = 0.5\n                    stagnation_counter = 0\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm with Enhanced Exploration\" introduces a momentum reset feature when stagnation is detected to escape local optima.", "configspace": "", "generation": 2, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c389f10-5004-4e0c-9ac8-53f5757b876e", "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "9cc81604-7bde-40b3-aca8-55063e675601", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" is enhanced by initializing fireflies closer to the lower bound, potentially improving initial exploration in constrained spaces.", "configspace": "", "generation": 2, "fitness": 0.7881685003239243, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.019. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "8c389f10-5004-4e0c-9ac8-53f5757b876e", "metadata": {"aucs": [0.8144074016491782, 0.7750490496612972, 0.7750490496612972], "final_y": [0.142322702609607, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
{"id": "2c67fac0-5218-405c-90ae-b2789dd56f46", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhancing the \"Dynamic Adaptive Momentum Firefly Algorithm\" by dynamically adjusting the randomization parameter alpha for better exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9cc81604-7bde-40b3-aca8-55063e675601", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "c1f18019-066b-4bd3-8f8c-52b152f79bff", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-(self.gamma + evaluations/self.budget) * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" now includes a variable gamma, which adjusts dynamically based on the number of evaluations, potentially enhancing convergence speed.", "configspace": "", "generation": 3, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9cc81604-7bde-40b3-aca8-55063e675601", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "e248ca3a-4baa-46a4-90a7-2ab5d9eb3d24", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.9 + 0.05 * (intensities[best_idx] - new_intensity) / intensities[best_idx]  # Dynamic momentum adjustment based on intensity\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" now updates the momentum dynamically based on intensity differences to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9cc81604-7bde-40b3-aca8-55063e675601", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "c3233354-db12-4911-93e5-3083356e5350", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n            \n            # Adapt gamma\n            self.gamma = 1 / (1 + 0.01 * evaluations)  # Decrease gamma over time\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Dynamic Adaptive Momentum Firefly Algorithm\" is refined by incorporating an adaptive gamma parameter for better exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9cc81604-7bde-40b3-aca8-55063e675601", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "2038e6d6-f3a8-4595-a741-e6a9d1bd0e14", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        # Adjust beta_min dynamically\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2) * (evaluations / self.budget)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhanced \"Dynamic Adaptive Momentum Firefly Algorithm\" with improved exploration by adjusting the beta_min dynamically based on evaluation progress.", "configspace": "", "generation": 3, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9cc81604-7bde-40b3-aca8-55063e675601", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "38b45d04-131e-440d-adba-f7e3be8b510b", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introducing adaptive beta_min adjustment based on distance to improve convergence.", "configspace": "", "generation": 4, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c67fac0-5218-405c-90ae-b2789dd56f46", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "cf8984a8-65c8-4076-9414-46d4a705f07b", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5) * (1 + evaluations / self.budget)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration by increasing randomization effect with a dynamic factor linked to evaluations.", "configspace": "", "generation": 4, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c67fac0-5218-405c-90ae-b2789dd56f46", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "cbc8daba-4973-4192-9053-574dbb211b95", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n            self.gamma = 1 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # Adaptive gamma\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Optimizing the \"Dynamic Adaptive Momentum Firefly Algorithm\" by introducing adaptive gamma for better adaptability across varying landscapes.", "configspace": "", "generation": 4, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c67fac0-5218-405c-90ae-b2789dd56f46", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "e87b4140-368a-4cf9-a6cc-cfe0f43e97e4", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n                    self.gamma *= 0.95  # Decrease gamma to increase exploration\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "\"Dynamic Adaptive Momentum Firefly Algorithm\" refined by introducing variable gamma to adjust light absorption dynamically based on convergence speed.", "configspace": "", "generation": 4, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c67fac0-5218-405c-90ae-b2789dd56f46", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "7632fdd7-d1c1-4cdf-8741-84fe809b8c34", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.6  # Initial randomization parameter (increased from 0.5 to 0.6)\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhancing the \"Dynamic Adaptive Momentum Firefly Algorithm\" by subtly increasing the initial randomization parameter alpha for improved exploration.", "configspace": "", "generation": 4, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c67fac0-5218-405c-90ae-b2789dd56f46", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "afdbb5b2-2081-4e4e-9ce0-b106be9a4d35", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhanced exploration by dynamically adjusting the light absorption coefficient and leveraging adaptive alpha.", "configspace": "", "generation": 5, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "38b45d04-131e-440d-adba-f7e3be8b510b", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "41319625-53e5-427c-8dee-d75130f56c99", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        \n                        # Adaptive velocity scaling\n                        scaling_factor = 0.5 + 0.5 * (intensities[i] - intensities[best_idx]) / (np.max(intensities) - np.min(intensities))\n                        velocities[i] = (self.momentum * velocities[i] + attraction + random_step) * scaling_factor\n                        \n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive velocity scaling to enhance exploration and convergence.", "configspace": "", "generation": 5, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "38b45d04-131e-440d-adba-f7e3be8b510b", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "8f0c4079-2e7c-43be-8f80-ba6954a665ea", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n            # Dynamically adjust gamma to enhance exploration\n            self.gamma = 1 + 0.1 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhancing exploration by adjusting gamma dynamically based on evaluations.", "configspace": "", "generation": 5, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "38b45d04-131e-440d-adba-f7e3be8b510b", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "bb4982d8-186c-4d70-a54e-9c00acf3f7ec", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n            # Adaptive adjustment of gamma\n            self.gamma = 1 - 0.5 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive gamma adjustment based on evaluations to improve exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "38b45d04-131e-440d-adba-f7e3be8b510b", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "1a3c2812-7e1f-49ee-914e-a72ebcfbd506", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        self.gamma = 1 + 0.5 * (evaluations / self.budget)  # Adaptive gamma adjustment\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive gamma adjustment based on iteration count to enhance exploration.", "configspace": "", "generation": 5, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "38b45d04-131e-440d-adba-f7e3be8b510b", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "45b00c6a-76d9-465c-bc17-94f253df0dbd", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Refine exploration by slightly enhancing the randomization step scaling factor for improved performance.", "configspace": "", "generation": 6, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "afdbb5b2-2081-4e4e-9ce0-b106be9a4d35", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "27a16d9b-b44f-4c0d-82fb-472ba414777e", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.05 * (1 - evaluations / self.budget)  # Adjust momentum based on progress\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Improved exploration through dynamic adaptation of the momentum coefficient based on search progress.", "configspace": "", "generation": 6, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "afdbb5b2-2081-4e4e-9ce0-b106be9a4d35", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "44539d51-8f81-4ff9-b844-e6802c3e57a5", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + (0.05 * (intensities[best_idx] - new_intensity))  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhanced exploration by dynamically adjusting the light absorption coefficient and leveraging adaptive alpha, now with a momentum adjustment based on best firefly improvement.  ", "configspace": "", "generation": 6, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "afdbb5b2-2081-4e4e-9ce0-b106be9a4d35", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "db4d870d-c72c-4dcf-9bdf-8a404207d7e9", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                    # Dynamically adjust gamma for exploration/exploitation balance\n                    self.gamma = 0.3 + 0.2 * (evaluations / self.budget) \n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance firefly adaptation and exploration by introducing dynamic gamma adjustment based on performance.", "configspace": "", "generation": 6, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "afdbb5b2-2081-4e4e-9ce0-b106be9a4d35", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "78665638-27c1-43e7-abf6-9e71a423068b", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n            # Adjust gamma based on evaluations\n            self.gamma = 0.5 * (1 - evaluations / self.budget) + 0.05 * (evaluations / self.budget)\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive gamma adjustment based on current evaluations to balance exploration and exploitation. ", "configspace": "", "generation": 6, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "afdbb5b2-2081-4e4e-9ce0-b106be9a4d35", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "34ec5357-1fdf-49c6-8d17-295b6d39f09e", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance convergence by dynamically adjusting parameters for improved balance between exploration and exploitation.", "configspace": "", "generation": 7, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45b00c6a-76d9-465c-bc17-94f253df0dbd", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "e3d09e3c-7786-44f1-953a-51fd6d256968", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.9725 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce small adaptive increments to the randomization step for finer local search.", "configspace": "", "generation": 7, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45b00c6a-76d9-465c-bc17-94f253df0dbd", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "f4b4163d-d74e-4d86-9588-c10549291a88", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.99 + 0.01 * (evaluations / self.budget)  # Dynamically adjust gamma\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance convergence by dynamically adjusting the light absorption coefficient based on evaluation progress.", "configspace": "", "generation": 7, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45b00c6a-76d9-465c-bc17-94f253df0dbd", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "3d178ba6-a78b-425b-a9c2-b34aeebf6eeb", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)  # Adjusted randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Further adjust momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance firefly movement by dynamically adjusting the randomization step and momentum for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45b00c6a-76d9-465c-bc17-94f253df0dbd", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "cc43a35b-a49b-42d8-a3fe-98c4ad4a8174", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.02 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95  # Increase momentum for better convergence\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration by slightly increasing the randomization step scaling factor for improved performance.", "configspace": "", "generation": 7, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45b00c6a-76d9-465c-bc17-94f253df0dbd", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "7d40e011-2ad8-47ce-9cda-4ec94036f252", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.15 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive light absorption and momentum scaling to enhance exploration and convergence.", "configspace": "", "generation": 8, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "34ec5357-1fdf-49c6-8d17-295b6d39f09e", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "89072883-f91b-4ee4-8159-3ce17051f395", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.03 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Further refine momentum dynamics and randomization to enhance the adaptability of fireflies in diverse landscapes.", "configspace": "", "generation": 8, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "34ec5357-1fdf-49c6-8d17-295b6d39f09e", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "0a2e54d8-b1ae-41f5-a5dc-c3ee4d8694a7", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.05 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Improve search efficiency by modifying the dynamic adjustment of momentum based on performance.", "configspace": "", "generation": 8, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "34ec5357-1fdf-49c6-8d17-295b6d39f09e", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "b39d776f-1913-401f-b6ed-ebafb07b69dd", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Increase momentum dynamically\n                    self.gamma = 0.5 + 0.1 * (1 - new_intensity)  # Adjust gamma dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive light absorption to enhance exploration capabilities dynamically.", "configspace": "", "generation": 8, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "34ec5357-1fdf-49c6-8d17-295b6d39f09e", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "e225fc56-2b85-4efd-8d72-861db46d909c", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.7  # Adjusted momentum coefficient for improved exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance convergence by optimizing the momentum initialization for improved global search capabilities.", "configspace": "", "generation": 8, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "34ec5357-1fdf-49c6-8d17-295b6d39f09e", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "a4168cc0-79c4-437c-bac4-cf7bf51242c2", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Slightly refine momentum dynamics in AdaptiveMomentumFirefly for enhanced convergence speed.", "configspace": "", "generation": 9, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7d40e011-2ad8-47ce-9cda-4ec94036f252", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "942b8bcf-abca-4ac8-a5db-d6f2d666088a", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        # Changed below line to include dynamic gamma scaling\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance ** (2 * evaluations / self.budget))  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n\n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.15 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Apply dynamic light absorption scaling to improve adaptive attractiveness of fireflies.", "configspace": "", "generation": 9, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7d40e011-2ad8-47ce-9cda-4ec94036f252", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "3b914c51-9c54-4261-bad6-1c2a9cd397af", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        mutation = np.random.uniform(-0.05, 0.05, self.dim)  # Differential mutation step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step + mutation\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.15 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce differential mutation and enhance dynamic adaptability for exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7d40e011-2ad8-47ce-9cda-4ec94036f252", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "d78ce6f5-76a7-4889-afa4-e47306990c0b", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies more diversely across the search space\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.1 * self.gamma * distance**2)  # Slightly reduce gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.15 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration by diversifying initial firefly positions and optimizing attraction strength.", "configspace": "", "generation": 9, "fitness": 0.8012879509865511, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.019. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "7d40e011-2ad8-47ce-9cda-4ec94036f252", "metadata": {"aucs": [0.7750490496612972, 0.8144074016491782, 0.8144074016491782], "final_y": [0.16715539111735223, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "6c8856e2-4981-4aae-a50c-c0919d3e9cec", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        # Dynamic gamma adjustment\n                        self.gamma = 0.5 + 0.5 * (np.std(intensities) / np.mean(intensities))\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.15 * (1 - new_intensity)  # Increase momentum dynamically\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce dynamic light absorption scaling based on intensity variance to balance exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7d40e011-2ad8-47ce-9cda-4ec94036f252", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "39350299-ad20-44df-a0cc-af8c8d7e247c", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive gamma scaling and enhanced boundary reflection for improved exploration.", "configspace": "", "generation": 10, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a4168cc0-79c4-437c-bac4-cf7bf51242c2", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "6db1771d-fdea-41d7-9797-c7de2ffd28e8", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.02 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Fine-tune the randomization step to improve exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a4168cc0-79c4-437c-bac4-cf7bf51242c2", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "f48dd3d1-5119-454a-801c-d6a909b684c9", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity) + 0.05 * (1 - evaluations/self.budget)  # Adjust momentum update\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Improve AdaptiveMomentumFirefly by enhancing the momentum update strategy for better exploration and convergence.  ", "configspace": "", "generation": 10, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a4168cc0-79c4-437c-bac4-cf7bf51242c2", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "d09d579a-62fa-47b5-ae03-2c7b25ebb506", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.4  # Light absorption coefficient, slightly reduced for better exploration\n        self.beta_min = 0.3  # Slightly increased minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.02 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Optimize convergence by adjusting attraction and randomization dynamics in AdaptiveMomentumFirefly.", "configspace": "", "generation": 10, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a4168cc0-79c4-437c-bac4-cf7bf51242c2", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "752a88f6-7ccd-44da-8fd6-844dac9a31e0", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-1.2 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.05 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance AdaptiveMomentumFirefly by adjusting momentum dynamics based on the best firefly's intensity.", "configspace": "", "generation": 10, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a4168cc0-79c4-437c-bac4-cf7bf51242c2", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "a84be30b-118a-4d14-9b07-9495eddd1dbf", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Implement adaptive beta scaling to dynamically adjust attractiveness for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "39350299-ad20-44df-a0cc-af8c8d7e247c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "8ade3878-dd11-4c6f-80ce-9acf88a7c315", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2) + 0.05 * (1 - evaluations / self.budget)  # Adjust gamma and introduce adaptive beta\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive beta scaling for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "39350299-ad20-44df-a0cc-af8c8d7e247c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "6e6375a5-48e9-41b5-9c30-4048988b9a88", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        # Dynamically adjust gamma based on progress within the budget\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * (self.gamma + 0.5 * evaluations/self.budget) * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance convergence by dynamically adjusting the gamma parameter based on function evaluation progress.", "configspace": "", "generation": 11, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "39350299-ad20-44df-a0cc-af8c8d7e247c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "d4d12ad8-3fb7-48e1-b6df-f499c26ac8fa", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.05 * np.sqrt(1 - new_intensity)  # Streamlined momentum adaptation\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95 + 0.05 * (evaluations / self.budget)  # Refine dynamic scaling\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce dynamic scaling of the randomization parameter and streamline momentum adaptation for enhanced convergence.", "configspace": "", "generation": 11, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "39350299-ad20-44df-a0cc-af8c8d7e247c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "71a2e2ec-247d-4b28-84d0-5d0b4cb79a97", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2)  # Adjust gamma\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity) + 0.05 * (evaluations / self.budget)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance convergence by dynamically adapting the momentum based on iteration progress.", "configspace": "", "generation": 11, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "39350299-ad20-44df-a0cc-af8c8d7e247c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "36048885-3428-4b55-abcd-6d7a1cc41b1c", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive step size and dynamic light absorption scaling to enhance exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a84be30b-118a-4d14-9b07-9495eddd1dbf", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "aeafd0fa-b535-442e-a6da-db9d7d48a136", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.05 * (np.random.rand(self.dim) - 0.5)  # Slightly increase randomization factor\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration by slightly modifying the randomization step to assist in escaping local optima.", "configspace": "", "generation": 12, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a84be30b-118a-4d14-9b07-9495eddd1dbf", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "230edb70-a148-46ee-9665-26811ae15abc", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])**0.9  # Refined distance calculation\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Improved convergence by optimizing the attractiveness function with a refined distance calculation.", "configspace": "", "generation": 12, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a84be30b-118a-4d14-9b07-9495eddd1dbf", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "ca87929e-0363-467b-8c54-a289fd3845cc", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocity_scaling = max(0.1, abs(intensities[j] - intensities[i]))  # New velocity scaling\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        velocities[i] *= velocity_scaling  # Apply adaptive velocity scaling\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive velocity scaling based on intensity differences to enhance convergence dynamics.", "configspace": "", "generation": 12, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a84be30b-118a-4d14-9b07-9495eddd1dbf", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "7c32675d-63ef-4ff7-831b-bd7c6a416c42", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, size=(self.budget, self.dim))  # Initialize velocities for exploration\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * 1.01 * (np.random.rand(self.dim) - 0.5)  # Enhanced randomization step\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Improve firefly velocities initialization for enhanced early exploration.", "configspace": "", "generation": 12, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a84be30b-118a-4d14-9b07-9495eddd1dbf", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "6d11e178-98e6-46de-aff1-f2abe710f0d5", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance attraction dynamics with a dynamic momentum coefficient based on performance variation.", "configspace": "", "generation": 13, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "36048885-3428-4b55-abcd-6d7a1cc41b1c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "1d872188-24fc-4a3e-85f1-4e358ad1e2a7", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = max(0.85, 0.95 + 0.1 * (1 - new_intensity) - 0.05 * (evaluations / self.budget))  # Introduce dynamic decay\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce a dynamic decay factor for momentum coefficient to balance exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "36048885-3428-4b55-abcd-6d7a1cc41b1c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "16480f09-5ce9-4a07-a3d4-1eb54140e68b", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1 + 0.1 * (evaluations/self.budget)) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size with dynamic factor\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration by introducing a dynamic factor in random step size scaling.", "configspace": "", "generation": 13, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "36048885-3428-4b55-abcd-6d7a1cc41b1c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "a729ab1c-05fc-4a0c-8504-4bc2b7982c57", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce adaptive momentum decay to enhance convergence towards optimal solutions.", "configspace": "", "generation": 13, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "36048885-3428-4b55-abcd-6d7a1cc41b1c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "bef36cfd-a441-4ea8-bc18-b7270f9ebc7f", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + (1 - self.beta_min) / (1 + distance)) * np.exp(-self.gamma * distance**2 * (1 - evaluations/self.budget))\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (1 - new_intensity)  # Slightly refine momentum dynamics\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration and convergence with adaptive beta scaling and dynamic parameter adjustments.", "configspace": "", "generation": 13, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "36048885-3428-4b55-abcd-6d7a1cc41b1c", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "bfaa2e09-d204-4c2c-bb26-bc8469c9ab76", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + 0.2 * (evaluations / self.budget) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introducing a dynamic beta scaling factor to enhance exploitation in the AdaptiveMomentumFirefly algorithm.", "configspace": "", "generation": 14, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6d11e178-98e6-46de-aff1-f2abe710f0d5", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "f9f3f014-2141-439a-b854-39d7e672bca7", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance firefly algorithm by dynamically adjusting both momentum and exploration based on proximity to the best solution.", "configspace": "", "generation": 14, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6d11e178-98e6-46de-aff1-f2abe710f0d5", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "dc834a16-ab35-44f5-b278-30f49e8d4011", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            temperature = (1 - evaluations / self.budget)  # New temperature-based term\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * temperature  # Slightly adapt alpha faster\n            self.gamma *= 0.98 * temperature  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce temperature-based dynamic exploration by modifying alpha and gamma to enhance search adaptability.", "configspace": "", "generation": 14, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6d11e178-98e6-46de-aff1-f2abe710f0d5", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "4ff15f71-92c5-47d9-919f-94f32ea8e3f2", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + distance * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = (0.95 + 0.1 * (evaluations / self.budget)) * 0.98  # Introduce decay factor in momentum update\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce a decay factor to the momentum update for enhanced convergence speed.", "configspace": "", "generation": 14, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6d11e178-98e6-46de-aff1-f2abe710f0d5", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "500fd8bf-2bb7-4b06-a0c8-109c5cea02d6", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + np.exp(-distance**2) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Improved beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5) * (1 - evaluations / self.budget)  # Enhanced dynamic step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance firefly movement dynamics by introducing a dynamic step size factor and improving the beta scaling for better convergence and exploration.", "configspace": "", "generation": 14, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6d11e178-98e6-46de-aff1-f2abe710f0d5", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "045a17ad-dec0-4363-ad63-1b7c25786ecc", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + 0.2 * (evaluations / self.budget) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.99  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce dynamic attraction scaling by modifying the gamma decrease rate in AdaptiveMomentumFirefly for enhanced optimization.", "configspace": "", "generation": 15, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bfaa2e09-d204-4c2c-bb26-bc8469c9ab76", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "8510fd9e-c682-4e20-88e5-fd8d2483c30d", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb and ub uniformly\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + 0.2 * (evaluations / self.budget) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.95, 1.05) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance exploration and exploitation by refining dynamic parameters and initialization strategy in AdaptiveMomentumFirefly.", "configspace": "", "generation": 15, "fitness": 0.8012879509865511, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.019. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "bfaa2e09-d204-4c2c-bb26-bc8469c9ab76", "metadata": {"aucs": [0.7750490496612972, 0.8144074016491782, 0.8144074016491782], "final_y": [0.16715539111735223, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "945c7144-bd3d-4476-ac1c-d720c35f2ffe", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + 0.1 * (evaluations / self.budget) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Modify the adaptive beta scaling factor for improved exploration-exploitation balance in AdaptiveMomentumFirefly.", "configspace": "", "generation": 15, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bfaa2e09-d204-4c2c-bb26-bc8469c9ab76", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "0682e1f0-1c57-48f5-9a33-8c51a92e20b0", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + 0.2 * (evaluations / self.budget) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.85, 1.15) * (np.random.rand(self.dim) - 0.5)  # Dynamic random step size range\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.1 * (evaluations / self.budget)  # Adjust momentum based on budget utilization\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98  # Dynamically scale gamma down\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Enhance AdaptiveMomentumFirefly by dynamically adjusting the random step size range for improved exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bfaa2e09-d204-4c2c-bb26-bc8469c9ab76", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
{"id": "4cebbb92-088b-41e9-a000-b32d2f6f78b5", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 0.5  # Light absorption coefficient, adjusted for better exploration\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies closer to lb\n        fireflies = np.random.uniform(lb, (lb + ub) / 2, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = (self.beta_min + 0.2 * (evaluations / self.budget) * (1 - self.beta_min)) * np.exp(-0.8 * self.gamma * distance**2 * (1 - evaluations/self.budget))  # Implement adaptive beta scaling\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * np.random.uniform(0.9, 1.1) * (np.random.rand(self.dim) - 0.5)  # Adaptive step size\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n                        fireflies[i] = np.where(fireflies[i] < lb, lb + (lb - fireflies[i]), fireflies[i])  # Reflection\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n                    self.momentum = 0.95 + 0.05 * np.sqrt(evaluations / self.budget)  # Non-linear momentum scaling\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.97 + 0.03 * (evaluations / self.budget)  # Slightly adapt alpha faster\n            self.gamma *= 0.98 * (1 - evaluations / self.budget)  # Dynamically scale gamma down adaptively\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "Introduce an adaptive light absorption coefficient and a non-linear momentum scaling to refine exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.8144074016491784, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.000. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bfaa2e09-d204-4c2c-bb26-bc8469c9ab76", "metadata": {"aucs": [0.8144074016491782, 0.8144074016491782, 0.8144074016491782], "final_y": [0.142322702609607, 0.142322702609607, 0.142322702609607]}, "mutation_prompt": null}
