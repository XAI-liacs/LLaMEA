{"id": "f360fc24-5cab-4079-b3cf-b1533748ec0e", "solution": "import numpy as np\n\nclass AdaptiveMomentumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = 0.5  # Initial randomization parameter\n        self.gamma = 1    # Light absorption coefficient\n        self.beta_min = 0.2  # Minimum attractiveness\n        self.momentum = 0.9  # Momentum coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize fireflies and their velocities\n        fireflies = np.random.uniform(lb, ub, size=(self.budget, self.dim))\n        velocities = np.zeros_like(fireflies)\n        intensities = np.array([func(ff) for ff in fireflies])\n\n        best_idx = np.argmin(intensities)\n        best_firefly = fireflies[best_idx]\n\n        evaluations = len(fireflies)\n\n        while evaluations < self.budget:\n            for i in range(len(fireflies)):\n                for j in range(len(fireflies)):\n                    if intensities[j] < intensities[i]:\n                        distance = np.linalg.norm(fireflies[i] - fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * distance**2)\n\n                        attraction = beta * (fireflies[j] - fireflies[i])\n                        random_step = self.alpha * (np.random.rand(self.dim) - 0.5)\n                        velocities[i] = self.momentum * velocities[i] + attraction + random_step\n                        fireflies[i] += velocities[i]\n                        \n                        # Ensure the fireflies remain within bounds\n                        fireflies[i] = np.clip(fireflies[i], lb, ub)\n\n                # Evaluate the new position of firefly i\n                new_intensity = func(fireflies[i])\n                evaluations += 1\n\n                # Update the intensity if improvement is found\n                if new_intensity < intensities[i]:\n                    intensities[i] = new_intensity\n\n                # Update the global best firefly\n                if new_intensity < intensities[best_idx]:\n                    best_idx = i\n                    best_firefly = fireflies[i]\n\n                # Break if we reach the budget\n                if evaluations >= self.budget:\n                    break\n\n            # Gradually decrease alpha\n            self.alpha *= 0.95\n\n        return best_firefly", "name": "AdaptiveMomentumFirefly", "description": "The \"Adaptive Momentum Firefly Algorithm\" enhances traditional metaheuristics by combining adaptive step sizes with momentum-based movement to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.7750490496612971, "feedback": "The algorithm AdaptiveMomentumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7750490496612972, 0.7750490496612972, 0.7750490496612972], "final_y": [0.16715539111735223, 0.16715539111735223, 0.16715539111735223]}, "mutation_prompt": null}
