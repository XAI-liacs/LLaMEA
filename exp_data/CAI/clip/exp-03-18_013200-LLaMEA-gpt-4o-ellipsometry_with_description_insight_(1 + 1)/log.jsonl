{"id": "102a7a60-47a2-49f1-85ef-d781c233662d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adaptive Bound Constrained Local Optimization (ABC-LO): Combines local optimization with dynamic bound adjustment to efficiently explore and exploit smooth, low-dimensional parameter spaces within a specified evaluation budget.", "configspace": "", "generation": 0, "fitness": 0.7999203223469801, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8278020368291251, 0.7770225401476881, 0.7949363900641272], "final_y": [4.216763331239896e-08, 1.6861569037070346e-07, 1.515575311714981e-07]}, "mutation_prompt": null}
{"id": "333038c0-5a03-4d85-8397-e67c15025fba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        # Modify to include a slight perturbation for better exploration\n        perturbed_guess = initial_guess + np.random.normal(0, 0.01, self.dim)\n        result = minimize(func, perturbed_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n\n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced Adaptive Bound Constrained Local Optimization (EABC-LO): Incorporates adaptive precision within objective function evaluations to improve exploration efficiency while maintaining dynamic bound adjustments.", "configspace": "", "generation": 1, "fitness": 0.7753945208475764, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "102a7a60-47a2-49f1-85ef-d781c233662d", "metadata": {"aucs": [0.7702905363729122, 0.7835847365462136, 0.7723082896236034], "final_y": [2.151519532927073e-07, 1.8063158982387702e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO by refining the initial guess through weighted sampling, targeting improved initial convergence.", "configspace": "", "generation": 2, "fitness": 0.8243044502924501, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "102a7a60-47a2-49f1-85ef-d781c233662d", "metadata": {"aucs": [0.8061324843138008, 0.8463618252179601, 0.8204190413455895], "final_y": [7.456259099084952e-08, 2.1725560015244248e-08, 7.098610888306131e-08]}, "mutation_prompt": null}
{"id": "c0f734f2-b9a7-4af0-b804-75ed4d1e175c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  # Adaptive weights line modified\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adaptive ABC-LO improves early exploration using adaptive weights, enhancing initial guesses to boost convergence.", "configspace": "", "generation": 3, "fitness": 0.8004733508909038, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8331889056951769, 0.7959060083018757, 0.7723251386756587], "final_y": [5.0293227139295933e-08, 1.913873891896187e-08, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "aa594594-18f4-4b9d-b4da-8ef4a2135839", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.5, 1.5, self.dim)  # Changed weights range for dynamic sampling\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced convergence by using a dynamic weighting strategy for initial guess sampling.", "configspace": "", "generation": 4, "fitness": 0.8029935642991602, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8055830019555521, 0.8055830019555521, 0.7978146889863766], "final_y": [1.016876831592731e-07, 1.016876831592731e-07, 1.2750523603677464e-07]}, "mutation_prompt": null}
{"id": "77e8ffe4-ca5a-4725-953f-906a8e63859e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Adjust initial guess by scaling random shifts\n        initial_guess = initial_guess + 0.1 * (np.random.rand(self.dim) - 0.5) * (func.bounds.ub - func.bounds.lb)\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adjusts initial guess by scaling random shifts, enhancing exploitation around the center.", "configspace": "", "generation": 5, "fitness": 0.7943992604927526, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.034. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8425362221337733, 0.7683294875119265, 0.7723320718325577], "final_y": [2.0991439337297076e-08, 2.4537550999155837e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "e50fba7c-5bc8-412c-aa8d-8f956b25d6a6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.5, 1.5, self.dim)  # Modified weighted sampling line\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Fine-tuned ABC_LO by enhancing the initial guess for a more balanced exploration-exploitation trade-off.", "configspace": "", "generation": 6, "fitness": 0.8029935642991602, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8055830019555521, 0.8055830019555521, 0.7978146889863766], "final_y": [1.016876831592731e-07, 1.016876831592731e-07, 1.2750523603677464e-07]}, "mutation_prompt": null}
{"id": "bb975adb-1d41-4dce-980e-601e98f5d385", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Dynamically adjust weights based on iteration\n        weights = np.linspace(0.5, 1.5, self.dim)  # Adjusted weights\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds and dynamic weights\n        refined_weights = np.linspace(0.8, 1.2, self.dim)  # Adjusted weights for refinement\n        refined_result = minimize(func, result.x * refined_weights, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Improved convergence by dynamically adjusting weights during initial sampling and solution refinement.", "configspace": "", "generation": 7, "fitness": 0.8107616976368429, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8076273466451813, 0.8076273466451813, 0.8170303996201662], "final_y": [6.599098708473137e-08, 6.599098708473137e-08, 7.447205953453374e-08]}, "mutation_prompt": null}
{"id": "e0629b0c-0704-4e8b-a826-05f4dc340a9a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Logarithmic sampling for initial guesses\n        weights = np.logspace(-2, 0, self.dim)  # Logarithmic sampling line modified\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.4  # Width adjustment line modified\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO by incorporating logarithmic sampling for initial guesses and adaptive bounding for refined solutions.", "configspace": "", "generation": 8, "fitness": 0.7851388416803237, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8219968503600739, 0.7610853106595015, 0.7723343640213958], "final_y": [6.221091513325133e-08, 2.1586543418690628e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
