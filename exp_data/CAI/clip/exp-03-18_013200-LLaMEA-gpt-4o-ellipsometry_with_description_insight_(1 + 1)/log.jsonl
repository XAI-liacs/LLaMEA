{"id": "102a7a60-47a2-49f1-85ef-d781c233662d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adaptive Bound Constrained Local Optimization (ABC-LO): Combines local optimization with dynamic bound adjustment to efficiently explore and exploit smooth, low-dimensional parameter spaces within a specified evaluation budget.", "configspace": "", "generation": 0, "fitness": 0.7999203223469801, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8278020368291251, 0.7770225401476881, 0.7949363900641272], "final_y": [4.216763331239896e-08, 1.6861569037070346e-07, 1.515575311714981e-07]}, "mutation_prompt": null}
{"id": "333038c0-5a03-4d85-8397-e67c15025fba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        # Modify to include a slight perturbation for better exploration\n        perturbed_guess = initial_guess + np.random.normal(0, 0.01, self.dim)\n        result = minimize(func, perturbed_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n\n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced Adaptive Bound Constrained Local Optimization (EABC-LO): Incorporates adaptive precision within objective function evaluations to improve exploration efficiency while maintaining dynamic bound adjustments.", "configspace": "", "generation": 1, "fitness": 0.7753945208475764, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "102a7a60-47a2-49f1-85ef-d781c233662d", "metadata": {"aucs": [0.7702905363729122, 0.7835847365462136, 0.7723082896236034], "final_y": [2.151519532927073e-07, 1.8063158982387702e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO by refining the initial guess through weighted sampling, targeting improved initial convergence.", "configspace": "", "generation": 2, "fitness": 0.8243044502924501, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "102a7a60-47a2-49f1-85ef-d781c233662d", "metadata": {"aucs": [0.8061324843138008, 0.8463618252179601, 0.8204190413455895], "final_y": [7.456259099084952e-08, 2.1725560015244248e-08, 7.098610888306131e-08]}, "mutation_prompt": null}
{"id": "c0f734f2-b9a7-4af0-b804-75ed4d1e175c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  # Adaptive weights line modified\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adaptive ABC-LO improves early exploration using adaptive weights, enhancing initial guesses to boost convergence.", "configspace": "", "generation": 3, "fitness": 0.8004733508909038, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8331889056951769, 0.7959060083018757, 0.7723251386756587], "final_y": [5.0293227139295933e-08, 1.913873891896187e-08, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "aa594594-18f4-4b9d-b4da-8ef4a2135839", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.5, 1.5, self.dim)  # Changed weights range for dynamic sampling\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced convergence by using a dynamic weighting strategy for initial guess sampling.", "configspace": "", "generation": 4, "fitness": 0.8029935642991602, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8055830019555521, 0.8055830019555521, 0.7978146889863766], "final_y": [1.016876831592731e-07, 1.016876831592731e-07, 1.2750523603677464e-07]}, "mutation_prompt": null}
{"id": "77e8ffe4-ca5a-4725-953f-906a8e63859e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Adjust initial guess by scaling random shifts\n        initial_guess = initial_guess + 0.1 * (np.random.rand(self.dim) - 0.5) * (func.bounds.ub - func.bounds.lb)\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adjusts initial guess by scaling random shifts, enhancing exploitation around the center.", "configspace": "", "generation": 5, "fitness": 0.7943992604927526, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.034. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8425362221337733, 0.7683294875119265, 0.7723320718325577], "final_y": [2.0991439337297076e-08, 2.4537550999155837e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "e50fba7c-5bc8-412c-aa8d-8f956b25d6a6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.5, 1.5, self.dim)  # Modified weighted sampling line\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Fine-tuned ABC_LO by enhancing the initial guess for a more balanced exploration-exploitation trade-off.", "configspace": "", "generation": 6, "fitness": 0.8029935642991602, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8055830019555521, 0.8055830019555521, 0.7978146889863766], "final_y": [1.016876831592731e-07, 1.016876831592731e-07, 1.2750523603677464e-07]}, "mutation_prompt": null}
{"id": "bb975adb-1d41-4dce-980e-601e98f5d385", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Dynamically adjust weights based on iteration\n        weights = np.linspace(0.5, 1.5, self.dim)  # Adjusted weights\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds and dynamic weights\n        refined_weights = np.linspace(0.8, 1.2, self.dim)  # Adjusted weights for refinement\n        refined_result = minimize(func, result.x * refined_weights, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Improved convergence by dynamically adjusting weights during initial sampling and solution refinement.", "configspace": "", "generation": 7, "fitness": 0.8107616976368429, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8076273466451813, 0.8076273466451813, 0.8170303996201662], "final_y": [6.599098708473137e-08, 6.599098708473137e-08, 7.447205953453374e-08]}, "mutation_prompt": null}
{"id": "e0629b0c-0704-4e8b-a826-05f4dc340a9a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Logarithmic sampling for initial guesses\n        weights = np.logspace(-2, 0, self.dim)  # Logarithmic sampling line modified\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.4  # Width adjustment line modified\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO by incorporating logarithmic sampling for initial guesses and adaptive bounding for refined solutions.", "configspace": "", "generation": 8, "fitness": 0.7851388416803237, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8219968503600739, 0.7610853106595015, 0.7723343640213958], "final_y": [6.221091513325133e-08, 2.1586543418690628e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "3294a7b3-4b23-48e5-a68e-32cc3c879bc0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.sin(np.linspace(0.1, np.pi/2, self.dim))  # Dynamic scaling using sine function\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "The method enhances exploration by dynamically adjusting initial guess scaling using a nonlinear function, improving solution diversity and convergence.", "configspace": "", "generation": 9, "fitness": 0.785419790266133, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8219825756340545, 0.7619424311429486, 0.7723343640213958], "final_y": [6.223862213060503e-08, 2.1041482151079439e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "f45a47a0-525f-48f9-9634-a6d8e2e0708a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  # Changed to random weights\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO by dynamically adjusting initial guess weights for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.8004733508909038, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8331889056951769, 0.7959060083018757, 0.7723251386756587], "final_y": [5.0293227139295933e-08, 1.913873891896187e-08, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "6752b3e1-d7cb-40d3-adc5-68d04c3acf79", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Dynamically adjust weights for initial solutions\n        weights = np.random.dirichlet(np.ones(self.dim))  # Changed line for dynamic weighting\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Improved convergence by dynamically adjusting weights during initial sampling for better exploitation of the search space.", "configspace": "", "generation": 11, "fitness": 0.8155334011339987, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8239700864925836, 0.8090480088343417, 0.8135821080750709], "final_y": [7.542900893708983e-08, 1.194169667671442e-07, 9.780832139282197e-08]}, "mutation_prompt": null}
{"id": "3969967a-65c5-4f06-883b-39f8b23b3fe6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions with random perturbation\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        initial_guess += np.random.uniform(-0.1, 0.1, self.dim)  # Added random perturbation\n\n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Improved ABC_LO by enhancing exploration through random perturbation of initial guess.", "configspace": "", "generation": 12, "fitness": 0.7871122770193568, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.7818299899799985, 0.7881553347705599, 0.7913515063075122], "final_y": [1.4182436181898755e-07, 1.1356875369680969e-07, 1.5960394336895366e-07]}, "mutation_prompt": null}
{"id": "5b107b1c-034f-41d6-bce8-1504feea351a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * (1.0 + weights/2)  # Modified weight adaptation\n\n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Introduced dynamic weight adaptation during initial sampling to enhance exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.8003401176412783, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8010747551273911, 0.8024451155253949, 0.797500482271049], "final_y": [9.022784292087368e-08, 6.132936412559322e-08, 1.4865110287634873e-07]}, "mutation_prompt": null}
{"id": "5dae6cb6-23cb-40e5-a195-2d214b29c96d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(1.0, 0.1, self.budget)[:self.dim]  # Dynamic weights line changed\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO by adjusting the weights dynamically based on the function evaluations, enabling faster convergence.", "configspace": "", "generation": 14, "fitness": 0.7653548984799192, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.765 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.7689737609493048, 0.7547833276548334, 0.7723076068356195], "final_y": [2.1188800400112252e-07, 3.759681464189879e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "5f836ca2-d113-4cd7-b267-c52de5764a0b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds, add momentum term\n        options = {'maxiter': self.budget, 'disp': False, 'momentum': 0.9}  # Momentum line added\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhance convergence by introducing momentum to the local optimization process in ABC_LO.", "configspace": "", "generation": 15, "fitness": 0.785419790266133, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8219825756340545, 0.7619424311429486, 0.7723343640213958], "final_y": [6.223862213060503e-08, 2.1041482151079439e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "d6ebf92a-8863-4c6f-95fa-d0c474235a69", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.5, 1.5, self.dim)  # Adaptive weighting line modified\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC-LO with adaptive weighting for initial guesses to boost early convergence.", "configspace": "", "generation": 16, "fitness": 0.7950699722321138, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.795 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.832441869471148, 0.7804741489353987, 0.7722938982897948], "final_y": [4.9815331353061804e-08, 1.644468850909714e-07, 1.0199974859655002e-07]}, "mutation_prompt": null}
{"id": "bf24b65c-0709-478e-a7b9-4c010a77dc1b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions with Gaussian noise\n        weights = np.linspace(0.1, 1.0, self.dim) \n        initial_guess = (np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights) + np.random.normal(0, 0.05, self.dim)  # Gaussian noise added\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced ABC_LO by increasing initial sample diversity through Gaussian noise perturbation.", "configspace": "", "generation": 17, "fitness": 0.8084950815430357, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.031. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.7864667696488883, 0.7872582089512818, 0.8517602660289374], "final_y": [1.1498424717101167e-07, 1.0342606841245724e-07, 3.364996407331798e-08]}, "mutation_prompt": null}
{"id": "2753d7ab-1c86-499e-a4d7-8dbe81133f36", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.linspace(0.1, 1.0, self.dim)  # Weighted sampling line added\n        step_sizes = np.random.uniform(0.05, 0.2, self.dim)  # Adaptive step size added\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights * step_sizes\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Improve convergence speed by incorporating adaptive step size in weighted sampling for initial guess refinement.", "configspace": "", "generation": 18, "fitness": 0.8106858991572211, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8106858991572211, 0.8106858991572211, 0.8106858991572211], "final_y": [1.016876831592731e-07, 1.016876831592731e-07, 1.016876831592731e-07]}, "mutation_prompt": null}
{"id": "a5e15d39-3a55-494a-a05a-a4a5fa72a406", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  # Dynamic weights replaced with random sampling\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced boundary exploration by dynamically adjusting weights for initial guesses, ensuring diverse starting points.", "configspace": "", "generation": 19, "fitness": 0.8369494574397066, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.038. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3477701b-0453-4840-b5f1-97a5f4ef64b9", "metadata": {"aucs": [0.8092379782621932, 0.8909244948997056, 0.8106858991572211], "final_y": [1.1503737854566485e-07, 1.2424164029603785e-08, 1.016876831592731e-07]}, "mutation_prompt": null}
{"id": "cfb01033-1a81-41f1-a741-3c88d109a6e1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  # Dynamic weights replaced with random sampling\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * np.var(weights)  # Changed line: Apply variance scaling\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, result.x, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Adaptive sampling for initial guesses by integrating variance scaling to improve convergence speed.", "configspace": "", "generation": 20, "fitness": 0.8106858991572211, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a5e15d39-3a55-494a-a05a-a4a5fa72a406", "metadata": {"aucs": [0.8106858991572211, 0.8106858991572211, 0.8106858991572211], "final_y": [1.016876831592731e-07, 1.016876831592731e-07, 1.016876831592731e-07]}, "mutation_prompt": null}
{"id": "1a51b72d-dc4f-487c-9dbc-87323a240968", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  \n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine initial guess by averaging with previous result for convergence improvement\n        refined_initial_guess = (result.x + initial_guess) / 2\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, refined_initial_guess, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Improved convergence by averaging weights with previous iterations for better initial guesses.", "configspace": "", "generation": 21, "fitness": 0.8551416331042464, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a5e15d39-3a55-494a-a05a-a4a5fa72a406", "metadata": {"aucs": [0.8638145052558126, 0.8909244948997048, 0.8106858991572217], "final_y": [1.6553653443523034e-08, 1.2424164029603785e-08, 1.016876831592731e-07]}, "mutation_prompt": null}
{"id": "0c9f93aa-d597-4574-8ea1-23093d203240", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  \n        variance = np.var(func.bounds.ub - func.bounds.lb)  # Incorporate variance for weighting\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights * variance\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine initial guess by averaging with previous result for convergence improvement\n        refined_initial_guess = (result.x + initial_guess) / 2\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, refined_initial_guess, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced initial guess weighting by incorporating variance for robust convergence.", "configspace": "", "generation": 22, "fitness": 0.0, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.000 with standard deviation 0.000. And the mean value of best solutions found was 41.453 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1a51b72d-dc4f-487c-9dbc-87323a240968", "metadata": {"aucs": [0.0, 0.0, 0.0], "final_y": [41.45268943671754, 41.45268943671754, 41.45268943671754]}, "mutation_prompt": null}
{"id": "66d65f86-17c2-4a25-83f2-8ae6ebd26cc6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  \n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine initial guess by averaging with previous result for convergence improvement\n        refined_initial_guess = (result.x + initial_guess + np.random.uniform(-0.05, 0.05, self.dim)) / 2\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, refined_initial_guess, method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced initial guess by incorporating random perturbations for better exploration.", "configspace": "", "generation": 23, "fitness": 0.8557685029345633, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1a51b72d-dc4f-487c-9dbc-87323a240968", "metadata": {"aucs": [0.8512375808227844, 0.890924494899705, 0.8251434330812005], "final_y": [2.4077237604432597e-08, 1.2424164029603785e-08, 5.8704445242468025e-08]}, "mutation_prompt": null}
{"id": "c4916135-528b-49f6-9038-b619b952cce9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABC_LO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Initialize bounds from the function\n        bounds = [(lb, ub) for lb, ub in zip(func.bounds.lb, func.bounds.ub)]\n        \n        # Uniformly sample initial solutions\n        weights = np.random.uniform(0.1, 1.0, self.dim)  \n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) * weights\n        \n        # Local optimization using BFGS within the bounds\n        options = {'maxiter': self.budget, 'disp': False}\n        result = minimize(func, initial_guess, method='L-BFGS-B', bounds=bounds, options=options)\n        \n        # Adjust bounds based on the optimization result\n        new_bounds = []\n        for i in range(self.dim):\n            center = result.x[i]\n            width = (bounds[i][1] - bounds[i][0]) * 0.5\n            new_bounds.append((max(center - width, func.bounds.lb[i]), min(center + width, func.bounds.ub[i])))\n        \n        # Refine initial guess by averaging with previous result for convergence improvement\n        refined_initial_guess = (result.x + initial_guess + np.random.uniform(-0.05, 0.05, self.dim)) / 2\n        \n        # Refine solution with adjusted bounds\n        refined_result = minimize(func, refined_initial_guess * np.random.uniform(0.95, 1.05, self.dim), method='L-BFGS-B', bounds=new_bounds, options=options)\n        \n        # Return the best found solution\n        return refined_result.x, refined_result.fun", "name": "ABC_LO", "description": "Enhanced local search by incorporating adaptive step sizes for improved exploration.", "configspace": "", "generation": 24, "fitness": 0.7439129618521315, "feedback": "The algorithm ABC_LO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.744 with standard deviation 0.036. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "66d65f86-17c2-4a25-83f2-8ae6ebd26cc6", "metadata": {"aucs": [0.7904091879396464, 0.7019285615807784, 0.7394011360359697], "final_y": [1.9004328313475532e-07, 1.5815756868941343e-07, 1.8325310479272698e-07]}, "mutation_prompt": null}
