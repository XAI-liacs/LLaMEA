{"id": "439c9377-df89-4168-8cea-87f6d86656f9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm dynamically balances exploration and exploitation using historical performance data.", "configspace": "", "generation": 0, "fitness": 0.8296011598194024, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.011. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8165479159153856, 0.8426764096857092, 0.8295791538571126], "final_y": [0.14047322738022483, 0.1348446425819445, 0.12306739078754148]}, "mutation_prompt": null}
{"id": "4e82297f-6846-4229-ab44-515a42ee7a3f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and mutation factor\n            self.w = 0.4 + (0.9 - 0.4) * (self.budget - evaluations) / self.budget\n            self.mutation_factor = 0.6 + (0.9 - 0.6) * (self.budget - evaluations) / self.budget\n\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive inertia weight and mutation factor in HybridPSODE to improve convergence.", "configspace": "", "generation": 1, "fitness": 0.8204927186233703, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.010. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "439c9377-df89-4168-8cea-87f6d86656f9", "metadata": {"aucs": [0.8161972093939537, 0.834286945693061, 0.8109940007830957], "final_y": [0.13985143663500976, 0.13827578339487023, 0.14123013036528165]}, "mutation_prompt": null}
{"id": "49fa5f5e-9280-465a-b4c6-ba449856e852", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduced adaptive inertia weight in HybridPSODE to better balance exploration and exploitation during optimization.", "configspace": "", "generation": 1, "fitness": 0.8459454737697875, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.028. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "439c9377-df89-4168-8cea-87f6d86656f9", "metadata": {"aucs": [0.8147910049683725, 0.8833634436704657, 0.8396819726705242], "final_y": [0.1469205797798605, 0.12444371900600937, 0.14211764069761268]}, "mutation_prompt": null}
{"id": "5eb56b2e-b1f8-49a2-a10b-8054bb9503fb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.c1 = 2.5 - 1.5 * (evaluations / self.budget)  # Adaptive c1\n            self.c2 = 0.5 + 1.5 * (evaluations / self.budget)  # Adaptive c2\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients for improved exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.8423915143573509, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.013. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "439c9377-df89-4168-8cea-87f6d86656f9", "metadata": {"aucs": [0.8557672395718754, 0.8466826433978343, 0.824724660102343], "final_y": [0.12046303582028706, 0.12843615269634134, 0.14248825644052487]}, "mutation_prompt": null}
{"id": "3b87f168-c1e9-42e5-a1d9-146e8e136871", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # initial inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n        previous_global_best_fitness = global_best_fitness\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Dynamic adjustment of inertia weight\n            if global_best_fitness < previous_global_best_fitness:\n                self.w *= 0.99  # slightly decrease inertia\n            previous_global_best_fitness = global_best_fitness\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "An enhanced Hybrid PSODE with dynamic inertia weight adjustment based on convergence rate to improve exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.8322444100944256, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.015. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "439c9377-df89-4168-8cea-87f6d86656f9", "metadata": {"aucs": [0.8187888641007235, 0.8535055124654534, 0.8244388537171001], "final_y": [0.1339358074447241, 0.13044640360707604, 0.13982743343585446]}, "mutation_prompt": null}
{"id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm with adaptive inertia weight to improve exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.8496238979762415, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.029. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "439c9377-df89-4168-8cea-87f6d86656f9", "metadata": {"aucs": [0.8848952478192069, 0.8140972212064089, 0.8498792249031084], "final_y": [0.12077737489991935, 0.1396850894086481, 0.13669109531427492]}, "mutation_prompt": null}
{"id": "d8b8aaea-7600-4cbc-9def-ac89c7b49844", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n        self.restart_threshold = int(0.1 * self.budget)  # Threshold for random restarts\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n        stagnant_evaluations = 0\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n                    stagnant_evaluations = 0\n                else:\n                    stagnant_evaluations += 1\n\n            if stagnant_evaluations > self.restart_threshold:\n                self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n                stagnant_evaluations = 0\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE using random restarts to improve exploration and avoid local minima.", "configspace": "", "generation": 2, "fitness": 0.8195926494950498, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.017. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8242528591695777, 0.837527450743754, 0.7969976385718179], "final_y": [0.13728853883521797, 0.13060107833864942, 0.14806286020534043]}, "mutation_prompt": null}
{"id": "0d87f477-fa0d-4cb1-9def-769a30db9a68", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n        self.neighborhood_size = max(1, self.population_size // 5)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n            # Dynamic population adaptation\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = max(15, self.population_size + np.random.randint(-self.neighborhood_size, self.neighborhood_size + 1))\n                self.particles = np.vstack((self.particles, np.random.uniform(lb, ub, (self.population_size - len(self.particles), self.dim))))\n                fitness = np.hstack((fitness, np.array([func(x) for x in self.particles[len(fitness):]])))\n                evaluations += self.population_size - len(fitness)\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic population adaptation and neighborhood best strategy for increased diversity and convergence.", "configspace": "", "generation": 2, "fitness": 0.8480998233700436, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.025. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8161428333892585, 0.8509683246347023, 0.8771883120861701], "final_y": [0.14558633757029726, 0.1340099579220554, 0.12481039810237948]}, "mutation_prompt": null}
{"id": "07e910e5-9565-4431-a3b6-ade3c922c977", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.5 + 0.5 * (1 - evaluations / self.budget)  # dynamic mutation factor\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Incorporate a dynamic mutation factor in the DE phase, evolving based on the search progress for enhanced diversification and convergence.", "configspace": "", "generation": 2, "fitness": 0.821342665216282, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.032. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8008854840520784, 0.8666885923954627, 0.7964539192013047], "final_y": [0.1368732655065239, 0.1316382126870349, 0.1434249544340428]}, "mutation_prompt": null}
{"id": "7029e3a2-a5b5-4cd8-a5ea-6d598aa8da64", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.8 + 0.2 * (global_best_fitness / (local_best_fitness[i]+1e-9))  # adaptive mutation factor\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm with adaptive inertia weight and adaptive mutation factor to improve exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8144540716123045, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.008. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8225350990910696, 0.816677675318655, 0.8041494404271892], "final_y": [0.14145890645700332, 0.13964404731399993, 0.14623822150624166]}, "mutation_prompt": null}
{"id": "63aec6c2-b633-43cd-a7ca-9f976ae5c260", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * (1 - evaluations / self.budget))  # dynamic recombination rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Hybrid PSO and DE algorithm with adaptive inertia and dynamic recombination rate for improved exploration-exploitation.", "configspace": "", "generation": 2, "fitness": 0.8295796171170627, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.015. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8389522202590304, 0.8418031270547656, 0.8079835040373922], "final_y": [0.12897704514240227, 0.13290565793013365, 0.14071377407918917]}, "mutation_prompt": null}
{"id": "d59a5918-f910-4ad5-93a0-f819778f3dde", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.initial_population_size = self.population_size\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with dynamic adjustment\n            if evaluations > 0.5 * self.budget:\n                self.population_size = int(self.initial_population_size * 0.8)  # reduce population size\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "An enhanced Hybrid PSO-DE algorithm with dynamic population size adjustment for improved convergence and solution quality.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (24,10) (30,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (24,10) (30,10) ')", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {}, "mutation_prompt": null}
{"id": "b0cfe30e-331b-4534-8bae-65518a46ab17", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n            # Simulated Annealing for local refinement\n            for i in range(self.population_size):\n                temp = 1.0 - evaluations / self.budget\n                neighbor = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, lb, ub)\n                neighbor_fitness = func(neighbor)\n                evaluations += 1\n                if neighbor_fitness < new_fitness[i] or np.random.rand() < np.exp((new_fitness[i] - neighbor_fitness) / temp):\n                    self.particles[i] = neighbor\n                    new_fitness[i] = neighbor_fitness\n                    if neighbor_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = neighbor_fitness\n                        self.local_best[i] = neighbor\n                    if neighbor_fitness < global_best_fitness:\n                        global_best_fitness = neighbor_fitness\n                        self.global_best = neighbor\n\n        return self.global_best", "name": "HybridPSODE", "description": "An improved hybrid PSO-DE algorithm with selective local search using simulated annealing to refine particles.", "configspace": "", "generation": 3, "fitness": 0.815212580158048, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.007. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.811897370877065, 0.8092263476932225, 0.8245140219038561], "final_y": [0.1497184289872927, 0.1418393119643231, 0.13485696224496846]}, "mutation_prompt": null}
{"id": "31bdfad6-d485-4803-9ce5-c34aa28d938b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by adjusting the cognitive coefficient (c1) to improve the algorithm's ability to explore the search space.", "configspace": "", "generation": 3, "fitness": 0.8253709725162616, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.012. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8321960640180819, 0.8358086899208025, 0.8081081636099], "final_y": [0.13422657870814858, 0.12932469695381765, 0.14651965978408854]}, "mutation_prompt": null}
{"id": "9d793dda-f803-4aba-af8b-1f290b80f884", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            self.mutation_factor = 0.5 + 0.4 * (1 - evaluations / self.budget)  # adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive mutation factor to balance exploration-exploitation.", "configspace": "", "generation": 3, "fitness": 0.8378562175874178, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.010. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8509669737563252, 0.8264544214840192, 0.8361472575219089], "final_y": [0.13073647544781464, 0.14191366717669518, 0.135165326858117]}, "mutation_prompt": null}
{"id": "9190515f-4ddd-4a9b-a12c-fa3b0718c9ab", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.6 * (evaluations / self.budget) ** 2  # enhanced adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with a more robust adaptive inertia weight strategy for better convergence.", "configspace": "", "generation": 3, "fitness": 0.8235615841525936, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8331913711385464, 0.8234758945539677, 0.8140174867652665], "final_y": [0.12404944664797701, 0.14037840485774944, 0.13834049486168787]}, "mutation_prompt": null}
{"id": "c3868f56-d704-4200-87a3-f9e086f3fe06", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c2 = 2.5 - 1.5 * evaluations / self.budget  # dynamic social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm with adaptive inertia weight and dynamic social coefficient for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.8230683521406803, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.013. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8057518634966941, 0.8352857127861151, 0.8281674801392318], "final_y": [0.1429414564252539, 0.12370834630467487, 0.13470468553157733]}, "mutation_prompt": null}
{"id": "590d1ab4-fe1f-46b4-99e7-f96aba489f95", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.mutation_factor_adaptive = 0.5  # adaptive mutation factor\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor_adaptive = 0.5 + 0.4 * (1 - evaluations / self.budget)\n                mutant = self.particles[a] + self.mutation_factor_adaptive * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid PSO and DE algorithm with dual-strategy evolution using adaptive mutation and crossover for enhanced diversity and convergence.", "configspace": "", "generation": 4, "fitness": 0.8467645509088908, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.020. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8731284341808931, 0.8425842546194143, 0.824580963926365], "final_y": [0.12528439639729394, 0.1343217003247673, 0.13158970843770312]}, "mutation_prompt": null}
{"id": "86c4960d-39e5-40be-984a-745b467d8923", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 1.5  # Adjusted cognitive coefficient\n        self.c2 = 1.5  # Adjusted social coefficient\n        self.w = 0.7\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def chaotic_initialization(self, lb, ub):\n        r = np.random.rand(self.population_size, self.dim)\n        return lb + (ub - lb) * np.sin(np.pi * r)\n\n    def adaptive_learning_rate(self, iteration, max_iter):\n        return 0.5 + 0.5 * (1 - iteration / max_iter)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = self.chaotic_initialization(lb, ub)\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n        iteration = 0\n        max_iter = self.budget // self.population_size\n\n        while evaluations < self.budget:\n            iteration += 1\n            adaptive_c1 = self.adaptive_learning_rate(iteration, max_iter)\n            adaptive_c2 = self.adaptive_learning_rate(iteration, max_iter)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget\n            self.velocities = (self.w * self.velocities +\n                               adaptive_c1 * r1 * (self.local_best - self.particles) +\n                               adaptive_c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid PSO-DE algorithm with adaptive learning rates and chaos-based initialization to improve convergence speed and robustness.", "configspace": "", "generation": 4, "fitness": 0.8293686094831658, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.051. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.7597099228904933, 0.8820957667839282, 0.8463001387750758], "final_y": [0.161616633408041, 0.12000416943378278, 0.12708939267393748]}, "mutation_prompt": null}
{"id": "fe2695e7-a218-4695-9a34-bf3ca9cd026b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Dynamic mutation factor\n                self.mutation_factor = 0.6 + 0.4 * (1 - evaluations / self.budget)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                # Adaptive crossover rate\n                self.recombination_rate = 0.9 - 0.5 * (local_best_fitness[i] / global_best_fitness)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with a dynamic mutation factor and adaptive crossover for improved exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8381314071658527, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.012. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8222368603874027, 0.8400643030995183, 0.8520930580106367], "final_y": [0.135881180683046, 0.1382541744874186, 0.13281198779275516]}, "mutation_prompt": null}
{"id": "2d13538c-eb01-4683-8a86-b27922cdd0ea", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = 0.8 + 0.2 * (1 - evaluations / self.budget)  # dynamically changing mutation factor\n                mutant = self.particles[a] + dynamic_mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduced a dynamic mutation factor in the DE component to enhance exploration during the early phases of optimization.", "configspace": "", "generation": 4, "fitness": 0.823621519047092, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.000. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8235236425502016, 0.8241996738870224, 0.8231412407040521], "final_y": [0.14082940836091884, 0.14051997570879904, 0.13763503797991905]}, "mutation_prompt": null}
{"id": "67f1583f-eb9e-4714-92c8-2fe59aec70db", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamic adjustment of population size\n            self.population_size = max(5, int(10 + 2 * self.dim * (1 - evaluations / self.budget)))\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce a dynamic population size strategy to enhance diversity and exploration-exploitation balance in HybridPSODE.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (29,10) (30,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (29,10) (30,10) ')", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {}, "mutation_prompt": null}
{"id": "f8161d86-a7b6-4e44-8bac-4496ea5f89d7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.5 - 1.5 * evaluations / self.budget  # adaptive cognitive coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduced an adaptive cognitive coefficient to dynamically balance the exploration and exploitation phases in the optimization process.", "configspace": "", "generation": 5, "fitness": 0.8294261684317451, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.029. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.7987608013459385, 0.8680316495157568, 0.8214860544335398], "final_y": [0.12724465845330823, 0.12691132130373728, 0.1336929023276464]}, "mutation_prompt": null}
{"id": "7121eabc-d690-4e5a-938a-4d7d19e8fcb5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                self.recombination_rate = 0.9 - 0.4 * evaluations / self.budget  # adaptive recombination rate\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive recombination rate for better diversity control.", "configspace": "", "generation": 5, "fitness": 0.8347776775197572, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.015. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8467393875229781, 0.8141958010260514, 0.8433978440102419], "final_y": [0.13108561917481032, 0.14851337514954266, 0.1322086883226956]}, "mutation_prompt": null}
{"id": "b3031a2c-ff98-40e1-aeed-4bd18d501ec7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 10 + 2 * dim\n        self.population_size = self.base_population_size\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor_base = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Dynamic mutation factor based on iterations\n            mutation_factor = self.mutation_factor_base + 0.1 * (1 - evaluations / self.budget)\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n            # Adaptive population resizing\n            if evaluations % (self.base_population_size * 2) == 0:\n                self.population_size = max(5 + 2 * dim, self.population_size - 1)\n\n        return self.global_best", "name": "HybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm introducing dynamic mutation strategies and adaptive population resizing to improve convergence speed and quality.", "configspace": "", "generation": 5, "fitness": 0.8290908764458136, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8296600402646015, 0.8199204500564737, 0.8376921390163659], "final_y": [0.13077783488571904, 0.13536328716036428, 0.1350253520669772]}, "mutation_prompt": null}
{"id": "08e841e1-a122-4020-b55b-68a9fd2a43d5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def levy_flight(self, Lmbda):\n        sigma = (np.math.gamma(1 + Lmbda) * np.sin(np.pi * Lmbda / 2) /\n                (np.math.gamma((1 + Lmbda) / 2) * Lmbda * 2 ** ((Lmbda - 1) / 2))) ** (1 / Lmbda)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v) ** (1 / Lmbda)\n        return step\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with Lévy flights\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutation_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutation_vector += self.levy_flight(1.5) * (self.global_best - self.particles[i])\n                mutation_vector = np.clip(mutation_vector, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutation_vector, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "An improved Hybrid PSO-DE algorithm with Lévy flights for enhanced exploration and adaptive parameter tuning for better convergence.  ", "configspace": "", "generation": 5, "fitness": 0.8252174070636146, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.020. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.7990690959506481, 0.847076485344713, 0.8295066398954822], "final_y": [0.1407668794783823, 0.13559252319680892, 0.1354511649381035]}, "mutation_prompt": null}
{"id": "645fefae-62fa-4089-9659-9017bda6db54", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n                        \n            # Added selection mechanism to enhance DE mutation\n            if np.random.rand() < 0.1:  # 10% chance to enhance global exploration\n                self.global_best += np.random.uniform(-0.1, 0.1, self.dim)\n                self.global_best = np.clip(self.global_best, lb, ub)\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm with adaptive inertia weight and improved selection in DE mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.8211222618229685, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.020. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8151769562138044, 0.8477138699406467, 0.8004759593144546], "final_y": [0.14047464607820914, 0.13802157402454784, 0.1460799447674057]}, "mutation_prompt": null}
{"id": "5a877970-ba70-42b2-abb5-2beea1cf0bcf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.95  # increased rate for better exploration\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "A hybrid PSO and DE algorithm with adaptive inertia weight and improved recombination rate for better exploration-exploitation.", "configspace": "", "generation": 6, "fitness": 0.7944374527344751, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.010. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.7878736625731118, 0.7862202080076672, 0.8092184876226463], "final_y": [0.15062936358869872, 0.1582597336589181, 0.13926771142041938]}, "mutation_prompt": null}
{"id": "6f05c2b6-2ada-4c70-9e75-cb012e627f97", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.5 + 0.3 * (np.min(fitness) / global_best_fitness)  # dynamic mutation factor\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic mutation factor adjustment for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.8260193676266369, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.016. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8030304744841491, 0.8395757657045129, 0.8354518626912488], "final_y": [0.14747259901073662, 0.13658581274463522, 0.1398784026237656]}, "mutation_prompt": null}
{"id": "ed766a64-f093-468d-b363-7a01f1f9a1f4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            self.mutation_factor = 0.5 + 0.4 * (global_best_fitness / (np.max(new_fitness) + 1e-9))\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced Hybrid PSO-DE with dynamic mutation factor adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.824101854123917, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.010. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8317461926064249, 0.8302776456729204, 0.8102817240924057], "final_y": [0.13545586175055635, 0.13576730816519067, 0.1486417732109595]}, "mutation_prompt": null}
{"id": "6791cd60-4e44-4297-87a6-ed81e38995b6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.85  # Increased from 0.8 to 0.85\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced the DE component by slightly increasing the mutation factor to improve exploration capabilities.", "configspace": "", "generation": 6, "fitness": 0.8249656733784426, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.016. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8402817388226889, 0.8026823023549723, 0.8319329789576668], "final_y": [0.1347423073657752, 0.13989335483906928, 0.13149746384307115]}, "mutation_prompt": null}
{"id": "89666b78-042f-4be4-bc5b-29d0eb5e6284", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n        self.max_velocity = 0.1 * (ub - lb)  # Introduce maximum velocity for clamping\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.velocities = np.clip(self.velocities, -self.max_velocity, self.max_velocity)  # Velocity clamping\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce velocity clamping in PSO to prevent particles from overshooting the search space.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'ub' is not defined\").", "error": "NameError(\"name 'ub' is not defined\")", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {}, "mutation_prompt": null}
{"id": "e95b2429-a512-4aa7-8a3f-01ef2174cbea", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            self.mutation_factor = 0.5 + 0.4 * (1 - evaluations / self.budget)  # adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Incorporate adaptive mutation factor in the DE component to enhance exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8210506677925536, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.006. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.81838315763636, 0.828856047022574, 0.8159127987187269], "final_y": [0.13673109388790672, 0.14110277211967093, 0.1422410902605219]}, "mutation_prompt": null}
{"id": "947da7f9-053e-4f8c-9933-ac0ff79c0a32", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive mutation and recombination strategies in the Hybrid PSO-DE algorithm to improve convergence speed and solution quality.", "configspace": "", "generation": 7, "fitness": 0.8536264000589231, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.017. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.830699302181207, 0.8711902330852448, 0.8589896649103173], "final_y": [0.13236631724636616, 0.12902500040426312, 0.12617692103936684]}, "mutation_prompt": null}
{"id": "cb64572b-592b-43cb-938f-2e431b6a5272", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.5 + 0.3 * (1 - evaluations / self.budget)  # adaptive mutation factor\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Hybrid Particle Swarm Optimization and Differential Evolution with adaptive mutation factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8208316957636811, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.003. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.8230998073480204, 0.823381628214765, 0.816013651728258], "final_y": [0.1347059611997492, 0.13597402027387573, 0.1383363414991765]}, "mutation_prompt": null}
{"id": "63277449-d653-440a-9586-c2c8008a7047", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Dynamic mutation factor and adaptive recombination rate\n            self.mutation_factor = 0.5 + 0.5 * np.random.rand()\n            self.recombination_rate = 0.7 + 0.3 * (global_best_fitness - np.min(local_best_fitness)) / max(global_best_fitness, 1e-10)\n\n            # Apply DE mutation and crossover with elite preservation\n            elite_index = np.argmin(fitness)\n            for i in range(self.population_size):\n                if i == elite_index:\n                    continue  # Preserve elite\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < self.recombination_rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing the PSO-DE hybrid by incorporating a dynamic mutation factor and adaptive recombination rate alongside elite preservation for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.8281156236849423, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.029. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "a4f750bf-c61a-44b0-9c87-03e2c3a10b93", "metadata": {"aucs": [0.815520616514811, 0.8685548661314723, 0.8002713884085437], "final_y": [0.1414790436959037, 0.1230087063573354, 0.15045795203455736]}, "mutation_prompt": null}
{"id": "af25de25-44cc-412d-8f7c-5421e41a1413", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamically update population size\n            self.population_size = max(4, int(10 + 2 * self.dim * (1 - evaluations / self.budget)))\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive population size reduction strategy to enhance exploration-exploitation balance in Hybrid PSO-DE algorithm.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (29,10) (30,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (29,10) (30,10) ')", "parent_id": "947da7f9-053e-4f8c-9933-ac0ff79c0a32", "metadata": {}, "mutation_prompt": null}
{"id": "5e731c4a-c9bf-4854-be6f-a1aefe10364a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                dynamic_mutation = adaptive_factor * self.mutation_factor * (new_fitness[i] / global_best_fitness)\n                mutant = self.particles[a] + dynamic_mutation * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * (global_best_fitness / new_fitness[i]))\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing the adaptive mutation and recombination strategy by introducing a dynamic mutation factor and enhanced crossover decision based on fitness improvements.", "configspace": "", "generation": 8, "fitness": 0.8148335543187063, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.010. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "947da7f9-053e-4f8c-9933-ac0ff79c0a32", "metadata": {"aucs": [0.8240498885830404, 0.8195376748851213, 0.8009130994879575], "final_y": [0.13217613752193813, 0.12912116341415925, 0.14498770310199305]}, "mutation_prompt": null}
{"id": "accc9e71-93d6-4471-b0f4-24e284e67dd7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 + 2 * dim, np.ceil(budget / 100).astype(int))  # Dynamic population size based on budget\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a dynamic particle population strategy where the population size is adjusted based on the evaluation budget to improve solution diversity.", "configspace": "", "generation": 8, "fitness": 0.8194821341773615, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.004. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "947da7f9-053e-4f8c-9933-ac0ff79c0a32", "metadata": {"aucs": [0.8202221199539105, 0.8237866337793396, 0.8144376487988344], "final_y": [0.13937166038641646, 0.13461171843899855, 0.14125593037413953]}, "mutation_prompt": null}
{"id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO convergence by increasing cognitive coefficient slightly for better local exploration.", "configspace": "", "generation": 8, "fitness": 0.8569998810115173, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.022. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "947da7f9-053e-4f8c-9933-ac0ff79c0a32", "metadata": {"aucs": [0.8489965366422051, 0.8869396191622523, 0.8350634872300944], "final_y": [0.13182496675287458, 0.12176927032054452, 0.13698788780153714]}, "mutation_prompt": null}
{"id": "7d2ecaa1-9599-4004-91f8-8c5c140f17b6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                self.mutation_factor = 0.8 * (1 + adaptive_factor)  # Change: Dynamic mutation factor adjustment\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve global exploration by modifying mutation factor with dynamic scaling based on budget usage.", "configspace": "", "generation": 8, "fitness": 0.8222095601687762, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.027. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "947da7f9-053e-4f8c-9933-ac0ff79c0a32", "metadata": {"aucs": [0.7955599688725925, 0.8587950862710434, 0.8122736253626929], "final_y": [0.1330950494755352, 0.12824131385184812, 0.14430471094716535]}, "mutation_prompt": null}
{"id": "5d30c446-fbd1-450a-8e92-40d36a1d9a05", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.random.rand()  # dynamic mutation factor\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine PSO by introducing dynamic mutation factor and recursive local best update.", "configspace": "", "generation": 9, "fitness": 0.8273637107527837, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.008. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8364746747766535, 0.8294838382092334, 0.8161326192724639], "final_y": [0.12889062037328858, 0.13855015055127196, 0.1417403636553467]}, "mutation_prompt": null}
{"id": "95cdcf24-b22b-4b17-9ce4-9ebf2c903c13", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        # Chaotic map for velocities\n        self.velocities = 0.5 * (np.sin(np.random.uniform(-np.pi, np.pi, (self.population_size, self.dim))) + 1)\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance exploration strategy by integrating a chaotic map to diversify initial velocity distribution.", "configspace": "", "generation": 9, "fitness": 0.8330264101377614, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.021. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8035080527689569, 0.8436172983936292, 0.851953879250698], "final_y": [0.13436873592158716, 0.12420321137602242, 0.12650432251509292]}, "mutation_prompt": null}
{"id": "7171f5de-5217-4c2c-8d15-44a4e18d3a5b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.2  # cognitive coefficient (slightly increased for better local exploration)\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve local exploration by slightly increasing the cognitive coefficient for better convergence in PSO.", "configspace": "", "generation": 9, "fitness": 0.8379998161103254, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.023. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8554657748303273, 0.8527465827305873, 0.8057870907700614], "final_y": [0.1287494509110585, 0.12799679727808277, 0.1466288371343598]}, "mutation_prompt": null}
{"id": "b1e0f1f4-ef9d-47f2-be57-da447f12f5d1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.2  # cognitive coefficient slightly increased\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce a slight increase in the cognitive coefficient to boost local exploration in the Hybrid Particle Swarm Optimization with Differential Evolution (PSODE) strategy.", "configspace": "", "generation": 9, "fitness": 0.818160687550464, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.007. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8119059069476423, 0.8286760110253217, 0.8139001446784284], "final_y": [0.13826946975510757, 0.13694599727416146, 0.1329921895772932]}, "mutation_prompt": null}
{"id": "ca3f6c4b-7753-42b3-a1f6-991d35d937a6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.85  # increased mutation factor\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Increase mutation factor slightly to enhance exploration in the DE step of HybridPSODE.", "configspace": "", "generation": 9, "fitness": 0.8188821517438676, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.012. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8175764794287765, 0.8338321959834334, 0.8052377798193929], "final_y": [0.13270002815970927, 0.1375608927696932, 0.14141631119120124]}, "mutation_prompt": null}
{"id": "12e99322-97c4-4a48-a9d2-a446e54441bf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 1.9  # slightly decreased social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.85  # slightly increased mutation factor\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.4 * evaluations / self.budget  # slightly lower adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * (0.5 + adaptive_factor))  # slightly dynamic crossover rate\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adaptive hybrid PSO-DE with dynamic inertia and crossover adjustment for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.8343923132289585, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.029. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.872171818771216, 0.8287281541443372, 0.802276966771322], "final_y": [0.11946092402531372, 0.12972350515372744, 0.1405247270798331]}, "mutation_prompt": null}
{"id": "80f0084b-59d7-44a2-9c35-fadacf25f03d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            # Adaptive adjustment of cognitive and social coefficients\n            self.c1 = 2.1 - 1.0 * (evaluations / self.budget)\n            self.c2 = 2.0 - 1.0 * (evaluations / self.budget)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO by further adaptively decreasing cognitive and social coefficients to improve exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8301555523165542, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.013. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8294284702313445, 0.8464327381309625, 0.8146054485873558], "final_y": [0.12495171974371622, 0.12994936830053216, 0.13853064946255367]}, "mutation_prompt": null}
{"id": "277f5fa3-5a9e-4d13-a932-8099a873d4ce", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = np.exp(-evaluations / self.budget)  # Stochastic tunneling\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Combine adaptive mutation factor with stochastic tunneling for improved exploration and convergence in PSO-DE.", "configspace": "", "generation": 10, "fitness": 0.8166388965758943, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.022. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8207277398433825, 0.8410418146672832, 0.7881471352170171], "final_y": [0.13921351578236596, 0.1350093245009334, 0.15529236715648131]}, "mutation_prompt": null}
{"id": "1736f767-c6ad-4b11-872c-f323b7431b93", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.2  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve social coefficient slightly for better global exploration.", "configspace": "", "generation": 10, "fitness": 0.8177696798867249, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.009. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8248062180749861, 0.8233343024273707, 0.8051685191578176], "final_y": [0.12997584439246024, 0.14011612128352513, 0.1398418706126846]}, "mutation_prompt": null}
{"id": "cff3a0cb-19a7-4ac7-b179-0d6cac6c337e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c2 = 2.0 + 0.3 * evaluations / self.budget  # time-varying social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO convergence by incorporating a time-varying social coefficient for improved global exploration.", "configspace": "", "generation": 10, "fitness": 0.829873049459552, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.003. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8322631967375533, 0.8311627887720632, 0.8261931628690393], "final_y": [0.14158437338662977, 0.13709893536414564, 0.12925947198158128]}, "mutation_prompt": null}
{"id": "25379adc-d30d-48db-b58c-8f17a31390cf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                convergence_rate = evaluations / self.budget  # Dynamic based on evaluations\n                adaptive_factor = 1.0 - convergence_rate\n                self.mutation_factor = 0.5 + 0.3 * adaptive_factor  # Changed line for dynamic mutation\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce a dynamic mutation factor by adjusting it based on particle convergence to enhance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.8295137878678472, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.003. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8341692751540041, 0.8265153872064102, 0.8278567012431272], "final_y": [0.1360172118302475, 0.13477975943160792, 0.13668891620456225]}, "mutation_prompt": null}
{"id": "8657ebd1-b2a6-42bb-bd3a-1c94af01ae1b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.2  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive coefficient to enhance local exploration and improve convergence.", "configspace": "", "generation": 11, "fitness": 0.8272768667273781, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.027. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8194709248166868, 0.8635469948027372, 0.7988126805627102], "final_y": [0.14137543177659762, 0.12114477742849983, 0.1536707891758089]}, "mutation_prompt": null}
{"id": "508088a6-78f8-42c3-b99a-0bc6fd1eb66e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.1  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO convergence by increasing the social coefficient slightly for better global exploration.", "configspace": "", "generation": 11, "fitness": 0.8384923622724735, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.010. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8430347227692911, 0.8472400577491838, 0.8252023062989458], "final_y": [0.13543264384384213, 0.13289902539207243, 0.135302336295421]}, "mutation_prompt": null}
{"id": "8ea47048-1065-4489-8ab7-ae2ad97a2a66", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # initial social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c2 = 2.0 - 1.0 * evaluations / self.budget  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                adjusted_mutation_factor = self.mutation_factor * (0.5 + 0.5 * adaptive_factor)\n                mutant = self.particles[a] + adjusted_mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce adaptive social coefficient and enhance exploration by dynamic mutation factor adjustment.", "configspace": "", "generation": 11, "fitness": 0.8332249155042399, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.007. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8429339542785426, 0.8254726124993557, 0.8312681797348216], "final_y": [0.13019707401774872, 0.12987815120769586, 0.13393346875565093]}, "mutation_prompt": null}
{"id": "17fb7856-4086-47eb-985e-50df0a8e6631", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.05  # cognitive coefficient\n        self.c2 = 2.05  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced PSO convergence by dynamically adjusting cognitive and social coefficients based on particle fitness improvements.", "configspace": "", "generation": 11, "fitness": 0.8373857048868958, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.012. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8211314762178878, 0.8505161746495908, 0.8405094637932089], "final_y": [0.14187199182796995, 0.12604017582178784, 0.1261734252676523]}, "mutation_prompt": null}
{"id": "30a63fbc-5905-48cc-b9ed-c3344fc214d5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.05  # slightly increased social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improved convergence by slightly increasing the social coefficient for better global exploration.", "configspace": "", "generation": 12, "fitness": 0.845511789797419, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.013. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8348947579930955, 0.838219580462766, 0.8634210309363953], "final_y": [0.12618871156374578, 0.1313334042030121, 0.1270936924613919]}, "mutation_prompt": null}
{"id": "9c6cc99b-94d8-4c6c-bd3e-e98890b10587", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 1.5 + 0.5 * np.random.rand()  # dynamic social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.9  # increased mutation factor\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO-DE convergence by dynamically adjusting the social coefficient and employing a better mutation mechanism.", "configspace": "", "generation": 12, "fitness": 0.8337415956252077, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.004. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8388551140219208, 0.8296305656590055, 0.8327391071946967], "final_y": [0.126579741567716, 0.13456590000754298, 0.13469132898153635]}, "mutation_prompt": null}
{"id": "e9ea8330-6b90-4c69-9032-19f633b0be67", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.1 + 0.5 * (evaluations / self.budget)  # dynamic cognitive coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                self.mutation_factor = 0.8 + 0.2 * adaptive_factor  # dynamic mutation factor\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adaptive PSO-DE hybrid improves exploration by dynamically adjusting cognitive coefficient and mutation factor.", "configspace": "", "generation": 12, "fitness": 0.8229890639486072, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.006. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8309933022377686, 0.8188496120911245, 0.8191242775169284], "final_y": [0.13384812448102845, 0.13635567026316053, 0.13751923475911]}, "mutation_prompt": null}
{"id": "4c457b8b-480e-4103-a286-ac98075b0fa1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.2  # cognitive coefficient, slightly increased for better exploration\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.8  # inertia weight, slightly increased for better exploration\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjust PSO's inertia weight and cognitive coefficient for enhanced global exploration and convergence.  ", "configspace": "", "generation": 12, "fitness": 0.8401006756729923, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.015. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8595962519157039, 0.8382658431051742, 0.8224399319980988], "final_y": [0.1284668745395171, 0.12670853350316602, 0.12762410340327335]}, "mutation_prompt": null}
{"id": "fc6c6376-86e7-4dfa-afb5-80b4365d0d70", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * (np.sin(evaluations / self.budget * np.pi))  # chaotic map for inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                self.mutation_factor = 0.5 + np.random.rand() * 0.5  # randomized mutation factor\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve exploration by introducing chaotic maps for weight adaptation and enhance diversity with randomized mutation factors.", "configspace": "", "generation": 12, "fitness": 0.830728050756168, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.016. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8396908120614118, 0.8442406768079495, 0.8082526633991428], "final_y": [0.125847185831104, 0.13463993126551121, 0.13989434724475625]}, "mutation_prompt": null}
{"id": "2180d2f9-e3e8-42d0-b96d-43ba1a604d2f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            \n            # Dynamic cognitive and social coefficients\n            self.c1 = 1.5 + 0.6 * (evaluations / self.budget)\n            self.c2 = 2.5 - 0.5 * (evaluations / self.budget)\n            \n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve local exploration by introducing a dynamic cognitive and social coefficient during iterations.", "configspace": "", "generation": 13, "fitness": 0.8351365872186225, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.004. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8387677195936414, 0.836518465656044, 0.8301235764061818], "final_y": [0.12874039821308536, 0.1294944322692435, 0.12921279833757726]}, "mutation_prompt": null}
{"id": "2bb46004-e87e-4a56-88b9-4993e51df144", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor * (1 - 0.5 * adaptive_factor))\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce a dynamic adjustment to the recombination rate to improve exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.8456841258881092, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.017. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8405762747550476, 0.8682649971577188, 0.8282111057515613], "final_y": [0.13138318142147687, 0.12231158130137021, 0.13805112163399869]}, "mutation_prompt": null}
{"id": "0e760496-15d9-4931-9160-a7b05af3facb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n            if evaluations > self.budget * 0.9:  # New line: introduce diversity near end of budget\n                self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce diversity by implementing a random reset of particle positions for stagnation recovery.", "configspace": "", "generation": 13, "fitness": 0.8295224293438546, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.010. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8207083591656381, 0.8250364419155474, 0.8428224869503782], "final_y": [0.13675829431299458, 0.12330123761656364, 0.1286719168201491]}, "mutation_prompt": null}
{"id": "0c07aee1-b7ee-42e8-9db5-deb00dd57cd2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.2  # social coefficient (increased slightly from 2.0 to 2.2)\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase social coefficient for enhanced global exploration.", "configspace": "", "generation": 13, "fitness": 0.8207295049339353, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.021. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8207520610995125, 0.8459228089396168, 0.7955136447626767], "final_y": [0.13794020633889714, 0.1368500793294114, 0.14120207344196367]}, "mutation_prompt": null}
{"id": "12cba8ce-b90c-4c12-8be1-a1499c44a4fa", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n        stagnation_threshold = 0.001\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c2 = 2.0 + 0.5 * (evaluations / self.budget)  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n                # Random re-initialization for stagnated particles\n                if np.abs(trial_fitness - local_best_fitness[i]) < stagnation_threshold:\n                    self.particles[i] = np.random.uniform(lb, ub, self.dim)\n                    new_fitness[i] = func(self.particles[i])\n                    evaluations += 1\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce adaptive social coefficient and enhance diversity with random re-initialization for stagnated particles.", "configspace": "", "generation": 13, "fitness": 0.8236100196054021, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.006. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8165766430008317, 0.8316776229260038, 0.822575792889371], "final_y": [0.14656770808844444, 0.1330017045214832, 0.14017239572920748]}, "mutation_prompt": null}
{"id": "87f67bd1-62e0-4c82-8c0e-e6247657c0c6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n        \n        initial_pop_size = self.population_size\n\n        while evaluations < self.budget:\n            self.population_size = initial_pop_size - int((initial_pop_size - 4) * (evaluations / self.budget))\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities + \n                               (0.5 + 1.5 * evaluations / self.budget) * r1 * (self.local_best - self.particles) + \n                               (0.5 + 1.5 * evaluations / self.budget) * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce learning coefficients and dynamic population resizing for improved convergence.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (28,10) (30,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (28,10) (30,10) ')", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {}, "mutation_prompt": null}
{"id": "45696cf6-9edb-4296-bc03-235edc78a03c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.4 * evaluations / self.budget  # modified inertia weight schedule\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine PSO by adjusting inertia weight schedule for improved exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.8273166193241405, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.014. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8460127506039922, 0.8217444764001567, 0.8141926309682728], "final_y": [0.1322541746403808, 0.13459209921899873, 0.13148716982304742]}, "mutation_prompt": null}
{"id": "de1c0e64-e092-4a63-97cc-ad6130821c50", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c2 = 2.1 - 0.1 * (evaluations / self.budget)  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO convergence by adapting social coefficient slightly for better global exploration.", "configspace": "", "generation": 14, "fitness": 0.8315838901694437, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.029. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8391545511579535, 0.8622702631607113, 0.7933268561896664], "final_y": [0.12804416680748265, 0.1284763184532055, 0.14793037395106579]}, "mutation_prompt": null}
{"id": "d258505e-1f05-4243-ad19-07b7f8baeaa0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.1 + 0.5 * (evaluations / self.budget)  # adaptive cognitive coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce an adaptive cognitive coefficient in PSO to enhance convergence by dynamically adjusting local exploration.", "configspace": "", "generation": 14, "fitness": 0.835486928929793, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.006. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8274911487652785, 0.8419596058149443, 0.8370100322091565], "final_y": [0.13037660154069353, 0.13513498492419407, 0.13842597653039468]}, "mutation_prompt": null}
{"id": "438b51bc-21ab-4786-af38-ba131a7535ee", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            # Dynamic update of c1 and c2\n            self.c1 = 2.5 - 1.5 * (evaluations / self.budget)\n            self.c2 = 0.5 + 1.5 * (evaluations / self.budget)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Integrate a dynamic update mechanism for social and cognitive coefficients to enhance exploration in early stages and exploitation in later stages.", "configspace": "", "generation": 14, "fitness": 0.8420923562404411, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.018. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8611922772299689, 0.8478798791006399, 0.8172049123907146], "final_y": [0.11744294421816381, 0.129879541580468, 0.14080181795699542]}, "mutation_prompt": null}
{"id": "bb4ae71b-e60e-48e4-8c19-3cadc2b440f8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.1 - 0.1 * (evaluations / self.budget)  # adaptive cognitive coefficient\n            self.c2 = 1.9 + 0.1 * (evaluations / self.budget)  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve PSO by making cognitive and social coefficients adaptive based on convergence progress.", "configspace": "", "generation": 15, "fitness": 0.8643723565425653, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.015. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8453216290527938, 0.8663286221900257, 0.8814668183848764], "final_y": [0.12375589454448566, 0.12743836251181695, 0.12330821369120215]}, "mutation_prompt": null}
{"id": "662824cf-43e2-429c-8c01-e2508b7be44f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Introduce adaptive mutation factor\n            self.mutation_factor = 0.5 + 0.5 * (global_best_fitness / (1 + np.max(new_fitness)))\n            \n            # Apply DE mutation and crossover with enhanced strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance PSO-DE by introducing an adaptive mutation factor and diversity preservation for improved exploration.", "configspace": "", "generation": 15, "fitness": 0.8431087461294888, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.005. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8463646414481841, 0.8465356412433774, 0.836425955696905], "final_y": [0.12879470342143007, 0.13138553347833315, 0.13101986805534427]}, "mutation_prompt": null}
{"id": "45114048-3c2f-4e32-88d7-3e81828a809d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            # Adaptive cognitive and social coefficients\n            self.c1 = 2.1 * (1 - evaluations / self.budget)\n            self.c2 = 2.0 * (evaluations / self.budget)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce adaptive cognitive and social coefficients in PSO for improved balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.8383536829817081, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.006. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8380593476190178, 0.8464506501397311, 0.8305510511863754], "final_y": [0.11798520752254438, 0.13200154444150802, 0.1274060374143643]}, "mutation_prompt": null}
{"id": "94f21068-2212-48b6-99af-bc25814d4ccc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            diversity = np.std(self.particles, axis=0).mean()\n            self.c1 = 2.1 + 0.5 * diversity\n            self.c2 = 2.0 - 0.5 * diversity\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                dynamic_recombination_rate = self.recombination_rate * (1 + 0.1 * np.sqrt(diversity))\n                crossover = np.random.rand(self.dim) < (dynamic_recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine HybridPSODE by employing a dynamic recombination rate and adaptive cognitive and social coefficients based on solution diversity.", "configspace": "", "generation": 15, "fitness": 0.8112430025663411, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.050. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.7445144328652669, 0.8254328622127471, 0.8637817126210093], "final_y": [0.17821583059479928, 0.13024436095431413, 0.1240187592353531]}, "mutation_prompt": null}
{"id": "2ce23997-38be-4291-8716-e3a365c6acd1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c2 = 2.0 * (1 - evaluations / self.budget)  # time-varying social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce a time-varying social coefficient to balance exploration and exploitation dynamically.", "configspace": "", "generation": 15, "fitness": 0.8600045377310459, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.020. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "eb68a3b7-873f-483d-ac5f-90f0755524c2", "metadata": {"aucs": [0.8668414140746291, 0.8801706174243296, 0.8330015816941788], "final_y": [0.12268345888974364, 0.12100588880744467, 0.12960385468576008]}, "mutation_prompt": null}
{"id": "b6a435ff-b469-4f21-829f-bbc00bb385cb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.4 * np.sqrt(evaluations / self.budget)  # more dynamic adaptive inertia weight\n            self.c1 = 2.1 - 0.1 * (evaluations / self.budget)  # adaptive cognitive coefficient\n            self.c2 = 1.9 + 0.1 * (evaluations / self.budget)  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine PSO by adjusting the inertia weight more dynamically to balance exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.8209103052412122, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.028. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "bb4ae71b-e60e-48e4-8c19-3cadc2b440f8", "metadata": {"aucs": [0.8554629687316323, 0.7875491548419663, 0.8197187921500378], "final_y": [0.12338803620025429, 0.16176055254720212, 0.14570197692875697]}, "mutation_prompt": null}
{"id": "009fc352-bd87-4c71-813f-3cb23908f188", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.diversity_factor = 0.1  # New factor for diversity\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  \n            self.c1 = 2.1 - 0.1 * (evaluations / self.budget)  \n            self.c2 = 1.9 + 0.1 * (evaluations / self.budget)  \n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with diversity enhancement\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                random_particle = self.particles[np.random.choice(indices)]\n                mutant += self.diversity_factor * (random_particle - self.particles[i])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Incorporate a diversity-enhancement mechanism based on distance to maintain exploration during convergence.", "configspace": "", "generation": 16, "fitness": 0.8094075004915476, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.019. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "bb4ae71b-e60e-48e4-8c19-3cadc2b440f8", "metadata": {"aucs": [0.8302540519205341, 0.8144508973855528, 0.783517552168556], "final_y": [0.1342360230919154, 0.15276245740366667, 0.16185997851840528]}, "mutation_prompt": null}
{"id": "4ad3e451-9dab-41eb-8e0a-eb8901670700", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.1 - 0.1 * (evaluations / self.budget)  # adaptive cognitive coefficient\n            self.c2 = 1.9 + 0.1 * (evaluations / self.budget)  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce dynamic particle swarm size to improve exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.8259871600514161, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.019. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "bb4ae71b-e60e-48e4-8c19-3cadc2b440f8", "metadata": {"aucs": [0.8464909578640686, 0.8300461227039885, 0.8014243995861916], "final_y": [0.12746740701961268, 0.1450990036230949, 0.15615853458755047]}, "mutation_prompt": null}
{"id": "1a9a070a-417d-49a9-aa87-43437016999c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.1 - 0.1 * (evaluations / self.budget)  # adaptive cognitive coefficient\n            self.c2 = 1.9 + 0.1 * (evaluations / self.budget)  # adaptive social coefficient\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.local_best - self.particles) +\n                               self.c2 * r2 * (self.global_best - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with adaptive strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.1 - (evaluations / self.budget)  # Increased adaptive factor\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve PSO by slightly adjusting the adaptive factor in the DE mutation to enhance exploration.", "configspace": "", "generation": 16, "fitness": 0.8261611107083318, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.014. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "bb4ae71b-e60e-48e4-8c19-3cadc2b440f8", "metadata": {"aucs": [0.8366757951992259, 0.806597149918646, 0.8352103870071234], "final_y": [0.1362637311396433, 0.15415109348357015, 0.14027379028207354]}, "mutation_prompt": null}
{"id": "227f009c-36dd-468c-843a-8b39b03e295a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * dim\n        self.c1 = 2.1  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.particles = None\n        self.velocities = None\n        self.local_best = None\n        self.global_best = None\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in self.particles])\n        self.local_best = self.particles.copy()\n        self.global_best = self.particles[np.argmin(fitness)]\n        local_best_fitness = fitness.copy()\n        global_best_fitness = np.min(fitness)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - 0.5 * evaluations / self.budget  # adaptive inertia weight\n            self.c1 = 2.1 - 0.1 * (evaluations / self.budget)  # adaptive cognitive coefficient\n            self.c2 = 1.9 + 0.1 * (evaluations / self.budget)  # adaptive social coefficient\n            # Dynamic neighborhood topology\n            neighbors = np.random.choice(self.population_size, (self.population_size, 3), replace=True)\n            for i in range(self.population_size):\n                local_best_neighbor = np.argmin([fitness[n] for n in neighbors[i]])\n                best_neighbor = neighbors[i][local_best_neighbor]\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1[i] * (self.local_best[i] - self.particles[i]) +\n                                      self.c2 * r2[i] * (self.particles[best_neighbor] - self.particles[i]))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # Evaluate new positions\n            new_fitness = np.array([func(x) for x in self.particles])\n            evaluations += self.population_size\n\n            # Update local and global bests\n            for i in range(self.population_size):\n                if new_fitness[i] < local_best_fitness[i]:\n                    local_best_fitness[i] = new_fitness[i]\n                    self.local_best[i] = self.particles[i]\n                if new_fitness[i] < global_best_fitness:\n                    global_best_fitness = new_fitness[i]\n                    self.global_best = self.particles[i]\n\n            # Apply DE mutation and crossover with enhanced strategies\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_factor = 1.0 - (evaluations / self.budget)\n                mutant = self.particles[a] + adaptive_factor * self.mutation_factor * (self.particles[b] - self.particles[c])\n                # Enhanced DE strategy: use a blend with best particle\n                mutant = mutant + adaptive_factor * 0.5 * (self.global_best - mutant)\n                mutant = np.clip(mutant, lb, ub)\n                crossover = np.random.rand(self.dim) < (self.recombination_rate * adaptive_factor)\n                trial_vector = np.where(crossover, mutant, self.particles[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < new_fitness[i]:\n                    self.particles[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < local_best_fitness[i]:\n                        local_best_fitness[i] = trial_fitness\n                        self.local_best[i] = trial_vector\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve PSO by including a dynamic neighborhood topology and enhancing the DE mutation strategy.", "configspace": "", "generation": 16, "fitness": 0.7824327200465588, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.782 with standard deviation 0.017. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "bb4ae71b-e60e-48e4-8c19-3cadc2b440f8", "metadata": {"aucs": [0.7603331952115996, 0.800902419090367, 0.7860625458377098], "final_y": [0.16455489361517717, 0.15123869388171007, 0.15073799124657672]}, "mutation_prompt": null}
