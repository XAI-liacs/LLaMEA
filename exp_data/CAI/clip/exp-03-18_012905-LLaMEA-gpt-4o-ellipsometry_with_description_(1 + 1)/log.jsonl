{"id": "0b6cb531-379c-42ae-b491-0491e6e0a354", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Pitch adjustment\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "A hybrid harmony search and differential evolution algorithm that combines global exploration with local exploitation to efficiently optimize black box functions within given budget constraints.", "configspace": "", "generation": 0, "fitness": 0.1869734850737718, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.041. And the mean value of best solutions found was 0.302 (0. is the best) with standard deviation 0.318.", "error": "", "parent_id": null, "metadata": {"aucs": [0.23955574861062034, 0.18204228615541107, 0.13932242045528398], "final_y": [0.06757480468435928, 0.08709608939099321, 0.750946027055325]}, "mutation_prompt": null}
{"id": "48240291-4fa3-46a2-96f5-a9306213d002", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "A hybrid harmony search and differential evolution algorithm with adaptive pitch adjustment to optimize black box functions efficiently within budget constraints.", "configspace": "", "generation": 1, "fitness": 0.28432088132688055, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.284 with standard deviation 0.114. And the mean value of best solutions found was 0.288 (0. is the best) with standard deviation 0.405.", "error": "", "parent_id": "0b6cb531-379c-42ae-b491-0491e6e0a354", "metadata": {"aucs": [0.28086803719490316, 0.4257847633748343, 0.14630984341090425], "final_y": [0.00377296837570191, 0.0006788518764079074, 0.8609311089730469]}, "mutation_prompt": null}
{"id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a learning factor adjustment to enhance the exploration-exploitation balance in the hybrid harmony and differential evolution algorithm.", "configspace": "", "generation": 2, "fitness": 0.30829346870765206, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.308 with standard deviation 0.090. And the mean value of best solutions found was 0.094 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "48240291-4fa3-46a2-96f5-a9306213d002", "metadata": {"aucs": [0.391069970518348, 0.18245986513396428, 0.3513505704706439], "final_y": [1.927497447651436e-07, 0.2817434961762621, 0.000585835560720372]}, "mutation_prompt": null}
{"id": "ef7b1c9e-d75c-4f72-824b-0517277eef97", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr * (1 - evaluations / self.budget), mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a decay factor to dynamically adjust the Crossover probability for improved exploration-exploitation trade-off.", "configspace": "", "generation": 3, "fitness": 0.18406644011450612, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.043. And the mean value of best solutions found was 0.644 (0. is the best) with standard deviation 0.531.", "error": "", "parent_id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "metadata": {"aucs": [0.24343489950552555, 0.14327821300287347, 0.16548620783511936], "final_y": [0.0076524445568089934, 1.3080801548749315, 0.6158857158697094]}, "mutation_prompt": null}
{"id": "a642df26-3851-4a6a-b349-37607aa27805", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with dynamic PAR\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        self.par = 0.1 + 0.2 * adapt_factor  # Dynamic adjustment \n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a dynamic adjustment to the pitch adjusting rate (PAR) for improved adaptability.", "configspace": "", "generation": 4, "fitness": 0.2752386875808751, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.010. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "metadata": {"aucs": [0.2836480028763583, 0.2611484337176563, 0.28091962614861077], "final_y": [0.008897474185715685, 0.012697260868280635, 0.012058517472573188]}, "mutation_prompt": null}
{"id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic adjustment to the pitch adjusting rate (PAR) based on remaining evaluations to enhance convergence.", "configspace": "", "generation": 5, "fitness": 0.4715158935595139, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.472 with standard deviation 0.054. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "metadata": {"aucs": [0.4014044425226867, 0.4809451987594744, 0.5321980393963808], "final_y": [5.807346730291547e-07, 7.151236816521785e-08, 1.6416566766041994e-08]}, "mutation_prompt": null}
{"id": "ec8f9bfb-3c48-40be-987e-04bf9631cf55", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        random_factor = np.random.rand()  # Added random factor for exploration\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * random_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Refine the dynamic adjustment of the pitch adjusting rate (PAR) by incorporating a random factor to enhance exploration capabilities.", "configspace": "", "generation": 6, "fitness": 0.2125386489088499, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.213 with standard deviation 0.079. And the mean value of best solutions found was 0.565 (0. is the best) with standard deviation 0.467.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.32329132362612145, 0.1649432592590997, 0.1493813638413286], "final_y": [0.00016872421842729394, 0.5519686475719721, 1.1437195511089777]}, "mutation_prompt": null}
{"id": "b507214c-b895-4b75-8c1f-101d55b8e3af", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Enhanced adaptive Pitch adjustment\n                        best_harmony = harmony_memory[np.argmin(harmony_fitness)]\n                        new_harmony[i] += np.random.uniform(-1, 1) * (best_harmony[i] - new_harmony[i]) * 0.01\n\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.8 - 0.3 * (evaluations / self.budget)  # Adaptive scaling factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation balance by incorporating adaptive mutation scaling and learning from the best harmonies.", "configspace": "", "generation": 7, "fitness": 0.23538917444956006, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.235 with standard deviation 0.173. And the mean value of best solutions found was 0.725 (0. is the best) with standard deviation 0.524.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.15127233074493307, 0.07913128584374529, 0.4757639067600018], "final_y": [1.2169595279140175, 0.9585885127936598, 2.618471235160102e-06]}, "mutation_prompt": null}
{"id": "329c4033-20e7-4e3c-995c-5907688e6f22", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with stochastic weighting\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        stochastic_weight = np.random.uniform(0.9, 1.1)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * stochastic_weight\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce stochastic weighting to further enhance adaptive pitch adjustment in Harmony Search.", "configspace": "", "generation": 8, "fitness": 0.22817707317530408, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.228 with standard deviation 0.071. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.153.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.3285909511810715, 0.17763289260062265, 0.17830737574421807], "final_y": [0.00030225795638581354, 0.3119141350318964, 0.3349163797170632]}, "mutation_prompt": null}
{"id": "51371baf-6c47-4c91-bdab-b85887fa3fca", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Initial Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n        self.opposition_based_rate = 0.2\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n            \n            # Opposition-based learning\n            if np.random.rand() < self.opposition_based_rate:\n                new_harmony = func.bounds.ub + func.bounds.lb - new_harmony\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.3 + 0.7 * np.random.rand()  # Self-adaptive learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance solution diversity and convergence by introducing self-adaptive parameters and opposition-based learning.", "configspace": "", "generation": 9, "fitness": 0.3073580687291134, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.307 with standard deviation 0.147. And the mean value of best solutions found was 0.987 (0. is the best) with standard deviation 1.396.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.35943060499240365, 0.10726115666748048, 0.45538244452745613], "final_y": [1.4893485942453428e-05, 2.9621672824580663, 0.0001454397950590795]}, "mutation_prompt": null}
{"id": "e4d3c0f9-0020-40d9-8f78-75327a0b09b8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget)  # Dynamic CR adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic crossover probability adjustment based on evaluations to improve exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.1158588662876097, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.025. And the mean value of best solutions found was 2.952 (0. is the best) with standard deviation 1.985.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.14101012970330573, 0.08169244398532405, 0.12487402517419932], "final_y": [1.1873178711636134, 5.725363066986029, 1.944120317399429]}, "mutation_prompt": null}
{"id": "7a02fbd5-c7cd-4922-a1f0-68bbce8ee73b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Crossover probability adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate a dynamic crossover probability adaptation to improve exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.26175481610335566, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.092. And the mean value of best solutions found was 0.110 (0. is the best) with standard deviation 0.104.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.20788970478550683, 0.18557613992623945, 0.39179860359832075], "final_y": [0.08136071206558, 0.24915003500155034, 0.00037475837417998126]}, "mutation_prompt": null}
{"id": "b337e83f-b763-499b-9230-b082c89fb73e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    adapt_factor = (1 - (evaluations / self.budget))**2  # Non-linear scaling for PAR\n                    if np.random.rand() < self.par * adapt_factor:\n                        # Adaptive Pitch adjustment\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a non-linear scaling of Pitch Adjusting Rate (PAR) for better exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.19215651230580758, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.192 with standard deviation 0.029. And the mean value of best solutions found was 0.411 (0. is the best) with standard deviation 0.340.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.2086452214094211, 0.15100209964686273, 0.21682221586113892], "final_y": [0.1999788823081676, 0.8906008644399768, 0.1428665181765466]}, "mutation_prompt": null}
{"id": "bdfcbc8a-1e2e-4af1-9d2c-1a13b11e6e07", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n            # Dynamic adjustment of HMCR and PAR\n            self.hmcr = 0.9 * (1 - evaluations / self.budget) + 0.1\n            self.par = 0.4 * (1 - evaluations / self.budget) + 0.2\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic adjustment to both the pitch adjusting rate (PAR) and harmony memory considering rate (HMCR) based on remaining evaluations to improve convergence.", "configspace": "", "generation": 13, "fitness": 0.41043308029761927, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.410 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.4116927189584033, 0.36728024905712087, 0.4523262728773336], "final_y": [1.0450297432110268e-06, 2.813193028036171e-06, 6.2538412171157615e-06]}, "mutation_prompt": null}
{"id": "cec969fb-7ef2-47a8-b30a-9693335dd796", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory with opposition-based learning\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        opposite_memory = func.bounds.lb + func.bounds.ub - harmony_memory[:self.harmony_memory_size//2]\n        harmony_memory[:self.harmony_memory_size//2] = opposite_memory\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce opposition-based learning to enhance exploration and convergence by initializing half of the harmony memory with opposite solutions.", "configspace": "", "generation": 14, "fitness": 0.3951599582911225, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.395 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.3144902918762379, 0.44112555485283256, 0.4298640281442969], "final_y": [7.162141672767129e-05, 0.00012148481248474095, 1.5143424242681773e-08]}, "mutation_prompt": null}
{"id": "f18cbc13-054b-4bba-9f9a-76ecd1da4900", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n            \n            # Adjust PAR exponentially based on evaluations\n            self.par = 0.3 * np.exp(3 * evaluations / self.budget - 3) \n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Adjust the pitch adjusting rate (PAR) to increase exponentially to enhance exploitation as evaluations progress.", "configspace": "", "generation": 15, "fitness": 0.15796153104200192, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.018. And the mean value of best solutions found was 0.869 (0. is the best) with standard deviation 0.528.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.1744041639813838, 0.16688597077415301, 0.1325944583704689], "final_y": [0.3661705672811657, 0.6435787771725812, 1.5984633626433058]}, "mutation_prompt": null}
{"id": "e3dc4bf9-5a34-4599-9ed7-f33a739a062d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with non-linear scaling\n                        adapt_factor = 1 - (evaluations / self.budget) ** 2\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate a non-linear scaling factor in pitch adjustment to dynamically enhance exploration.", "configspace": "", "generation": 16, "fitness": 0.3575029936636323, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.358 with standard deviation 0.110. And the mean value of best solutions found was 0.016 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.35968065338379074, 0.22217153048725524, 0.4906567971198509], "final_y": [0.004195772044615472, 0.044495509762834715, 2.1644396062605667e-08]}, "mutation_prompt": null}
{"id": "813f82a0-13aa-4ff7-b849-4539bf6fbe3c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic crossover probability\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the crossover probability (CR) based on remaining evaluations.", "configspace": "", "generation": 17, "fitness": 0.21166230129557587, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.212 with standard deviation 0.074. And the mean value of best solutions found was 0.513 (0. is the best) with standard deviation 0.463.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.31526496388867453, 0.14561157698455385, 0.17411036301349925], "final_y": [1.6443912373222805e-05, 1.1219367611107727, 0.41558811556596215]}, "mutation_prompt": null}
{"id": "2e5f443e-0534-4936-a76e-295cb24ac64c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.6 + 0.4 * (1 - evaluations / self.budget)  # Adjusted Learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Optimize the learning factor adjustment to strengthen the adaptive mechanism in differential evolution.", "configspace": "", "generation": 18, "fitness": 0.24917328028742391, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.249 with standard deviation 0.049. And the mean value of best solutions found was 0.096 (0. is the best) with standard deviation 0.125.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.28171856675817497, 0.18044861124028877, 0.285352662863808], "final_y": [0.00021569572650099937, 0.2719391508802805, 0.015498653881871898]}, "mutation_prompt": null}
{"id": "5760aeb6-f78e-449b-b1db-9dcfe99fd92c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        # Introducing temperature-based adaptation\n                        temperature = np.exp(-evaluations/self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * temperature\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce temperature-based adaptation to the pitch adjusting rate (PAR) for more effective convergence control.", "configspace": "", "generation": 19, "fitness": 0.3183362210541382, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.318 with standard deviation 0.164. And the mean value of best solutions found was 0.373 (0. is the best) with standard deviation 0.521.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.2667426860328691, 0.1482686707355152, 0.5399973063940303], "final_y": [0.008966354285065268, 1.1090667449664673, 1.8129490698137178e-07]}, "mutation_prompt": null}
{"id": "63251acf-9904-4cdf-ac2e-bd2ee7a5ddcb", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (1 - evaluations / self.budget)  # Dynamic crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Implement dynamic adjustment to the crossover probability (cr) to potentially enhance solution diversity and convergence rate.", "configspace": "", "generation": 20, "fitness": 0.18406644011450612, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.043. And the mean value of best solutions found was 0.644 (0. is the best) with standard deviation 0.531.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.24343489950552555, 0.14327821300287347, 0.16548620783511936], "final_y": [0.0076524445568089934, 1.3080801548749315, 0.6158857158697094]}, "mutation_prompt": null}
{"id": "f9455b34-2e44-40f8-8ea3-d3ac78f0245a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Dynamic CR adjustment\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic adjustment to the crossover probability (CR) based on remaining evaluations to enhance diversity.", "configspace": "", "generation": 21, "fitness": 0.26175481610335566, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.092. And the mean value of best solutions found was 0.110 (0. is the best) with standard deviation 0.104.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.20788970478550683, 0.18557613992623945, 0.39179860359832075], "final_y": [0.08136071206558, 0.24915003500155034, 0.00037475837417998126]}, "mutation_prompt": null}
{"id": "8c66f455-3096-4003-87a3-7a226eb9a49c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamic adjustment of harmony memory size\n            self.harmony_memory_size = int(10 + (self.budget - evaluations) / self.budget * 10)\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic adjustment of harmony memory size based on remaining evaluations to enhance diversity.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {}, "mutation_prompt": null}
{"id": "7c13739c-0b28-460f-b890-fe6f444fb9b8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Adaptive harmony memory size reduction\n            current_memory_size = max(2, int(self.harmony_memory_size * (1 - evaluations / self.budget)))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate adaptive harmony memory size reduction to focus search efforts during later optimization stages.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {}, "mutation_prompt": null}
{"id": "d92df0e7-e170-4407-bef3-899dc117bca9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr * np.random.rand(), mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce stochastic scaling factor adjustment for crossover probability based on iteration progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.22828321853844954, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.228 with standard deviation 0.013. And the mean value of best solutions found was 0.203 (0. is the best) with standard deviation 0.075.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.21152185474069451, 0.23063105742269796, 0.24269674345195613], "final_y": [0.30312952729370896, 0.18073981215626886, 0.12372892596275191]}, "mutation_prompt": null}
{"id": "8369775d-839e-49cb-b46d-95255c1236ef", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Adjust harmony memory size adaptively\n            self.harmony_memory_size = max(5, int(10 * (1 - evaluations / self.budget)))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce an adaptive harmony memory size based on remaining evaluations to maintain diversity and enhance convergence.", "configspace": "", "generation": 25, "fitness": 0.21902597078989838, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.219 with standard deviation 0.058. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.208.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.16122476573732591, 0.29792551677716816, 0.19792762985520107], "final_y": [0.5035391315409362, 0.010459428084545865, 0.1443051694783229]}, "mutation_prompt": null}
{"id": "82f9a24e-0752-4017-b100-44d758d3265b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (evaluations / self.budget)  # Dynamic adjustment of crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic adjustment to crossover probability (CR) for better exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.35397663149679737, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.354 with standard deviation 0.047. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.29038185481264756, 0.40197126779290937, 0.36957677188483506], "final_y": [0.00203211079846591, 0.00016206589293864425, 0.0011203715309905861]}, "mutation_prompt": null}
{"id": "6ba62f9b-80e1-4f5b-8019-c60d86eb66ca", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Dynamic crossover probability adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic crossover probability adjustment based on remaining evaluations to balance exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.26175481610335566, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.092. And the mean value of best solutions found was 0.110 (0. is the best) with standard deviation 0.104.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.20788970478550683, 0.18557613992623945, 0.39179860359832075], "final_y": [0.08136071206558, 0.24915003500155034, 0.00037475837417998126]}, "mutation_prompt": null}
{"id": "da6c1d4d-c738-4e56-9d97-0bca6b5baffd", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.4 + 0.5 * (evaluations / self.budget)  # Adaptive CR adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Adaptively adjust the crossover probability (CR) based on remaining evaluations for enhanced solution diversity.", "configspace": "", "generation": 28, "fitness": 0.22716204103498502, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.071. And the mean value of best solutions found was 0.269 (0. is the best) with standard deviation 0.293.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.32411333715613044, 0.19973619507800666, 0.15763659087081794], "final_y": [0.0038423819798115086, 0.12569318073274557, 0.677291753294612]}, "mutation_prompt": null}
{"id": "43b15d4a-2a87-40a6-ac43-19e52f34d66e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size\n            self.harmony_memory_size = max(5, int(10 * (1 - evaluations / self.budget)))\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Dynamic harmony memory size adjustment based on remaining evaluations to balance exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.2223959413044074, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.222 with standard deviation 0.056. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.142.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.30197890969692365, 0.18008642432181843, 0.1851224898944801], "final_y": [0.008255952115893415, 0.3407833928339567, 0.2646543000804839]}, "mutation_prompt": null}
{"id": "64d76a15-d6c1-4e26-9d88-208437868e40", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce exploration enhancement by dynamically adjusting harmony memory size based on evaluations.", "configspace": "", "generation": 30, "fitness": 0.5141541361346559, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.514 with standard deviation 0.048. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.5541239576350143, 0.5416634041775723, 0.4466750465913809], "final_y": [4.0455715623019785e-07, 7.10118888303147e-06, 0.00017509560785004073]}, "mutation_prompt": null}
