{"id": "12e8047f-ec33-4a9d-964e-c85555543102", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Adaptive Boundary Refinement with Local Search (ABR-LS) combines initial uniform sampling with adaptive boundary refinement and local search using BFGS to optimize smooth and low-dimensional black box functions efficiently.", "configspace": "", "generation": 0, "fitness": 0.8432268167047452, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.037. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7919540005724399, 0.8575354788705214, 0.8801909706712745], "final_y": [8.348725856425736e-08, 2.7483824602686643e-08, 2.557050102683057e-09]}, "mutation_prompt": null}
{"id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) optimizes smooth and low-dimensional functions by integrating momentum-based boundary refinement for improved convergence speed.", "configspace": "", "generation": 1, "fitness": 0.8576252797806928, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "12e8047f-ec33-4a9d-964e-c85555543102", "metadata": {"aucs": [0.8356469335443953, 0.8430892534768955, 0.8941396523207877], "final_y": [3.146417414264372e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "db84935b-dc82-490f-8b5e-5f8e4e87f7f2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Adjusted shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) optimizes smooth and low-dimensional functions by integrating momentum-based boundary refinement and dynamic sampling adjustment for improved convergence speed.", "configspace": "", "generation": 2, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "dce769ec-f86c-4f23-9d2c-0fd61f854def", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='trust-constr', bounds=refined_bounds)  # Change here\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Local Exploration with Curvature-Aware Refinement (ELE-CAR) incorporates curvature sensitivity for improved exploration in smooth landscapes.", "configspace": "", "generation": 3, "fitness": 0.5530156835290789, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.553 with standard deviation 0.314. And the mean value of best solutions found was 1.153 (0. is the best) with standard deviation 1.630.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.7339111697327656, 0.11151995448224883, 0.8136159263722225], "final_y": [1.818563055280448e-07, 3.457594396618161, 5.655078527670846e-08]}, "mutation_prompt": null}
{"id": "96599001-4c25-4231-9dcd-7767dd81ea54", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed shrink factor for better refinement\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.85 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.15  # Adjusted momentum influence\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Modified Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) by improving initial sample coverage and momentum influence for enhanced convergence.", "configspace": "", "generation": 4, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "407c2674-cab5-493a-9597-1eefcf4d91f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Reduced shrink factor for finer adjustments\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Refinement of the Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) algorithm by adjusting the shrink factor for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "3924b428-5e21-4b41-b000-b5fe85af15bd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Updated momentum\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Momentum and Boundary Scaling (EMBS) refines local optima convergence by dynamically adjusting momentum scaling.", "configspace": "", "generation": 6, "fitness": 0.8576252797806928, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8356469335443953, 0.8430892534768955, 0.8941396523207877], "final_y": [3.146417414264372e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "f2df9f9f-a81f-4795-8b2f-c295a65f7f6e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 * (1 + 0.1 * (self.budget - function_evals) / self.budget)\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Incorporating a dynamic shrink factor for boundary refinement in Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) to improve convergence speed.", "configspace": "", "generation": 7, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) with improved initial sampling by incorporating variance-based scaling for better starting conditions.", "configspace": "", "generation": 8, "fitness": 0.8605235728673838, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8603283571569454, 0.8725322639254003, 0.8487100975198054], "final_y": [1.6262696571239394e-08, 1.6745554089326937e-09, 2.4584055362991597e-08]}, "mutation_prompt": null}
{"id": "cc84d706-4838-4b40-bc87-7b712c3058cf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed from 0.8 to 0.85\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) by adjusting the shrink factor to increase exploration in the final stages.", "configspace": "", "generation": 9, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "415b09c4-5b70-410f-9bc2-df575dec4aff", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        decay_rate = 0.01  # New decay factor for shrink_factor\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = max(0.4, 0.8 * (1 - decay_rate * function_evals))  # Modified shrink_factor with decay\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a decay factor to the shrink_factor, adapting boundary refinement to gradually narrow the search space more efficiently.", "configspace": "", "generation": 10, "fitness": 0.8415520244089457, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8387658514990112, 0.8359839825235369, 0.849906239204289], "final_y": [4.363490347582046e-09, 3.5990160606368895e-08, 5.8230389074446605e-09]}, "mutation_prompt": null}
{"id": "04ed5446-57c7-4455-8bb1-f7902b22acc7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = min(0.8, 1 - best_value / 10)  # Dynamic adjustment based on progress\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a dynamic shrink factor adjustment to improve the convergence speed by adapting the search space based on progress.", "configspace": "", "generation": 11, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "3042978f-0f8b-4cc8-a885-8041c8b3ace3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05 * np.linalg.norm(x0 - best_point)  # Momentum update with adaptive scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introducing adaptive velocity scaling in momentum update to enhance convergence speed and solution quality.", "configspace": "", "generation": 12, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "0b70a0cb-41b8-4372-bcfc-d64e74f587aa", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.7 + 0.2 * (res.success)  # Dynamically adjust shrink factor based on success\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) now incorporates a dynamic shrink factor adjustment based on the current success rate of optimization steps.", "configspace": "", "generation": 13, "fitness": 0.8422443666277006, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8583892571067692, 0.8359839825235369, 0.8323598602527958], "final_y": [9.15739950124202e-09, 3.5990160606368895e-08, 4.604746818710519e-08]}, "mutation_prompt": null}
{"id": "b4adbd9f-f34c-4821-91ee-ff3750820b06", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved Adaptive Boundary Refinement with Local Search and Momentum (IABR-LSM) enhances convergence by adjusting the momentum update factor for more dynamic exploration.", "configspace": "", "generation": 14, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "2e95d3de-90cd-4d7a-83f0-acc6c87e3ab2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Momentum update with acceleration\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved convergence speed by adjusting the velocity update with a momentum-based acceleration term.", "configspace": "", "generation": 15, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "77fae17e-04c0-41d3-936c-6c1675af61a6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            improvement_rate = (best_value - res.fun) / best_value if best_value != 0 else 0\n            shrink_factor = 0.8 + 0.2 * improvement_rate  # Dynamic adjustment of shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic shrink factor adjustment based on improvement rate to enhance boundary refinement.", "configspace": "", "generation": 16, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "686ff544-30e1-4651-a701-b0e83d388ab4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Adaptive momentum scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced EABR-LS with adaptive momentum scaling for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
