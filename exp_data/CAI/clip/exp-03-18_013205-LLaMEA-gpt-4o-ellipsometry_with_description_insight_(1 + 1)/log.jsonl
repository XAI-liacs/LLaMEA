{"id": "12e8047f-ec33-4a9d-964e-c85555543102", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Adaptive Boundary Refinement with Local Search (ABR-LS) combines initial uniform sampling with adaptive boundary refinement and local search using BFGS to optimize smooth and low-dimensional black box functions efficiently.", "configspace": "", "generation": 0, "fitness": 0.8432268167047452, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.037. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7919540005724399, 0.8575354788705214, 0.8801909706712745], "final_y": [8.348725856425736e-08, 2.7483824602686643e-08, 2.557050102683057e-09]}, "mutation_prompt": null}
{"id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) optimizes smooth and low-dimensional functions by integrating momentum-based boundary refinement for improved convergence speed.", "configspace": "", "generation": 1, "fitness": 0.8576252797806928, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "12e8047f-ec33-4a9d-964e-c85555543102", "metadata": {"aucs": [0.8356469335443953, 0.8430892534768955, 0.8941396523207877], "final_y": [3.146417414264372e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "db84935b-dc82-490f-8b5e-5f8e4e87f7f2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Adjusted shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) optimizes smooth and low-dimensional functions by integrating momentum-based boundary refinement and dynamic sampling adjustment for improved convergence speed.", "configspace": "", "generation": 2, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
