{"id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "A novel hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently explore and exploit search spaces for black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.21355062839146954, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.021. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": null, "metadata": {"aucs": [0.22851012932240633, 0.2289699991091626, 0.1831717567428397], "final_y": [0.08380205140393618, 0.1058188283726997, 0.22803423363764386]}, "mutation_prompt": null}
{"id": "154acd53-e187-4bc5-a776-2695172a8a5d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Dynamic inertia weight adjustment\n                inertia = self.inertia_weight * (0.5 + np.random.rand() / 2) * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n                # Introduce random jumps\n                if np.random.rand() < 0.1:\n                    particles[i] = np.random.uniform(lb, ub, self.dim)\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by dynamically adjusting inertia and introducing random jumps for improved exploration.", "configspace": "", "generation": 1, "fitness": 0.2110399438207321, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.023. And the mean value of best solutions found was 0.282 (0. is the best) with standard deviation 0.217.", "error": "", "parent_id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "metadata": {"aucs": [0.22400554783116478, 0.2301326531163136, 0.17898163051471794], "final_y": [0.24232481763500852, 0.03774217945118173, 0.5659791734469436]}, "mutation_prompt": null}
{"id": "f3b0e2e0-dfd0-48c8-90d1-1a2bb48d47c1", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive inertia to enhance search efficiency in black-box optimization problems.", "configspace": "", "generation": 2, "fitness": 0.21737733820780678, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.217 with standard deviation 0.033. And the mean value of best solutions found was 0.086 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "metadata": {"aucs": [0.26322322974754875, 0.18550841571795063, 0.20340036915792092], "final_y": [0.014383735256230552, 0.16186816309457602, 0.08239557682008332]}, "mutation_prompt": null}
{"id": "c2dd37ff-c3b7-44c9-9688-c0bc56d2e57d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)  # Enhanced exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA with dynamic population size adjustment and enhanced velocity update rules for better exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.22386534484476198, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.018. And the mean value of best solutions found was 0.102 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "f3b0e2e0-dfd0-48c8-90d1-1a2bb48d47c1", "metadata": {"aucs": [0.20832950814000495, 0.21419768020225283, 0.24906884619202818], "final_y": [0.14007196156125104, 0.09502200790753494, 0.07167576395853585]}, "mutation_prompt": null}
{"id": "a44db520-1323-49c2-9869-00f1e043e8e3", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adjusting velocity update rules and personal best position strategy for improved exploration-exploitation.", "configspace": "", "generation": 4, "fitness": 0.28123336087949147, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.281 with standard deviation 0.014. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "c2dd37ff-c3b7-44c9-9688-c0bc56d2e57d", "metadata": {"aucs": [0.2714111824888148, 0.271790052870718, 0.3004988472789416], "final_y": [0.041508452599182365, 0.05772925403943972, 0.00955031933674791]}, "mutation_prompt": null}
{"id": "009c749d-17ca-474c-85d1-efb4d00881c2", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * (1 - evaluations/self.budget) * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduced a dynamic social constant that decreases over time to balance exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.24369972303735787, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.043. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.116.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.24246670727537434, 0.19227301739738034, 0.29635944443931894], "final_y": [0.06551301004954872, 0.28359557551076425, 0.01716562449445154]}, "mutation_prompt": null}
{"id": "2bda5400-f3a8-43e8-aa03-f3d6aedad162", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                # Dynamic adjustment of cognitive and social constants\n                cognitive = (self.cognitive_constant + np.random.rand()) * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = (self.social_constant + np.random.rand()) * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with dynamic cognitive and social constants for improved convergence and optimization.", "configspace": "", "generation": 6, "fitness": 0.22882565348963657, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.020. And the mean value of best solutions found was 0.061 (0. is the best) with standard deviation 0.039.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.20472445700628905, 0.22844646257012713, 0.25330604089249353], "final_y": [0.1019886151014442, 0.00856913221090501, 0.07338192790885656]}, "mutation_prompt": null}
{"id": "de49f011-0e4e-44e1-bece-cd958d0064be", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * (0.5 + np.random.rand(self.dim)) * (global_best_position - particle)  # Adjusted line\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adding a dynamic social constant adjustment for improved convergence stability.", "configspace": "", "generation": 7, "fitness": 0.21894169062336866, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.219 with standard deviation 0.014. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.058.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.20562289545905443, 0.23762769821877128, 0.21357447819228026], "final_y": [0.17357414095834353, 0.07643376862135323, 0.21611268910389633]}, "mutation_prompt": null}
{"id": "75a8f582-d6f4-436d-9d1f-5a4ba61687a4", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim) + np.random.normal(0, 0.1, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by incorporating Gaussian noise for finer exploration-exploitation balancing.", "configspace": "", "generation": 8, "fitness": 0.22885785589564425, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.024. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.056.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2216121250786447, 0.20316494840478205, 0.26179649420350604], "final_y": [0.12862150872878939, 0.1710093785124371, 0.036215469636141036]}, "mutation_prompt": null}
{"id": "8d544ead-c8d4-4a9c-8adf-3e76969d7dbb", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim) * np.log(1 + 0.5 * evaluations/self.budget)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Adaptive velocity update for improved convergence in the Enhanced HybridPSOSA.", "configspace": "", "generation": 9, "fitness": 0.26422455739839157, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.264 with standard deviation 0.022. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.27283488283786483, 0.2859267217974981, 0.23391206755981175], "final_y": [0.023690031087307523, 0.016091027663687932, 0.0459687884994501]}, "mutation_prompt": null}
{"id": "d9af4b34-17f9-4e4c-a25a-19c13c77c5dd", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA by enhancing velocity perturbation for better exploitation. ", "configspace": "", "generation": 10, "fitness": 0.23742091216737207, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.020. And the mean value of best solutions found was 0.070 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2102481924982127, 0.25932443329924315, 0.2426901107046604], "final_y": [0.10089303964338477, 0.02588949895849511, 0.08426869647594185]}, "mutation_prompt": null}
{"id": "74217ecd-e8cb-43cf-8756-07182c01ec76", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.6  # Adjusted social constant\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Slightly increased the social constant to boost the influence of the global best position for enhanced convergence.", "configspace": "", "generation": 11, "fitness": 0.23051424549798086, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.023. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.075.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.24813781687320313, 0.19754213114274866, 0.2458627884779908], "final_y": [0.026330785309724537, 0.20903740878662166, 0.10295297535802617]}, "mutation_prompt": null}
{"id": "4c569127-ec54-4e13-bfd4-a40bd68b5543", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Refined HybridPSOSA by implementing chaotic local search with dynamic weight adjustments for enhanced exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.22962543420553472, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.230 with standard deviation 0.021. And the mean value of best solutions found was 0.092 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.21376206439427847, 0.21627824184927502, 0.25883599637305066], "final_y": [0.1155320118615739, 0.12495623827530997, 0.03586426270920761]}, "mutation_prompt": null}
{"id": "9b50efe6-7e34-46d6-a342-58b683f231a9", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.7  # Adjusted cognitive constant for improved strategy\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by fine-tuning the cognitive constant for better balancing exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.22651012634599277, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.024. And the mean value of best solutions found was 0.064 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.22270062018705294, 0.19952678919309674, 0.2573029696578286], "final_y": [0.0935099365460624, 0.0642915505471973, 0.032914553739592955]}, "mutation_prompt": null}
{"id": "977a0a7b-9b29-4024-ad1c-49ec424c9632", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.0 + np.random.rand() * 1.0  # Dynamic cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with a dynamic cognitive constant for improved personal best convergence.", "configspace": "", "generation": 14, "fitness": 0.2438436090731895, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.009. And the mean value of best solutions found was 0.080 (0. is the best) with standard deviation 0.059.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.23799014800734009, 0.256574528013072, 0.23696615119915643], "final_y": [0.163179623898719, 0.03140111790202975, 0.0467922171439402]}, "mutation_prompt": null}
{"id": "e1350d4e-b5ab-4415-8366-0f046cc3293d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            # Adaptively update cognitive and social constants\n            self.cognitive_constant = 1.5 * (1 - evaluations / self.budget)\n            self.social_constant = 1.5 * (evaluations / self.budget)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by introducing adaptive cognitive and social constants for improved convergence balance.", "configspace": "", "generation": 15, "fitness": 0.2660331419706644, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.266 with standard deviation 0.009. And the mean value of best solutions found was 0.027 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2547000231174321, 0.26565551717863667, 0.27774388561592445], "final_y": [0.03006944400510616, 0.021245006195694374, 0.029519576456239753]}, "mutation_prompt": null}
{"id": "0350da9c-829d-4607-9d52-d04a617c4fa5", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = np.random.uniform(1.0, 2.0) * self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = np.random.uniform(1.0, 2.0) * self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with improved velocity update using adaptive cognitive and social factors for better convergence.", "configspace": "", "generation": 16, "fitness": 0.20834019284181082, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.018. And the mean value of best solutions found was 0.276 (0. is the best) with standard deviation 0.044.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.1914809292843931, 0.20020833293896534, 0.23333131630207404], "final_y": [0.27353694920722693, 0.3318931182687758, 0.22301738900606546]}, "mutation_prompt": null}
{"id": "bbeea194-b229-4feb-9970-a9aebc1107fb", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                self.cognitive_constant = 1.5 + 0.5 * np.random.rand()  # Adjusted line\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic cognitive constant adjustment to enhance local search adaptability.", "configspace": "", "generation": 17, "fitness": 0.21231252625064742, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.212 with standard deviation 0.028. And the mean value of best solutions found was 0.091 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.191389137985013, 0.19345413847361104, 0.2520943022933182], "final_y": [0.15747925504292376, 0.10408692393798306, 0.011483487372659308]}, "mutation_prompt": null}
