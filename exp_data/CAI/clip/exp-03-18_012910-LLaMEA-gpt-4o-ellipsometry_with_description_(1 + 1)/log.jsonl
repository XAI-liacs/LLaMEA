{"id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "A novel hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently explore and exploit search spaces for black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.21355062839146954, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.021. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": null, "metadata": {"aucs": [0.22851012932240633, 0.2289699991091626, 0.1831717567428397], "final_y": [0.08380205140393618, 0.1058188283726997, 0.22803423363764386]}, "mutation_prompt": null}
{"id": "154acd53-e187-4bc5-a776-2695172a8a5d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Dynamic inertia weight adjustment\n                inertia = self.inertia_weight * (0.5 + np.random.rand() / 2) * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n                # Introduce random jumps\n                if np.random.rand() < 0.1:\n                    particles[i] = np.random.uniform(lb, ub, self.dim)\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by dynamically adjusting inertia and introducing random jumps for improved exploration.", "configspace": "", "generation": 1, "fitness": 0.2110399438207321, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.023. And the mean value of best solutions found was 0.282 (0. is the best) with standard deviation 0.217.", "error": "", "parent_id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "metadata": {"aucs": [0.22400554783116478, 0.2301326531163136, 0.17898163051471794], "final_y": [0.24232481763500852, 0.03774217945118173, 0.5659791734469436]}, "mutation_prompt": null}
{"id": "f3b0e2e0-dfd0-48c8-90d1-1a2bb48d47c1", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive inertia to enhance search efficiency in black-box optimization problems.", "configspace": "", "generation": 2, "fitness": 0.21737733820780678, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.217 with standard deviation 0.033. And the mean value of best solutions found was 0.086 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "metadata": {"aucs": [0.26322322974754875, 0.18550841571795063, 0.20340036915792092], "final_y": [0.014383735256230552, 0.16186816309457602, 0.08239557682008332]}, "mutation_prompt": null}
{"id": "c2dd37ff-c3b7-44c9-9688-c0bc56d2e57d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)  # Enhanced exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA with dynamic population size adjustment and enhanced velocity update rules for better exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.22386534484476198, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.018. And the mean value of best solutions found was 0.102 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "f3b0e2e0-dfd0-48c8-90d1-1a2bb48d47c1", "metadata": {"aucs": [0.20832950814000495, 0.21419768020225283, 0.24906884619202818], "final_y": [0.14007196156125104, 0.09502200790753494, 0.07167576395853585]}, "mutation_prompt": null}
{"id": "a44db520-1323-49c2-9869-00f1e043e8e3", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adjusting velocity update rules and personal best position strategy for improved exploration-exploitation.", "configspace": "", "generation": 4, "fitness": 0.28123336087949147, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.281 with standard deviation 0.014. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "c2dd37ff-c3b7-44c9-9688-c0bc56d2e57d", "metadata": {"aucs": [0.2714111824888148, 0.271790052870718, 0.3004988472789416], "final_y": [0.041508452599182365, 0.05772925403943972, 0.00955031933674791]}, "mutation_prompt": null}
