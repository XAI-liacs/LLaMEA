{"id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with a dynamic population size and self-adaptive control parameters for efficient exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.3527530543742902, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.353 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3806146168952741, 0.3669503680478776, 0.3106941781797189], "final_y": [4.70013625454655e-05, 9.554337524336317e-05, 0.0009981177690130498]}, "mutation_prompt": null}
{"id": "fc624c83-3959-4787-9a92-3193db215bf7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Opposition-based learning\n                opposite = lower_bound + upper_bound - trial\n                trial_fitness = func(trial)\n                opposite_fitness = func(opposite)\n                budget_used += 2\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                elif opposite_fitness < fitness[i]:\n                    new_population[i] = opposite\n                    fitness[i] = opposite_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with opposition-based learning for enhanced global exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.2078921107475786, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.012. And the mean value of best solutions found was 0.027 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "metadata": {"aucs": [0.20064619963622987, 0.19844370708789505, 0.22458642551861085], "final_y": [0.025913589337605233, 0.015390260514256151, 0.03821447491118889]}, "mutation_prompt": null}
{"id": "09984399-f4e0-47d3-9c02-91683f3e1f4d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Adaptive Differential Evolution algorithm with a modified dynamic population size calculation for improved exploration and exploitation in black box optimization.", "configspace": "", "generation": 2, "fitness": 0.44315382605698367, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.443 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "metadata": {"aucs": [0.43776708657435326, 0.4117814624240419, 0.479912929172556], "final_y": [1.0618204943030353e-05, 2.4738314956875467e-06, 2.793910027327928e-07]}, "mutation_prompt": null}
{"id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Optimizes the crossover probability range and uses elitism to retain best solutions in Adaptive Differential Evolution.", "configspace": "", "generation": 3, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "09984399-f4e0-47d3-9c02-91683f3e1f4d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "e2a247e8-d0a0-44f8-85ca-c11e802aece9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) * (1 - budget_used / self.budget)  # Adjusted differential weight\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adaptation of the differential weight to improve exploration and exploitation balance in Adaptive Differential Evolution.", "configspace": "", "generation": 4, "fitness": 0.4597138229276691, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.460 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4943925471612425, 0.4124880416022717, 0.47226088001949296], "final_y": [3.7976495248939712e-06, 0.00021562432189659372, 5.922364449999288e-06]}, "mutation_prompt": null}
{"id": "20960695-b987-46be-a456-be35958d7ccd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) * (1 - budget_used / self.budget)  # Dynamic mutation scale\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation scaling and enhanced elitism.", "configspace": "", "generation": 5, "fitness": 0.4597138229276691, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.460 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4943925471612425, 0.4124880416022717, 0.47226088001949296], "final_y": [3.7976495248939712e-06, 0.00021562432189659372, 5.922364449999288e-06]}, "mutation_prompt": null}
{"id": "657dd9ca-8d21-484b-8ea0-9d39bf609d0d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                f_dynamic = self.f * (1 - budget_used / self.budget)  # Time-varying scaling factor\n                mutant = np.clip(x1 + f_dynamic * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces time-varying scaling factor and adaptive mutation strategy in Adaptive Differential Evolution.", "configspace": "", "generation": 6, "fitness": 0.43361587462193757, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.044. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4063356745738991, 0.4955681602650055, 0.3989437890269081], "final_y": [0.00024090930243552867, 2.215669675324738e-06, 0.00013512662376298325]}, "mutation_prompt": null}
{"id": "75173052-a493-4d0e-88c0-495a4cf64ac3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Early stopping based on convergence\n            if np.std(fitness) < 1e-6:\n                break\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce early stopping based on convergence stability to enhance efficiency in Adaptive Differential Evolution.", "configspace": "", "generation": 7, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "1d01a6c8-6346-4f4d-b953-c6b3fb868edc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.8  # Initial crossover probability adjusted\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.5, 0.9)  # More aggressive mutation factor adjustment\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by modifying the initial crossover probability and dynamically updating the mutation factor more aggressively.", "configspace": "", "generation": 8, "fitness": 0.4031475896536533, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.403 with standard deviation 0.056. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.38652925940605276, 0.4789672861057658, 0.3439462234491415], "final_y": [0.0008221020032459232, 4.846220867717656e-06, 0.001625527072405441]}, "mutation_prompt": null}
{"id": "6d284879-687a-4633-946f-510d8d544d5d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.4, 0.9)  # Self-adaptive step-size\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing a self-adaptive step-size evolution strategy in the mutation process to improve convergence.", "configspace": "", "generation": 9, "fitness": 0.43378810340222934, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4542006023785945, 0.41349996015064494, 0.43366374767744864], "final_y": [1.4538270635533636e-05, 4.6135565212979066e-05, 3.252567744265981e-05]}, "mutation_prompt": null}
{"id": "68088284-799b-4221-8e14-26fd6c79da2d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            fitness_variance = np.var(fitness)\n            self.f = np.random.uniform(0.4, 0.9) * (1.0 - fitness_variance)  # Dynamic adaptation\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adaptation of the differential weight `f` based on the fitness variance to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.12051232765949964, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.121 with standard deviation 0.018. And the mean value of best solutions found was 2.867 (0. is the best) with standard deviation 0.971.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.11666235193642072, 0.10011199651773361, 0.14476263452434457], "final_y": [3.0043832434304316, 3.980461312446879, 1.6148440520314065]}, "mutation_prompt": null}
{"id": "b3df4b29-039e-4853-9211-91c93df437c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                adaptive_f = self.f * np.random.uniform(0.8, 1.2)  # Adaptive mutation strategy\n                mutant = np.clip(x1 + adaptive_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far, increase elitism\n            best_indices = np.argsort(fitness)[:3]\n            population[:3] = population[best_indices]\n            fitness[:3] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive mutation strategy alongside modified elitism to enhance exploration and exploitation balance in Differential Evolution.", "configspace": "", "generation": 11, "fitness": 0.42652805532720234, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.427 with standard deviation 0.082. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.36426534085560325, 0.37314549218101156, 0.542173332944992], "final_y": [0.0009760139727455138, 0.0007968573931954813, 1.8728769094875007e-08]}, "mutation_prompt": null}
{"id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a condition to adjust mutation control parameter `f` based on population diversity to enhance exploration.", "configspace": "", "generation": 12, "fitness": 0.504310745559167, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.504 with standard deviation 0.052. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.5169402830191157, 0.5607198572481301, 0.4352720964102553], "final_y": [4.924687420783526e-07, 1.0959389186176737e-07, 1.2478064611987484e-05]}, "mutation_prompt": null}
{"id": "ddbf97f1-9b71-4efa-9bf8-e2d910fb3eac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Early stopping criterion based on convergence\n            if np.std(fitness) < 1e-5:\n                break\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a stopping criterion based on convergence to improve efficiency.", "configspace": "", "generation": 13, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "172efa25-88f5-475f-93e6-281032c69727", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.6, 0.9) if diversity > 0.1 else np.random.uniform(0.4, 0.6)\n            self.cr = np.random.uniform(0.8, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation and crossover parameters based on population diversity for improved adaptation.", "configspace": "", "generation": 14, "fitness": 0.4283402570941681, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.428 with standard deviation 0.065. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.36474932169066343, 0.51789572013288, 0.40237572945896083], "final_y": [0.0002515166799446886, 1.623254430762373e-07, 2.0480821720932618e-05]}, "mutation_prompt": null}
{"id": "48b229ae-05f6-418c-b285-adec2593ad67", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.5, 0.9)  # Update mutation control parameter dynamically\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation strategy of AdaptiveDifferentialEvolution by incorporating a dynamic scaling factor in the mutation operation for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.41135510728567143, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.411 with standard deviation 0.071. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.5038580525171826, 0.39806953736134154, 0.33213773197849017], "final_y": [1.8296607479907592e-06, 0.00035809785468030286, 0.0031370777006308054]}, "mutation_prompt": null}
{"id": "c5038ca7-5968-4a74-a3d0-3756e296358f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 0.95) if diversity > 0.2 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a condition to dynamically adjust crossover probability `cr` based on population diversity to enhance exploration.", "configspace": "", "generation": 16, "fitness": 0.4714216663229082, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.471 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.4711031634259526, 0.4398671100832303, 0.5032947254595417], "final_y": [1.437339345744192e-06, 2.3357854575766732e-05, 6.887967769639786e-07]}, "mutation_prompt": null}
{"id": "6f555f82-ac53-46fd-a223-2d3bdffe05b1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            fitness_change = np.max(fitness) - np.min(fitness)  # Measure fitness change\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 and fitness_change > 0.05 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting mutation rate based on both diversity and fitness change.", "configspace": "", "generation": 17, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "4b1fe4b6-655b-40ab-9c9a-86460dc1f7d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                # Change 1: Refine mutation\n                mutant = np.clip(x1 + self.f * ((x2 - x3) + 0.1 * (population.mean(axis=0) - x1)), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            # Change 2: Refine population size adjustment\n            self.population_size = max(4, int(10 * self.dim * (0.9 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine mutation step by using weighted averaging of differences to enhance convergence.", "configspace": "", "generation": 18, "fitness": 0.3294988988401779, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.022. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.29920609239585594, 0.35064601584148336, 0.33864458828319444], "final_y": [0.015254546181664849, 0.0019717636709388506, 0.004257883699924294]}, "mutation_prompt": null}
{"id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting crossover probability based on population diversity.", "configspace": "", "generation": 19, "fitness": 0.5214975777068988, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.521 with standard deviation 0.078. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.5795098437873853, 0.4112872763160912, 0.5736956130172197], "final_y": [3.1715198908980014e-08, 0.00010114915846889675, 5.20753538587927e-08]}, "mutation_prompt": null}
{"id": "d453d36c-e297-4167-aa29-c31d116f6730", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                iteration_progress = budget_used / self.budget\n                adaptive_f = self.f * (1 + 0.5 * np.sin(iteration_progress * np.pi))  # Adaptive mutation scaling\n                mutant = np.clip(x1 + adaptive_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on iteration progress to enhance convergence.", "configspace": "", "generation": 20, "fitness": 0.3310783539904572, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.331 with standard deviation 0.013. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.31783323893082494, 0.3488775738544502, 0.32652424918609657], "final_y": [0.0027094995814246734, 0.000853635763111298, 0.004739694672978463]}, "mutation_prompt": null}
{"id": "9758d36d-575f-4630-9b8a-375c7d5fc4cf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.3, 0.8) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.7, 0.9)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce stochastic control parameter adaptation to improve diversity handling in Adaptive Differential Evolution.", "configspace": "", "generation": 21, "fitness": 0.45826855185405097, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.458 with standard deviation 0.039. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5134794261126598, 0.43670094367997525, 0.42462528576951786], "final_y": [6.354294676088701e-07, 1.5652911055604458e-05, 5.371529094223266e-05]}, "mutation_prompt": null}
{"id": "b32d3bdf-2ff6-4bb6-af68-bda4210b92f8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n            self.f *= (1 - budget_used / self.budget)  # Adaptive scaling of differential weight\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling of the differential weight based on budget utilization to improve convergence.", "configspace": "", "generation": 22, "fitness": 0.4456522535860137, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.446 with standard deviation 0.081. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5602675051375776, 0.39655372018011403, 0.3801355354403494], "final_y": [1.945581384060202e-07, 0.00014229167832163973, 0.0010903569148023162]}, "mutation_prompt": null}
{"id": "c38c83cc-d69a-4c90-a2b9-73cc28ca8fe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                f_local = np.random.uniform(0.4, 0.9) if np.random.rand() < 0.5 else np.random.uniform(0.1, 0.4)\n                mutant = np.clip(x1 + f_local * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptability by refining mutation strategy based on historical success. ", "configspace": "", "generation": 23, "fitness": 0.38206873226415716, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.382 with standard deviation 0.077. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4897215977090871, 0.317606405291736, 0.3388781937916483], "final_y": [5.414545376178547e-06, 0.006854402534504363, 0.004306751481858991]}, "mutation_prompt": null}
{"id": "7642dd9c-3b7e-42e6-b410-c31b4c34a73f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.15 else np.random.uniform(0.5, 0.7)  # Adjusted line\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.15 else np.random.uniform(0.75, 0.85)  # Adjusted line\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enrich selection pressure by refining crossover probability adjustment based on improved diversity analysis.", "configspace": "", "generation": 24, "fitness": 0.45077349972962133, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.054. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46904768229785254, 0.37712702381717433, 0.5061457930738371], "final_y": [6.928386180759781e-07, 0.00011796374707335577, 1.2538729618198218e-06]}, "mutation_prompt": null}
{"id": "dd6ef9c3-4d77-467b-b1d6-4e437490abac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.3, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling of differential weight (f) based on convergence speed to enhance exploitation-exploration balance.", "configspace": "", "generation": 25, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "6ce6a8c5-b08f-434a-b657-d03a270f2b1c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Add random restart mechanism\n            if diversity < 0.05:  # Trigger random restart if diversity is too low\n                population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                budget_used += self.population_size\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a random restart mechanism to enhance exploration when diversity falls below a threshold.", "configspace": "", "generation": 26, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "23092be9-5a35-4de3-b054-705f763ef9e3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Adaptive adjustment based on success rates\n            successful_mutations = np.sum(fitness < trial_fitness)\n            self.f = min(0.9, self.f + 0.1 * (successful_mutations / self.population_size))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine control parameter adjustments by introducing adaptive strategies based on mutation and crossover success rates.", "configspace": "", "generation": 27, "fitness": 0.3935951771251003, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.394 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.43417535227395443, 0.38506662982483686, 0.36154354927650956], "final_y": [1.1770697520000357e-06, 5.290251820492601e-05, 0.0008137120215175942]}, "mutation_prompt": null}
{"id": "70e1e429-eda5-436b-a12d-7d91425f8eaf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Tournament selection for more competitive individuals\n                tournament_indices = np.random.choice(self.population_size, 3)\n                indices = sorted(tournament_indices, key=lambda idx: fitness[idx])[:3]\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.4, 0.9)  # Adjust mutation strength adaptively\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            # Maintain original logic for crossover probability adjustment\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce tournament selection and adaptive mutation strength for an improved exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.4766490668008883, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.477 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4824660010658308, 0.5162407580980496, 0.43124044123878447], "final_y": [1.627003216647488e-05, 7.083588517300765e-07, 0.00011721880877012558]}, "mutation_prompt": null}
{"id": "64381fde-1389-4c70-b35a-480030e81f7e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            fitness_improvement_rate = (np.min(fitness) - np.mean(fitness)) / np.std(fitness)  # Change line\n            self.f = np.random.uniform(0.4, 0.9) if fitness_improvement_rate > 0.1 else np.random.uniform(0.5, 0.7)  # Change line\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by dynamically adjusting differential weight based on fitness improvement rate.", "configspace": "", "generation": 29, "fitness": 0.4021083895414191, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.402 with standard deviation 0.048. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46865360295732506, 0.35917201204342286, 0.3784995536235093], "final_y": [4.445635506612438e-06, 0.0003742255730927603, 6.613500454841945e-05]}, "mutation_prompt": null}
{"id": "9583bd30-44b2-4b95-a81d-2403ea255f46", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.f = self.f + 0.1 * (fitness[i] - trial_fitness) / max(1, abs(fitness[i]))  # Adjust mutation factor\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting the mutation factor based on fitness improvement.", "configspace": "", "generation": 30, "fitness": 0.4180361627623683, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.418 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.37864319249359224, 0.4445981344782174, 0.43086716131529534], "final_y": [0.001008682325017209, 6.248851087749651e-06, 1.7655420005124412e-05]}, "mutation_prompt": null}
