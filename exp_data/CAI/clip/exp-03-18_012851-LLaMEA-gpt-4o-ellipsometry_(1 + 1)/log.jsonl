{"id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with a dynamic population size and self-adaptive control parameters for efficient exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.3527530543742902, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.353 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3806146168952741, 0.3669503680478776, 0.3106941781797189], "final_y": [4.70013625454655e-05, 9.554337524336317e-05, 0.0009981177690130498]}, "mutation_prompt": null}
{"id": "fc624c83-3959-4787-9a92-3193db215bf7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Opposition-based learning\n                opposite = lower_bound + upper_bound - trial\n                trial_fitness = func(trial)\n                opposite_fitness = func(opposite)\n                budget_used += 2\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                elif opposite_fitness < fitness[i]:\n                    new_population[i] = opposite\n                    fitness[i] = opposite_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with opposition-based learning for enhanced global exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.2078921107475786, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.012. And the mean value of best solutions found was 0.027 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "metadata": {"aucs": [0.20064619963622987, 0.19844370708789505, 0.22458642551861085], "final_y": [0.025913589337605233, 0.015390260514256151, 0.03821447491118889]}, "mutation_prompt": null}
{"id": "09984399-f4e0-47d3-9c02-91683f3e1f4d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Adaptive Differential Evolution algorithm with a modified dynamic population size calculation for improved exploration and exploitation in black box optimization.", "configspace": "", "generation": 2, "fitness": 0.44315382605698367, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.443 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "metadata": {"aucs": [0.43776708657435326, 0.4117814624240419, 0.479912929172556], "final_y": [1.0618204943030353e-05, 2.4738314956875467e-06, 2.793910027327928e-07]}, "mutation_prompt": null}
{"id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Optimizes the crossover probability range and uses elitism to retain best solutions in Adaptive Differential Evolution.", "configspace": "", "generation": 3, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "09984399-f4e0-47d3-9c02-91683f3e1f4d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "e2a247e8-d0a0-44f8-85ca-c11e802aece9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) * (1 - budget_used / self.budget)  # Adjusted differential weight\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adaptation of the differential weight to improve exploration and exploitation balance in Adaptive Differential Evolution.", "configspace": "", "generation": 4, "fitness": 0.4597138229276691, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.460 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4943925471612425, 0.4124880416022717, 0.47226088001949296], "final_y": [3.7976495248939712e-06, 0.00021562432189659372, 5.922364449999288e-06]}, "mutation_prompt": null}
{"id": "20960695-b987-46be-a456-be35958d7ccd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) * (1 - budget_used / self.budget)  # Dynamic mutation scale\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation scaling and enhanced elitism.", "configspace": "", "generation": 5, "fitness": 0.4597138229276691, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.460 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4943925471612425, 0.4124880416022717, 0.47226088001949296], "final_y": [3.7976495248939712e-06, 0.00021562432189659372, 5.922364449999288e-06]}, "mutation_prompt": null}
{"id": "657dd9ca-8d21-484b-8ea0-9d39bf609d0d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                f_dynamic = self.f * (1 - budget_used / self.budget)  # Time-varying scaling factor\n                mutant = np.clip(x1 + f_dynamic * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces time-varying scaling factor and adaptive mutation strategy in Adaptive Differential Evolution.", "configspace": "", "generation": 6, "fitness": 0.43361587462193757, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.044. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4063356745738991, 0.4955681602650055, 0.3989437890269081], "final_y": [0.00024090930243552867, 2.215669675324738e-06, 0.00013512662376298325]}, "mutation_prompt": null}
{"id": "75173052-a493-4d0e-88c0-495a4cf64ac3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Early stopping based on convergence\n            if np.std(fitness) < 1e-6:\n                break\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce early stopping based on convergence stability to enhance efficiency in Adaptive Differential Evolution.", "configspace": "", "generation": 7, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "1d01a6c8-6346-4f4d-b953-c6b3fb868edc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.8  # Initial crossover probability adjusted\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.5, 0.9)  # More aggressive mutation factor adjustment\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by modifying the initial crossover probability and dynamically updating the mutation factor more aggressively.", "configspace": "", "generation": 8, "fitness": 0.4031475896536533, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.403 with standard deviation 0.056. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.38652925940605276, 0.4789672861057658, 0.3439462234491415], "final_y": [0.0008221020032459232, 4.846220867717656e-06, 0.001625527072405441]}, "mutation_prompt": null}
{"id": "6d284879-687a-4633-946f-510d8d544d5d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.4, 0.9)  # Self-adaptive step-size\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing a self-adaptive step-size evolution strategy in the mutation process to improve convergence.", "configspace": "", "generation": 9, "fitness": 0.43378810340222934, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4542006023785945, 0.41349996015064494, 0.43366374767744864], "final_y": [1.4538270635533636e-05, 4.6135565212979066e-05, 3.252567744265981e-05]}, "mutation_prompt": null}
{"id": "68088284-799b-4221-8e14-26fd6c79da2d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            fitness_variance = np.var(fitness)\n            self.f = np.random.uniform(0.4, 0.9) * (1.0 - fitness_variance)  # Dynamic adaptation\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adaptation of the differential weight `f` based on the fitness variance to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.12051232765949964, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.121 with standard deviation 0.018. And the mean value of best solutions found was 2.867 (0. is the best) with standard deviation 0.971.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.11666235193642072, 0.10011199651773361, 0.14476263452434457], "final_y": [3.0043832434304316, 3.980461312446879, 1.6148440520314065]}, "mutation_prompt": null}
