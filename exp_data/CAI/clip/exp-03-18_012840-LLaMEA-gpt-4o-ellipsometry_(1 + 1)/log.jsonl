{"id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (DE) crossover strategy for enhanced exploration and exploitation in black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.22401872227633468, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.021. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": null, "metadata": {"aucs": [0.20836011606493632, 0.21000701169983638, 0.25368903906423135], "final_y": [0.30388414571003536, 0.07466984810533882, 0.05573472562564738]}, "mutation_prompt": null}
{"id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9  # Change applied here\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced velocity update in PSO to improve solution quality and convergence.", "configspace": "", "generation": 1, "fitness": 0.24392882217362952, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.011. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "metadata": {"aucs": [0.24435960783666644, 0.25666019866968826, 0.23076666001453383], "final_y": [0.05246998427272941, 0.013285397115227882, 0.053927249022532535]}, "mutation_prompt": null}
{"id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = 1.5 + np.random.rand() * 0.5  # Change applied here\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced learning factor adaptation in PSO's velocity update to enhance convergence speed and quality.", "configspace": "", "generation": 2, "fitness": 0.2499420466422891, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.020. And the mean value of best solutions found was 0.021 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "metadata": {"aucs": [0.27779544092850716, 0.2331714822095523, 0.23885921678880784], "final_y": [0.011306998770328458, 0.035089343230070215, 0.017926153240863545]}, "mutation_prompt": null}
{"id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the dynamic adaptation of the inertia weight in PSO to improve exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.3401065046924194, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.340 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "metadata": {"aucs": [0.3329053816536932, 0.3273252343799834, 0.36008889804358146], "final_y": [0.0006104841545707365, 0.000658332133204789, 0.00047703587206836024]}, "mutation_prompt": null}
{"id": "ef5d1247-7693-46ee-9270-2eee8f6646da", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.7 + 0.3  # Slight tweak here.\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Tweaked the differential evolution mutation factor for better exploration-exploitation trade-off.", "configspace": "", "generation": 4, "fitness": 0.3266848568601571, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.032. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3360037659231079, 0.2832086752401376, 0.3608421294172257], "final_y": [0.0003500800904879811, 0.0013499930921221372, 0.0004612716212528403]}, "mutation_prompt": null}
{"id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive crossover rate in DE to enhance exploration capabilities.", "configspace": "", "generation": 5, "fitness": 0.3418035335180794, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.342 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3346380960181542, 0.33383060784117136, 0.3569418966949126], "final_y": [0.00029975330293733634, 0.00019900480136867635, 0.0004413438052892716]}, "mutation_prompt": null}
{"id": "65f48bf2-9771-4ccc-909b-2ff1da9b34ef", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.5 * np.cos(evals / self.budget * np.pi)  # Dynamic mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced DE mutation factor to dynamically respond to optimization progress.", "configspace": "", "generation": 6, "fitness": 0.32774375285488055, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.328 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3278912970728144, 0.32099389610113305, 0.3343460653906942], "final_y": [0.00019530388702958414, 0.00043018389644871425, 0.0005226880607969029]}, "mutation_prompt": null}
{"id": "6094f493-9308-4dbf-b565-dd70a9b24c04", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - 0.5 * (evals / self.budget)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand(self.pop_size, self.dim) * 0.5  # Chaotic sequence\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic inertia weight in PSO and chaotic sequence to enhance exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.2294540901717693, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.016. And the mean value of best solutions found was 0.026 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.21277568925257162, 0.22504974268780487, 0.25053683857493136], "final_y": [0.04563820233393574, 0.008134999100937002, 0.022973636476565907]}, "mutation_prompt": null}
{"id": "48a3d0d1-d982-4ccf-aaa0-9120427c0c2a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.4 * np.cos(evals / self.budget * np.pi)) # Dynamic inertia weight adjustment\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced convergence by introducing dynamic inertia weight adjustment in PSO update.", "configspace": "", "generation": 8, "fitness": 0.2955896873336769, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2891685925331724, 0.3154849910027888, 0.28211547846506957], "final_y": [0.0010663100061310531, 0.000252224995055844, 0.0005067488825655916]}, "mutation_prompt": null}
{"id": "3f661715-c58d-4f6b-a75e-f57bb6ab9116", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Adaptive F scaling factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting the F scaling factor adaptively based on evaluation progress.", "configspace": "", "generation": 9, "fitness": 0.32720018774860654, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.311197789955998, 0.32837434625349293, 0.34202842703632863], "final_y": [0.00037218278923101955, 0.000292283596697245, 0.00024309220223133084]}, "mutation_prompt": null}
{"id": "ce6ecf9e-4efa-4b15-ab0c-4157711238d6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + np.random.rand() * 0.3  # Modified DE mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic inertia weight strategy and modified DE mutation factor to enhance convergence speed.", "configspace": "", "generation": 10, "fitness": 0.27543107706027375, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.032. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2698161182160622, 0.31706811342228525, 0.23940899954247385], "final_y": [0.0006434546339695983, 0.0028010444959953532, 0.01733502640544668]}, "mutation_prompt": null}
{"id": "5effba22-9d38-4622-928f-255974b44768", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Changed from 0.4 to a dynamic range for F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the DE mutation factor adaptation to improve exploration.", "configspace": "", "generation": 11, "fitness": 0.33177488429172913, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.332 with standard deviation 0.027. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3332168002306989, 0.29801967091404, 0.36408818173044843], "final_y": [0.000756089370622271, 0.001872405225360899, 0.0007725402611016861]}, "mutation_prompt": null}
{"id": "c90b5e6d-a87b-48ec-80dd-4248a39bb0f0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + 0.5 * (self.global_best_score / (np.min(self.personal_best_scores) + 1e-10))  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Incorporated dynamic inertia weight adjustment based on current exploitation and exploration balance.", "configspace": "", "generation": 12, "fitness": 0.22281456914920297, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.223 with standard deviation 0.011. And the mean value of best solutions found was 0.079 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2234419187000083, 0.23617002937530907, 0.2088317593722916], "final_y": [0.06710009133120577, 0.042915446431761, 0.1279052073223784]}, "mutation_prompt": null}
{"id": "48050891-ecb3-486e-a656-1303ae2dd94b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.exp(-evals / (0.1 * self.budget))  # Changed from 0.4 to 0.5\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced global best update mechanism by slightly increasing the exploration factor in PSO.", "configspace": "", "generation": 13, "fitness": 0.2872321370797672, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.287 with standard deviation 0.005. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2928315616297964, 0.28757661803690115, 0.2812882315726041], "final_y": [0.0009762892867548705, 0.0034161475598417624, 0.0010189213572509507]}, "mutation_prompt": null}
{"id": "d443b7e1-bc1a-40a3-b376-3b7de16ff774", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.normal(0.5, 0.3)  # Gaussian perturbation for F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Utilized Gaussian perturbations in DE mutation to enhance local search capabilities.", "configspace": "", "generation": 14, "fitness": 0.33162616755009405, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.332 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3374679202462847, 0.3506619066221438, 0.3067486757818537], "final_y": [7.97108330460381e-05, 0.00012721484692397136, 0.0007875794926715575]}, "mutation_prompt": null}
{"id": "2c2c80f4-1381-406e-a92e-f54c9ea2dfb6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + np.random.rand() * (0.9 - 0.4)  # Stochastic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced stochastic inertia weight in PSO for better balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.2914447871234944, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.001. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2904618599972384, 0.29191636499622486, 0.29195613637702], "final_y": [0.010867824168361274, 0.00705514951312785, 0.005278621160763959]}, "mutation_prompt": null}
{"id": "eda8252f-22db-48a0-bb27-d4409d0bf3e6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (1 + np.cos(np.pi * evals / self.budget)) / 2  # Dynamically adjusted inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by dynamically adjusting the inertia weight using a cosine function.", "configspace": "", "generation": 16, "fitness": 0.24490934064624595, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.005. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2494659946829324, 0.24749040371399522, 0.23777162354181025], "final_y": [0.012919999586802393, 0.005768197766022725, 0.012279003384879526]}, "mutation_prompt": null}
{"id": "7500f3c0-25f8-401f-a672-649a0189258d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.8 + 0.2 * np.cos(np.pi * evals / self.budget)  # Adaptive factor F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced DE mutation strategy by adjusting factor F adaptively for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.3242976493124075, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.324 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3375080326781099, 0.29833296482131166, 0.337051950437801], "final_y": [0.00019832277192947123, 0.0010278204366409394, 0.00022423121378734352]}, "mutation_prompt": null}
