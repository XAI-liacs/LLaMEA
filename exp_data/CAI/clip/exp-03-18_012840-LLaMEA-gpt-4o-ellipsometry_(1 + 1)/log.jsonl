{"id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (DE) crossover strategy for enhanced exploration and exploitation in black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.22401872227633468, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.021. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": null, "metadata": {"aucs": [0.20836011606493632, 0.21000701169983638, 0.25368903906423135], "final_y": [0.30388414571003536, 0.07466984810533882, 0.05573472562564738]}, "mutation_prompt": null}
{"id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9  # Change applied here\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced velocity update in PSO to improve solution quality and convergence.", "configspace": "", "generation": 1, "fitness": 0.24392882217362952, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.011. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "metadata": {"aucs": [0.24435960783666644, 0.25666019866968826, 0.23076666001453383], "final_y": [0.05246998427272941, 0.013285397115227882, 0.053927249022532535]}, "mutation_prompt": null}
{"id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = 1.5 + np.random.rand() * 0.5  # Change applied here\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced learning factor adaptation in PSO's velocity update to enhance convergence speed and quality.", "configspace": "", "generation": 2, "fitness": 0.2499420466422891, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.020. And the mean value of best solutions found was 0.021 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "metadata": {"aucs": [0.27779544092850716, 0.2331714822095523, 0.23885921678880784], "final_y": [0.011306998770328458, 0.035089343230070215, 0.017926153240863545]}, "mutation_prompt": null}
{"id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the dynamic adaptation of the inertia weight in PSO to improve exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.3401065046924194, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.340 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "metadata": {"aucs": [0.3329053816536932, 0.3273252343799834, 0.36008889804358146], "final_y": [0.0006104841545707365, 0.000658332133204789, 0.00047703587206836024]}, "mutation_prompt": null}
{"id": "ef5d1247-7693-46ee-9270-2eee8f6646da", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.7 + 0.3  # Slight tweak here.\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Tweaked the differential evolution mutation factor for better exploration-exploitation trade-off.", "configspace": "", "generation": 4, "fitness": 0.3266848568601571, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.032. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3360037659231079, 0.2832086752401376, 0.3608421294172257], "final_y": [0.0003500800904879811, 0.0013499930921221372, 0.0004612716212528403]}, "mutation_prompt": null}
