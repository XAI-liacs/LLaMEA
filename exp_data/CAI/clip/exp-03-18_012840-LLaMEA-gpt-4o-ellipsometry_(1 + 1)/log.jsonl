{"id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (DE) crossover strategy for enhanced exploration and exploitation in black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.22401872227633468, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.021. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": null, "metadata": {"aucs": [0.20836011606493632, 0.21000701169983638, 0.25368903906423135], "final_y": [0.30388414571003536, 0.07466984810533882, 0.05573472562564738]}, "mutation_prompt": null}
{"id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9  # Change applied here\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced velocity update in PSO to improve solution quality and convergence.", "configspace": "", "generation": 1, "fitness": 0.24392882217362952, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.011. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "metadata": {"aucs": [0.24435960783666644, 0.25666019866968826, 0.23076666001453383], "final_y": [0.05246998427272941, 0.013285397115227882, 0.053927249022532535]}, "mutation_prompt": null}
{"id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = 1.5 + np.random.rand() * 0.5  # Change applied here\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced learning factor adaptation in PSO's velocity update to enhance convergence speed and quality.", "configspace": "", "generation": 2, "fitness": 0.2499420466422891, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.020. And the mean value of best solutions found was 0.021 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "metadata": {"aucs": [0.27779544092850716, 0.2331714822095523, 0.23885921678880784], "final_y": [0.011306998770328458, 0.035089343230070215, 0.017926153240863545]}, "mutation_prompt": null}
{"id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the dynamic adaptation of the inertia weight in PSO to improve exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.3401065046924194, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.340 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "metadata": {"aucs": [0.3329053816536932, 0.3273252343799834, 0.36008889804358146], "final_y": [0.0006104841545707365, 0.000658332133204789, 0.00047703587206836024]}, "mutation_prompt": null}
{"id": "ef5d1247-7693-46ee-9270-2eee8f6646da", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.7 + 0.3  # Slight tweak here.\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Tweaked the differential evolution mutation factor for better exploration-exploitation trade-off.", "configspace": "", "generation": 4, "fitness": 0.3266848568601571, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.032. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3360037659231079, 0.2832086752401376, 0.3608421294172257], "final_y": [0.0003500800904879811, 0.0013499930921221372, 0.0004612716212528403]}, "mutation_prompt": null}
{"id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive crossover rate in DE to enhance exploration capabilities.", "configspace": "", "generation": 5, "fitness": 0.3418035335180794, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.342 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3346380960181542, 0.33383060784117136, 0.3569418966949126], "final_y": [0.00029975330293733634, 0.00019900480136867635, 0.0004413438052892716]}, "mutation_prompt": null}
{"id": "65f48bf2-9771-4ccc-909b-2ff1da9b34ef", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.5 * np.cos(evals / self.budget * np.pi)  # Dynamic mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced DE mutation factor to dynamically respond to optimization progress.", "configspace": "", "generation": 6, "fitness": 0.32774375285488055, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.328 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3278912970728144, 0.32099389610113305, 0.3343460653906942], "final_y": [0.00019530388702958414, 0.00043018389644871425, 0.0005226880607969029]}, "mutation_prompt": null}
{"id": "6094f493-9308-4dbf-b565-dd70a9b24c04", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - 0.5 * (evals / self.budget)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand(self.pop_size, self.dim) * 0.5  # Chaotic sequence\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic inertia weight in PSO and chaotic sequence to enhance exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.2294540901717693, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.016. And the mean value of best solutions found was 0.026 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.21277568925257162, 0.22504974268780487, 0.25053683857493136], "final_y": [0.04563820233393574, 0.008134999100937002, 0.022973636476565907]}, "mutation_prompt": null}
{"id": "48a3d0d1-d982-4ccf-aaa0-9120427c0c2a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.4 * np.cos(evals / self.budget * np.pi)) # Dynamic inertia weight adjustment\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced convergence by introducing dynamic inertia weight adjustment in PSO update.", "configspace": "", "generation": 8, "fitness": 0.2955896873336769, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2891685925331724, 0.3154849910027888, 0.28211547846506957], "final_y": [0.0010663100061310531, 0.000252224995055844, 0.0005067488825655916]}, "mutation_prompt": null}
{"id": "3f661715-c58d-4f6b-a75e-f57bb6ab9116", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Adaptive F scaling factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting the F scaling factor adaptively based on evaluation progress.", "configspace": "", "generation": 9, "fitness": 0.32720018774860654, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.311197789955998, 0.32837434625349293, 0.34202842703632863], "final_y": [0.00037218278923101955, 0.000292283596697245, 0.00024309220223133084]}, "mutation_prompt": null}
{"id": "ce6ecf9e-4efa-4b15-ab0c-4157711238d6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + np.random.rand() * 0.3  # Modified DE mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic inertia weight strategy and modified DE mutation factor to enhance convergence speed.", "configspace": "", "generation": 10, "fitness": 0.27543107706027375, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.032. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2698161182160622, 0.31706811342228525, 0.23940899954247385], "final_y": [0.0006434546339695983, 0.0028010444959953532, 0.01733502640544668]}, "mutation_prompt": null}
