{"id": "a1186fb3-0987-463e-bcda-412e51ae1d29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Initial uniform random sampling\n        num_initial_samples = min(5 * self.dim, remaining_budget // 2)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Update bounds based on current best solution\n            bounds_range = (ub - lb) / 4\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Adaptive Parameter Space Reduction (APSR) - A metaheuristic algorithm that iteratively narrows down the search space based on local optimization successes, using a blend of uniform sampling and BFGS, to efficiently solve smooth low-dimensional optimization problems.", "configspace": "", "generation": 0, "fitness": 0.8034232782080171, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.822413450027327, 0.753823341857784, 0.8340330427389402], "final_y": [5.975206555339443e-08, 3.2245358180625636e-07, 5.375207582983452e-08]}, "mutation_prompt": null}
{"id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial uniform random sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR with dynamic adjustment of initial sample count and more flexible bounds adaptation for improved convergence and efficiency.", "configspace": "", "generation": 1, "fitness": 0.8461511858194983, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a1186fb3-0987-463e-bcda-412e51ae1d29", "metadata": {"aucs": [0.8634533109703009, 0.828205553360243, 0.8467946931279512], "final_y": [8.206757686961178e-09, 2.4485811326748747e-08, 1.8915138970570107e-08]}, "mutation_prompt": null}
{"id": "f82bc18b-5694-4e7d-ab92-f4adc2dd5adc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial uniform random sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='trust-constr', bounds=zip(lb, ub), options={'maxiter': remaining_budget}) # Changed method\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by improving local optimization convergence speed through the use of the more aggressive 'trust-constr' method for faster exploitation.", "configspace": "", "generation": 2, "fitness": 0.7128410589679728, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.713 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "metadata": {"aucs": [0.7229323249939781, 0.7201415738751114, 0.6954492780348289], "final_y": [8.501847676465326e-08, 8.618463455761691e-08, 1.7228649733986606e-07]}, "mutation_prompt": null}
{"id": "32e18bc9-7b65-492d-a50e-6bff3e367239", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR with enhanced sampling strategy using Sobol sequence for improved initial coverage and convergence efficiency.", "configspace": "", "generation": 3, "fitness": 0.8469687523520618, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "metadata": {"aucs": [0.8386936760173881, 0.8282964630805143, 0.873916117958283], "final_y": [4.335238974729917e-08, 5.4078673292230604e-08, 1.4613173996362413e-08]}, "mutation_prompt": null}
{"id": "eff3d7d5-1d03-4955-8b04-b8cf76960e8a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization with slight code adjustment\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget, 'ftol': 1e-8})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR with dynamic sampling adjustment based on budget and landscape complexity.", "configspace": "", "generation": 4, "fitness": 0.8456322140421744, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "32e18bc9-7b65-492d-a50e-6bff3e367239", "metadata": {"aucs": [0.8243949015210158, 0.8676204493037424, 0.8448812913017647], "final_y": [5.803395187451144e-08, 1.7584472599152374e-08, 2.8149925282654792e-08]}, "mutation_prompt": null}
{"id": "843c3f1a-9903-4286-8d5c-30dd46e663ae", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4  # Changed from /3 to /4 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR using a more aggressive bounds adaptation strategy for faster convergence.", "configspace": "", "generation": 5, "fitness": 0.8591377274442501, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "32e18bc9-7b65-492d-a50e-6bff3e367239", "metadata": {"aucs": [0.8604013163353554, 0.8473330531637878, 0.869678812833607], "final_y": [2.0163292192796736e-08, 9.719095994231992e-09, 1.635571250430742e-08]}, "mutation_prompt": null}
{"id": "58e44af6-e6d6-4da8-a51f-92715a178455", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling with larger scramble\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)  # No change\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples * 2)[:num_initial_samples]  # Improved sampling\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4  # No change\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Optimized APSR with an improved Sobol sequence strategy for better initial sampling coverage.", "configspace": "", "generation": 6, "fitness": 0.8495099429531942, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "843c3f1a-9903-4286-8d5c-30dd46e663ae", "metadata": {"aucs": [0.8765192135094813, 0.8362725388197281, 0.8357380765303731], "final_y": [8.845587939458374e-10, 1.9402881779744802e-08, 3.12743136144215e-08]}, "mutation_prompt": null}
{"id": "4e42b1e2-61ce-4175-a360-e59165497557", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4  # Changed from /3 to /4 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Slightly increased the Sobol initial sample size for better initial diversity and coverage.", "configspace": "", "generation": 7, "fitness": 0.8628604224731493, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "843c3f1a-9903-4286-8d5c-30dd46e663ae", "metadata": {"aucs": [0.8167860831975877, 0.8783517528027711, 0.893443431419089], "final_y": [4.4032719225664156e-08, 1.0335738871186672e-08, 3.0966075879324657e-09]}, "mutation_prompt": null}
{"id": "64330e28-3a14-45e3-bc72-af7ef24e56eb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced Sobol sampling diversity by further increasing initial sample size for improved coverage.", "configspace": "", "generation": 8, "fitness": 0.828512585679405, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e42b1e2-61ce-4175-a360-e59165497557", "metadata": {"aucs": [0.8049730404100424, 0.832617146720015, 0.8479475699081577], "final_y": [3.750832984242976e-08, 3.284907312899612e-08, 1.8452415014991324e-08]}, "mutation_prompt": null}
{"id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR by increasing the aggressiveness of bounds adaptation for faster convergence.", "configspace": "", "generation": 9, "fitness": 0.865873320767633, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e42b1e2-61ce-4175-a360-e59165497557", "metadata": {"aucs": [0.887542954314846, 0.8380052223264017, 0.8720717856616514], "final_y": [3.964574440406229e-09, 2.2889187199551788e-08, 7.2659468457162954e-09]}, "mutation_prompt": null}
{"id": "9cf8798c-da7a-4608-9fef-07886edfc6af", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='Nelder-Mead', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refine APSR by adjusting local optimization method from 'L-BFGS-B' to 'Nelder-Mead' for potentially better performance in smooth landscapes.", "configspace": "", "generation": 10, "fitness": 0.7193802515853718, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.719 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.706640913118006, 0.7485630490864776, 0.7029367925516316], "final_y": [1.507775306393219e-06, 2.0476905813153818e-07, 2.524372389294928e-06]}, "mutation_prompt": null}
{"id": "3969d8f9-1989-4614-a08b-8fdc75787d7c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3) + (best_value < 1e-3)  # Adaptive change\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refined APSR by introducing an adaptive Sobol sequence sample count based on current best value for more efficient initial exploration.", "configspace": "", "generation": 11, "fitness": 0.8551524853895014, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8809676483047537, 0.8645825391750673, 0.819907268688683], "final_y": [1.4005057151945775e-08, 1.9818052724213662e-08, 3.8005850018944555e-08]}, "mutation_prompt": null}
{"id": "c563e54c-a683-4a1f-a094-a96bfcc5f785", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget, 'ftol': 1e-8})  # Changed ftol for tighter convergence\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refined APSR by enhancing the local optimization convergence criteria for improved efficiency.", "configspace": "", "generation": 12, "fitness": 0.8242339406073316, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8218621647388347, 0.8274099310324352, 0.823429726050725], "final_y": [3.920142504510382e-08, 3.737592587381499e-08, 5.8184518697598025e-08]}, "mutation_prompt": null}
{"id": "dc68ee45-26ad-46f1-a66e-c7a4f188578a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by increasing the Sobol sequence sampling range for improved initial exploration.", "configspace": "", "generation": 13, "fitness": 0.8351348086803944, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8435640565593574, 0.8240326625382202, 0.8378077069436056], "final_y": [1.951739263139334e-08, 6.320679260185036e-08, 4.7064955978977136e-08]}, "mutation_prompt": null}
{"id": "a33f7f89-7ab4-4758-b6dc-1e2cbab05c19", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "APSR refined by enhancing initial sample distribution through increased number of Sobol samples for better initial coverage.", "configspace": "", "generation": 14, "fitness": 0.8390422192061119, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8734182454694208, 0.8262650157863568, 0.8174433963625577], "final_y": [2.8106222484304274e-08, 1.9800978960404948e-08, 4.582755949573708e-08]}, "mutation_prompt": null}
{"id": "80071083-2d26-427f-b709-66191c1e80ce", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 2)  # Changed from remaining_budget // 3 to // 2\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refined APSR by introducing dynamic adjustment of the initial sample size based on the remaining budget to enhance convergence speed.", "configspace": "", "generation": 15, "fitness": 0.8428295365171854, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8483027791530796, 0.8288882403598624, 0.8512975900386142], "final_y": [1.881340304689862e-08, 3.1200114180198e-08, 2.0659306669656104e-08]}, "mutation_prompt": null}
{"id": "0d20c72c-e834-43c0-9f16-a3991a101a1a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 6  # Changed from /5 to /6 for more precise adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by modifying bounds adaptation to precisely tighten bounds for faster convergence.", "configspace": "", "generation": 16, "fitness": 0.847986366718097, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8367480469265749, 0.8617302283477014, 0.845480824880015], "final_y": [2.3498264851024776e-08, 5.236829531754049e-09, 1.0734788011157209e-08]}, "mutation_prompt": null}
{"id": "179a55d9-92bb-43fa-84da-af018fd699e8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Increased from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refine APSR by increasing initial sampling density for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.8362906732070904, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.836 with standard deviation 0.034. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.811895883808548, 0.8843514370930043, 0.8126246987197188], "final_y": [3.474298343438233e-08, 3.210378628125247e-09, 4.646523297109626e-08]}, "mutation_prompt": null}
{"id": "d4e9a94c-560c-4c2a-865b-030d58820ca0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxiter': min(remaining_budget, 150)})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refined APSR by increasing local optimization aggressiveness for faster convergence.", "configspace": "", "generation": 18, "fitness": 0.8373031762619175, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8540027084859279, 0.8144640177201264, 0.8434428025796984], "final_y": [3.087063442665548e-08, 2.0550050393131613e-08, 2.401725740464883e-08]}, "mutation_prompt": null}
{"id": "f89d0756-e15d-4eee-9257-8f8867f589fe", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(10, 4 * self.dim), remaining_budget // 3)  # Changed from 5 to 10\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Improved APSR by adjusting initial Sobol samples to enhance exploration and convergence speed.", "configspace": "", "generation": 19, "fitness": 0.8306033317524836, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8530424657934281, 0.8003687147627379, 0.8383988147012849], "final_y": [1.684899484208696e-08, 3.49821752531101e-08, 1.1265241320758545e-08]}, "mutation_prompt": null}
{"id": "aabb764d-9414-4d1c-ae87-2ac5d55749f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 6  # Changed from /5 to /6 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by modifying the bounds adaptation strategy for improved convergence and robustness.", "configspace": "", "generation": 20, "fitness": 0.8629239620113353, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8499092248363503, 0.855206312836285, 0.88365634836137], "final_y": [2.5377782808355253e-08, 1.4372000614161535e-08, 2.350602433482827e-09]}, "mutation_prompt": null}
{"id": "9d6918a7-704e-4d7d-be62-295bdda5d0a7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 6  # Changed from /5 to /6 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by further decreasing bounds adaptation for more precise convergence.", "configspace": "", "generation": 21, "fitness": 0.8334112797960614, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8274524428328953, 0.8524474148405936, 0.8203339817146956], "final_y": [3.4936099348659035e-08, 1.1443089022211299e-08, 2.1289217471008128e-08]}, "mutation_prompt": null}
{"id": "d260acd8-40e5-4946-948e-36bd659a2335", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(6, 4 * self.dim), remaining_budget // 3)  # Changed from 5 to 6\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhance APSR by refining the Sobol sequence sample size for better initial coverage.", "configspace": "", "generation": 22, "fitness": 0.8338795173474737, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8261796864987385, 0.8310928294710269, 0.8443660360726555], "final_y": [2.4727552439027643e-08, 2.1750064115598494e-08, 1.657488683402796e-08]}, "mutation_prompt": null}
{"id": "5405830d-6ba9-4f48-ac47-9bdab1d04044", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhancing APSR by adjusting the Sobol sampling size for improved exploration.", "configspace": "", "generation": 23, "fitness": 0.829110571930642, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8410477864570872, 0.8153293281092979, 0.8309546012255407], "final_y": [2.4681959478230235e-08, 4.8428729401465936e-08, 3.541959242536114e-08]}, "mutation_prompt": null}
{"id": "b0efd1e4-2a55-4feb-8770-c39164c815eb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(6, 4 * self.dim), remaining_budget // 3)  # Modified from max(5, ...) to max(6, ...) for a larger initial sample size\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refine APSR by increasing initial sample size for better exploration and convergence.", "configspace": "", "generation": 24, "fitness": 0.8452700301246511, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8709171855315758, 0.8407669873568239, 0.824125917485554], "final_y": [1.863124379964298e-09, 2.1030409042025747e-08, 4.503024074682866e-08]}, "mutation_prompt": null}
{"id": "a29dc257-9137-4ae0-a5fa-1a4df7f333d3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization with Nelder-Mead\n            result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': remaining_budget})  # Changed method to 'Nelder-Mead'\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by optimizing local search strategy for refined convergence.", "configspace": "", "generation": 25, "fitness": 0.5106434997309611, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.511 with standard deviation 0.254. And the mean value of best solutions found was 0.455 (0. is the best) with standard deviation 0.643.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.1517041537720487, 0.6917892739457046, 0.6884370714751303], "final_y": [1.3648251345826412, 4.834472950394422e-06, 5.927744131008227e-06]}, "mutation_prompt": null}
{"id": "3465ec61-ee88-4616-9567-1d8e471a9a42", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget, 'ftol': 1e-9})  # Changed ftol for more precise convergence\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "APSR refined by adjusting the balance between exploration and exploitation through optimized local search strategy.", "configspace": "", "generation": 26, "fitness": 0.8388370880587663, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.842602976191146, 0.8276630373844338, 0.8462452506007192], "final_y": [3.2062749933519316e-08, 1.7199144849501982e-08, 1.3199914920617707e-08]}, "mutation_prompt": null}
