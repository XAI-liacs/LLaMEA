{"id": "a1186fb3-0987-463e-bcda-412e51ae1d29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Initial uniform random sampling\n        num_initial_samples = min(5 * self.dim, remaining_budget // 2)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Update bounds based on current best solution\n            bounds_range = (ub - lb) / 4\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Adaptive Parameter Space Reduction (APSR) - A metaheuristic algorithm that iteratively narrows down the search space based on local optimization successes, using a blend of uniform sampling and BFGS, to efficiently solve smooth low-dimensional optimization problems.", "configspace": "", "generation": 0, "fitness": 0.8034232782080171, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.822413450027327, 0.753823341857784, 0.8340330427389402], "final_y": [5.975206555339443e-08, 3.2245358180625636e-07, 5.375207582983452e-08]}, "mutation_prompt": null}
{"id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial uniform random sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR with dynamic adjustment of initial sample count and more flexible bounds adaptation for improved convergence and efficiency.", "configspace": "", "generation": 1, "fitness": 0.8461511858194983, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a1186fb3-0987-463e-bcda-412e51ae1d29", "metadata": {"aucs": [0.8634533109703009, 0.828205553360243, 0.8467946931279512], "final_y": [8.206757686961178e-09, 2.4485811326748747e-08, 1.8915138970570107e-08]}, "mutation_prompt": null}
{"id": "f82bc18b-5694-4e7d-ab92-f4adc2dd5adc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial uniform random sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='trust-constr', bounds=zip(lb, ub), options={'maxiter': remaining_budget}) # Changed method\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by improving local optimization convergence speed through the use of the more aggressive 'trust-constr' method for faster exploitation.", "configspace": "", "generation": 2, "fitness": 0.7128410589679728, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.713 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "metadata": {"aucs": [0.7229323249939781, 0.7201415738751114, 0.6954492780348289], "final_y": [8.501847676465326e-08, 8.618463455761691e-08, 1.7228649733986606e-07]}, "mutation_prompt": null}
{"id": "32e18bc9-7b65-492d-a50e-6bff3e367239", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR with enhanced sampling strategy using Sobol sequence for improved initial coverage and convergence efficiency.", "configspace": "", "generation": 3, "fitness": 0.8469687523520618, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "metadata": {"aucs": [0.8386936760173881, 0.8282964630805143, 0.873916117958283], "final_y": [4.335238974729917e-08, 5.4078673292230604e-08, 1.4613173996362413e-08]}, "mutation_prompt": null}
{"id": "eff3d7d5-1d03-4955-8b04-b8cf76960e8a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization with slight code adjustment\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget, 'ftol': 1e-8})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR with dynamic sampling adjustment based on budget and landscape complexity.", "configspace": "", "generation": 4, "fitness": 0.8456322140421744, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "32e18bc9-7b65-492d-a50e-6bff3e367239", "metadata": {"aucs": [0.8243949015210158, 0.8676204493037424, 0.8448812913017647], "final_y": [5.803395187451144e-08, 1.7584472599152374e-08, 2.8149925282654792e-08]}, "mutation_prompt": null}
{"id": "843c3f1a-9903-4286-8d5c-30dd46e663ae", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4  # Changed from /3 to /4 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR using a more aggressive bounds adaptation strategy for faster convergence.", "configspace": "", "generation": 5, "fitness": 0.8591377274442501, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "32e18bc9-7b65-492d-a50e-6bff3e367239", "metadata": {"aucs": [0.8604013163353554, 0.8473330531637878, 0.869678812833607], "final_y": [2.0163292192796736e-08, 9.719095994231992e-09, 1.635571250430742e-08]}, "mutation_prompt": null}
{"id": "58e44af6-e6d6-4da8-a51f-92715a178455", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling with larger scramble\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)  # No change\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples * 2)[:num_initial_samples]  # Improved sampling\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4  # No change\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Optimized APSR with an improved Sobol sequence strategy for better initial sampling coverage.", "configspace": "", "generation": 6, "fitness": 0.8495099429531942, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "843c3f1a-9903-4286-8d5c-30dd46e663ae", "metadata": {"aucs": [0.8765192135094813, 0.8362725388197281, 0.8357380765303731], "final_y": [8.845587939458374e-10, 1.9402881779744802e-08, 3.12743136144215e-08]}, "mutation_prompt": null}
{"id": "4e42b1e2-61ce-4175-a360-e59165497557", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4  # Changed from /3 to /4 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Slightly increased the Sobol initial sample size for better initial diversity and coverage.", "configspace": "", "generation": 7, "fitness": 0.8628604224731493, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "843c3f1a-9903-4286-8d5c-30dd46e663ae", "metadata": {"aucs": [0.8167860831975877, 0.8783517528027711, 0.893443431419089], "final_y": [4.4032719225664156e-08, 1.0335738871186672e-08, 3.0966075879324657e-09]}, "mutation_prompt": null}
{"id": "64330e28-3a14-45e3-bc72-af7ef24e56eb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 4\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced Sobol sampling diversity by further increasing initial sample size for improved coverage.", "configspace": "", "generation": 8, "fitness": 0.828512585679405, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e42b1e2-61ce-4175-a360-e59165497557", "metadata": {"aucs": [0.8049730404100424, 0.832617146720015, 0.8479475699081577], "final_y": [3.750832984242976e-08, 3.284907312899612e-08, 1.8452415014991324e-08]}, "mutation_prompt": null}
{"id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR by increasing the aggressiveness of bounds adaptation for faster convergence.", "configspace": "", "generation": 9, "fitness": 0.865873320767633, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e42b1e2-61ce-4175-a360-e59165497557", "metadata": {"aucs": [0.887542954314846, 0.8380052223264017, 0.8720717856616514], "final_y": [3.964574440406229e-09, 2.2889187199551788e-08, 7.2659468457162954e-09]}, "mutation_prompt": null}
{"id": "9cf8798c-da7a-4608-9fef-07886edfc6af", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='Nelder-Mead', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refine APSR by adjusting local optimization method from 'L-BFGS-B' to 'Nelder-Mead' for potentially better performance in smooth landscapes.", "configspace": "", "generation": 10, "fitness": 0.7193802515853718, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.719 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.706640913118006, 0.7485630490864776, 0.7029367925516316], "final_y": [1.507775306393219e-06, 2.0476905813153818e-07, 2.524372389294928e-06]}, "mutation_prompt": null}
{"id": "3969d8f9-1989-4614-a08b-8fdc75787d7c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3) + (best_value < 1e-3)  # Adaptive change\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refined APSR by introducing an adaptive Sobol sequence sample count based on current best value for more efficient initial exploration.", "configspace": "", "generation": 11, "fitness": 0.8551524853895014, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8809676483047537, 0.8645825391750673, 0.819907268688683], "final_y": [1.4005057151945775e-08, 1.9818052724213662e-08, 3.8005850018944555e-08]}, "mutation_prompt": null}
{"id": "c563e54c-a683-4a1f-a094-a96bfcc5f785", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 4 * self.dim), remaining_budget // 3)  # Changed from 3 * self.dim to 4 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget, 'ftol': 1e-8})  # Changed ftol for tighter convergence\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Further refined APSR by enhancing the local optimization convergence criteria for improved efficiency.", "configspace": "", "generation": 12, "fitness": 0.8242339406073316, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8218621647388347, 0.8274099310324352, 0.823429726050725], "final_y": [3.920142504510382e-08, 3.737592587381499e-08, 5.8184518697598025e-08]}, "mutation_prompt": null}
{"id": "dc68ee45-26ad-46f1-a66e-c7a4f188578a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Enhanced APSR by increasing the Sobol sequence sampling range for improved initial exploration.", "configspace": "", "generation": 13, "fitness": 0.8351348086803944, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8435640565593574, 0.8240326625382202, 0.8378077069436056], "final_y": [1.951739263139334e-08, 6.320679260185036e-08, 4.7064955978977136e-08]}, "mutation_prompt": null}
{"id": "a33f7f89-7ab4-4758-b6dc-1e2cbab05c19", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial Sobol sequence sampling\n        num_initial_samples = min(max(5, 5 * self.dim), remaining_budget // 3)  # Changed from 4 * self.dim to 5 * self.dim\n        sampler = Sobol(self.dim, scramble=True)\n        samples = lb + (ub - lb) * sampler.random(num_initial_samples)\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 5  # Changed from /4 to /5 for more aggressive adaptation\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "APSR refined by enhancing initial sample distribution through increased number of Sobol samples for better initial coverage.", "configspace": "", "generation": 14, "fitness": 0.8390422192061119, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3d708008-95d1-41a1-8bf2-ad011cf863e7", "metadata": {"aucs": [0.8734182454694208, 0.8262650157863568, 0.8174433963625577], "final_y": [2.8106222484304274e-08, 1.9800978960404948e-08, 4.582755949573708e-08]}, "mutation_prompt": null}
