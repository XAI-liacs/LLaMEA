{"id": "a1186fb3-0987-463e-bcda-412e51ae1d29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Initial uniform random sampling\n        num_initial_samples = min(5 * self.dim, remaining_budget // 2)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Update bounds based on current best solution\n            bounds_range = (ub - lb) / 4\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Adaptive Parameter Space Reduction (APSR) - A metaheuristic algorithm that iteratively narrows down the search space based on local optimization successes, using a blend of uniform sampling and BFGS, to efficiently solve smooth low-dimensional optimization problems.", "configspace": "", "generation": 0, "fitness": 0.8034232782080171, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.822413450027327, 0.753823341857784, 0.8340330427389402], "final_y": [5.975206555339443e-08, 3.2245358180625636e-07, 5.375207582983452e-08]}, "mutation_prompt": null}
{"id": "7112bbfc-a2bf-4938-922e-e8c5a5777585", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APSR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        best_solution = None\n        best_value = float('inf')\n        remaining_budget = self.budget\n        \n        # Adjusted initial uniform random sampling\n        num_initial_samples = min(max(5, 3 * self.dim), remaining_budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        remaining_budget -= num_initial_samples\n        \n        # Evaluate initial samples\n        for sample in samples:\n            value = func(sample)\n            remaining_budget -= 1\n            if value < best_value:\n                best_value = value\n                best_solution = sample\n        \n        # Adaptive Parameter Space Reduction with local optimization\n        while remaining_budget > 0:\n            # Run local optimization\n            result = minimize(func, best_solution, method='L-BFGS-B', bounds=zip(lb, ub), options={'maxfun': remaining_budget})\n            remaining_budget -= result.nfev\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_solution = result.x\n            \n            # Updated bounds adaptation\n            bounds_range = (ub - lb) / 3\n            lb = np.maximum(lb, best_solution - bounds_range)\n            ub = np.minimum(ub, best_solution + bounds_range)\n        \n        return best_solution", "name": "APSR", "description": "Refined APSR with dynamic adjustment of initial sample count and more flexible bounds adaptation for improved convergence and efficiency.", "configspace": "", "generation": 1, "fitness": 0.8461511858194983, "feedback": "The algorithm APSR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a1186fb3-0987-463e-bcda-412e51ae1d29", "metadata": {"aucs": [0.8634533109703009, 0.828205553360243, 0.8467946931279512], "final_y": [8.206757686961178e-09, 2.4485811326748747e-08, 1.8915138970570107e-08]}, "mutation_prompt": null}
