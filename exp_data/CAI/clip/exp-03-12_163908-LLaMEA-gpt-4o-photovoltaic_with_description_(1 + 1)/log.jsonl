{"id": "fc47d3a6-23ae-476a-843f-486078c1978f", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Adaptive Swarm Gradient Descent (ASGD): Combines swarm intelligence and gradient estimation to explore and exploit search space efficiently.", "configspace": "", "generation": 0, "fitness": 0.8264407036439118, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.020. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8041324604654931, 0.8227266579918514, 0.8524629924743906], "final_y": [0.1412466306774247, 0.13112094863304602, 0.12789490696654837]}, "mutation_prompt": null}
{"id": "ad4a62d1-c199-42a7-918a-719ee5d7c776", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor # Changed: dynamic inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n            mutation_rate = 0.1 * adaptive_factor # Added: mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                # Added: mutation step\n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Incorporates mutation for diversity and dynamic inertia for better convergence.", "configspace": "", "generation": 1, "fitness": 0.8426971933580661, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.027. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "fc47d3a6-23ae-476a-843f-486078c1978f", "metadata": {"aucs": [0.8043221119507036, 0.8576889244073185, 0.8660805437161763], "final_y": [0.14393161081025907, 0.1204065054900415, 0.12256958024125031]}, "mutation_prompt": null}
{"id": "b8a19125-4523-4354-965b-81e87c550599", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor \n            cognitive_coeff = 1.5 + 0.5 * adaptive_factor # Changed: adaptive cognitive coefficient\n            social_coeff = 1.5\n            mutation_rate = 0.1 * adaptive_factor \n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Adaptive Cognitive Coefficient for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.8298555138229995, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.025. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "ad4a62d1-c199-42a7-918a-719ee5d7c776", "metadata": {"aucs": [0.7944759397319199, 0.8509035730409428, 0.8441870286961358], "final_y": [0.14194164389344355, 0.12151343498576084, 0.11586550546436214]}, "mutation_prompt": null}
{"id": "d911e651-2a1a-4f97-b0a8-1b244550d033", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n            mutation_rate = 0.1 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                # Modified: mutation step with Gaussian perturbation\n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improved Adaptive Swarm Gradient Descent with Gaussian perturbation for enhanced exploration.", "configspace": "", "generation": 3, "fitness": 0.8438385311547719, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.031. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "ad4a62d1-c199-42a7-918a-719ee5d7c776", "metadata": {"aucs": [0.7998063166441067, 0.8655961075927618, 0.8661131692274473], "final_y": [0.1471917295498919, 0.12218412339426432, 0.12235478602601413]}, "mutation_prompt": null}
{"id": "a2495e22-3c53-4aba-b464-336cb4ccc376", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n            mutation_rate = 0.15 * adaptive_factor  # Change: increased mutation rate from 0.1 to 0.15\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                # Modified: mutation step with Gaussian perturbation\n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with increased mutation rate for better exploration.", "configspace": "", "generation": 4, "fitness": 0.8560576269725407, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.010. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d911e651-2a1a-4f97-b0a8-1b244550d033", "metadata": {"aucs": [0.8663823720487651, 0.8418061019459615, 0.8599844069228955], "final_y": [0.12880052003304243, 0.13515430151820484, 0.12311839592532459]}, "mutation_prompt": null}
{"id": "9d0db6da-c698-4fbf-8fd3-cb1cda4f7b39", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2)  # Modified: nonlinear inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n            mutation_rate = 0.15 * adaptive_factor  # Change: increased mutation rate from 0.1 to 0.15\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                # Modified: mutation step with Gaussian perturbation\n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Integrate a nonlinear inertia weight component for improved convergence speed and solution quality.", "configspace": "", "generation": 5, "fitness": 0.8678015054444869, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.013. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a2495e22-3c53-4aba-b464-336cb4ccc376", "metadata": {"aucs": [0.8726206399247527, 0.8801667964681775, 0.8506170799405305], "final_y": [0.12693051459409632, 0.11418491094352068, 0.12085603953105362]}, "mutation_prompt": null}
{"id": "f63d666a-9074-4de4-8d51-1ea4601970d2", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2)  # Modified: nonlinear inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 * (1 - adaptive_factor)  # Changed: dynamic social coefficient scaling\n            mutation_rate = 0.15 * adaptive_factor  # Change: increased mutation rate from 0.1 to 0.15\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                # Modified: mutation step with Gaussian perturbation\n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce dynamic social coefficient scaling for enhanced exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.8885220840985867, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.005. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "9d0db6da-c698-4fbf-8fd3-cb1cda4f7b39", "metadata": {"aucs": [0.8932522037139007, 0.8815112524159707, 0.8908027961658888], "final_y": [0.11382454480948367, 0.11634568408873469, 0.11042256541100803]}, "mutation_prompt": null}
{"id": "38d7a14d-f66b-4cf0-8282-985287124526", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * np.sin(adaptive_factor * np.pi)  # Modified: sinusoidal modulation on inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 * (1 - adaptive_factor)  # Changed: dynamic social coefficient scaling\n            mutation_rate = 0.15 * adaptive_factor  # Change: increased mutation rate from 0.1 to 0.15\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                # Modified: mutation step with Gaussian perturbation\n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence by introducing a sinusoidal modulation on the inertia weight.", "configspace": "", "generation": 7, "fitness": 0.8537976023293665, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.012. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "f63d666a-9074-4de4-8d51-1ea4601970d2", "metadata": {"aucs": [0.8367253459853694, 0.8662706309131379, 0.8583968300895921], "final_y": [0.13318410213151677, 0.12091588268700293, 0.12122724102939775]}, "mutation_prompt": null}
{"id": "3a65e7be-266e-4838-93f9-c057070019c8", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed: added sinusoidal component to inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a global exploration boost by adjusting the inertia weight with a sinusoidal component for enhanced search dynamics.", "configspace": "", "generation": 8, "fitness": 0.888973283354101, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.007. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f63d666a-9074-4de4-8d51-1ea4601970d2", "metadata": {"aucs": [0.8957759163010275, 0.8793546010156698, 0.8917893327456053], "final_y": [0.11284356626625747, 0.11275391938146662, 0.11081138083558928]}, "mutation_prompt": null}
{"id": "b752d1e3-0131-4e27-a394-2b2f0372d3fd", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget))  # Changed: added cosine oscillation to cognitive coefficient\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global exploration by introducing a dynamic cognitive coefficient that oscillates with a cosine function.", "configspace": "", "generation": 9, "fitness": 0.8843380003410544, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.009. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "3a65e7be-266e-4838-93f9-c057070019c8", "metadata": {"aucs": [0.8933693438852722, 0.8715690854020107, 0.88807557173588], "final_y": [0.11299770000118592, 0.1168759199228937, 0.10976414523441536]}, "mutation_prompt": null}
{"id": "d161d7ac-f479-4c65-8d58-cd52251d83d4", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor + 0.01 * np.random.normal()  # Changed: added adaptive noise component to mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Modify mutation rate to include adaptive noise to enhance exploration capability.", "configspace": "", "generation": 10, "fitness": 0.8870436167247612, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.014. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3a65e7be-266e-4838-93f9-c057070019c8", "metadata": {"aucs": [0.8674535572128911, 0.9006369599709781, 0.8930403329904141], "final_y": [0.11064092394875702, 0.11163349609309992, 0.11161934968348886]}, "mutation_prompt": null}
{"id": "a8ddff1e-7c89-413f-8710-25b3afcbba29", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * (1 - np.std(personal_best_value)), self.dim)  # Changed: adaptive mutation intensity\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation intensity based on performance variance to enhance exploration stability.", "configspace": "", "generation": 11, "fitness": 0.8881017191704107, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.007. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "3a65e7be-266e-4838-93f9-c057070019c8", "metadata": {"aucs": [0.8957605127132606, 0.8793671538245205, 0.8891774909734509], "final_y": [0.11286042324423995, 0.11267392799413534, 0.11103988409733545]}, "mutation_prompt": null}
{"id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed: added sinusoidal component to cognitive coefficient\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a time-varying sinusoidal component in the cognitive coefficient to enhance diversity and convergence speed.", "configspace": "", "generation": 12, "fitness": 0.8924035781457237, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.892 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "3a65e7be-266e-4838-93f9-c057070019c8", "metadata": {"aucs": [0.8981806909364476, 0.8839063286782753, 0.8951237148224482], "final_y": [0.11275918703835386, 0.11629289028958789, 0.11024837965610657]}, "mutation_prompt": null}
{"id": "d0d16e0f-6eac-4aa7-b91e-0bb9d13f4ada", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed: added sinusoidal component to social coefficient\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a time-varying sinusoidal component in the social coefficient to further enhance exploration and convergence speed.", "configspace": "", "generation": 13, "fitness": 0.8704790139269081, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.014. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.855266811003675, 0.8670166602959551, 0.8891535704810943], "final_y": [0.12430898257702216, 0.11656912512410655, 0.11066739565383465]}, "mutation_prompt": null}
{"id": "693741d0-8ecb-4987-a020-e6e320adfd1b", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor + 0.05 * np.cos(2 * np.pi * evaluations / self.budget)  # Changed: added cosine component to mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Add dynamic adjustment to the mutation rate for improved exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.8694197796109986, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.009. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8571408693221847, 0.8730581941460834, 0.8780602753647277], "final_y": [0.12370965331080575, 0.11305716579301583, 0.11056436043881401]}, "mutation_prompt": null}
{"id": "8c67e73b-d9e1-4043-bc86-5df213400b8a", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) * np.exp(-0.1 * evaluations / self.budget)  # Changed: integrated exponential factor into inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Integrate an exponential factor into the inertia weight for improved convergence control.", "configspace": "", "generation": 15, "fitness": 0.8888249401507694, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.005. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8890004115246732, 0.8822025671050204, 0.8952718418226145], "final_y": [0.11335244029131031, 0.11707036133399373, 0.1102259949484593]}, "mutation_prompt": null}
{"id": "88c4f1fe-f453-4f45-9eea-31499c55ba24", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed: added sinusoidal component to social coefficient\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a time-varying sinusoidal component in both cognitive and social coefficients for enhanced exploration and convergence.", "configspace": "", "generation": 16, "fitness": 0.8704790139269081, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.014. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.855266811003675, 0.8670166602959551, 0.8891535704810943], "final_y": [0.12430898257702216, 0.11656912512410655, 0.11066739565383465]}, "mutation_prompt": null}
{"id": "f6e6d0c9-8976-4043-8c6b-19ef4b2340bf", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * (1 - adaptive_factor), self.dim)  # Changed: refined mutation magnitude\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation magnitude based on exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.8910500710901021, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.008. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8979193627202366, 0.8802752833055136, 0.894955567244556], "final_y": [0.1131158638476909, 0.11642500544874346, 0.11025789790942497]}, "mutation_prompt": null}
{"id": "4f575488-0dfb-4d0c-bda4-2fdbaebd07af", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget) + 0.01 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed: added additional sinusoidal component to inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Add a small sinusoidal component to the inertia weight to balance exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.8858966603036996, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.008. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8899326076449362, 0.8753651980119168, 0.8923921752542457], "final_y": [0.11212820851324423, 0.11645063302777348, 0.11014448951490075]}, "mutation_prompt": null}
{"id": "15b808be-0a09-418d-837d-b1048b1fff7b", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                scaling_factor = 1 + 0.1 * np.sin(np.pi * evaluations / self.budget)  # Added dynamic scaling factor\n                self.velocity[i] = scaling_factor * (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Incorporate an adaptive dynamic scaling factor in the velocity update to enhance exploration and exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.8775149961020929, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.005. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8758070231864508, 0.8841329020024659, 0.8726050631173621], "final_y": [0.11388364600865741, 0.11662205992511643, 0.11423694299191622]}, "mutation_prompt": null}
{"id": "da4dc31e-1a9f-4435-b584-5558aedd04f6", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Adjusted mutation rate with sinusoidal component\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Use an adaptive factor to dynamically adjust the mutation rate for better exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.882301183511765, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.012. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8706771715996725, 0.87674052123621, 0.8994858576994126], "final_y": [0.11218048872054454, 0.11630275491031772, 0.11025070163632622]}, "mutation_prompt": null}
{"id": "9a4f5034-fcb6-4ef7-9db7-318191fed423", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.1 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed: added sinusoidal component to inertia weight\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a time-varying sinusoidal component in the inertia weight to enhance exploration and exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.868099956422955, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.010. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8788763774869758, 0.8705329115087489, 0.8548905802731406], "final_y": [0.11153297948430341, 0.1162241980844474, 0.11793800212120753]}, "mutation_prompt": null}
{"id": "ac771fb7-baae-48dd-9d91-b2d8f7ed6ab7", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor) * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget))  # Changed: added dynamic adaptation to social coefficient\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic adaptation of the social coefficient based on the evaluations to balance exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.8722409299079095, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.872 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8852606719580003, 0.8582947829325865, 0.8731673348331415], "final_y": [0.11312737057693423, 0.11767616961389826, 0.11273867576208374]}, "mutation_prompt": null}
{"id": "9f8dba27-e2d5-4c67-a521-86705db4ebb1", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 * np.exp(-0.1 * evaluations / self.budget) + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Adjust the inertia weight formula to incorporate an exponential decay factor, enhancing balance between exploration and exploitation.", "configspace": "", "generation": 23, "fitness": 0.8907360915606702, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.007. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8977266355258592, 0.8811931475573785, 0.8932884915987729], "final_y": [0.11274227741087739, 0.11700145801089246, 0.11056684813567075]}, "mutation_prompt": null}
{"id": "f96148cd-c156-4bee-99fa-a35596cc1a28", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n            constriction_factor = 0.729  # Added: dynamic constriction factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = constriction_factor * (  # Applied: constriction factor to velocity\n                                    inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Incorporate a dynamic constriction factor to adaptively regulate swarm velocity and enhance convergence.", "configspace": "", "generation": 24, "fitness": 0.827620997645481, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.016. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8323578703851119, 0.8448184426232141, 0.805686679928117], "final_y": [0.1339651170987023, 0.12873128956615332, 0.12705846761990025]}, "mutation_prompt": null}
{"id": "53fed7ee-5202-4f2c-8585-9c0c5e3a588f", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i] + np.random.normal(0, 0.01, self.dim)  # Changed: random perturbation to global best\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by adding a random perturbation to global best in AdaptiveSwarmGradientDescent.", "configspace": "", "generation": 25, "fitness": 0.8752763404127464, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.013. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.857360012499175, 0.8797962425726038, 0.8886727661664603], "final_y": [0.1131616921898102, 0.11624622609039925, 0.11021788006567945]}, "mutation_prompt": null}
{"id": "aad7c515-321d-475b-b067-4c676234e8b1", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = (0.5 + 0.5 * (adaptive_factor ** 2) + \n                              0.1 * (global_best_value / np.mean(personal_best_value)))  # Changed: dynamic inertia weight based on fitness landscape\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic inertia weight adaptation based on the fitness landscape to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.8678692695047993, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.013. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8686124720570221, 0.8836572328055952, 0.8513381036517805], "final_y": [0.11777704934850008, 0.1175238265384938, 0.12267602995671778]}, "mutation_prompt": null}
{"id": "8759d8d3-694c-46a9-8e86-4782c2c74c38", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n                    inertia_weight *= 0.99  # Changed: adaptive inertia weight decay based on improvement\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive inertia weight decay based on the current best solution's improvement rate to balance exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.8905930085110206, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.007. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8984866433360055, 0.8820167141212042, 0.8912756680758523], "final_y": [0.11277065393322083, 0.11650266398394116, 0.11120969953395554]}, "mutation_prompt": null}
{"id": "81f14024-deb6-45e2-8bcf-2098c30163a8", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value) \n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor * quality_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation strength based on current solution quality to enhance exploration capabilities.", "configspace": "", "generation": 28, "fitness": 0.8924038384023644, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.892 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "ea5722fc-3759-40ea-a84e-9e91cfe88c2c", "metadata": {"aucs": [0.8981806966729167, 0.8839069360750911, 0.8951238824590854], "final_y": [0.1127591861436884, 0.11629293076034686, 0.1102483894338766]}, "mutation_prompt": null}
{"id": "1d0fac62-928a-4db3-ad6d-29821a0f1e57", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * np.mean(personal_best_value) / (np.std(personal_best_value) + 1e-9)  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value)\n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor * quality_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce dynamic mutation rate adjustment based on the relative improvement in solution quality.", "configspace": "", "generation": 29, "fitness": 0.8813000429950416, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.002. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "81f14024-deb6-45e2-8bcf-2098c30163a8", "metadata": {"aucs": [0.878505290891461, 0.8813208438320834, 0.8840739942615804], "final_y": [0.11025869623240203, 0.11524938556970377, 0.11258241666253754]}, "mutation_prompt": null}
{"id": "bbb9caa9-85aa-4a71-acb3-233587c4bf7b", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(4 * np.pi * evaluations / self.budget)  # Changed line\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value) \n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor * quality_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by adjusting cognitive coefficient using adaptive sine wave modulation based on evaluations.", "configspace": "", "generation": 30, "fitness": 0.8860643507980627, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.013. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "81f14024-deb6-45e2-8bcf-2098c30163a8", "metadata": {"aucs": [0.8970814739503936, 0.8678938549148165, 0.8932177235289779], "final_y": [0.11328637178986667, 0.12026162963403819, 0.11107154221249937]}, "mutation_prompt": null}
{"id": "aab22e28-a83b-4e7e-b2bc-8276a3d13b74", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 1.5) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed exponent from 2 to 1.5\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value) \n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor * quality_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance solution diversity by introducing adaptive inertia weight granularity for better convergence speed.", "configspace": "", "generation": 31, "fitness": 0.8696991328902944, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.006. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "81f14024-deb6-45e2-8bcf-2098c30163a8", "metadata": {"aucs": [0.8653606618575506, 0.877827612177581, 0.8659091246357516], "final_y": [0.11446871862865149, 0.111640159106693, 0.11646987221901983]}, "mutation_prompt": null}
{"id": "2ba17f95-e78f-4d59-80d9-b16b7f745a17", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value) \n                    swarm[i] += np.random.normal(0, 0.05 * adaptive_factor * quality_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                # Local search step\n                if evaluations % (self.population_size * 5) == 0:\n                    local_search = global_best + np.random.normal(0, 0.01 * adaptive_factor, self.dim)\n                    local_search = np.clip(local_search, lb, ub)\n                    f_local_value = func(local_search)\n                    evaluations += 1\n                    if f_local_value < global_best_value:\n                        global_best = local_search\n                        global_best_value = f_local_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce local search step based on the best solution to refine convergence near the optimum. ", "configspace": "", "generation": 32, "fitness": 0.8647153885332385, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.018. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "81f14024-deb6-45e2-8bcf-2098c30163a8", "metadata": {"aucs": [0.8562187104536911, 0.8481403857091634, 0.889787069436861], "final_y": [0.12349796747291286, 0.12403917436420586, 0.11257270064845648]}, "mutation_prompt": null}
{"id": "84614cea-fdf6-47e9-9d66-e1fcb3254b98", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value) \n                    swarm[i] += np.random.normal(0, 0.07 * adaptive_factor * quality_factor, self.dim)  # Changed here\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by introducing Gaussian perturbations to swarm positions based on adaptive mutation strength.", "configspace": "", "generation": 33, "fitness": 0.8925102547935402, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "81f14024-deb6-45e2-8bcf-2098c30163a8", "metadata": {"aucs": [0.8983907080193012, 0.8839495716293231, 0.8951904847319961], "final_y": [0.11275733600252213, 0.11625650897661122, 0.11030448715210195]}, "mutation_prompt": null}
{"id": "b9e7b482-e6e6-473d-a375-2fd5de87122d", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * np.sin(adaptive_factor * np.pi)  # Changed here\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value)\n                    swarm[i] += np.random.normal(0, 0.07 * adaptive_factor * quality_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Further refine the AdaptiveSwarmGradientDescent by varying the inertia weight non-linearly to enhance convergence speed.", "configspace": "", "generation": 34, "fitness": 0.8552316367922868, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.015. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "84614cea-fdf6-47e9-9d66-e1fcb3254b98", "metadata": {"aucs": [0.8364604129420294, 0.856933707766536, 0.8723007896682949], "final_y": [0.11970294841878648, 0.12633683781272143, 0.11389233848132696]}, "mutation_prompt": null}
{"id": "1d659e3f-b7a3-4a13-860f-0087bdf91550", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value) \n                    worst_factor = 1.0 + 0.1 * (np.max(personal_best_value) - personal_best_value[i])  # Changed here\n                    swarm[i] += np.random.normal(0, 0.07 * adaptive_factor * quality_factor * worst_factor, self.dim)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by increasing the magnitude of Gaussian perturbations based on adaptive mutation strength and swarm's worst-performing individuals.", "configspace": "", "generation": 35, "fitness": 0.8924290909448637, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.892 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "84614cea-fdf6-47e9-9d66-e1fcb3254b98", "metadata": {"aucs": [0.898390911246308, 0.8837006276828967, 0.8951957339053865], "final_y": [0.11275712834725404, 0.11639176134491236, 0.11030449044129065]}, "mutation_prompt": null}
{"id": "4deb718a-5130-4229-b995-66db07d68b03", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                \n                if np.random.rand() < mutation_rate:\n                    quality_factor = 1.0 + 0.1 * (personal_best_value[i] - global_best_value)\n                    swarm[i] += np.random.normal(0, 0.07 * adaptive_factor * quality_factor * (1.0 + 0.1 * np.random.rand()), self.dim)  # Changed here\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by increasing diversity in swarm positions using a dynamic mutation rate adjusted by the relative performance of the global best.", "configspace": "", "generation": 36, "fitness": 0.8654053951024565, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.011. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "84614cea-fdf6-47e9-9d66-e1fcb3254b98", "metadata": {"aucs": [0.8582298261616214, 0.856775194768859, 0.8812111643768894], "final_y": [0.1239018915858624, 0.11669022508132731, 0.11167745025232967]}, "mutation_prompt": null}
{"id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance solution diversity and convergence rate by introducing chaotic maps for parameter adaptation and Levy flight for mutation.", "configspace": "", "generation": 37, "fitness": 0.9042311533756981, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "84614cea-fdf6-47e9-9d66-e1fcb3254b98", "metadata": {"aucs": [0.9085088258894429, 0.8955092979898353, 0.9086753362478164], "final_y": [0.1098105026113988, 0.11531314680930926, 0.11390612043082338]}, "mutation_prompt": null}
{"id": "cea954fc-d002-4c58-9a66-a47a50cb6d9a", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            fitness_weight = (global_best_value - np.min(personal_best_value)) / max(global_best_value, 1e-8)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor) * fitness_weight\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor * (1 + 0.1 * np.random.normal())\n                    swarm[i] += self.levy_flight(L)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Integrate fitness-based adaptive parameters and a turbulence model to improve convergence and solution quality.", "configspace": "", "generation": 38, "fitness": 0.7214797113076741, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.721 with standard deviation 0.039. And the mean value of best solutions found was 0.191 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.6742236092708342, 0.7696667143518401, 0.7205488103003479], "final_y": [0.21165837522517217, 0.16977944384341603, 0.19008529272185115]}, "mutation_prompt": null}
{"id": "b369a165-7dbe-480f-80cc-e9677aa4d035", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.cos(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence by dynamically adjusting the cognitive coefficient using a cosine function.", "configspace": "", "generation": 39, "fitness": 0.9005141515159464, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.014. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.910842171501212, 0.8807778748890975, 0.9099224081575294], "final_y": [0.11050431683198891, 0.11364628625313433, 0.1134237069033378]}, "mutation_prompt": null}
{"id": "75779bad-c5e0-489f-9190-d3efb315e2fa", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(4.0 * x * (1 - x), 1.0)  # Adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L) + np.random.normal(0, 0.01, self.dim)  # Added perturbation\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve the algorithm by introducing a diversity-enhancing perturbation and adjusting the chaotic map for better exploration.", "configspace": "", "generation": 40, "fitness": 0.8794978181553513, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.020. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.8764391236208929, 0.8564915194838202, 0.9055628113613409], "final_y": [0.12471309909290329, 0.1266723432654614, 0.11066350202586128]}, "mutation_prompt": null}
{"id": "c802ebe4-4a84-4ee7-90e4-846fdea00bef", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)\n\n    def quantum_variation(self, q):\n        return np.random.uniform(-1, 1, self.dim) * q\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n            \n            quantum_effect = 0.1 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.5:\n                    swarm[i] += self.quantum_variation(quantum_effect)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve convergence by integrating quantum-inspired variation and enhancing exploration-exploitation balance with adaptive parameter tuning.", "configspace": "", "generation": 41, "fitness": 0.8954855398153653, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.895 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.8906558995612514, 0.8845856504437443, 0.9112150694411002], "final_y": [0.11542367749396054, 0.12014881941047606, 0.11339950749155525]}, "mutation_prompt": null}
{"id": "e3de5f59-8072-4e5d-b765-d0eb65422b37", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor**2)  # Non-linear scaling for better exploitation\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor * np.cos(np.pi * evaluations / self.budget)  # Cosine decay mutation\n                    swarm[i] += self.levy_flight(L)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation based on a cosine decay schedule and enhance global exploitation by scaling social coefficients non-linearly.", "configspace": "", "generation": 42, "fitness": 0.8950073447784602, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.895 with standard deviation 0.022. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.9079046356978561, 0.8636663655084569, 0.913451033129068], "final_y": [0.11097179293614112, 0.12696988989128144, 0.11245313164522464]}, "mutation_prompt": null}
{"id": "0f0725a3-fcb4-400b-b5a6-7585cb141ccf", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.7  # Initial value for the chaotic map\n        velocity_memory = np.zeros_like(self.velocity)  # Track velocities\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                velocity_memory[i] = self.velocity[i]  # Remember past velocity\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                if np.dot(self.velocity[i], velocity_memory[i]) < 0:  # Check for direction change\n                    self.velocity[i] *= 0.9  # Dampen velocity if direction changed\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve swarm convergence by introducing per-particle inertia and velocity adaptation based on historical successes and failures.", "configspace": "", "generation": 43, "fitness": 0.8956998218938593, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.009. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.8874042329173456, 0.8912026276334086, 0.908492605130824], "final_y": [0.11749017450337784, 0.11549038692103364, 0.11480267630556873]}, "mutation_prompt": null}
{"id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve global search capabilities by adjusting chaotic map parameters and incorporating a modified crossover mechanism for diversity.", "configspace": "", "generation": 44, "fitness": 0.9131263578426956, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.010. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eb0e66d1-f3b1-4401-8413-49d412fc2cea", "metadata": {"aucs": [0.9091291057679529, 0.9028178191929936, 0.9274321485671402], "final_y": [0.11230862475823922, 0.11637610868044412, 0.11073214247242635]}, "mutation_prompt": null}
{"id": "e4ab9f86-6766-4315-baff-2d3d19630930", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                dynamic_crossover_rate = 0.05 + 0.1 * (1 - evaluations / self.budget)  # Dynamic crossover rate\n                if np.random.rand() < dynamic_crossover_rate:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n                    if f_value < global_best_value:  # Ensure global best is updated within personal best\n                        global_best = swarm[i]\n                        global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic crossover rate and improve global best update to enhance exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.8888147114078834, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.013. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8981444022858635, 0.8985320401079925, 0.8697676918297944], "final_y": [0.11227559271162602, 0.11685690334899412, 0.12815946437087122]}, "mutation_prompt": null}
{"id": "ee810368-4918-48bf-83cb-0cea9c2a2519", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(4.0 * x * (1 - x) + 0.035, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.08:  # 8% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration and exploitation balance by refining chaotic mapping and crossover parameters.", "configspace": "", "generation": 46, "fitness": 0.8910688442438578, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8789045839967129, 0.8908289202860544, 0.9034730284488062], "final_y": [0.1257061227717966, 0.11976233914056489, 0.1108355394883882]}, "mutation_prompt": null}
{"id": "d8ad661c-d389-4bf5-911a-4b5929eb214f", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.1 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Dynamic mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L * np.random.rand())  # Enhanced Levy flight\n\n                # Refined crossover mechanism\n                if np.random.rand() < 0.2:  # Increased crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_points = np.random.choice(self.dim, size=int(0.2 * self.dim), replace=False)\n                    swarm[i][crossover_points] = personal_best[partner_idx][crossover_points]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance algorithm exploration with a dynamic mutation approach and refined crossover to improve diversity and convergence.  ", "configspace": "", "generation": 47, "fitness": 0.9030434385384565, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.009. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8908292261489296, 0.9056704799328529, 0.912630609533587], "final_y": [0.1190948761516547, 0.11632223979584422, 0.1115883642773342]}, "mutation_prompt": null}
{"id": "6f7db7d1-0c9e-4a1d-8ae6-9f76f0d55e99", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(4 * np.pi * evaluations / self.budget)  # Change here\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.15:  # Change here\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by adjusting inertia weight oscillation frequency and increasing crossover probability.", "configspace": "", "generation": 48, "fitness": 0.8871835717113444, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.013. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8875524485412971, 0.903415335081833, 0.8705829315109034], "final_y": [0.11125390739724483, 0.1162727257269861, 0.12821510927872404]}, "mutation_prompt": null}
{"id": "577f6201-b93c-4083-a4a2-0c98e86f9a8d", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.1 * np.sin(2 * np.pi * evaluations / self.budget)  # Adjusted\n            social_coeff = 1.5 * (1 - adaptive_factor) + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)  # Adjusted\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by adjusting cognitive and social coefficients and incorporating a dynamic mutation rate based on convergence progress.", "configspace": "", "generation": 49, "fitness": 0.8931522922816288, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.014. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.873589286683394, 0.9045981951468713, 0.9012693950146211], "final_y": [0.12582866093606826, 0.116872433852647, 0.11883032727275278]}, "mutation_prompt": null}
{"id": "d8f2b5cb-d360-4df1-9c33-7d55ef645654", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < adaptive_factor:  # Dynamic crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence by incorporating dynamic crossover rates and more frequent chaotic map updates.  ", "configspace": "", "generation": 50, "fitness": 0.9001746399702407, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.002. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.902710493160491, 0.9010288431412523, 0.8967845836089788], "final_y": [0.1131142122558989, 0.11641202404780127, 0.11810656246006512]}, "mutation_prompt": null}
{"id": "6d2841e3-05b4-48a2-877e-ab418aaf0391", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.cos(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.12 * adaptive_factor\n\n            if evaluations % 10 == 0:  # Multi-population strategy\n                secondary_swarm_idx = np.random.choice(range(self.population_size), size=self.population_size//3, replace=False)\n                secondary_swarm = swarm[secondary_swarm_idx]\n                secondary_personal_best_value = np.array([func(x) for x in secondary_swarm])\n                secondary_global_best = secondary_swarm[np.argmin(secondary_personal_best_value)]\n                if func(secondary_global_best) < global_best_value:\n                    global_best = secondary_global_best\n                    global_best_value = func(secondary_global_best)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance solution searching by integrating dynamic inertia and multi-population strategy to improve diversity and convergence.", "configspace": "", "generation": 51, "fitness": 0.8989980826664056, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.016. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8805667255464826, 0.8976788752087433, 0.9187486472439905], "final_y": [0.12420314797354115, 0.11662720577343477, 0.10968168062449768]}, "mutation_prompt": null}
{"id": "fc03366b-0198-4a5f-92c3-27b78b3bf293", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(4.02 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence precision by fine-tuning the chaotic map parameters to better guide the search.", "configspace": "", "generation": 52, "fitness": 0.9123851652436038, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9155496809199577, 0.9040053322026862, 0.9176004826081678], "final_y": [0.11080771335267525, 0.1162452846471359, 0.11213184293160405]}, "mutation_prompt": null}
{"id": "94d6071d-215d-4c8f-ba76-e47ab70da2b8", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            chaos_factor = np.random.rand() * 0.1  # Added chaos factor\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget) + chaos_factor\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence by introducing a probabilistic chaos factor in inertia weight adaptation.", "configspace": "", "generation": 53, "fitness": 0.880670856877205, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.010. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.880773346579844, 0.8926645153380535, 0.8685747087137174], "final_y": [0.1182856349414163, 0.12105832132909489, 0.12596805978180126]}, "mutation_prompt": null}
{"id": "926554ca-cb58-4365-bb06-a5753f91bef4", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                crossover_rate = 0.1 * (1 - evaluations / self.budget)  # Dynamic crossover rate\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence by introducing a dynamic crossover rate based on function evaluations.", "configspace": "", "generation": 54, "fitness": 0.9083705057862281, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.005. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.905607932040061, 0.9035908196646016, 0.9159127656540217], "final_y": [0.11357350982313241, 0.11626084951327331, 0.11077765766927572]}, "mutation_prompt": null}
{"id": "bb6a263c-fda7-4322-ac56-d3ab07bf1402", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * (1 + adaptive_factor) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed line\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance the exploration-exploitation balance by dynamically adapting the cognitive coefficient based on the chaotic parameter. ", "configspace": "", "generation": 55, "fitness": 0.8979743836859934, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.014. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8837702058526162, 0.89287184686391, 0.9172810983414542], "final_y": [0.12346565728603132, 0.1202210840238479, 0.1121370416115578]}, "mutation_prompt": null}
{"id": "57e381d9-aceb-4266-903c-2b7a267832b6", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.95 * x * (1 - x) + 0.05, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                dynamic_crossover_rate = 0.05 + 0.05 * adaptive_factor\n                if np.random.rand() < dynamic_crossover_rate:  # Dynamic crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic crossover rate and adapt chaotic map parameters for improved convergence.", "configspace": "", "generation": 56, "fitness": 0.9015571124469158, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.007. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9044858494321182, 0.8918942170438591, 0.9082912708647706], "final_y": [0.1112019996534207, 0.12041759703576516, 0.11282478616806768]}, "mutation_prompt": null}
{"id": "2edd7fb1-a634-4135-bf62-a4816f9a8976", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def opposition_based_learning(self, swarm, lb, ub):\n        return lb + ub - swarm\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.4 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.05 + 0.15 * adaptive_factor  # Adjusted mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                opposition = self.opposition_based_learning(swarm[i], lb, ub)\n                swarm[i] = np.where(np.random.rand(self.dim) < 0.5, swarm[i], opposition)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by adapting particle velocities using opposition-based learning and incorporate adaptive mutation rates for better convergence.", "configspace": "", "generation": 57, "fitness": 0.8204926754015621, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.007. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8122865501748934, 0.819108782831969, 0.830082693197824], "final_y": [0.14636033639856139, 0.14964195127854696, 0.13441677146421283]}, "mutation_prompt": null}
{"id": "ad249fd5-c72a-45c4-939a-e5efa1812326", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Improved crossover mechanism\n                if np.random.rand() < 0.2:  # Increased crossover rate to 20%\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_points = np.random.choice(range(1, self.dim), 2, replace=False)\n                    crossover_points.sort()\n                    swarm[i][crossover_points[0]:crossover_points[1]] = personal_best[partner_idx][crossover_points[0]:crossover_points[1]]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced global exploration with adaptive chaos and improved crossover for diversity.", "configspace": "", "generation": 58, "fitness": 0.9083226551533651, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.016. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8876297471375966, 0.9256391148958972, 0.9116991034266015], "final_y": [0.11774101676651605, 0.11199018351446477, 0.11597204957315232]}, "mutation_prompt": null}
{"id": "c8ac8b73-4707-421e-ae5c-7939791c03b7", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.85  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.45 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.6 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.4 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced convergence by refining velocity update and adaptive parameters for better exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.8989893686260371, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.006. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8973928667908384, 0.8922876348779875, 0.9072876042092853], "final_y": [0.11099286666172237, 0.11633614421340788, 0.11424549267246908]}, "mutation_prompt": null}
{"id": "2bc4531d-3a17-4df5-ae45-d49ed2419f7b", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor * (1 - evaluations / self.budget) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic cognitive coefficient adjustment based on iteration progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.9116518338890174, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.004. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9170393973711563, 0.907770228791756, 0.9101458755041396], "final_y": [0.11066494581946751, 0.11645530008172744, 0.11381948639263151]}, "mutation_prompt": null}
{"id": "4e893c9b-cbfe-4e6b-99d3-81238eff2ce2", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.95 * x * (1 - x) + 0.05, 1.0)  # Tweaked nonlinearity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.15:  # Increased crossover rate to 15%\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by tweaking the chaotic map's nonlinearity and increasing the crossover rate to refine diversity.", "configspace": "", "generation": 61, "fitness": 0.8791679706079183, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.002. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8769303636145751, 0.8811748926092045, 0.8793986555999755], "final_y": [0.12574296147443487, 0.12346427615992328, 0.1252658405931435]}, "mutation_prompt": null}
{"id": "0644367e-8d9b-4db9-967b-ec14236f5167", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(4.0 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.2:  # 20% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global exploration by refining chaotic map dynamics and increasing crossover probability for broader search.", "configspace": "", "generation": 62, "fitness": 0.8892348009721752, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.009. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8859342390153363, 0.9011009679790113, 0.880669195922178], "final_y": [0.11629088154393108, 0.11741284346903857, 0.12592154714220027]}, "mutation_prompt": null}
{"id": "9a3208f3-750b-4355-8474-894b6174e2b7", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.2:  # Increased crossover rate to 20%\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance convergence by increasing the crossover rate to improve exploration capabilities.", "configspace": "", "generation": 63, "fitness": 0.8803442495305829, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.020. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8539555112839339, 0.9010964279229244, 0.8859808093848901], "final_y": [0.13021002259186631, 0.11690053041244342, 0.12363316900951882]}, "mutation_prompt": null}
{"id": "b19e8b64-89e5-499c-b22d-31a26cf4fe3b", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            diversity = np.std(swarm, axis=0).mean()  # Calculate swarm diversity\n            mutation_rate = 0.15 * adaptive_factor * diversity  # Adjust mutation based on diversity\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance local exploration with dynamic adjustment of mutation rate based on swarm diversity to improve solution quality.", "configspace": "", "generation": 64, "fitness": 0.9016178553050906, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.023. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.869559210859314, 0.9105267523228446, 0.9247676027331135], "final_y": [0.1211645435121047, 0.11714837018025359, 0.11020159885603587]}, "mutation_prompt": null}
{"id": "4ed751e4-cbe4-4651-befb-22ef12fa3dd6", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.978 * x * (1 - x) + 0.04, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.82  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.12 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration and exploitation balance by fine-tuning chaotic and mutation mechanisms.", "configspace": "", "generation": 65, "fitness": 0.8869288761605078, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.010. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8747780727683332, 0.8984388481641203, 0.8875697075490695], "final_y": [0.12369761549429681, 0.12021152720956307, 0.1227282609857333]}, "mutation_prompt": null}
{"id": "19d0e523-cd90-4b4a-8e17-5934e0af1051", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.95 * x * (1 - x) + 0.05, 1.0)  # Changed map dynamics slightly\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.15:  # Increased crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance swarm adaptability by refining chaotic map dynamics and crossover strength for improved solution exploration.", "configspace": "", "generation": 66, "fitness": 0.8791679706079183, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.002. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8769303636145751, 0.8811748926092045, 0.8793986555999755], "final_y": [0.12574296147443487, 0.12346427615992328, 0.1252658405931435]}, "mutation_prompt": null}
{"id": "e3b4b234-2aaa-4650-974e-0e36b880cc56", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.2 * adaptive_factor  # Adjusted mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global search efficiency by tweaking chaotic map parameters and introducing a refined adaptive mutation mechanism for increased diversity.", "configspace": "", "generation": 67, "fitness": 0.8914221999047115, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.005. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8858167006500595, 0.8915824338479671, 0.8968674652161082], "final_y": [0.1163302403124834, 0.11636646971190545, 0.12050413623804679]}, "mutation_prompt": null}
{"id": "f8702d17-9b82-407e-9629-3a4589e77632", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * (1 - evaluations / self.budget)  # Linearly decreasing mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation rate that decreases linearly over the iterations for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.8809164961054646, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.009. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8752824691471606, 0.8743492142647151, 0.8931178049045181], "final_y": [0.1266610657491436, 0.12370619488343026, 0.11949058502635934]}, "mutation_prompt": null}
{"id": "8ba464c3-3680-400b-87a2-5ac3ba9a57f0", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(4.01 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global exploration by slightly increasing the chaotic map influence, leveraging its non-linear dynamic behavior.", "configspace": "", "generation": 69, "fitness": 0.9081928427660889, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.013. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9164291561233842, 0.8898306453335665, 0.9183187268413161], "final_y": [0.1107380149003403, 0.11634740418028688, 0.11065292213184585]}, "mutation_prompt": null}
{"id": "a137a31a-866a-49c4-9ce1-8141e397deda", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.97 * x * (1 - x) + 0.02, 1.0)  # Slightly adjusted for enhanced exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.2 * adaptive_factor  # Increased mutation rate to enhance exploration\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global search by refining chaotic map parameters and dynamically adjusting mutation based on search progress.", "configspace": "", "generation": 70, "fitness": 0.8927111805752146, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.015. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8770475726469321, 0.8879087161066945, 0.9131772529720172], "final_y": [0.12658659678749973, 0.1202752034255491, 0.11309259929612459]}, "mutation_prompt": null}
{"id": "d37ad8b3-cb8e-462f-b31d-f7f3d423ccb6", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = np.random.uniform(0.4, 0.9) * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.1 + 0.15 * adaptive_factor  # Increased dynamic mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve solution quality by enhancing exploration through randomized self-adaptive velocity scaling and introducing dynamic mutation.", "configspace": "", "generation": 71, "fitness": 0.8871864927335705, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.024. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8540141897654915, 0.8966671561477407, 0.9108781322874795], "final_y": [0.13367981603143875, 0.1212032954196528, 0.11567610938110662]}, "mutation_prompt": null}
{"id": "eb29bb97-1237-431c-ae2a-d031dd4d6e07", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.95 * x * (1 - x) + 0.05, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by updating the chaotic map equation for improved dynamic control.", "configspace": "", "generation": 72, "fitness": 0.9094556219399016, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.909 with standard deviation 0.012. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.92385262828833, 0.8952967032182061, 0.9092175343131685], "final_y": [0.11066284963146655, 0.11485496868655187, 0.11587092324766235]}, "mutation_prompt": null}
{"id": "d9f23f1e-ddf9-4762-8bfb-2aefa7d17f69", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor * (1.5 - chaotic_param)  # Adjusted mutation scaling\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                crossover_rate = 0.05 + 0.1 * chaotic_param  # Dynamic crossover rate\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global optimization by introducing adaptive mutation scaling and dynamic crossover probability.", "configspace": "", "generation": 73, "fitness": 0.8913229566422854, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.015. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8718633393126403, 0.894923767907705, 0.9071817627065109], "final_y": [0.12484708400788447, 0.11719313176242496, 0.11481852752998634]}, "mutation_prompt": null}
{"id": "8f5ee4cc-3857-4099-97ac-c926ad63323a", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.05, 1.0)  # Adjusted slightly for better exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by adjusting the chaotic map dynamics to improve diversity.", "configspace": "", "generation": 74, "fitness": 0.9061160146019255, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.012. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9091634594990671, 0.88996452436728, 0.9192200599394298], "final_y": [0.11233921833140392, 0.1165922412111543, 0.11001784324636787]}, "mutation_prompt": null}
{"id": "d6fee9f2-a9e8-4793-9af3-5907c1552a23", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate * (personal_best_value[i] / global_best_value):\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance local search by introducing a dynamic mutation rate based on fitness improvement.", "configspace": "", "generation": 75, "fitness": 0.8887886149701373, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.008. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.878221065371532, 0.8924488677323346, 0.8956959118065453], "final_y": [0.12628719826595658, 0.1202414037005548, 0.11629667149800371]}, "mutation_prompt": null}
{"id": "7eaa06cd-755a-466b-b7a8-47c4f92ec6de", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) + \n                                    0.01 * np.sin(2 * np.pi * chaotic_param))  # Added sinusoidal perturbation\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by integrating sinusoidal perturbation into velocity updates for stochastic diversity.", "configspace": "", "generation": 76, "fitness": 0.9110679465445578, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.010. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9067462624701295, 0.9014270332328944, 0.9250305439306497], "final_y": [0.11306422551486162, 0.11640468742709131, 0.11046133028659622]}, "mutation_prompt": null}
{"id": "9274533d-f926-4357-9cbf-54a5226b9160", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.10 * adaptive_factor  # Decreased mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance solution diversity by adapting mutation rate dynamically and introducing competition between personal bests.", "configspace": "", "generation": 77, "fitness": 0.8924341571275614, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.892 with standard deviation 0.018. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8666068316476581, 0.9027782961725297, 0.9079173435624965], "final_y": [0.12930778556811173, 0.11621935607833644, 0.11375945569234058]}, "mutation_prompt": null}
{"id": "78f3c45c-2e5d-4286-9c14-3175e7839d82", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * chaotic_param  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce an adaptive mutation rate influenced by the chaotic map, improving exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.8974553701375889, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.897 with standard deviation 0.022. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8781099939672291, 0.8858033756083685, 0.9284527408371689], "final_y": [0.12523054763892594, 0.12056773049054126, 0.11005025256546974]}, "mutation_prompt": null}
{"id": "9038b638-2e2a-43c1-b8a9-ef5e552e912a", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                dynamic_crossover_rate = 0.1 + 0.4 * (1 - evaluations / self.budget)  # Dynamic crossover rate\n                if np.random.rand() < dynamic_crossover_rate:  # 10% to 50% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve exploitation by introducing a dynamic crossover rate that adapts based on current iteration progress.", "configspace": "", "generation": 79, "fitness": 0.9069243813676454, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.024. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8737879917317424, 0.9159994193434128, 0.930985733027781], "final_y": [0.12951855360064268, 0.1133163095861115, 0.10999657736906165]}, "mutation_prompt": null}
{"id": "588b56e7-4479-4ae3-ba1a-95c405c9d1e8", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.03 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                neighbor_idx = (i + np.random.randint(1, self.population_size)) % self.population_size\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.1 * (swarm[neighbor_idx] - swarm[i]))  # Added neighborhood influence\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration and convergence using dynamic neighborhood-based communication with adaptive parameter tuning.", "configspace": "", "generation": 80, "fitness": 0.9114245373595402, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.019. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9195196801299677, 0.8854865298565422, 0.9292674020921106], "final_y": [0.11007764765341732, 0.12058141622567364, 0.11185095157897373]}, "mutation_prompt": null}
{"id": "8b05a6b9-fd3e-4ba9-839d-f880e0486c99", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.18 * adaptive_factor  # Increased slightly from 0.15\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global exploration by slightly increasing the mutation rate adaptively.", "configspace": "", "generation": 81, "fitness": 0.8940823983613365, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.015. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8779342675076767, 0.8911630183473815, 0.9131499092289515], "final_y": [0.12582938096741292, 0.12038534286801394, 0.11186494782814549]}, "mutation_prompt": null}
{"id": "94fb07ca-ae86-4940-a1e9-5364d36441ee", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += 1 / (1 + np.exp(-self.velocity[i]))  # Change: Apply sigmoid function\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                if np.random.rand() < 0.1:  # 10% crossover rate\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance the solution update mechanism with a sigmoid function to balance exploration and exploitation.", "configspace": "", "generation": 82, "fitness": 0.7967508354119611, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.021. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8055175698007534, 0.8164962373882293, 0.7682386990469005], "final_y": [0.14434105759659954, 0.14829887120150365, 0.16170915002342134]}, "mutation_prompt": null}
{"id": "706d2476-70a0-4e8a-8489-c6df2317fb21", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x), 1.0)  # Removed the constant addition\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor) * np.random.uniform(0.9, 1.1)  # Added variability\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by introducing a dynamic social coefficient and refining the chaotic map transformation.", "configspace": "", "generation": 83, "fitness": 0.8947889891363192, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.895 with standard deviation 0.020. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8979415033874932, 0.9179219357418019, 0.8685035282796625], "final_y": [0.1116998095285252, 0.11183576980499388, 0.12720469387236588]}, "mutation_prompt": null}
{"id": "6824b13a-a6c9-403f-8173-2b294a591e6a", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)  # Slightly adjusted\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8  # Adjusted initial value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                # Modified crossover mechanism\n                dynamic_crossover_rate = 0.05 + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n                if np.random.rand() < dynamic_crossover_rate:\n                    partner_idx = np.random.randint(self.population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance exploration by dynamically adapting crossover probability and introducing enhanced chaotic parameter scaling.", "configspace": "", "generation": 84, "fitness": 0.8877886970723509, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.018. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.8665672549685994, 0.8873608440175025, 0.9094379922309507], "final_y": [0.13012897494013143, 0.12019468805325173, 0.11381933875982087]}, "mutation_prompt": null}
{"id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance global and local exploration via dynamic population sizing and strategic parameter tuning.", "configspace": "", "generation": 85, "fitness": 0.9139977182392164, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.011. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d6f898dd-a5cd-49c3-a5f9-3aa876cb0294", "metadata": {"aucs": [0.9114026687337512, 0.9019166084117508, 0.9286738775721471], "final_y": [0.11061318730996228, 0.11626087729042245, 0.11001206820713538]}, "mutation_prompt": null}
{"id": "70c6770c-4500-48dc-9a6c-fa1d7a85b56a", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.4 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.7 * (1 - adaptive_factor)\n            mutation_rate = 0.2 * adaptive_factor  # Adjusted mutation rate\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) + \n                                    0.1 * np.random.randn(self.dim))  # Added local search\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Integrates local search with non-linear adaptive velocity updates to enhance convergence rate and solution quality.", "configspace": "", "generation": 86, "fitness": 0.8804387993834167, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.013. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8821475360921951, 0.8957011594430643, 0.8634677026149911], "final_y": [0.117130788771174, 0.11967824165059637, 0.12666732229195055]}, "mutation_prompt": null}
{"id": "c56337bb-72cd-496a-b57c-b692cc22b058", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def calculate_diversity(self, swarm):\n        return np.mean(np.std(swarm, axis=0))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            diversity = self.calculate_diversity(swarm)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget) * diversity\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce dynamic inertia weight scaling based on swarm diversity to improve exploration and exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.7936741929290408, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.006. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.7990231441477206, 0.7967084160287367, 0.7852910186106652], "final_y": [0.15723719634915234, 0.1592929316147077, 0.16307066656276314]}, "mutation_prompt": null}
{"id": "fb6e23fa-c656-40c2-981b-9cfe10103963", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def sine_cosine_map(self, x):\n        return 0.5 * (np.sin(x * np.pi) + np.cos(x * np.pi))\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            sine_cosine_param = self.sine_cosine_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * sine_cosine_param ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance adaptive exploration with a multi-faceted strategic update using chaotic maps and adaptive inertia.", "configspace": "", "generation": 88, "fitness": 0.9135144733708177, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.010. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.9099600623590197, 0.9028217752659313, 0.9277615824875022], "final_y": [0.11070275133056817, 0.11622981136702903, 0.1101523468526232]}, "mutation_prompt": null}
{"id": "d2017644-4b8f-4ca3-a0fb-45bc0ff02cda", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * chaotic_param  # Changed line\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Improve global exploration by adapting mutation rate based on chaotic dynamics.", "configspace": "", "generation": 89, "fitness": 0.8960183057185597, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.023. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8758675592447359, 0.8834502694083871, 0.9287370885025561], "final_y": [0.12534236783353636, 0.12164235475240681, 0.11006248254916096]}, "mutation_prompt": null}
{"id": "4efa70ba-9cca-48bb-bd26-91fe0712d8f0", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                chaotic_velocity = self.chaotic_map(self.velocity[i])  # Introduce chaos in velocity\n                self.velocity[i] = (inertia_weight * chaotic_velocity +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_points = np.random.randint(1, self.dim, size=np.random.randint(1, self.dim))\n                    for cp in crossover_points:  # Dynamic crossover\n                        swarm[i][cp] = personal_best[partner_idx][cp]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce chaotic variability in velocity and dynamic crossover to enhance swarm diversity and adaptability.", "configspace": "", "generation": 90, "fitness": 0.8535868953149203, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.012. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8390118549473946, 0.854060005236907, 0.8676888257604589], "final_y": [0.14084488884567925, 0.1369210199879436, 0.1295511039100894]}, "mutation_prompt": null}
{"id": "d2383513-4688-4c9b-bba4-749462c1465d", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            # Change: Introduce dynamic chaotic parameter for exploration\n            chaotic_exploration_param = 0.1 * np.sin(2 * np.pi * evaluations / self.budget)\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    chaotic_exploration_param * (np.random.uniform(lb, ub, self.dim) - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a dynamic chaotic exploration parameter for enhanced solution diversity and adaptability.", "configspace": "", "generation": 91, "fitness": 0.8852480397400925, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.003. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8868861484307772, 0.8883688186842441, 0.8804891521052562], "final_y": [0.11657609323134532, 0.11700443946054817, 0.11948816766442982]}, "mutation_prompt": null}
{"id": "09cf4889-3903-4114-9581-23d501f0ecbc", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce chaotic learning rate to further enhance convergence speed and precision.", "configspace": "", "generation": 92, "fitness": 0.9139977182392164, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.011. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.9114026687337512, 0.9019166084117508, 0.9286738775721471], "final_y": [0.11061318730996228, 0.11626087729042245, 0.11001206820713538]}, "mutation_prompt": null}
{"id": "cd07337e-07b9-4bec-b8af-77b9d55fb07f", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def fractional_brownian_motion(self, H):\n        return np.cumsum(np.random.normal(0, 1, self.dim)) * (np.arange(1, self.dim + 1) ** H)\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L) + self.fractional_brownian_motion(adaptive_factor)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce hybrid exploration with fractional Brownian motion and adaptive chaotic maps for improved balance in exploration-exploitation.", "configspace": "", "generation": 93, "fitness": 0.8934921509040659, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.024. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8591010997387861, 0.9139037807328271, 0.9074715722405845], "final_y": [0.13083063486765967, 0.11413501138846627, 0.11362926161089237]}, "mutation_prompt": null}
{"id": "96591f4f-d33a-4577-88ec-941101d53b13", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n        last_global_best_value = global_best_value\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            \n            # Adjust mutation rate based on fitness improvement\n            fitness_improvement_rate = np.abs(global_best_value - last_global_best_value) / max(1e-8, np.abs(last_global_best_value))\n            mutation_rate = 0.15 * adaptive_factor * (1 + fitness_improvement_rate)\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            last_global_best_value = global_best_value\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation based on fitness improvement rate to enhance solution diversity.", "configspace": "", "generation": 94, "fitness": 0.9139977182392164, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.011. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.9114026687337512, 0.9019166084117508, 0.9286738775721471], "final_y": [0.11061318730996228, 0.11626087729042245, 0.11001206820713538]}, "mutation_prompt": null}
{"id": "69a3f76b-dd35-417e-9764-bc6f12c5fe21", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n            \n            learning_rate = 0.7 * adaptive_factor + 0.3  # New adaptive learning rate\n\n            if evaluations % (self.budget // 10) == 0: \n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * learning_rate * (personal_best[i] - swarm[i]) +  # Apply learning rate\n                                    social_coeff * r2 * learning_rate * (global_best - swarm[i]))  # Apply learning rate\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor * chaotic_param  # Integrate chaotic levy flights\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive learning rates and chaotic levy flight for improved convergence. ", "configspace": "", "generation": 95, "fitness": 0.8850646894295919, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.011. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8719681924438912, 0.8986507868777797, 0.884575088967105], "final_y": [0.12813612206608527, 0.11933229052326078, 0.12011222904542185]}, "mutation_prompt": null}
{"id": "5e561939-71d0-4604-963b-ad1b9ff42b51", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * chaotic_param  # Adjusted to use chaotic_param\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < chaotic_param:  # Adjust crossover probability using chaotic_param\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Integrate adaptive hyper-parameter tuning with enhanced exploration-exploitation balance through chaos-driven mutation and crossover adjustments.", "configspace": "", "generation": 96, "fitness": 0.8991094869154607, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.006. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8995619320769307, 0.8909679906153584, 0.9067985380540932], "final_y": [0.11638292541906836, 0.12030410447708806, 0.11332036141775104]}, "mutation_prompt": null}
{"id": "9b3a448a-592b-497e-82d4-5e2322185586", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def gradient_descent(self, x, func, lr=0.01):\n        grad = (func(x + lr) - func(x - lr)) / (2 * lr)\n        return x - lr * grad\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                if evaluations % (self.budget // 5) == 0:  # Gradient-based local search\n                    swarm[i] = self.gradient_descent(swarm[i], func)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce a gradient-based local search phase in strategic iterations for refined exploitation.", "configspace": "", "generation": 97, "fitness": 0.9138171890440671, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.011. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.911117046041414, 0.9017741674909683, 0.928560353599819], "final_y": [0.11061493647431553, 0.11626087728198642, 0.11001223781113356]}, "mutation_prompt": null}
{"id": "6fe6ef1f-8c25-4975-aab8-abd29ece56ba", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor * chaotic_param  # Modified line for adaptive Levy scaling\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Introduce adaptive Levy flight scaling for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 98, "fitness": 0.908994726893865, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.909 with standard deviation 0.006. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.907535171437047, 0.9027688948291426, 0.9166801144154053], "final_y": [0.11121185227622632, 0.11636694173559692, 0.1119820708474989]}, "mutation_prompt": null}
{"id": "2317831e-f519-4f68-a210-732be4745250", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.5 + 0.5 * (adaptive_factor ** 2)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    indices = np.random.choice(self.dynamic_population_size, 3, replace=False)\n                    swarm[i] += 0.8 * (personal_best[indices[0]] - personal_best[indices[1]] + personal_best[indices[2]])  # Differential evolution inspired mutation\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Integrate differential evolution-inspired mutation and adaptive chaotic dynamics for enhanced exploration and exploitation.", "configspace": "", "generation": 99, "fitness": 0.8835049486668364, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.025. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8612637911158544, 0.8710126375795342, 0.9182384173051203], "final_y": [0.12558264637177252, 0.12409141858409356, 0.11248687320413997]}, "mutation_prompt": null}
{"id": "0fc6ae4b-c60d-4ff8-b880-345b5f41bcd5", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def chaotic_map(self, x):\n        return np.mod(3.99 * x * (1 - x) + 0.03, 1.0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        chaotic_param = 0.8\n\n        while evaluations < self.budget:\n            chaotic_param = self.chaotic_map(chaotic_param)\n            adaptive_factor = chaotic_param * (1 - evaluations / self.budget)\n            inertia_weight = 0.6 + 0.4 * (adaptive_factor ** 1.5) + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)\n            social_coeff = 1.5 * (1 - adaptive_factor)\n            mutation_rate = 0.15 * adaptive_factor\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population sizing\n                self.dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget) ** 0.5))\n\n            for i in range(self.dynamic_population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < mutation_rate:\n                    L = 0.1 * adaptive_factor\n                    swarm[i] += self.levy_flight(L)\n\n                if np.random.rand() < 0.1:\n                    partner_idx = np.random.randint(self.dynamic_population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = personal_best[partner_idx][:crossover_point]\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhance swarm intelligence by incorporating adaptive strategy for global exploration and exploitation through refined parameter balance.", "configspace": "", "generation": 100, "fitness": 0.8922759014325078, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.892 with standard deviation 0.011. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "787d8418-4f9a-417f-9c6a-6fe66e55dc52", "metadata": {"aucs": [0.8770189690189613, 0.895665196770366, 0.904143538508196], "final_y": [0.1251439965543083, 0.11946243740615758, 0.11289269795805912]}, "mutation_prompt": null}
