{"id": "6547932b-efa0-40fd-98c0-6d6d4e44ef43", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)\n        \n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Adaptive Nelder-Mead with Dynamic Bound Refinement for Efficient Local Search in Smooth Landscapes", "configspace": "", "generation": 0, "fitness": 0.656184762211322, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.656 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.656184762211322, 0.656184762211322, 0.656184762211322], "final_y": [1.0345191213582081e-05, 1.0345191213582081e-05, 1.0345191213582081e-05]}, "mutation_prompt": null}
{"id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.median(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced Adaptive Nelder-Mead with Optimized Initial Guess using Median Sampling for Improved Performance.", "configspace": "", "generation": 1, "fitness": 0.7096814243490156, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.710 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6547932b-efa0-40fd-98c0-6d6d4e44ef43", "metadata": {"aucs": [0.7096814243490155, 0.7096814243490155, 0.7096814243490155], "final_y": [3.1787469668039093e-06, 3.1787469668039093e-06, 3.1787469668039093e-06]}, "mutation_prompt": null}
{"id": "61318d68-346b-45d4-8e84-75ed08148495", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.random.uniform(func.bounds.lb, func.bounds.ub)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced Adaptive Nelder-Mead with Randomized Initial Guess for Diverse Solution Exploration.", "configspace": "", "generation": 2, "fitness": 0.6663612721503722, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.666 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.6718005281340352, 0.6581497440304127, 0.6691335442866687], "final_y": [3.5430922566813273e-06, 5.07014109346482e-06, 3.955254072171814e-06]}, "mutation_prompt": null}
{"id": "b4155d40-0b5a-49fe-8100-b329841efbef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced Adaptive Nelder-Mead with Gradient-Based Initialization for Smoother Convergence.", "configspace": "", "generation": 3, "fitness": 0.644578259188791, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.645 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.644578259188791, 0.644578259188791, 0.644578259188791], "final_y": [1.4601899355290045e-05, 1.4601899355290045e-05, 1.4601899355290045e-05]}, "mutation_prompt": null}
{"id": "cbf3cfbb-3e81-42f5-a1f0-814a0e41ee8b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a multimodal sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Refined Initial Guess through Multimodal Sampling for Enhanced Convergence in Adaptive Nelder-Mead.", "configspace": "", "generation": 4, "fitness": 0.7096814243490156, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.710 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.7096814243490155, 0.7096814243490155, 0.7096814243490155], "final_y": [3.1787469668039093e-06, 3.1787469668039093e-06, 3.1787469668039093e-06]}, "mutation_prompt": null}
{"id": "4e8e65e5-22b3-4bb5-b977-312d13f2a807", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Improved initialization by using centroid-based sampling for better initial guesses.", "configspace": "", "generation": 5, "fitness": 0.7096814243490156, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.710 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.7096814243490155, 0.7096814243490155, 0.7096814243490155], "final_y": [3.1787469668039093e-06, 3.1787469668039093e-06, 3.1787469668039093e-06]}, "mutation_prompt": null}
{"id": "46a52f8d-f795-4cbb-9d4e-f78b484e5b5a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a dynamic sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced Adaptive Nelder-Mead with Dynamic Initial Guess Using Mean Sampling for Improved Convergence.", "configspace": "", "generation": 6, "fitness": 0.7096814243490156, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.710 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.7096814243490155, 0.7096814243490155, 0.7096814243490155], "final_y": [3.1787469668039093e-06, 3.1787469668039093e-06, 3.1787469668039093e-06]}, "mutation_prompt": null}
{"id": "a2a1cb49-4cdc-4ba1-bb22-c83785af8d3b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Improved Adaptive Nelder-Mead by adjusting the initial guess to the mean of bounds for better starting points and convergence.", "configspace": "", "generation": 7, "fitness": 0.7096814243490156, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.710 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.7096814243490155, 0.7096814243490155, 0.7096814243490155], "final_y": [3.1787469668039093e-06, 3.1787469668039093e-06, 3.1787469668039093e-06]}, "mutation_prompt": null}
{"id": "c077557b-54ef-4c1d-bcd5-ed11bb4b86e6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform random sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.random.uniform(bounds[:, 0], bounds[:, 1])  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced Adaptive Nelder-Mead with Initial Guess from Random Uniform Sampling for Diverse Start Points.", "configspace": "", "generation": 8, "fitness": 0.6663612721503722, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.666 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.6718005281340352, 0.6581497440304127, 0.6691335442866687], "final_y": [3.5430922566813273e-06, 5.07014109346482e-06, 3.955254072171814e-06]}, "mutation_prompt": null}
{"id": "127a8b00-d69d-455b-b210-ccdb8708dd3d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.mean(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True}\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.05 * (func.bounds.ub[i] - func.bounds.lb[i])),  # Changed line\n                               min(func.bounds.ub[i], result.x[i] + 0.05 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Improved initial guess by using mean sampling and adjusted step size for refined bounds to enhance performance.", "configspace": "", "generation": 9, "fitness": 0.644578259188791, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.645 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.644578259188791, 0.644578259188791, 0.644578259188791], "final_y": [1.4601899355290045e-05, 1.4601899355290045e-05, 1.4601899355290045e-05]}, "mutation_prompt": null}
{"id": "7ad574fe-6e7a-475f-b244-07026cf8822f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.median(bounds, axis=1)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True, 'xatol': 1e-6}  # Changed line\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True, 'xatol': 1e-6}  # Changed line\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Improved Adaptive Nelder-Mead with Exponential Decay for Step Size Adjustment for Enhanced Convergence.", "configspace": "", "generation": 10, "fitness": 0.9154265237418223, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3e5be5b-c1fe-4fb8-b43c-2e7b1b1d28c8", "metadata": {"aucs": [0.9154265237418223, 0.9154265237418223, 0.9154265237418223], "final_y": [1.9903489831934684e-08, 1.9903489831934684e-08, 1.9903489831934684e-08]}, "mutation_prompt": null}
{"id": "dacfba50-47ed-44fd-856e-5e451c0a46a3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.random.uniform(bounds[:, 0], bounds[:, 1])  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True, 'xatol': 1e-6}  # Changed line\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True, 'xatol': 1e-6}  # Changed line\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Improved Adaptive Nelder-Mead with Initial Guess Diversity for Enhanced Convergence.", "configspace": "", "generation": 11, "fitness": 0.8330374042448258, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7ad574fe-6e7a-475f-b244-07026cf8822f", "metadata": {"aucs": [0.8278592562404776, 0.8370733550993571, 0.8341796013946425], "final_y": [4.034690116535096e-08, 2.9502548401131356e-08, 3.148191837840255e-08]}, "mutation_prompt": null}
{"id": "d9b53dc5-6a82-4581-84fa-d2e56469b430", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.median(bounds, axis=1) + np.random.uniform(-0.05, 0.05, self.dim)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True, 'xatol': 1e-7}  # Changed line\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True, 'xatol': 1e-6}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced initial guess with random perturbation and refined step size tolerance for faster convergence.", "configspace": "", "generation": 12, "fitness": 0.9229152130208851, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.923 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7ad574fe-6e7a-475f-b244-07026cf8822f", "metadata": {"aucs": [0.9386311503659275, 0.9385072345856513, 0.8916072541110767], "final_y": [1.0096209122631005e-08, 7.646845018085473e-09, 3.1156625970888496e-08]}, "mutation_prompt": null}
{"id": "edacf1b5-e705-4197-acb6-9240f524869f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveNelderMead:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        # Start with a uniform sampling to get initial guess\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_guess = np.median(bounds, axis=1) + np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n\n        # Define the callback function to track evaluation budget\n        def callback(xk):\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n        \n        # Define a function to wrap the original function with budget control\n        def func_with_budget(x):\n            if self.eval_count >= self.budget:\n                raise StopIteration(\"Budget exhausted\")\n            self.eval_count += 1\n            return func(x)\n        \n        self.eval_count = 0\n        \n        try:\n            # Use Nelder-Mead with adaptive bounds\n            result = minimize(\n                func_with_budget, \n                initial_guess, \n                method='Nelder-Mead', \n                bounds=bounds,\n                callback=callback,\n                options={'maxiter': self.budget, 'adaptive': True, 'xatol': 1e-8}  # Changed line\n            )\n        except StopIteration:\n            # Catch StopIteration to handle budget limit\n            pass\n        \n        # Refine bounds and iteratively improve\n        if self.eval_count < self.budget:\n            refined_bounds = [(max(func.bounds.lb[i], result.x[i] - 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])), \n                               min(func.bounds.ub[i], result.x[i] + 0.1 * (func.bounds.ub[i] - func.bounds.lb[i])))\n                              for i in range(self.dim)]\n            try:\n                result = minimize(\n                    func_with_budget, \n                    result.x, \n                    method='Nelder-Mead', \n                    bounds=refined_bounds,\n                    callback=callback,\n                    options={'maxiter': self.budget - self.eval_count, 'adaptive': True, 'xatol': 1e-6}\n                )\n            except StopIteration:\n                pass\n        \n        return result.x", "name": "AdaptiveNelderMead", "description": "Enhanced initial guess with dynamic perturbation factor and refined convergence criteria for improved performance.", "configspace": "", "generation": 13, "fitness": 0.9381359631536291, "feedback": "The algorithm AdaptiveNelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.938 with standard deviation 0.000. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d9b53dc5-6a82-4581-84fa-d2e56469b430", "metadata": {"aucs": [0.9375559565891571, 0.9382088696124047, 0.9386430632593252], "final_y": [7.086340256762769e-10, 1.1520435477297037e-09, 1.7166148959054397e-09]}, "mutation_prompt": null}
