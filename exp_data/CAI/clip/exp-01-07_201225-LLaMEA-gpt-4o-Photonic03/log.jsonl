{"id": "089824dd-c08a-43da-a9ca-acd03abf4ce2", "solution": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.quantum_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_population(quantum_population):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * quantum_population)\n\n        def evaluate_population(population):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in population])\n            evaluations += len(population)\n            return fitness\n\n        while evaluations < self.budget:\n            population = decode_population(self.quantum_population)\n            fitness = evaluate_population(population)\n\n            min_fitness_idx = np.argmin(fitness)\n            if fitness[min_fitness_idx] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_idx]\n                self.best_solution = population[min_fitness_idx]\n\n            for i in range(self.population_size):\n                phi = np.random.rand(self.dim)\n                R = np.random.rand(self.dim)\n                self.quantum_population[i] = (R < phi) * self.quantum_population[min_fitness_idx] + (R >= phi) * self.quantum_population[i]\n\n                mutation_rate = 1.0 / (self.dim + np.sqrt(np.sum(self.quantum_population[i]**2)))\n                mutation = mutation_rate * np.random.randn(self.dim)\n                self.quantum_population[i] = np.clip(self.quantum_population[i] + mutation, 0, 1)\n\n        return self.best_solution, self.best_fitness", "name": "AQEA", "description": "Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) leveraging quantum superposition and self-adaptive mutation for diverse exploration and exploitation balance.", "configspace": "", "generation": 0, "fitness": 0.1102351117687429, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.110 with standard deviation 0.002. And the mean value of best solutions found was 0.127 (0. is the best).", "error": "", "parent_id": null, "metadata": {"aucs": [0.10886492127612202, 0.11276404050308642, 0.10907637352702027], "final_y": [0.12989904269403785, 0.12356022339717798, 0.12739632026484693]}, "mutation_prompt": null}
{"id": "eb1e2b1a-f056-4f6d-88cb-ec9a511245cb", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.position = np.random.rand(self.population_size, dim)\n        self.velocity = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best_position = np.copy(self.position)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        while evaluations < self.budget:\n            decoded_position = decode_position(self.position)\n            fitness = evaluate_position(decoded_position)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness[i]\n                    self.personal_best_position[i] = self.position[i]\n                \n                if fitness[i] < self.global_best_fitness:\n                    self.global_best_fitness = fitness[i]\n                    self.global_best_position = self.position[i]\n\n            inertia_weight = 0.7\n            cognitive_component = 1.5\n            social_component = 1.5\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i]\n                                    + cognitive_component * r1 * (self.personal_best_position[i] - self.position[i])\n                                    + social_component * r2 * (self.global_best_position - self.position[i]))\n                self.position[i] = np.clip(self.position[i] + self.velocity[i], 0, 1)\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) using quantum superposition and adaptive velocity for efficient search space exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.11245014432614364, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.112 with standard deviation 0.001. And the mean value of best solutions found was 0.121 (0. is the best).", "error": "", "parent_id": "089824dd-c08a-43da-a9ca-acd03abf4ce2", "metadata": {"aucs": [0.11162703693675713, 0.11443932715456673, 0.11128406888710707], "final_y": [0.12235482990849367, 0.11906489100435058, 0.12134872064418878]}, "mutation_prompt": null}
{"id": "659d75fd-90cc-4a71-9228-9c8f2e987700", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.position = np.random.rand(self.population_size, dim)\n        self.velocity = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best_position = np.copy(self.position)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        while evaluations < self.budget:\n            decoded_position = decode_position(self.position)\n            fitness = evaluate_position(decoded_position)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness[i]\n                    self.personal_best_position[i] = self.position[i]\n                \n                if fitness[i] < self.global_best_fitness:\n                    self.global_best_fitness = fitness[i]\n                    self.global_best_position = self.position[i]\n\n            # Changed line for dynamic inertia weight\n            inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n            cognitive_component = 1.5\n            social_component = 1.5\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i]\n                                    + cognitive_component * r1 * (self.personal_best_position[i] - self.position[i])\n                                    + social_component * r2 * (self.global_best_position - self.position[i]))\n                self.position[i] = np.clip(self.position[i] + self.velocity[i], 0, 1)\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "QIPSO", "description": "Enhanced QIPSO by incorporating a dynamic inertia weight adjustment for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.11006969755887723, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.110 with standard deviation 0.004. And the mean value of best solutions found was 0.122 (0. is the best).", "error": "", "parent_id": "eb1e2b1a-f056-4f6d-88cb-ec9a511245cb", "metadata": {"aucs": [0.10491068956174454, 0.11118557510459126, 0.11411282801029587], "final_y": [0.13543273361172914, 0.11633650512333626, 0.1131547004609712]}, "mutation_prompt": null}
{"id": "944d6b14-819b-451e-96b5-cc58223e380a", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.position = np.random.rand(self.population_size, dim)\n        self.velocity = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best_position = np.copy(self.position)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        while evaluations < self.budget:\n            decoded_position = decode_position(self.position)\n            fitness = evaluate_position(decoded_position)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness[i]\n                    self.personal_best_position[i] = self.position[i]\n                \n                if fitness[i] < self.global_best_fitness:\n                    self.global_best_fitness = fitness[i]\n                    self.global_best_position = self.position[i]\n\n            inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n            cognitive_component = 1.5\n            social_component = 1.5\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i]\n                                    + cognitive_component * r1 * (self.personal_best_position[i] - self.position[i])\n                                    + social_component * r2 * (self.global_best_position - self.position[i]))\n                self.position[i] = np.clip(self.position[i] + self.velocity[i], 0, 1)\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "QIPSO", "description": "Enhanced QIPSO by introducing dynamic inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.11006969755887723, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.110 with standard deviation 0.004. And the mean value of best solutions found was 0.122 (0. is the best).", "error": "", "parent_id": "eb1e2b1a-f056-4f6d-88cb-ec9a511245cb", "metadata": {"aucs": [0.10491068956174454, 0.11118557510459126, 0.11411282801029587], "final_y": [0.13543273361172914, 0.11633650512333626, 0.1131547004609712]}, "mutation_prompt": null}
{"id": "af844449-50a5-413e-a710-142d77ea013a", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.position = np.random.rand(self.population_size, dim)\n        self.velocity = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best_position = np.copy(self.position)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        while evaluations < self.budget:\n            decoded_position = decode_position(self.position)\n            fitness = evaluate_position(decoded_position)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness[i]\n                    self.personal_best_position[i] = self.position[i]\n                \n                if fitness[i] < self.global_best_fitness:\n                    self.global_best_fitness = fitness[i]\n                    self.global_best_position = self.position[i]\n\n            inertia_weight = 0.7 - 0.5 * (evaluations / self.budget)  # Changed line for adaptive inertia\n            cognitive_component = 1.5\n            social_component = 1.5\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i]\n                                    + cognitive_component * r1 * (self.personal_best_position[i] - self.position[i])\n                                    + social_component * r2 * (self.global_best_position - self.position[i]))\n                self.position[i] = np.clip(self.position[i] + self.velocity[i], 0, 1)\n\n            if evaluations < self.budget / 2:  # Changed line for dynamic population size\n                self.position = np.vstack((self.position, np.random.rand(1, self.dim)))  # Adding a new particle\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) with adaptive inertia and dynamic population size for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.11120399534116661, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.111 with standard deviation 0.000. And the mean value of best solutions found was 0.125 (0. is the best).", "error": "", "parent_id": "eb1e2b1a-f056-4f6d-88cb-ec9a511245cb", "metadata": {"aucs": [0.11174907855550209, 0.11131820655078839, 0.11054470091720936], "final_y": [0.12266980438442376, 0.12664433636579664, 0.125937288896254]}, "mutation_prompt": null}
{"id": "d85ddf96-a88b-434a-a53c-56267ed8a73e", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Quantum-Enhanced Differential Evolution (QEDE) using quantum-inspired mutation and crossover strategies for enhanced exploration and convergence.", "configspace": "", "generation": 5, "fitness": 0.11385260254947416, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "eb1e2b1a-f056-4f6d-88cb-ec9a511245cb", "metadata": {"aucs": [0.11352585787954905, 0.11283149930395009, 0.11520045046492333], "final_y": [0.11711330749356041, 0.11897150660252376, 0.11014110438086566]}, "mutation_prompt": null}
{"id": "0c683bbd-dd02-4dd5-9181-329f0b6a5801", "solution": "import numpy as np\n\nclass AQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.5\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.population = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def update_velocities_and_positions():\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                quantum_component = np.random.normal(0, 1, self.dim)\n                self.velocities[i] = (\n                    self.inertia_weight * self.velocities[i] +\n                    self.c1 * r1 * (self.personal_best_positions[i] - self.population[i]) +\n                    self.c2 * r2 * (self.global_best_position - self.population[i]) +\n                    quantum_component\n                )\n                self.population[i] += self.velocities[i]\n                self.population[i] = np.clip(self.population[i], 0, 1)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness[i]\n                    self.personal_best_positions[i] = self.population[i]\n                    if fitness[i] < self.global_best_fitness:\n                        self.global_best_fitness = fitness[i]\n                        self.global_best_position = self.population[i]\n\n            update_velocities_and_positions()\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "AQIPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization (AQIPSO) leveraging dynamic quantum-inspired velocities for enhanced exploration and adaptability.", "configspace": "", "generation": 6, "fitness": 0.09713850866502571, "feedback": "The algorithm AQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.001. And the mean value of best solutions found was 0.163 (0. is the best).", "error": "", "parent_id": "d85ddf96-a88b-434a-a53c-56267ed8a73e", "metadata": {"aucs": [0.09789045300418808, 0.09743308979272525, 0.09609198319816381], "final_y": [0.1615042287537679, 0.166040707206908, 0.16210020368650024]}, "mutation_prompt": null}
{"id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Improved Quantum-Enhanced Differential Evolution (QEDE) with adaptive population size for enhanced exploration and convergence.", "configspace": "", "generation": 7, "fitness": 0.11611010202464833, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "d85ddf96-a88b-434a-a53c-56267ed8a73e", "metadata": {"aucs": [0.11566686159049044, 0.1154878938659003, 0.11717555061755425], "final_y": [0.11157262505788457, 0.11197534121340935, 0.11050258847113514]}, "mutation_prompt": null}
{"id": "52a7c456-9d9b-4cc9-a019-3b5291856b7e", "solution": "import numpy as np\n\nclass QPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.velocity = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_positions = self.population.copy()\n        self.best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n        self.c1 = 2.0  # Cognitive parameter\n        self.c2 = 2.0  # Social parameter\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def adaptive_velocity(particle, velocity, pbest, gbest):\n            r1, r2 = np.random.rand(), np.random.rand()\n            cognitive_component = self.c1 * r1 * (pbest - particle)\n            social_component = self.c2 * r2 * (gbest - particle)\n            return self.w * velocity + cognitive_component + social_component\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness[i]\n                    self.best_positions[i] = self.population[i]\n                    if fitness[i] < self.global_best_fitness:\n                        self.global_best_fitness = fitness[i]\n                        self.global_best_position = self.population[i]\n\n            for i in range(self.population_size):\n                self.velocity[i] = adaptive_velocity(self.population[i], self.velocity[i],\n                                                     self.best_positions[i], self.global_best_position)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], 0, 1)\n\n            evaluations += self.population_size\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "QPSO", "description": "Quantum-inspired Particle Swarm Optimization (QPSO) integrating adaptive velocity control for efficient exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.11109244258719753, "feedback": "The algorithm QPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.111 with standard deviation 0.001. And the mean value of best solutions found was 0.120 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11160095790208047, 0.11026677076149882, 0.11140959909801329], "final_y": [0.12014110821584023, 0.12312932991916714, 0.11775865626903936]}, "mutation_prompt": null}
{"id": "c394c7a5-6cdc-4eef-95f2-289c166be1f7", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            scale_factor = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Dynamic scaling factor\n            return base + phi * (best - base) + scale_factor * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE with dynamic scaling factor to improve adaptation and convergence.", "configspace": "", "generation": 9, "fitness": 0.10963639196297732, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.110 with standard deviation 0.001. And the mean value of best solutions found was 0.118 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11025622597869289, 0.10792999387519508, 0.110722956035044], "final_y": [0.11201432788872356, 0.12533400515868265, 0.11641181935425748]}, "mutation_prompt": null}
{"id": "47667fd8-0553-4705-96c0-73bd636613bf", "solution": "import numpy as np\n\nclass AQSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(25, 5 + dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.velocity = np.zeros_like(self.population)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.personal_best = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_inspired_update(position, velocity, best_individual, best_global):\n            phi = np.random.rand(self.dim)\n            return position + self.inertia_weight * velocity + phi * (best_individual - position) + (1 - phi) * (best_global - position)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best[i] = self.population[i]\n                    self.personal_best_fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                self.velocity[i] = quantum_inspired_update(\n                    self.population[i], \n                    self.velocity[i], \n                    self.personal_best[i], \n                    self.best_solution\n                )\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], 0, 1)\n\n            # Update inertia weight\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "AQSO", "description": "Adaptive Quantum Swarm Optimization (AQSO) integrates quantum-inspired position updates with dynamic inertia for enhanced exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.09026789939431612, "feedback": "The algorithm AQSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.005. And the mean value of best solutions found was 0.191 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.0842044407787712, 0.09645008525394072, 0.09014917215023643], "final_y": [0.21317730405884872, 0.17010744006707457, 0.19108812572416767]}, "mutation_prompt": null}
{"id": "be758fd8-df09-44a1-a39d-0782683faae1", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            psi = np.random.uniform(0.5, 0.8, self.dim)  # Changed mutation coefficient\n            return base + psi * (best - base) + (1 - psi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            crossover_rate = np.random.uniform(0.2, 0.8)  # Adaptive crossover rate\n            return np.where(rand_vec < crossover_rate, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            next_population = []\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    next_population.append(trial)\n                else:\n                    next_population.append(self.population[i])\n\n            self.population = np.array(next_population)\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Quantum-Enhanced Differential Evolution with adaptive offspring generation and elitist selection for improved exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.11248764309927291, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.112 with standard deviation 0.004. And the mean value of best solutions found was 0.122 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.10701749498299085, 0.11289810393932675, 0.11754733037550114], "final_y": [0.1351155341479665, 0.12036364004570144, 0.11071075356718252]}, "mutation_prompt": null}
{"id": "502e0983-2614-4353-8eaa-ccfa2f13b20e", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.uniform(0, 2, self.dim)  # Increased randomness range to enhance exploration\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced exploration via increased quantum mutation randomness.", "configspace": "", "generation": 12, "fitness": 0.11432977467503243, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.002. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11359172746226687, 0.11268626997919784, 0.11671132658363259], "final_y": [0.10979842725968625, 0.11633663666121952, 0.10975065637733539]}, "mutation_prompt": null}
{"id": "adb35632-1730-40c0-95c1-b0b2c1735397", "solution": "import numpy as np\n\nclass QPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(30, 5 + dim * 2)  # Adaptive swarm size based on dimensionality\n        self.positions = np.random.rand(self.swarm_size, dim)\n        self.velocities = np.zeros((self.swarm_size, dim))\n        self.personal_best_positions = self.positions.copy()\n        self.personal_best_fitness = np.full(self.swarm_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        while evaluations < self.budget:\n            decoded_positions = decode_position(self.positions)\n            fitness = evaluate_position(decoded_positions)\n\n            for i in range(self.swarm_size):\n                if fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                    if fitness[i] < self.global_best_fitness:\n                        self.global_best_fitness = fitness[i]\n                        self.global_best_position = self.positions[i]\n\n            for i in range(self.swarm_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_part = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_part = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_part + social_part\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], 0, 1)\n\n            # Update inertia weight dynamically\n            self.inertia_weight = 0.4 + 0.5 * ((self.budget - evaluations) / self.budget)\n\n        best_solution = decode_position(self.global_best_position)\n        return best_solution, self.global_best_fitness", "name": "QPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QPSO) with Adaptive Inertia Weight for enhanced exploration-exploitation balance and convergence.", "configspace": "", "generation": 13, "fitness": 0.10812534847810311, "feedback": "The algorithm QPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.108 with standard deviation 0.001. And the mean value of best solutions found was 0.121 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11003629278711424, 0.10643293456307978, 0.10790681808411529], "final_y": [0.11557319212360562, 0.12963391970419924, 0.11684327862378563]}, "mutation_prompt": null}
{"id": "8a66c759-0629-4ffd-8a4c-f16c0f33f8f5", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            F = 0.5 + 0.5 * (self.best_fitness / np.mean(self.fitness))  # Dynamic scaling factor\n            return base + F * (phi * (best - base) + (1 - phi) * (r1 - r2))\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced mutation strategy by incorporating a dynamic scaling factor for improved diversity and convergence.", "configspace": "", "generation": 14, "fitness": 0.11358507552963985, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.004. And the mean value of best solutions found was 0.117 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.10878698608649517, 0.1145264718188892, 0.11744176868353517], "final_y": [0.13000652040748562, 0.1117918685929975, 0.10975840742409626]}, "mutation_prompt": null}
{"id": "2acf6659-4bc2-4c6f-9fd9-cbc4b736d564", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.F = 0.5  # Initial scaling factor\n        self.CR = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + self.F * (phi * (best - base) + (1 - phi) * (r1 - r2))\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < self.CR, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n            # Adaptive update of scaling factor and crossover probability\n            self.F = np.clip(self.F + 0.1 * (2 * np.random.rand() - 1), 0.4, 0.9)\n            self.CR = np.clip(self.CR + 0.1 * (2 * np.random.rand() - 1), 0.7, 1.0)\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE with adaptive scaling factor and crossover probability for improved exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.1076186281416663, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.108 with standard deviation 0.001. And the mean value of best solutions found was 0.122 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.1059088999778196, 0.1075813794242576, 0.1093656050229217], "final_y": [0.12476610609648175, 0.12242997006434286, 0.11749261751629203]}, "mutation_prompt": null}
{"id": "db31258a-9e7d-4c60-87b1-cb21100b55f0", "solution": "import numpy as np\n\nclass QDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(25, 5 + 2 * dim)  # Adjusted adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_factor = 0.5  # Introduced mutation factor\n        self.crossover_prob = 0.9  # Introduced crossover probability\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            F = self.mutation_factor * np.random.rand()  # Dynamic mutation factor\n            return base + F * (best - base) + F * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < self.crossover_prob, mutant, target)  # Use crossover probability\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QDE", "description": "Enhanced Quantum-Driven Differential Evolution (QDE) with dynamic parameter tuning for improved convergence and exploration.", "configspace": "", "generation": 16, "fitness": 0.10914960737074371, "feedback": "The algorithm QDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.109 with standard deviation 0.003. And the mean value of best solutions found was 0.129 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.10470928501753007, 0.11146998635805738, 0.11126955073664369], "final_y": [0.14247623679822863, 0.12325461015961392, 0.12171802215595284]}, "mutation_prompt": null}
{"id": "7b5715cc-06d9-4654-8147-b1847826b60a", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim) * 0.8  # Adjusted mutation scale\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE with fine-tuned mutation scale for improved exploration and convergence.", "configspace": "", "generation": 17, "fitness": 0.11402532397468239, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11353288204856293, 0.11293756980533054, 0.11560552007015368], "final_y": [0.11531872583206759, 0.11346371554199686, 0.11175018971925466]}, "mutation_prompt": null}
{"id": "8f67b1ec-b8d7-401a-bc21-165012691b6d", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim) * (1 - self.best_fitness)  # Dynamic parameter\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE by replacing static quantum mutation with a dynamic parameter to improve exploration based on current fitness.", "configspace": "", "generation": 18, "fitness": 0.11311027256607124, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.003. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.10912317025717899, 0.11417085467027055, 0.11603679277076417], "final_y": [0.1273114573249583, 0.11128126936596672, 0.10972146549121298]}, "mutation_prompt": null}
{"id": "51514ee9-138c-4c8f-887e-5d16b73770cd", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim) \n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + phi * self.mutation_factor * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < self.crossover_rate, mutant, target)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced Quantum-Enhanced Differential Evolution with adaptive mutation and crossover rates for improved exploration and exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.11365311506264608, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.002. And the mean value of best solutions found was 0.118 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11208404798730798, 0.11309895933283076, 0.1157763378677995], "final_y": [0.12197160654161354, 0.11878487837560037, 0.11289611263432275]}, "mutation_prompt": null}
{"id": "c1f24492-bba7-4a33-a8f9-c58eefacb985", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            # Adaptive mutation scaling\n            F = 0.5 + 0.3 * (self.budget - evaluations) / self.budget\n            return base + F * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introducing adaptive mutation scaling in QEDE to enhance exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.11518203611249844, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.002. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11621832035032575, 0.11265312958196183, 0.11667465840520774], "final_y": [0.11170964876024614, 0.12055342130262725, 0.11262114771942788]}, "mutation_prompt": null}
{"id": "acbb13e4-9102-49c0-b840-0e2184d52613", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.7, target, mutant)  # Refined crossover probability\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE with a refined quantum crossover strategy to improve convergence.", "configspace": "", "generation": 21, "fitness": 0.11307413050068045, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.001. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11137701421200363, 0.11358251729425628, 0.11426285999578145], "final_y": [0.11868917753757169, 0.11276756810280819, 0.11326052706732681]}, "mutation_prompt": null}
{"id": "ecf7eab0-ba70-4a0b-b41f-7e4d71e35722", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            crossover_prob = 0.5 + 0.3 * (func.bounds.ub - func.bounds.lb) / (func.bounds.ub + func.bounds.lb)  # Adjusted crossover probability\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced Quantum-Enhanced Differential Evolution (QEDE) by introducing dynamic crossover probability for improved balance between exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.11353862513521862, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11426219294889217, 0.11167238125256185, 0.11468130120420184], "final_y": [0.1106879212604367, 0.1147590284024782, 0.111352319020107]}, "mutation_prompt": null}
{"id": "f6de6984-618c-4649-85d6-c27547faf430", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            delta = 0.9  # Introduced delta to adjust the balance between exploration and exploitation\n            return base + phi * (best - base) + delta * (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced Quantum-Enhanced Differential Evolution (QEDE) with modified mutation strategy for improved exploration.", "configspace": "", "generation": 23, "fitness": 0.11496382073375917, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.1153558847149545, 0.11316716589752018, 0.11636841158880284], "final_y": [0.11383189066712196, 0.11393678587519618, 0.11312487080744793]}, "mutation_prompt": null}
{"id": "2a04ce05-04f8-4c48-8cb7-2bbd2c094d97", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            \n            # Stochastic boundary reinforcement\n            rand_idx = np.random.randint(self.population_size)\n            self.population[rand_idx] = np.random.rand(self.dim) * 0.1\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE with stochastic boundary reinforcement for improved edge exploration and convergence.", "configspace": "", "generation": 24, "fitness": 0.11160398112632626, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.112 with standard deviation 0.000. And the mean value of best solutions found was 0.123 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11137029780385455, 0.11169048181711949, 0.11175116375800476], "final_y": [0.121133774190465, 0.12198175771458264, 0.12446678037846359]}, "mutation_prompt": null}
{"id": "f122ce43-2d86-451e-ae9e-39f37a75d523", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            fitness = np.array([func(ind) for ind in decoded_position])\n            self.evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2, convergence_pressure):\n            phi = np.random.rand(self.dim)\n            return base + phi * convergence_pressure * (best - base) + (1 - phi) * (r1 - r2)\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while self.evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            convergence_pressure = 1.0 - (self.evaluations / self.budget)  # Dynamic convergence strategy\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c, convergence_pressure)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "AQDE", "description": "Adaptive Quantum Differential Evolution (AQDE) with dynamic convergence pressure for improved exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.11460415725561486, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.002. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.1141585399847368, 0.11295135995056016, 0.11670257183154764], "final_y": [0.11539453619589879, 0.11726839709582948, 0.1098842311558792]}, "mutation_prompt": null}
{"id": "1e722d3b-c61f-4fd4-85dd-f235588f7788", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            # Change: Adjusted mutation to use weighted average\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * 0.9 + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced mutation strategy using a weighted average of the best-so-far and random selection to improve convergence.", "configspace": "", "generation": 26, "fitness": 0.11618724252179857, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "a2b90c32-d655-46ca-bbec-51a6627a2aad", "metadata": {"aucs": [0.11644200553155426, 0.11614852073307691, 0.11597120130076455], "final_y": [0.11167712951198339, 0.11188299735334006, 0.11013363850523084]}, "mutation_prompt": null}
{"id": "2e99ff79-6f29-4511-853d-cc64e776e37b", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            # Change: Adjusted mutation to use evaluation progress for scaling\n            scaling_factor = 0.9 + (0.1 * evaluations / self.budget)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced adaptive mutation scaling based on evaluation progress to enhance convergence toward the optimal solution.", "configspace": "", "generation": 27, "fitness": 0.11594019212120399, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "1e722d3b-c61f-4fd4-85dd-f235588f7788", "metadata": {"aucs": [0.1152954354608623, 0.11619282855435709, 0.11633231234839259], "final_y": [0.11189864981445563, 0.11194352867677548, 0.1104312151623813]}, "mutation_prompt": null}
{"id": "7b50630c-6c62-472c-be85-b6b775039cb3", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            # Change: Adjusted mutation to use weighted average\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * 0.7 + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Refined mutation scaling factor to improve balance between exploration and exploitation.", "configspace": "", "generation": 28, "fitness": 0.11382072229394886, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.000. And the mean value of best solutions found was 0.117 (0. is the best).", "error": "", "parent_id": "1e722d3b-c61f-4fd4-85dd-f235588f7788", "metadata": {"aucs": [0.114189091020938, 0.11412816116199653, 0.11314491469891208], "final_y": [0.11720435242440219, 0.11604994036617522, 0.1187572002840086]}, "mutation_prompt": null}
{"id": "797d19eb-0d5f-4b80-9dc8-62f8a92cbe8c", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            # Change: Adjusted mutation to use weighted average\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * 0.9 + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)  # Line edited to increase randomness in crossover\n            return np.where(rand_vec < 0.7, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced crossover strategy to improve exploration capabilities by increasing randomness.", "configspace": "", "generation": 29, "fitness": 0.11392294501293565, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.000. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "1e722d3b-c61f-4fd4-85dd-f235588f7788", "metadata": {"aucs": [0.11352754602418147, 0.1140652172668486, 0.11417607174777689], "final_y": [0.11311351574157213, 0.11316422807087345, 0.11209489434778408]}, "mutation_prompt": null}
{"id": "b1116c87-0c95-4247-a1a8-99e747f5e2ca", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced mutation strategy with adaptive scaling factor based on budget consumption to improve convergence.", "configspace": "", "generation": 30, "fitness": 0.11618738108393893, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "1e722d3b-c61f-4fd4-85dd-f235588f7788", "metadata": {"aucs": [0.11634356254131561, 0.11525804539319373, 0.11696053531730743], "final_y": [0.11186165667057901, 0.11430145810401116, 0.10990566396495649]}, "mutation_prompt": null}
{"id": "b3bcf49e-4ec1-4ee4-920d-157a2a89e22c", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            scaling_factor = 0.9 * (1 - evaluations / self.budget) + np.random.normal(0, 0.01)  # Change: Added stochastic perturbation\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introducing a modest stochastic perturbation in the adaptive scaling factor to enhance exploration capabilities.", "configspace": "", "generation": 31, "fitness": 0.11482293058712068, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "b1116c87-0c95-4247-a1a8-99e747f5e2ca", "metadata": {"aucs": [0.114487382609747, 0.11384840854517886, 0.11613300060643617], "final_y": [0.11430507042339444, 0.11609670934986072, 0.11183661294363101]}, "mutation_prompt": null}
{"id": "5daa0e02-6e03-4013-a0bd-9df9c9f0577d", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            scaling_factor = 0.9 * (1 - evaluations / self.budget) + 0.1 * np.var(self.population, axis=0).mean()  # Change: Diversity-aware scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a diversity preservation mechanism by modifying the scaling factor to avoid premature convergence.", "configspace": "", "generation": 32, "fitness": 0.11614964409797875, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "b1116c87-0c95-4247-a1a8-99e747f5e2ca", "metadata": {"aucs": [0.11653082840144546, 0.11532080719523785, 0.11659729669725294], "final_y": [0.11177939967363115, 0.11424189113822159, 0.11012876045316411]}, "mutation_prompt": null}
{"id": "780f389f-746f-4099-91e3-67140825a17f", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * 0.1\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            crossover_rate = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Change: Dynamic crossover probability\n            return np.where(rand_vec < crossover_rate, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduce dynamic crossover probability to enhance exploration and exploitation balance in the quantum DE algorithm.", "configspace": "", "generation": 33, "fitness": 0.10914071698796446, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.109 with standard deviation 0.002. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "b1116c87-0c95-4247-a1a8-99e747f5e2ca", "metadata": {"aucs": [0.1068308773803075, 0.11025429488949068, 0.1103369786940952], "final_y": [0.11304658460533856, 0.1122857384184398, 0.11245011212968792]}, "mutation_prompt": null}
{"id": "5899c32d-9224-4034-8bc9-53d5137fae16", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Refined quantum mutation by dynamically adjusting the perturbation factor based on evaluations to further enhance convergence.", "configspace": "", "generation": 34, "fitness": 0.1167320779849554, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "b1116c87-0c95-4247-a1a8-99e747f5e2ca", "metadata": {"aucs": [0.11656983785170683, 0.11637128379829631, 0.11725511230486307], "final_y": [0.11171520026726012, 0.11145405890894511, 0.10976266645432176]}, "mutation_prompt": null}
{"id": "e28db5f5-eb8f-4949-90dc-ea030cb1ae4e", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * ((1 - evaluations / self.budget) ** 0.5)  # Updated: Slower decrease of perturbation\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Improved convergence by adjusting the perturbation factor to decrease more slowly, allowing more exploration.", "configspace": "", "generation": 35, "fitness": 0.11634843083475288, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11585693327283475, 0.11628582248973329, 0.1169025367416906], "final_y": [0.11339172915817775, 0.11171783026321935, 0.10982213704305999]}, "mutation_prompt": null}
{"id": "714e0cc7-2023-4e64-b529-75f201590007", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.85 * (1 - evaluations / self.budget)  # Change: Slight adjustment to scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced dynamic scaling factor to further optimize convergence speed by slight adjustment.", "configspace": "", "generation": 36, "fitness": 0.11370896893420905, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11341198126134955, 0.11496914388352641, 0.11274578165775118], "final_y": [0.11136703442320006, 0.11160075381937817, 0.12013256390095739]}, "mutation_prompt": null}
{"id": "f533eac8-33ba-4b01-ad4a-574bace2e94c", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Enhanced scaling factor for better balance\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by adjusting the quantum mutation scaling factor to 0.95 for improved exploration-exploitation balance.", "configspace": "", "generation": 37, "fitness": 0.11623524669729353, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11553942675413253, 0.11654857581749012, 0.11661773752025795], "final_y": [0.11102074708579435, 0.11169269576825991, 0.10984648865357827]}, "mutation_prompt": null}
{"id": "53c08032-196d-497e-8159-14770b01d124", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - (evaluations / self.budget) ** 2)  # Fine-tuned: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Improved quantum mutation strategy by fine-tuning the dynamic perturbation factor formula for enhanced convergence.", "configspace": "", "generation": 38, "fitness": 0.11616649711745745, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.1162114489943783, 0.11538927075096794, 0.11689877160702611], "final_y": [0.11175598227256855, 0.1140811269670916, 0.10974941987214815]}, "mutation_prompt": null}
{"id": "f533d840-1b9f-451c-810e-bbfa4d69e60c", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - np.sin(np.pi * evaluations / self.budget))  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Improved the scaling factor to be more adaptive by incorporating a sinusoidal function for better exploration and exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.11627908884666045, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11611896175289649, 0.1167988314095677, 0.11591947337751718], "final_y": [0.109463657622063, 0.11137625145658292, 0.11173480220041798]}, "mutation_prompt": null}
{"id": "60ab5169-2d8b-486f-af5a-08f77fb3d603", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.elite_fraction = 0.1  # New: Fraction of elite individuals\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.15 * (1 - evaluations / self.budget)  # Change: Adjusted perturbation for exploration\n            scaling_factor = 0.85 * (1 - evaluations / self.budget)  # Change: Adjusted scaling factor for balance\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.7, target, mutant)  # Change: Increased crossover probability\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            elite_count = int(self.elite_fraction * self.population_size)  # New: Determine elite count\n            elite_indices = np.argsort(self.fitness)[:elite_count]  # New: Identify elite individuals\n\n            for i in range(self.population_size):\n                if i in elite_indices:  # New: Preserve elite individuals\n                    continue\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced dynamic quantum mutation and crossover strategy with elite preservation to improve optimization convergence.", "configspace": "", "generation": 40, "fitness": 0.11342071390085695, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.002. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11503064329190804, 0.11106721401818842, 0.11416428439247439], "final_y": [0.11048141297293712, 0.11680048432926227, 0.11181245003038354]}, "mutation_prompt": null}
{"id": "c5d2a241-6e25-4fb4-8457-72fc92c5ea0d", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - (evaluations / self.budget)**2)  # Non-linear scaling for perturbation\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced dynamic adaptation by introducing non-linear scaling to perturbation factor for improved convergence.", "configspace": "", "generation": 41, "fitness": 0.11616649711745745, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.1162114489943783, 0.11538927075096794, 0.11689877160702611], "final_y": [0.11175598227256855, 0.1140811269670916, 0.10974941987214815]}, "mutation_prompt": null}
{"id": "4cdea44e-fa80-446e-b6d2-1195e2b0c9b3", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Fine-tuned scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Fine-tuned the scaling factor by slightly increasing its initial value for improved exploration-exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.11623524669729353, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11553942675413253, 0.11654857581749012, 0.11661773752025795], "final_y": [0.11102074708579435, 0.11169269576825991, 0.10984648865357827]}, "mutation_prompt": null}
{"id": "07f4d937-c188-4e07-bb45-9addf18aea01", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget) * (1 + np.sin(evaluations))  # Updated: Self-adaptive perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced mutation by incorporating a self-adaptive perturbation factor for improved convergence dynamics.", "configspace": "", "generation": 43, "fitness": 0.1149515722275684, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11564928207466241, 0.11603542842872427, 0.1131700061793185], "final_y": [0.11051873969462378, 0.11154259884462936, 0.11478812546617201]}, "mutation_prompt": null}
{"id": "9991bd40-c780-4497-9240-7f58735404e7", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Adjusted scaling factor decay rate\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by refining the scaling factor's decay rate for improved exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.11623524669729353, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11553942675413253, 0.11654857581749012, 0.11661773752025795], "final_y": [0.11102074708579435, 0.11169269576825991, 0.10984648865357827]}, "mutation_prompt": null}
{"id": "bebbc882-8f3f-4912-854f-9ff486c963d2", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            convergence_acceleration = 0.05 * ((best - base) * perturbation)  # New: Convergence acceleration\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + convergence_acceleration\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced adaptive mutation by introducing convergence acceleration terms to improve efficiency.", "configspace": "", "generation": 45, "fitness": 0.11363005723660224, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.002. And the mean value of best solutions found was 0.119 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.1104808758749638, 0.11452260658875446, 0.11588668924608847], "final_y": [0.12764951869095065, 0.11671712000115975, 0.1140529430102567]}, "mutation_prompt": null}
{"id": "7209d6b0-7154-414c-9c55-bc1c6059386e", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)\n            scaling_factor = 0.8 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhance the convergence rate by adjusting the quantum mutation scaling factor.", "configspace": "", "generation": 46, "fitness": 0.11440272771327797, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11390189317807953, 0.11311227406713442, 0.11619401589461997], "final_y": [0.11372122945661245, 0.11963180884202762, 0.1117490956011934]}, "mutation_prompt": null}
{"id": "e94b4700-42e3-4202-81be-23df700ad5c5", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            crossover_prob = 0.5 + 0.3 * (evaluations / self.budget)  # Change: Adaptive crossover probability\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced adaptive crossover probability based on evaluations to enhance diversity and convergence speed.", "configspace": "", "generation": 47, "fitness": 0.11367169082897222, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.117 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11504945133141309, 0.11407967045949918, 0.11188595069600438], "final_y": [0.1130377854345771, 0.11505099306732625, 0.12190744291608535]}, "mutation_prompt": null}
{"id": "7a6115e2-b876-4779-913e-da37aacdc005", "solution": "import numpy as np\n\nclass QEDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, 5 + dim)  # Change: Larger adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.2 * (1 - evaluations / self.budget)  # Updated: Increase perturbation factor\n            return base + phi * (r1 - r2) + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def elitism_selection():\n            elite_indices = np.argsort(self.fitness)[:max(1, self.population_size // 4)]\n            return self.population[elite_indices]\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            elites = elitism_selection()  # Change: Use elitism to guide selection\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a = self.population[np.random.choice(idxs)]\n                b, c = np.random.choice(elites, 2, replace=False)\n                mutant = quantum_mutation(a, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = mutant\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE_Enhanced", "description": "Enhanced quantum-inspired mutation with adaptive elite selection for improved convergence in complex optimization landscapes.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {}, "mutation_prompt": null}
{"id": "7a06672d-0cd2-4ffa-9bf4-e6c18b9839ed", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            # Adaptive crossover probability\n            crossover_prob = 0.5 + 0.5 * (1 - evaluations / self.budget)\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced adaptive crossover probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.10910403524476568, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.109 with standard deviation 0.002. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.10646551603456422, 0.11040653864008587, 0.11044005105964694], "final_y": [0.11835048290639905, 0.11163183903548024, 0.11238973573758926]}, "mutation_prompt": null}
{"id": "bb95f467-c6bc-495b-b299-046eb8b8e758", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            \n            # Added elitism: Sort by fitness and keep the top half of the population\n            elite_indices = np.argsort(self.fitness)[:self.population_size//2]\n            self.population = self.population[elite_indices]\n            self.fitness = self.fitness[elite_indices]\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced moderate elitism to preserve top solutions for improved convergence stability.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 7 is out of bounds for axis 0 with size 7').", "error": "IndexError('index 7 is out of bounds for axis 0 with size 7')", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {}, "mutation_prompt": null}
{"id": "5c216c31-0a16-4874-8faa-5f7ef0392596", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Enhanced scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced scaling factor to ensure a more robust convergence.", "configspace": "", "generation": 51, "fitness": 0.11623524669729353, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11553942675413253, 0.11654857581749012, 0.11661773752025795], "final_y": [0.11102074708579435, 0.11169269576825991, 0.10984648865357827]}, "mutation_prompt": null}
{"id": "f77cb13d-a18c-4abb-b937-933170442489", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i] or np.random.rand() < 0.1:  # Change: Increase trial replacement rate\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced selection strategy to improve convergence by replacing less fitting individuals with trial solutions more frequently.", "configspace": "", "generation": 52, "fitness": 0.11449495927547197, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.002. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11297570501960463, 0.11713307341885926, 0.11337609938795201], "final_y": [0.11702063244618188, 0.10942271158331884, 0.11751711579600566]}, "mutation_prompt": null}
{"id": "7dd76c3c-7306-448f-8234-e8986359444f", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget) + np.var(self.population) * 0.01  # Updated perturbation\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by introducing differential perturbation in quantum mutation based on variance of the population.", "configspace": "", "generation": 53, "fitness": 0.11669118982999864, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11653547405282116, 0.11636584029210917, 0.11717225514506557], "final_y": [0.11171476425579385, 0.11143463345050098, 0.10974505957121017]}, "mutation_prompt": null}
{"id": "13e13670-a42e-4e65-8a82-24dc171640b5", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 1.0 * (1 - evaluations / self.budget)  # Change: Increased adaptive scaling factor slightly\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Slightly increase the scaling factor's influence on the mutation for more exploration capability.", "configspace": "", "generation": 54, "fitness": 0.11484717272720428, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11518061602585405, 0.11408473450547973, 0.11527616765027904], "final_y": [0.1148399473165328, 0.11633768037555037, 0.11178786311081557]}, "mutation_prompt": null}
{"id": "ba167ed8-5981-4110-84a3-bd3a52e74c0e", "solution": "import numpy as np\n\nclass EQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, 7 + dim)  # Increased adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.2 * (1 - evaluations / self.budget)  # Increased perturbation for exploration\n            scaling_factor = 0.8 * (1 - evaluations / self.budget) + 0.1  # Adjusted scaling for diversity\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            crossover_rate = 0.6  # Introduced adaptive crossover rate\n            return np.where(rand_vec < crossover_rate, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "EQDE", "description": "Enhanced Quantum Differential Evolution (EQDE) with adaptive mutation and crossover strategies for robust convergence.", "configspace": "", "generation": 55, "fitness": 0.11428120506436812, "feedback": "The algorithm EQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11352933975207402, 0.11408438383368802, 0.11522989160734232], "final_y": [0.1117607352109996, 0.11320811878816517, 0.1111011154060525]}, "mutation_prompt": null}
{"id": "91bac2db-1154-4ec3-ad25-8457325aa267", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.15 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced dynamic perturbation factor to improve exploration and convergence balance.", "configspace": "", "generation": 56, "fitness": 0.11430286476953722, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.003. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11038534271221134, 0.116164693471563, 0.11635855812483731], "final_y": [0.12622925326690837, 0.1114388144213243, 0.11176280409155848]}, "mutation_prompt": null}
{"id": "5937e5fc-d574-4c90-9480-bb2c86a412a8", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor to 0.95\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduce a diversity-driven mechanism by making minor adjustments in the scaling factor to enhance exploration capabilities.", "configspace": "", "generation": 57, "fitness": 0.11623524669729353, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11553942675413253, 0.11654857581749012, 0.11661773752025795], "final_y": [0.11102074708579435, 0.11169269576825991, 0.10984648865357827]}, "mutation_prompt": null}
{"id": "5d455ca9-9164-44b8-bf27-e5fec714b972", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Refined quantum mutation by dynamically adjusting the perturbation factor based on evaluations to further enhance convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11656983785170683, 0.11637128379829631, 0.11725511230486307], "final_y": [0.11171520026726012, 0.11145405890894511, 0.10976266645432176]}, "mutation_prompt": null}
{"id": "520ac1ce-64c6-460f-bbca-e2d5d36a095b", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            crossover_prob = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduce an adaptive crossover probability to enhance population diversity and convergence rate.", "configspace": "", "generation": 59, "fitness": 0.10910403524476568, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.109 with standard deviation 0.002. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.10646551603456422, 0.11040653864008587, 0.11044005105964694], "final_y": [0.11835048290639905, 0.11163183903548024, 0.11238973573758926]}, "mutation_prompt": null}
{"id": "15b492c2-ef83-4f1c-9834-9f7db4d06cd2", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.2 * (1 - evaluations / self.budget)  # Updated: More aggressive dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by adjusting the quantum perturbation factor more aggressively based on evaluations to improve exploration.", "configspace": "", "generation": 60, "fitness": 0.11415372422971685, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.1130659541500274, 0.11361751771386364, 0.11577770082525951], "final_y": [0.11812303800666402, 0.11963777243976348, 0.10983761138020143]}, "mutation_prompt": null}
{"id": "052993c3-46ef-4962-8ed6-fc35df5e49bb", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 1.0 * (1 - evaluations / self.budget)  # Change: More aggressive adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Adjusted the scaling factor to adapt more aggressively to remaining evaluations, enhancing convergence speed.", "configspace": "", "generation": 61, "fitness": 0.11484717272720428, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11518061602585405, 0.11408473450547973, 0.11527616765027904], "final_y": [0.1148399473165328, 0.11633768037555037, 0.11178786311081557]}, "mutation_prompt": null}
{"id": "60d0ee16-37d7-400d-a890-a33b86fac396", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.8 * (1 - evaluations / self.budget)  # Change: Adjusting the scaling factor from 0.9 to 0.8\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced adaptive scaling by modifying the quantum mutation process to improve convergence.", "configspace": "", "generation": 62, "fitness": 0.11440272771327797, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11390189317807953, 0.11311227406713442, 0.11619401589461997], "final_y": [0.11372122945661245, 0.11963180884202762, 0.1117490956011934]}, "mutation_prompt": null}
{"id": "1ba0f703-2c53-458c-aa8e-7e3574073d9f", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n        \n        def quantum_crossover(target, mutant):\n            crossover_threshold = 0.5 * (1 + 0.5 * np.sin(np.pi * evaluations / self.budget))  # Dynamic crossover threshold\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_threshold, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a dynamic crossover threshold to enhance diversity and exploration.", "configspace": "", "generation": 63, "fitness": 0.11322056167129417, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.001. And the mean value of best solutions found was 0.118 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11484084220287571, 0.11268366384042594, 0.11213717897058084], "final_y": [0.1150993474924179, 0.11911103562326342, 0.120134296368822]}, "mutation_prompt": null}
{"id": "1b500fbd-44f5-438b-866a-39a9416900e1", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.91 * (1 - evaluations / self.budget)  # Change: Slightly increased adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced quantum mutation by introducing a slight increase in the adaptive scaling factor to improve exploration.", "configspace": "", "generation": 64, "fitness": 0.11669167124631352, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11650511266416275, 0.11630207117859803, 0.11726782989617979], "final_y": [0.11171541871406743, 0.11165984748979507, 0.10974116190063687]}, "mutation_prompt": null}
{"id": "27ea62cf-dd96-4ef6-af85-58904b66db1a", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            beta = 0.5 + 0.5 * np.random.rand()  # Added: Randomized crossover factor\n            return np.where(rand_vec < beta, target, mutant)  # Adjusted to use beta\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced quantum DE with improved crossover for better exploration.", "configspace": "", "generation": 65, "fitness": 0.11228289807042002, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.112 with standard deviation 0.000. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11244364133175733, 0.11209853718464513, 0.11230651569485761], "final_y": [0.11456486241417263, 0.11526622231031336, 0.11512572099470386]}, "mutation_prompt": null}
{"id": "8cc2dce3-f306-4b3f-b3b8-9c7bfa2804fb", "solution": "import numpy as np\n\nclass QEDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(25, 5 + dim)  # Changed: Slightly larger adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n    \n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def levy_flight(Lambda=1.5):\n            sigma1 = np.power((np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2)) /\n                              np.math.gamma((1 + Lambda) / 2) * Lambda * np.power(2, (Lambda - 1) / 2), 1 / Lambda)\n            u = np.random.normal(0, sigma1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1 / Lambda)\n            return 0.1 * step\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = levy_flight()  # Change: Use Lvy flight for mutation\n            scaling_factor = 0.8 * (1 - evaluations / self.budget)  # Adjusted scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + perturbation\n\n        def quantum_crossover(target, mutant):\n            crossover_probability = 0.7 + 0.3 * (evaluations / self.budget)  # Change: Dynamic crossover probability\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_probability, mutant, target)  # Swap mutant and target\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDEL", "description": "Enhanced adaptive search by integrating Lvy flight-based mutation and dynamic crossover probability to improve exploration capabilities.", "configspace": "", "generation": 66, "fitness": 0.10443140929942873, "feedback": "The algorithm QEDEL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.104 with standard deviation 0.001. And the mean value of best solutions found was 0.139 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.10588103616874933, 0.10366818196721717, 0.1037450097623197], "final_y": [0.136404215397549, 0.14305244269835615, 0.13627077429417112]}, "mutation_prompt": null}
{"id": "80e05f89-7761-4c76-81f4-5b41ca70bf84", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.sqrt(1 - (evaluations / self.budget))  # Updated: Further refined perturbation factor using sqrt\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced quantum mutation strategy by adjusting the perturbation factor calculation for improved convergence.", "configspace": "", "generation": 67, "fitness": 0.11634843083475288, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.000. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11585693327283475, 0.11628582248973329, 0.1169025367416906], "final_y": [0.11339172915817775, 0.11171783026321935, 0.10982213704305999]}, "mutation_prompt": null}
{"id": "a5d5e49c-1b4d-4faa-bcc4-79f2b87e1c70", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * ((1 - evaluations / self.budget) ** 2)  # Change: Non-linear adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced the adaptive scaling factor to further refine convergence by introducing non-linear scaling.", "configspace": "", "generation": 68, "fitness": 0.11655414953999414, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.1164178157044935, 0.11616907606286409, 0.11707555685262483], "final_y": [0.11169508442655807, 0.11139431112933185, 0.10974465119590682]}, "mutation_prompt": null}
{"id": "dfd3c7f6-5388-4ae4-ba94-ea6d17597080", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.05 * (1 - evaluations / self.budget)  # Updated line 1: Slightly reduced perturbation\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            elite_member = self.best_solution.copy()  # Added line 2: Implement elitism\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n            self.population[0] = elite_member  # Ensure the elite member survives\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced quantum mutation and selection strategy by adjusting the perturbation and incorporating elitism for better convergence.", "configspace": "", "generation": 69, "fitness": 0.11299190368506529, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.003. And the mean value of best solutions found was 0.120 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.10876867346656571, 0.1148794540776914, 0.11532758351093875], "final_y": [0.13253625075723596, 0.11633653086265205, 0.1096787360588436]}, "mutation_prompt": null}
{"id": "3759167e-92ad-4f54-b396-50cb32c81bf6", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - (evaluations / self.budget)**2)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by adjusting the perturbation factor and scaling factor dynamically based on the square of the evaluations ratio.", "configspace": "", "generation": 70, "fitness": 0.11616649711745745, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.1162114489943783, 0.11538927075096794, 0.11689877160702611], "final_y": [0.11175598227256855, 0.1140811269670916, 0.10974941987214815]}, "mutation_prompt": null}
{"id": "ade8742d-44c0-4cdd-986d-a73c91ac95c9", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim) * (1 - evaluations / self.budget)  # Line updated\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * 0.1  # Line added for Lvy flight\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation + levy_flight\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced exploration by incorporating Lvy flight-based mutation for improved global search capability.", "configspace": "", "generation": 71, "fitness": 0.10858979967186473, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.109 with standard deviation 0.001. And the mean value of best solutions found was 0.123 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.10894171013982057, 0.10732065279259051, 0.10950703608318313], "final_y": [0.11631901708723791, 0.12782864409277872, 0.12630349241911976]}, "mutation_prompt": null}
{"id": "cd72dcfd-fcf3-4dfb-9d4d-af1d4cab55ab", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * (1 - evaluations / self.budget)  # Updated: Dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            crossover_prob = 0.5 + 0.5 * (self.best_fitness / (self.best_fitness + 1e-8))  # Adaptive crossover probability\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced an adaptive quantum crossover probability to exploit the best solution found so far for enhanced convergence.", "configspace": "", "generation": 72, "fitness": 0.09026789939431612, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.005. And the mean value of best solutions found was 0.191 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.0842044407787712, 0.09645008525394072, 0.09014917215023643], "final_y": [0.21317730405884872, 0.17010744006707457, 0.19108812572416767]}, "mutation_prompt": null}
{"id": "3f633ca1-c5f4-4cf7-b276-9dd47af9250c", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):  # Modified mutation strategy\n            phi = np.random.rand(self.dim)\n            perturbation = 0.05 * (1 - evaluations / self.budget)  # Changed perturbation factor\n            scaling_factor = 0.8 * (1 - evaluations / self.budget)  # Adjusted scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def adaptive_de_crossover(target, mutant):  # New crossover method with adaptive strategy\n            rand_vec = np.random.rand(self.dim)\n            crossover_rate = 0.3 + 0.7 * (self.budget - evaluations) / self.budget  # Decrease crossover rate over time\n            return np.where(rand_vec < crossover_rate, mutant, target)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = adaptive_de_crossover(self.population[i], mutant)  # Apply the new crossover\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introducing adaptive differential evolution with a novel learning strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.11562454777466864, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.002. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11464987277044081, 0.1138709840214438, 0.11835278653212133], "final_y": [0.11627033444499213, 0.11963768606804881, 0.1117118834679931]}, "mutation_prompt": null}
{"id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a smoother adaptive perturbation factor to ensure better convergence and balance exploration-exploitation trade-off.", "configspace": "", "generation": 74, "fitness": 0.11674402553337648, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "5899c32d-9224-4034-8bc9-53d5137fae16", "metadata": {"aucs": [0.11659047612642703, 0.11643479451487326, 0.11720680595882915], "final_y": [0.11164090915241165, 0.11138070273002088, 0.10976534512406888]}, "mutation_prompt": null}
{"id": "f8a33080-4082-4dc1-a830-58ba7fc2e553", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.3 * self.budget))  # Updated: Altered decay rate for perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced exploitation by adjusting the perturbation factor's exponential decay rate.", "configspace": "", "generation": 75, "fitness": 0.1167209454477468, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11668995758040823, 0.1163677579890201, 0.11710512077381208], "final_y": [0.1114257722783566, 0.11140000419037888, 0.10981034524419919]}, "mutation_prompt": null}
{"id": "cf9b9b71-c812-44ca-bd89-233a0e11fce6", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced adaptive scaling for refined exploration-exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.11608513221809091, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11527809818515322, 0.11653360209791153, 0.116443696371208], "final_y": [0.11102756825702276, 0.11170660918697273, 0.10978563971642108]}, "mutation_prompt": null}
{"id": "aec46ea1-a8b3-4dcc-bc9c-f92451dbe93f", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor with faster decay\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by increasing the adaptive scaling factor's decay rate, giving the algorithm more explorative power early on.", "configspace": "", "generation": 77, "fitness": 0.11608513221809091, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11527809818515322, 0.11653360209791153, 0.116443696371208], "final_y": [0.11102756825702276, 0.11170660918697273, 0.10978563971642108]}, "mutation_prompt": null}
{"id": "6a6dcd18-7073-4d90-8235-fbeabd3ebb1d", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.2 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Improved the perturbation factor to enhance exploration during early search phases.", "configspace": "", "generation": 78, "fitness": 0.11384338328209805, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.003. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.10999529589913493, 0.11473353736331482, 0.1168013165838444], "final_y": [0.12361083872946221, 0.1151855471406692, 0.10979206749267345]}, "mutation_prompt": null}
{"id": "e1dc602b-b951-400d-bc70-a97e32532420", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.elitism_rate = 0.2  # New: Elitism rate\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor \\\n                   + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            num_elites = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            elites = self.population[elite_indices]\n\n            for i in range(self.population_size):\n                if i in elite_indices:\n                    continue\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n            # Incorporate diversity mechanism\n            if evaluations < self.budget:\n                diversity_threshold = 0.05 * (1 - evaluations / self.budget)\n                for i in range(self.population_size):\n                    diversity = np.mean([np.linalg.norm(self.population[i] - self.population[j]) for j in range(self.population_size) if j != i])\n                    if diversity < diversity_threshold:\n                        self.population[i] = np.random.rand(self.dim)\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introducing adaptive elitism and diversity mechanisms to enhance convergence and exploration capabilities in quantum differential evolution.", "configspace": "", "generation": 79, "fitness": 0.11455529365738897, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.115 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11407005296804873, 0.11434566602276797, 0.11525016198135019], "final_y": [0.11743507213826432, 0.11444637683273673, 0.11181795426007124]}, "mutation_prompt": null}
{"id": "272977dc-4ef9-4e60-b901-e2852d7b1a76", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.6, target, mutant)  # Tweaked crossover probability\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced exploitation by tweaking the crossover probability for better convergence.", "configspace": "", "generation": 80, "fitness": 0.11490705138552777, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11378282366819503, 0.11522293375178194, 0.11571539673660636], "final_y": [0.11308075205481405, 0.11254831468798876, 0.10982615306705557]}, "mutation_prompt": null}
{"id": "c8cd63f6-97ad-4c6d-8c0c-111ba4d5b307", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - (evaluations / self.budget) ** 0.5)  # Change: Enhanced scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Adjusted the mutation scaling factor to enhance exploration during early budget phases.", "configspace": "", "generation": 81, "fitness": 0.11399828254899425, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.1153888533283145, 0.11312617010098192, 0.11347982421768632], "final_y": [0.1106460546193494, 0.11867793364710122, 0.11860469631747717]}, "mutation_prompt": null}
{"id": "bbd11759-8a73-4573-b7da-fd886a62b381", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            diversity = np.mean(np.std(self.population, axis=0))\n            scaling_factor = 0.9 * (1 - evaluations / self.budget) * (1 + 0.1 * diversity)  # Change: Dynamic scaling factor based on diversity\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced convergence by dynamically adjusting scaling factor based on population diversity.", "configspace": "", "generation": 82, "fitness": 0.11653805736102792, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.110 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11612588308897032, 0.11647835598574918, 0.11700993300836426], "final_y": [0.10973271644550686, 0.11171340596548862, 0.10975637408857308]}, "mutation_prompt": null}
{"id": "bff908cc-ae5d-429a-8260-b02f56593e95", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            crossover_prob = 0.7  # Adjusted crossover probability\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced crossover mechanism by adjusting crossover probability to improve exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.11436321611333726, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11346823890299462, 0.11513991460198247, 0.11448149483503467], "final_y": [0.11442127596880292, 0.1124077614641038, 0.11218101405661063]}, "mutation_prompt": null}
{"id": "f37da764-7937-4580-8ff8-bb1794586b0b", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            chaotic_factor = np.sin(3.14 * evaluations / self.budget)  # Introduced: Chaotic modulation for diversity\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor * chaotic_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a chaotic map to modulate mutation intensity and enhance diversity and convergence.", "configspace": "", "generation": 84, "fitness": 0.11638953723556071, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11652967615787668, 0.11514204843441633, 0.1174968871143891], "final_y": [0.10982552547952829, 0.11782486401583092, 0.10985200106935078]}, "mutation_prompt": null}
{"id": "b1830a5c-a266-49d0-b9a8-81baf76da9b6", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)\n        self.population = np.random.rand(self.population_size, dim) * 0.9 + 0.05  # Change: Improved population initialization for diversity\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))\n            scaling_factor = 0.9 * np.cos(np.pi * evaluations / (2 * self.budget))  # Change: Non-linear adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced QEDE with a non-linear adaptive scaling factor and improved population initialization for better diversity.", "configspace": "", "generation": 85, "fitness": 0.1113608800167812, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.111 with standard deviation 0.002. And the mean value of best solutions found was 0.121 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11089262156000967, 0.11369051886162884, 0.10949949962870509], "final_y": [0.12347225188441657, 0.11444143022057951, 0.12371481540680895]}, "mutation_prompt": null}
{"id": "6bdf58b7-a83f-4e59-865b-e33fefe1416e", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim) * 0.8  # Altered random vector initialization for diversity enhancement\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced exploration by altering the random vector initialization in quantum crossover for improved diversity.", "configspace": "", "generation": 86, "fitness": 0.1145609766041068, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11516706322708614, 0.11390160309928499, 0.11461426348594927], "final_y": [0.11249159332513625, 0.11634277016183181, 0.11177183880826425]}, "mutation_prompt": null}
{"id": "1a912bfb-bc0f-40a3-a4bb-dfa0076e59e2", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Change: More adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Improved the scaling factor's adaptability to enhance convergence speed and solution quality.", "configspace": "", "generation": 87, "fitness": 0.11530137288595739, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11346842470614427, 0.11599989039799885, 0.11643580355372907], "final_y": [0.11813868337635636, 0.11170498629110459, 0.10976406425926377]}, "mutation_prompt": null}
{"id": "50c5e612-c2b3-4e8f-9d26-e9c3766cff95", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * np.sin(np.pi * evaluations / self.budget)  # Change: Non-linear adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            crossover_prob = 0.5 + 0.5 * evaluations / self.budget  # Change: Dynamic crossover probability\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a non-linear adaptive scaling factor and a dynamic crossover probability to enhance exploitation and exploration balance.", "configspace": "", "generation": 88, "fitness": 0.11382288221375207, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.114 with standard deviation 0.001. And the mean value of best solutions found was 0.119 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.112791306438903, 0.11489838969641397, 0.11377895050593922], "final_y": [0.11838001275114507, 0.11884207887487352, 0.12019094485348514]}, "mutation_prompt": null}
{"id": "6f50b031-6c6a-49e1-b93a-c5589fd4977e", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: Slightly modified dynamic scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Applied a slightly modified dynamic scaling factor for improved exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.11608513221809091, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11527809818515322, 0.11653360209791153, 0.116443696371208], "final_y": [0.11102756825702276, 0.11170660918697273, 0.10978563971642108]}, "mutation_prompt": null}
{"id": "6a9232a6-f2fb-4ca3-843f-9a7e8edd47c5", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < np.tanh(fitness[i] / self.best_fitness), target, mutant)  # Updated crossover strategy\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Refined the quantum crossover to adaptively adjust based on fitness improvement probability, enhancing exploration.", "configspace": "", "generation": 90, "fitness": 0.11246456279206045, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.112 with standard deviation 0.001. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11234875837443192, 0.11146866755742457, 0.11357626244432484], "final_y": [0.11533866449927277, 0.11499432927418285, 0.11189561388091762]}, "mutation_prompt": null}
{"id": "a11d2e92-f51e-45cd-a89e-fcf39928ad12", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.95 * (1 - evaluations / self.budget)  # Change: More sensitive adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a more sensitive adaptive scaling factor to enhance exploration-exploitation dynamics.", "configspace": "", "generation": 91, "fitness": 0.11608513221809091, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.001. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11527809818515322, 0.11653360209791153, 0.116443696371208], "final_y": [0.11102756825702276, 0.11170660918697273, 0.10978563971642108]}, "mutation_prompt": null}
{"id": "4ad5e894-94e5-45af-a1f5-88305aa0b7bb", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / (0.8 * self.budget))  # Change: Self-adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a self-adaptive mutation factor to enhance the exploration capability during the early stages of optimization.", "configspace": "", "generation": 92, "fitness": 0.11665387266581129, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11652194225297352, 0.11631911455903421, 0.11712056118542613], "final_y": [0.11162353466595543, 0.1113811198848289, 0.10981144894422312]}, "mutation_prompt": null}
{"id": "df13735d-ccb4-4424-821b-45736464c317", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            crossover_prob = 0.5 + 0.5 * (evaluations / self.budget)  # Change: Dynamic crossover probability\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < crossover_prob, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduced a dynamic crossover probability based on evaluation progress to enhance exploration in early phases and exploitation in later phases.", "configspace": "", "generation": 93, "fitness": 0.11459905899260121, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11354251130305193, 0.11505584624824539, 0.11519881942650634], "final_y": [0.11526557701764772, 0.11179888507467495, 0.11233308503183581]}, "mutation_prompt": null}
{"id": "42515c08-db90-4567-bae8-5b72ec947b67", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.5 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.5 * (1 - evaluations / self.budget)  # Change: Enhanced adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced the adaptive scaling factor for better exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.11613363586735488, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.002. And the mean value of best solutions found was 0.112 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11402362355098106, 0.11765467892737069, 0.11672260512371291], "final_y": [0.11742409721148395, 0.10941704242382344, 0.10980546864437724]}, "mutation_prompt": null}
{"id": "71e13bdd-5ca1-401d-9ca8-694898ddeb8a", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.4 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Enhanced adaptive perturbation factor for improved exploration capabilities as the budget progresses.", "configspace": "", "generation": 95, "fitness": 0.11675740283706741, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "e884f5f4-e56a-49bc-8df7-620ef8328c90", "metadata": {"aucs": [0.11663837973948621, 0.11634879509064333, 0.11728503368107268], "final_y": [0.11142758280033283, 0.11137414877081386, 0.10972871436157805]}, "mutation_prompt": null}
{"id": "5928bb2c-d6b2-4ada-9c1a-ae4b2ad3320c", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.4 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget) + 0.1 * np.random.rand()  # Change: Integrating decay-based randomness\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Integrate decay-based randomness to enhance mutation exploration in later stages.", "configspace": "", "generation": 96, "fitness": 0.11528546703479096, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.002. And the mean value of best solutions found was 0.114 (0. is the best).", "error": "", "parent_id": "71e13bdd-5ca1-401d-9ca8-694898ddeb8a", "metadata": {"aucs": [0.11319548391869938, 0.11704575058730582, 0.11561516659836768], "final_y": [0.11972199780588055, 0.1094989755648319, 0.11192171510958182]}, "mutation_prompt": null}
{"id": "4f7c3d91-fbb2-4abe-be9e-8197ade1a92b", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.4 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.8 + 0.2 * (1 - evaluations / self.budget)  # Modified scaling: 0.8 + 0.2 * dynamic\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Adjusted mutation factor to enhance exploration by utilizing a more dynamic scaling factor formula.", "configspace": "", "generation": 97, "fitness": 0.11521623561420276, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.115 with standard deviation 0.001. And the mean value of best solutions found was 0.113 (0. is the best).", "error": "", "parent_id": "71e13bdd-5ca1-401d-9ca8-694898ddeb8a", "metadata": {"aucs": [0.11403563378586112, 0.1158438771692587, 0.11576919588748846], "final_y": [0.11606223655010295, 0.11161015479272385, 0.1103572314736121]}, "mutation_prompt": null}
{"id": "fc1c598f-5e14-4663-9cd9-33a0606a9567", "solution": "import numpy as np\n\nclass QEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, 5 + dim)  # Changed to adaptive population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.1 * np.exp(-evaluations / (0.4 * self.budget))  # Updated: Smoother dynamic perturbation factor\n            scaling_factor = 0.9 * (1 - evaluations / self.budget)  # Change: Adaptive scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def quantum_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.5, target, mutant)\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            if evaluations % 20 == 0:  # Re-evaluate the best solution every 20 evaluations\n                best_solution_decoded = decode_position(self.best_solution)\n                best_recheck_fitness = func(best_solution_decoded)\n                evaluations += 1\n                if best_recheck_fitness < self.best_fitness:\n                    self.best_fitness = best_recheck_fitness\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = quantum_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "QEDE", "description": "Introduce elite enhancement by retaining and re-evaluating the best solution periodically.", "configspace": "", "generation": 98, "fitness": 0.11675740283706741, "feedback": "The algorithm QEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.000. And the mean value of best solutions found was 0.111 (0. is the best).", "error": "", "parent_id": "71e13bdd-5ca1-401d-9ca8-694898ddeb8a", "metadata": {"aucs": [0.11663837973948621, 0.11634879509064333, 0.11728503368107268], "final_y": [0.11142758280033283, 0.11137414877081386, 0.10972871436157805]}, "mutation_prompt": null}
{"id": "4a7698fd-f283-4a95-b43c-9e7b6fd291ca", "solution": "import numpy as np\n\nclass HybridQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 3 * dim)  # Scaled population size\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = np.vstack((func.bounds.lb, func.bounds.ub)).T\n        evaluations = 0\n\n        def decode_position(position):\n            return bounds[:, 0] + ((bounds[:, 1] - bounds[:, 0]) * position)\n\n        def evaluate_position(decoded_position):\n            nonlocal evaluations\n            fitness = np.array([func(ind) for ind in decoded_position])\n            evaluations += len(decoded_position)\n            return fitness\n\n        def quantum_mutation(base, best, r1, r2):\n            phi = np.random.rand(self.dim)\n            perturbation = 0.05 * np.exp(-evaluations / (0.3 * self.budget))  # Dynamic perturbation\n            scaling_factor = 0.8 * (1 - evaluations / self.budget)  # Scaling factor\n            return base + phi * (best - base) + (1 - phi) * (r1 - r2) * scaling_factor + phi * (np.random.rand(self.dim) - 0.5) * perturbation\n\n        def adaptive_crossover(target, mutant):\n            rand_vec = np.random.rand(self.dim)\n            return np.where(rand_vec < 0.6, target, mutant)\n\n        def stochastic_rank_selection():\n            sorted_indices = np.argsort(self.fitness)\n            ranks = np.arange(1, self.population_size + 1)\n            probabilities = 2 * (self.population_size - ranks + 1) / (self.population_size * (self.population_size + 1))\n            return sorted_indices[np.random.choice(self.population_size, p=probabilities)]\n\n        while evaluations < self.budget:\n            decoded_population = decode_position(self.population)\n            fitness = evaluate_position(decoded_population)\n\n            for i in range(self.population_size):\n                if fitness[i] < self.fitness[i]:\n                    self.fitness[i] = fitness[i]\n                    if fitness[i] < self.best_fitness:\n                        self.best_fitness = fitness[i]\n                        self.best_solution = self.population[i]\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a = self.population[stochastic_rank_selection()]\n                b, c = self.population[np.random.choice(idxs, 2, replace=False)]\n                mutant = quantum_mutation(a, self.best_solution, b, c)\n                mutant = np.clip(mutant, 0, 1)\n                trial = adaptive_crossover(self.population[i], mutant)\n\n                trial_decoded = decode_position(trial)\n                trial_fitness = func(trial_decoded)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        best_solution = decode_position(self.best_solution)\n        return best_solution, self.best_fitness", "name": "HybridQDE", "description": "Hybrid Quantum-inspired Differential Evolution with Stochastic Rank-based Selection to enhance exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.1133772693934183, "feedback": "The algorithm HybridQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.001. And the mean value of best solutions found was 0.116 (0. is the best).", "error": "", "parent_id": "71e13bdd-5ca1-401d-9ca8-694898ddeb8a", "metadata": {"aucs": [0.11318009383411332, 0.11200217351149666, 0.11494954083464493], "final_y": [0.11408476892549779, 0.12248821741091553, 0.11175227365187135]}, "mutation_prompt": null}
