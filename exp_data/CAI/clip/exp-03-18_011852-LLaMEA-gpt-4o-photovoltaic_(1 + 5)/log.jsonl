{"id": "fd267b54-ac8d-4efc-ba11-7109772a4db3", "solution": "import numpy as np\n\nclass HQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.alpha = 0.5\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = self.select_parents(population, fitness)\n                offspring = self.quantum_crossover(parent1, parent2, lb, ub)\n                new_population.append(offspring)\n            \n            new_population = np.array(new_population)\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n            \n            population, fitness = self.selection(population, fitness, new_population, new_fitness)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_solution, best_fitness = population[current_best_idx], fitness[current_best_idx]\n        \n        return best_solution, best_fitness\n    \n    def select_parents(self, population, fitness):\n        idx1, idx2 = np.random.choice(len(population), size=2, replace=False)\n        return population[idx1], population[idx2]\n    \n    def quantum_crossover(self, parent1, parent2, lb, ub):\n        q1 = self.alpha * parent1 + (1 - self.alpha) * parent2\n        q2 = self.alpha * parent2 + (1 - self.alpha) * parent1\n        offspring = q1 if np.random.rand() < 0.5 else q2\n        offspring = np.clip(offspring, lb, ub)\n        return offspring\n    \n    def selection(self, population, fitness, new_population, new_fitness):\n        combined_population = np.vstack((population, new_population))\n        combined_fitness = np.concatenate((fitness, new_fitness))\n        sorted_indices = np.argsort(combined_fitness)\n        return combined_population[sorted_indices][:self.population_size], combined_fitness[sorted_indices][:self.population_size]", "name": "HQEA", "description": "Hybrid Quantum-Inspired Evolutionary Algorithm (HQEA) combines principles of quantum computing with evolutionary strategies to efficiently explore and exploit the search space within a limited budget.", "configspace": "", "generation": 0, "fitness": 0.8383463349386043, "feedback": "The algorithm HQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.016. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": null, "metadata": {"aucs": [0.844252560037563, 0.8170507041948162, 0.8537357405834335], "final_y": [0.1388542413182755, 0.1504091797850191, 0.13633142594711012]}, "mutation_prompt": null}
