{"id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * \\\n                             np.random.uniform(0.05, 0.2)\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "The algorithm combines the exploratory power of a random walk with adaptive differential scaling strategies to efficiently navigate the search space and refine solutions.", "configspace": "", "generation": 0, "fitness": 0.249790812615128, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": null, "metadata": {"aucs": [0.25195217672316417, 0.25834931174126385, 0.23907094938095597], "final_y": [0.13050641862124077, 0.09218839076639117, 0.0943692905024889]}, "mutation_prompt": null}
{"id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            if np.random.rand() < 0.1:  # 10% chance for global exploration\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor based on evaluation progress and incorporate a small probability of global exploration to enhance convergence and avoid local optima.", "configspace": "", "generation": 1, "fitness": 0.2504375964923852, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "metadata": {"aucs": [0.2605763977228509, 0.24228299945723353, 0.24845339229707109], "final_y": [0.0036262598222203614, 0.00898367204022192, 0.0018372989088071424]}, "mutation_prompt": null}
{"id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic inertia weight and adaptive mutation factor to balance exploration and exploitation, improving convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.3056773081009247, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.306 with standard deviation 0.019. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "metadata": {"aucs": [0.32991963878858066, 0.304120076354256, 0.2829922091599374], "final_y": [0.0015924992724814684, 0.005047593837986818, 0.0006038840454873686]}, "mutation_prompt": null}
{"id": "802b4601-d59e-4f0c-86fc-91300c9fb71d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget)  # Adjusted upper limit\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                perturbation = np.random.normal(0, 0.1, self.dim)  # New line for Gaussian perturbation\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + perturbation\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration factor adjustment and enhance solution refinement using random Gaussian perturbation.", "configspace": "", "generation": 3, "fitness": 0.27240395123559796, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.028. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.3094505257690725, 0.2655214455685282, 0.24223988236919325], "final_y": [0.00885809563057967, 0.018954015175489065, 0.08096061253359946]}, "mutation_prompt": null}
{"id": "3d220014-b8db-4523-99b4-f9200000c830", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        def levy_flight(Lambda):\n            sigma = (np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2) /\n                     (np.math.gamma((1 + Lambda) / 2) * Lambda * 2 ** ((Lambda - 1) / 2))) ** (1 / Lambda)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / Lambda)\n            return 0.01 * step  # Small scaling factor\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed exploration range\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim) + levy_flight(1.5)  # Levy flight step\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a stochastic levy flight step, and refine the adaptive mutation factor for better convergence.", "configspace": "", "generation": 4, "fitness": 0.271611947478802, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.2691865333151985, 0.26491788566021635, 0.2807314234609912], "final_y": [0.0001667993478435302, 0.00437397949660532, 0.001155660409110231]}, "mutation_prompt": null}
