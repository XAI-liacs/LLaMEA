{"id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * \\\n                             np.random.uniform(0.05, 0.2)\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "The algorithm combines the exploratory power of a random walk with adaptive differential scaling strategies to efficiently navigate the search space and refine solutions.", "configspace": "", "generation": 0, "fitness": 0.249790812615128, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": null, "metadata": {"aucs": [0.25195217672316417, 0.25834931174126385, 0.23907094938095597], "final_y": [0.13050641862124077, 0.09218839076639117, 0.0943692905024889]}, "mutation_prompt": null}
{"id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            if np.random.rand() < 0.1:  # 10% chance for global exploration\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor based on evaluation progress and incorporate a small probability of global exploration to enhance convergence and avoid local optima.", "configspace": "", "generation": 1, "fitness": 0.2504375964923852, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "metadata": {"aucs": [0.2605763977228509, 0.24228299945723353, 0.24845339229707109], "final_y": [0.0036262598222203614, 0.00898367204022192, 0.0018372989088071424]}, "mutation_prompt": null}
{"id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic inertia weight and adaptive mutation factor to balance exploration and exploitation, improving convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.3056773081009247, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.306 with standard deviation 0.019. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "metadata": {"aucs": [0.32991963878858066, 0.304120076354256, 0.2829922091599374], "final_y": [0.0015924992724814684, 0.005047593837986818, 0.0006038840454873686]}, "mutation_prompt": null}
{"id": "802b4601-d59e-4f0c-86fc-91300c9fb71d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget)  # Adjusted upper limit\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                perturbation = np.random.normal(0, 0.1, self.dim)  # New line for Gaussian perturbation\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + perturbation\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration factor adjustment and enhance solution refinement using random Gaussian perturbation.", "configspace": "", "generation": 3, "fitness": 0.27240395123559796, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.028. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.3094505257690725, 0.2655214455685282, 0.24223988236919325], "final_y": [0.00885809563057967, 0.018954015175489065, 0.08096061253359946]}, "mutation_prompt": null}
{"id": "3d220014-b8db-4523-99b4-f9200000c830", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        def levy_flight(Lambda):\n            sigma = (np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2) /\n                     (np.math.gamma((1 + Lambda) / 2) * Lambda * 2 ** ((Lambda - 1) / 2))) ** (1 / Lambda)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / Lambda)\n            return 0.01 * step  # Small scaling factor\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed exploration range\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim) + levy_flight(1.5)  # Levy flight step\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a stochastic levy flight step, and refine the adaptive mutation factor for better convergence.", "configspace": "", "generation": 4, "fitness": 0.271611947478802, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.2691865333151985, 0.26491788566021635, 0.2807314234609912], "final_y": [0.0001667993478435302, 0.00437397949660532, 0.001155660409110231]}, "mutation_prompt": null}
{"id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Implement a dynamic exploration factor adjustment to improve solution discovery by gradually decreasing randomness.", "configspace": "", "generation": 5, "fitness": 0.34686963027995604, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.347 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.33485245721123735, 0.3529350603077426, 0.35282137332088814], "final_y": [2.4341930938906698e-05, 0.00027647873181912454, 0.00016709361471107354]}, "mutation_prompt": null}
{"id": "129dacb7-141c-49f2-b26e-ee25c06d4fb7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_exploration_factor = 0.1  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            self.memory_exploration_factor = (self.memory_exploration_factor + np.random.uniform(0.05, 0.15)) / 2  # Modified line\n            exploration_factor = self.memory_exploration_factor * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  \n            if np.random.rand() < 0.15:  \n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance solution refinement by incorporating a memory-based adjustment mechanism for exploration factor.", "configspace": "", "generation": 6, "fitness": 0.3381783563990246, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.338 with standard deviation 0.008. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32686530072775766, 0.3451383448898262, 0.34253142357948985], "final_y": [0.0002530144586748067, 0.00017769161427315803, 0.0012013277291476438]}, "mutation_prompt": null}
{"id": "6df4c1e2-673a-4ceb-acba-2a9de20e8ca3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                gaussian_noise = np.random.normal(0, 0.1, self.dim)  # New line\n                trial_solution = best_solution + inertia_weight * (np.random.uniform(-1, 1, self.dim) + gaussian_noise) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration phase by introducing adaptive Gaussian noise to improve solution discovery.", "configspace": "", "generation": 7, "fitness": 0.3286517946695915, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.3391498585875735, 0.3188271504852218, 0.32797837493597914], "final_y": [4.729762796506504e-06, 0.00011701860434630446, 5.791759538264903e-05]}, "mutation_prompt": null}
{"id": "829e10c6-ef58-4fe2-bf31-856b92866954", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)  # Changed this line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            mutation_scale = 0.5 + 0.4 * np.random.rand()  # New line\n            if np.random.rand() < 0.2:  # Changed from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-mutation_scale, mutation_scale, self.dim) * (ub - lb) * exploration_factor  # Changed this line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            # Changed comparison for more robustness\n            if trial_value < best_value - 1e-8:  # Changed this line\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration mechanism with adaptive mutation scaling and improved solution comparison.", "configspace": "", "generation": 8, "fitness": 0.30056829716413996, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.29977363888797826, 0.2921037241490696, 0.3098275284553721], "final_y": [0.00256990834367748, 0.001490067651989829, 0.002420438456763865]}, "mutation_prompt": null}
{"id": "19eb4e0e-4f81-4349-a3b9-1a053dd47d27", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.95 - 0.85 * (evaluations / self.budget)  # Modified line\n            if np.random.rand() < 0.2:  # Modified from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by fine-tuning the inertia weight decay and adjusting random trial solutions frequency.", "configspace": "", "generation": 9, "fitness": 0.32065142771368876, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.321 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32328992894214026, 0.3188227837724109, 0.3198415704265152], "final_y": [6.522590474725796e-05, 1.579944823480418e-05, 2.630123607231089e-06]}, "mutation_prompt": null}
{"id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refine adaptive exploration by introducing exponential decay for inertia weight and include stagnation detection to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.5150631111444585, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.515 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.5222295232298514, 0.5047869359451109, 0.5181728742584133], "final_y": [7.131117500644502e-09, 1.520615306043773e-08, 5.099616967036962e-08]}, "mutation_prompt": null}
{"id": "2518d2ce-53b8-40c4-9a3e-d96b4193f4ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                step_size = np.random.uniform(0.003, 0.3)  # Modified line\n                trial_solution = best_solution + step_size * np.random.standard_cauchy(size=self.dim)  # Modified line\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * (0.05 + evaluations / (20 * self.budget)):  # Modified line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    no_improvement_counter = 0  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce Lévy flight for enhanced exploration and use adaptive convergence threshold to improve solution refinement.", "configspace": "", "generation": 11, "fitness": 0.5053773906711073, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5061981569151427, 0.5160695510357441, 0.493864464062435], "final_y": [2.2541932054288706e-08, 4.036392389606195e-07, 2.8205947327085635e-08]}, "mutation_prompt": null}
{"id": "95bc09fd-3da7-462d-923c-93ceb5ce38eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        improvement_rate = 1.0  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2 * improvement_rate  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                improvement_rate = 1.1  # New line\n            else:\n                no_improvement_counter += 1\n                improvement_rate = 0.9  # New line\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate adaptive step size control by dynamically adjusting the exploration factor based on improvement rate.", "configspace": "", "generation": 12, "fitness": 0.505240866632117, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5166450008743909, 0.4890504239981849, 0.5100271750237753], "final_y": [1.5430677278259767e-08, 2.9745038573610435e-08, 2.644328597011707e-09]}, "mutation_prompt": null}
{"id": "fcf8c9e8-ae4a-4818-9ec8-be120b13029a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - no_improvement_counter / (0.1 * self.budget)) ** 2  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance convergence by dynamically adjusting the exploration factor based on recent improvements.", "configspace": "", "generation": 13, "fitness": 0.45708733945397323, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.457 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.46577775463553206, 0.4499143177511018, 0.4555699459752858], "final_y": [3.1372414081306642e-06, 1.1076129116780685e-05, 1.2157530781760706e-05]}, "mutation_prompt": null}
{"id": "0c18b58d-27e5-4997-87de-c200a3ef857d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * ((ub - lb) / (1 + evaluations))  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget)) \n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:  \n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive scaling for exploration factor to balance exploration and exploitation dynamically.", "configspace": "", "generation": 14, "fitness": 0.14448629400369584, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.017. And the mean value of best solutions found was 1.718 (0. is the best) with standard deviation 0.630.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.14621223413562656, 0.16396051318883265, 0.1232861346866283], "final_y": [1.5374396726547344, 1.0523358413848003, 2.563843998093371]}, "mutation_prompt": null}
{"id": "72569226-fdf4-4e08-91aa-71922a9782ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            mutation_factor = 0.5 * np.exp(-0.01 * evaluations)  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + mutation_factor * np.random.uniform(-1, 1, self.dim)  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a decaying mutation factor and reboot mechanism to escape local minima.  ", "configspace": "", "generation": 15, "fitness": 0.22904227657977524, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.015. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.099.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2493432558615546, 0.21330523020441594, 0.22447834367335517], "final_y": [0.11885751644548463, 0.34147365731822166, 0.14538910547630413]}, "mutation_prompt": null}
{"id": "9ffe9d10-ce2b-4368-99cc-6bb806a9aa14", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        population = [best_solution]\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean() / (ub - lb).mean()  # New line\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget)) * (1 + diversity)  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                population.append(trial_solution)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    if no_improvement_counter > self.budget * 0.1:  # New line\n                        best_solution = np.random.uniform(lb, ub, self.dim)  # New line\n                        best_value = func(best_solution)  # New line\n                        population = [best_solution]  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive scaling based on population diversity and dynamic parameter restart for escaping local optima.", "configspace": "", "generation": 16, "fitness": 0.40919437747727433, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.409 with standard deviation 0.078. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.48635534152295845, 0.30314628505990193, 0.43808150584896266], "final_y": [9.487221649981798e-06, 0.0377067573332952, 0.00024607824801346686]}, "mutation_prompt": null}
{"id": "f01f9d90-9663-435a-9a5c-2f13f1eccaee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.sin(evaluations * np.pi / self.budget) * 0.15  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration efficiency by incorporating a dynamic exploration factor based on a sinusoidal function.", "configspace": "", "generation": 17, "fitness": 0.41268370970694024, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.413 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.3854300213195686, 0.44284871860378927, 0.4097723891974627], "final_y": [8.401736731398042e-06, 7.94411259505668e-06, 5.640253963144227e-06]}, "mutation_prompt": null}
{"id": "b8ffb1fc-4e11-4f40-8c46-94f7e80d1834", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 3  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a decreasing random exploration factor to enhance global exploration at early stages and controlled convergence later.", "configspace": "", "generation": 18, "fitness": 0.4097527502298046, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.410 with standard deviation 0.138. And the mean value of best solutions found was 0.053 (0. is the best) with standard deviation 0.075.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.499807548033389, 0.5150379692634579, 0.21441273339256695], "final_y": [1.3285870562760348e-06, 4.8310136880412875e-09, 0.15869471584341868]}, "mutation_prompt": null}
{"id": "6d9f3c64-cc03-47ee-9902-91dacdbd2609", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - (evaluations / self.budget) ** 2)  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Modified line\n                    no_improvement_counter = 0  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Incorporate adaptive exploration factor decay and strategic restart to enhance convergence.", "configspace": "", "generation": 19, "fitness": 0.23758244734162323, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.238 with standard deviation 0.018. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.081.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2215638984942937, 0.22899967959056422, 0.26218376394001175], "final_y": [0.2850462957894389, 0.23563583276830147, 0.09413719694693959]}, "mutation_prompt": null}
{"id": "7f2acffb-364d-42a3-865d-d77040a2935c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        dynamic_threshold = self.budget * 0.05  # Dynamic threshold\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.2:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                learning_rate = np.random.uniform(0.1, 0.5)  # New line\n                trial_solution = best_solution + learning_rate * inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                dynamic_threshold = max(dynamic_threshold * 0.9, 1)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > dynamic_threshold:  # Changed line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    dynamic_threshold = min(dynamic_threshold * 1.1, self.budget * 0.1)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Implement a self-adaptive learning rate for exploring solutions and use a dynamic threshold for stagnation detection to improve convergence efficiency.", "configspace": "", "generation": 20, "fitness": 0.29801078723167157, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.298 with standard deviation 0.242. And the mean value of best solutions found was 1.463 (0. is the best) with standard deviation 1.237.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.11010422418265675, 0.640400116728572, 0.1435280207837859], "final_y": [3.0260652084061648, 1.9332107143213226e-07, 1.361608163262353]}, "mutation_prompt": null}
{"id": "fdcb6b72-3787-4356-a190-efd18d260ad0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        previous_best_value = best_value  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** (2 - 2 * (best_value - previous_best_value))  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                previous_best_value = best_value  # New line\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    previous_best_value = best_value  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Improve convergence by introducing dynamic exploration scaling and a reset mechanism based on fitness diversity.", "configspace": "", "generation": 21, "fitness": 0.49735078620610995, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.497 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5007563838341096, 0.505245008818821, 0.48605096596539943], "final_y": [2.8237616791785664e-09, 2.60369187986894e-07, 3.6056111087377932e-09]}, "mutation_prompt": null}
{"id": "25d589dd-4842-495a-b29b-b39fde5bb7a4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            scaling_factor = 1 + 0.5 * np.sin(evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * scaling_factor  # Adjusted line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor for exploration to balance exploration and exploitation during optimization.", "configspace": "", "generation": 22, "fitness": 0.3731993921426399, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.092. And the mean value of best solutions found was 0.012 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2868473192130835, 0.5008843874265316, 0.3318664697883046], "final_y": [0.027198887433621456, 2.507440630051122e-07, 0.007302505280815829]}, "mutation_prompt": null}
{"id": "e15f290c-2493-4487-83cc-1b536b7d140c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        recent_improvements = []\n\n        while evaluations < self.budget:\n            if len(recent_improvements) > 10:\n                recent_improvements.pop(0)\n            avg_improvement = np.mean(recent_improvements) if recent_improvements else 0\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - avg_improvement)  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                recent_improvements.append(best_value - trial_value)  # New line\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance rapid convergence by dynamically adjusting exploration factor and inertia based on the mean improvement in the last few evaluations.", "configspace": "", "generation": 23, "fitness": 0.3711784883840113, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.371 with standard deviation 0.190. And the mean value of best solutions found was 0.203 (0. is the best) with standard deviation 0.282.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.6228598532696658, 0.3276467941952801, 0.1630288176870881], "final_y": [1.502380903412633e-09, 0.007607399426650663, 0.6017978217088665]}, "mutation_prompt": null}
{"id": "17b3951a-5ded-4f24-8609-27f51314b014", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                adaptive_intensity = 1 - (best_value / (best_value + 1))  # Modified line\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-adaptive_intensity, adaptive_intensity, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration with adaptive mutation intensity based on progress while maintaining constrained randomness.", "configspace": "", "generation": 24, "fitness": 0.5059467942623428, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.506 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5211639723637413, 0.4967927042348277, 0.49988370618845934], "final_y": [4.383731454943937e-09, 1.8480749231284197e-08, 8.605570262307141e-09]}, "mutation_prompt": null}
{"id": "03ba3c37-8cbe-4889-8d27-9dcdcd4d91c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        dynamic_scaling_factor = 0.1 + 0.4 * np.random.rand()  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.2:  # Modified line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + dynamic_scaling_factor * inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                dynamic_scaling_factor = min(dynamic_scaling_factor + 0.01, 0.5)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    dynamic_scaling_factor = max(dynamic_scaling_factor - 0.02, 0.1)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration-exploitation balance through adaptive random walks and dynamic parameter updates for improved convergence.", "configspace": "", "generation": 25, "fitness": 0.44981753055757046, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.450 with standard deviation 0.184. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2980638792070821, 0.34287319557900975, 0.7085155168866195], "final_y": [0.024103563128780387, 0.0057907162297658465, 5.059524038139668e-14]}, "mutation_prompt": null}
{"id": "8b00afda-9205-4ec3-b755-7716ecf1d3eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            # Modified line\n            exploration_factor = (0.05 + (0.15 * (best_value / (func(best_solution) + 1e-9)))) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate a dynamic exploration factor based on the quality of previous solutions, allowing adaptive focus shifts between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.2963538115277224, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.005. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.30112797449757245, 0.2991901256968986, 0.28874333438869604], "final_y": [0.002457486834677807, 0.0030263748042583813, 0.002596651743502215]}, "mutation_prompt": null}
{"id": "7bdbf19a-6d3e-4300-8a00-e46f3cdd5bce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.sin(evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a deterministic oscillating inertia weight to improve convergence. ", "configspace": "", "generation": 27, "fitness": 0.3585737110278741, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.359 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.38368395962340984, 0.34597934393371177, 0.34605782952650066], "final_y": [1.7999647032895786e-05, 1.5191348441467264e-05, 2.4610248953807425e-05]}, "mutation_prompt": null}
{"id": "558f9708-055b-4a4c-a476-36f209d3861b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-(evaluations + no_improvement_counter) / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive inertia weight scaling based on evaluation success for refined exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.47486435796208787, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.475 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.49463101899264006, 0.4487161544848216, 0.4812459004088018], "final_y": [1.4198260914672852e-08, 1.379027512613822e-07, 1.1876904676355395e-07]}, "mutation_prompt": null}
{"id": "dbd918c0-c06a-4968-9560-10134d404954", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        last_improvement_evaluation = 0  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                adaptive_factor = 1 - (evaluations - last_improvement_evaluation) / self.budget  # New line\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-adaptive_factor, adaptive_factor, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                last_improvement_evaluation = evaluations  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate an adaptive mutation scale informed by recent improvements to strike a balance between exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.4944258012497265, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.494 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5019566367568247, 0.49453953216380153, 0.4867812348285535], "final_y": [2.3175886272373184e-08, 3.2629342710352975e-07, 1.2215059085224505e-06]}, "mutation_prompt": null}
{"id": "e1464835-7992-48d3-8646-c310298de162", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by increasing inertia weight decay rate to improve convergence speed.", "configspace": "", "generation": 30, "fitness": 0.6768330622273506, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.677 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.6701243290195373, 0.6755940459582971, 0.6847808117042173], "final_y": [2.740464543386915e-11, 1.4100523715001754e-12, 1.9548542141563514e-11]}, "mutation_prompt": null}
