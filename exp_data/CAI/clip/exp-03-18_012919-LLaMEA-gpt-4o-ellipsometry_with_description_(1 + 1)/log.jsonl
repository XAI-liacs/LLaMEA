{"id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * \\\n                             np.random.uniform(0.05, 0.2)\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "The algorithm combines the exploratory power of a random walk with adaptive differential scaling strategies to efficiently navigate the search space and refine solutions.", "configspace": "", "generation": 0, "fitness": 0.249790812615128, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": null, "metadata": {"aucs": [0.25195217672316417, 0.25834931174126385, 0.23907094938095597], "final_y": [0.13050641862124077, 0.09218839076639117, 0.0943692905024889]}, "mutation_prompt": null}
{"id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            if np.random.rand() < 0.1:  # 10% chance for global exploration\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor based on evaluation progress and incorporate a small probability of global exploration to enhance convergence and avoid local optima.", "configspace": "", "generation": 1, "fitness": 0.2504375964923852, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "metadata": {"aucs": [0.2605763977228509, 0.24228299945723353, 0.24845339229707109], "final_y": [0.0036262598222203614, 0.00898367204022192, 0.0018372989088071424]}, "mutation_prompt": null}
{"id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic inertia weight and adaptive mutation factor to balance exploration and exploitation, improving convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.3056773081009247, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.306 with standard deviation 0.019. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "metadata": {"aucs": [0.32991963878858066, 0.304120076354256, 0.2829922091599374], "final_y": [0.0015924992724814684, 0.005047593837986818, 0.0006038840454873686]}, "mutation_prompt": null}
{"id": "802b4601-d59e-4f0c-86fc-91300c9fb71d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget)  # Adjusted upper limit\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                perturbation = np.random.normal(0, 0.1, self.dim)  # New line for Gaussian perturbation\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + perturbation\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration factor adjustment and enhance solution refinement using random Gaussian perturbation.", "configspace": "", "generation": 3, "fitness": 0.27240395123559796, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.028. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.3094505257690725, 0.2655214455685282, 0.24223988236919325], "final_y": [0.00885809563057967, 0.018954015175489065, 0.08096061253359946]}, "mutation_prompt": null}
{"id": "3d220014-b8db-4523-99b4-f9200000c830", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        def levy_flight(Lambda):\n            sigma = (np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2) /\n                     (np.math.gamma((1 + Lambda) / 2) * Lambda * 2 ** ((Lambda - 1) / 2))) ** (1 / Lambda)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / Lambda)\n            return 0.01 * step  # Small scaling factor\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed exploration range\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim) + levy_flight(1.5)  # Levy flight step\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a stochastic levy flight step, and refine the adaptive mutation factor for better convergence.", "configspace": "", "generation": 4, "fitness": 0.271611947478802, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.2691865333151985, 0.26491788566021635, 0.2807314234609912], "final_y": [0.0001667993478435302, 0.00437397949660532, 0.001155660409110231]}, "mutation_prompt": null}
{"id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Implement a dynamic exploration factor adjustment to improve solution discovery by gradually decreasing randomness.", "configspace": "", "generation": 5, "fitness": 0.34686963027995604, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.347 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.33485245721123735, 0.3529350603077426, 0.35282137332088814], "final_y": [2.4341930938906698e-05, 0.00027647873181912454, 0.00016709361471107354]}, "mutation_prompt": null}
{"id": "129dacb7-141c-49f2-b26e-ee25c06d4fb7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_exploration_factor = 0.1  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            self.memory_exploration_factor = (self.memory_exploration_factor + np.random.uniform(0.05, 0.15)) / 2  # Modified line\n            exploration_factor = self.memory_exploration_factor * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  \n            if np.random.rand() < 0.15:  \n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance solution refinement by incorporating a memory-based adjustment mechanism for exploration factor.", "configspace": "", "generation": 6, "fitness": 0.3381783563990246, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.338 with standard deviation 0.008. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32686530072775766, 0.3451383448898262, 0.34253142357948985], "final_y": [0.0002530144586748067, 0.00017769161427315803, 0.0012013277291476438]}, "mutation_prompt": null}
{"id": "6df4c1e2-673a-4ceb-acba-2a9de20e8ca3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                gaussian_noise = np.random.normal(0, 0.1, self.dim)  # New line\n                trial_solution = best_solution + inertia_weight * (np.random.uniform(-1, 1, self.dim) + gaussian_noise) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration phase by introducing adaptive Gaussian noise to improve solution discovery.", "configspace": "", "generation": 7, "fitness": 0.3286517946695915, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.3391498585875735, 0.3188271504852218, 0.32797837493597914], "final_y": [4.729762796506504e-06, 0.00011701860434630446, 5.791759538264903e-05]}, "mutation_prompt": null}
{"id": "829e10c6-ef58-4fe2-bf31-856b92866954", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)  # Changed this line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            mutation_scale = 0.5 + 0.4 * np.random.rand()  # New line\n            if np.random.rand() < 0.2:  # Changed from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-mutation_scale, mutation_scale, self.dim) * (ub - lb) * exploration_factor  # Changed this line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            # Changed comparison for more robustness\n            if trial_value < best_value - 1e-8:  # Changed this line\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration mechanism with adaptive mutation scaling and improved solution comparison.", "configspace": "", "generation": 8, "fitness": 0.30056829716413996, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.29977363888797826, 0.2921037241490696, 0.3098275284553721], "final_y": [0.00256990834367748, 0.001490067651989829, 0.002420438456763865]}, "mutation_prompt": null}
{"id": "19eb4e0e-4f81-4349-a3b9-1a053dd47d27", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.95 - 0.85 * (evaluations / self.budget)  # Modified line\n            if np.random.rand() < 0.2:  # Modified from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by fine-tuning the inertia weight decay and adjusting random trial solutions frequency.", "configspace": "", "generation": 9, "fitness": 0.32065142771368876, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.321 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32328992894214026, 0.3188227837724109, 0.3198415704265152], "final_y": [6.522590474725796e-05, 1.579944823480418e-05, 2.630123607231089e-06]}, "mutation_prompt": null}
{"id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refine adaptive exploration by introducing exponential decay for inertia weight and include stagnation detection to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.5150631111444585, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.515 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.5222295232298514, 0.5047869359451109, 0.5181728742584133], "final_y": [7.131117500644502e-09, 1.520615306043773e-08, 5.099616967036962e-08]}, "mutation_prompt": null}
{"id": "2518d2ce-53b8-40c4-9a3e-d96b4193f4ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                step_size = np.random.uniform(0.003, 0.3)  # Modified line\n                trial_solution = best_solution + step_size * np.random.standard_cauchy(size=self.dim)  # Modified line\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * (0.05 + evaluations / (20 * self.budget)):  # Modified line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    no_improvement_counter = 0  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce Lévy flight for enhanced exploration and use adaptive convergence threshold to improve solution refinement.", "configspace": "", "generation": 11, "fitness": 0.5053773906711073, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5061981569151427, 0.5160695510357441, 0.493864464062435], "final_y": [2.2541932054288706e-08, 4.036392389606195e-07, 2.8205947327085635e-08]}, "mutation_prompt": null}
{"id": "95bc09fd-3da7-462d-923c-93ceb5ce38eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        improvement_rate = 1.0  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2 * improvement_rate  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                improvement_rate = 1.1  # New line\n            else:\n                no_improvement_counter += 1\n                improvement_rate = 0.9  # New line\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate adaptive step size control by dynamically adjusting the exploration factor based on improvement rate.", "configspace": "", "generation": 12, "fitness": 0.505240866632117, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5166450008743909, 0.4890504239981849, 0.5100271750237753], "final_y": [1.5430677278259767e-08, 2.9745038573610435e-08, 2.644328597011707e-09]}, "mutation_prompt": null}
{"id": "fcf8c9e8-ae4a-4818-9ec8-be120b13029a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - no_improvement_counter / (0.1 * self.budget)) ** 2  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance convergence by dynamically adjusting the exploration factor based on recent improvements.", "configspace": "", "generation": 13, "fitness": 0.45708733945397323, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.457 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.46577775463553206, 0.4499143177511018, 0.4555699459752858], "final_y": [3.1372414081306642e-06, 1.1076129116780685e-05, 1.2157530781760706e-05]}, "mutation_prompt": null}
{"id": "0c18b58d-27e5-4997-87de-c200a3ef857d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * ((ub - lb) / (1 + evaluations))  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget)) \n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:  \n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive scaling for exploration factor to balance exploration and exploitation dynamically.", "configspace": "", "generation": 14, "fitness": 0.14448629400369584, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.017. And the mean value of best solutions found was 1.718 (0. is the best) with standard deviation 0.630.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.14621223413562656, 0.16396051318883265, 0.1232861346866283], "final_y": [1.5374396726547344, 1.0523358413848003, 2.563843998093371]}, "mutation_prompt": null}
{"id": "72569226-fdf4-4e08-91aa-71922a9782ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            mutation_factor = 0.5 * np.exp(-0.01 * evaluations)  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + mutation_factor * np.random.uniform(-1, 1, self.dim)  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a decaying mutation factor and reboot mechanism to escape local minima.  ", "configspace": "", "generation": 15, "fitness": 0.22904227657977524, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.015. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.099.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2493432558615546, 0.21330523020441594, 0.22447834367335517], "final_y": [0.11885751644548463, 0.34147365731822166, 0.14538910547630413]}, "mutation_prompt": null}
{"id": "9ffe9d10-ce2b-4368-99cc-6bb806a9aa14", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        population = [best_solution]\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean() / (ub - lb).mean()  # New line\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget)) * (1 + diversity)  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                population.append(trial_solution)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    if no_improvement_counter > self.budget * 0.1:  # New line\n                        best_solution = np.random.uniform(lb, ub, self.dim)  # New line\n                        best_value = func(best_solution)  # New line\n                        population = [best_solution]  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive scaling based on population diversity and dynamic parameter restart for escaping local optima.", "configspace": "", "generation": 16, "fitness": 0.40919437747727433, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.409 with standard deviation 0.078. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.48635534152295845, 0.30314628505990193, 0.43808150584896266], "final_y": [9.487221649981798e-06, 0.0377067573332952, 0.00024607824801346686]}, "mutation_prompt": null}
{"id": "f01f9d90-9663-435a-9a5c-2f13f1eccaee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.sin(evaluations * np.pi / self.budget) * 0.15  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration efficiency by incorporating a dynamic exploration factor based on a sinusoidal function.", "configspace": "", "generation": 17, "fitness": 0.41268370970694024, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.413 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.3854300213195686, 0.44284871860378927, 0.4097723891974627], "final_y": [8.401736731398042e-06, 7.94411259505668e-06, 5.640253963144227e-06]}, "mutation_prompt": null}
