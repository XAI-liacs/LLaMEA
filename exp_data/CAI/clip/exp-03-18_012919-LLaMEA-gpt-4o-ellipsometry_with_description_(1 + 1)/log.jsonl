{"id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * \\\n                             np.random.uniform(0.05, 0.2)\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "The algorithm combines the exploratory power of a random walk with adaptive differential scaling strategies to efficiently navigate the search space and refine solutions.", "configspace": "", "generation": 0, "fitness": 0.249790812615128, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": null, "metadata": {"aucs": [0.25195217672316417, 0.25834931174126385, 0.23907094938095597], "final_y": [0.13050641862124077, 0.09218839076639117, 0.0943692905024889]}, "mutation_prompt": null}
{"id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            if np.random.rand() < 0.1:  # 10% chance for global exploration\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor based on evaluation progress and incorporate a small probability of global exploration to enhance convergence and avoid local optima.", "configspace": "", "generation": 1, "fitness": 0.2504375964923852, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "metadata": {"aucs": [0.2605763977228509, 0.24228299945723353, 0.24845339229707109], "final_y": [0.0036262598222203614, 0.00898367204022192, 0.0018372989088071424]}, "mutation_prompt": null}
{"id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic inertia weight and adaptive mutation factor to balance exploration and exploitation, improving convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.3056773081009247, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.306 with standard deviation 0.019. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "metadata": {"aucs": [0.32991963878858066, 0.304120076354256, 0.2829922091599374], "final_y": [0.0015924992724814684, 0.005047593837986818, 0.0006038840454873686]}, "mutation_prompt": null}
{"id": "802b4601-d59e-4f0c-86fc-91300c9fb71d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget)  # Adjusted upper limit\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                perturbation = np.random.normal(0, 0.1, self.dim)  # New line for Gaussian perturbation\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + perturbation\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration factor adjustment and enhance solution refinement using random Gaussian perturbation.", "configspace": "", "generation": 3, "fitness": 0.27240395123559796, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.028. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.3094505257690725, 0.2655214455685282, 0.24223988236919325], "final_y": [0.00885809563057967, 0.018954015175489065, 0.08096061253359946]}, "mutation_prompt": null}
{"id": "3d220014-b8db-4523-99b4-f9200000c830", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        def levy_flight(Lambda):\n            sigma = (np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2) /\n                     (np.math.gamma((1 + Lambda) / 2) * Lambda * 2 ** ((Lambda - 1) / 2))) ** (1 / Lambda)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / Lambda)\n            return 0.01 * step  # Small scaling factor\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed exploration range\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim) + levy_flight(1.5)  # Levy flight step\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a stochastic levy flight step, and refine the adaptive mutation factor for better convergence.", "configspace": "", "generation": 4, "fitness": 0.271611947478802, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.2691865333151985, 0.26491788566021635, 0.2807314234609912], "final_y": [0.0001667993478435302, 0.00437397949660532, 0.001155660409110231]}, "mutation_prompt": null}
{"id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Implement a dynamic exploration factor adjustment to improve solution discovery by gradually decreasing randomness.", "configspace": "", "generation": 5, "fitness": 0.34686963027995604, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.347 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.33485245721123735, 0.3529350603077426, 0.35282137332088814], "final_y": [2.4341930938906698e-05, 0.00027647873181912454, 0.00016709361471107354]}, "mutation_prompt": null}
{"id": "129dacb7-141c-49f2-b26e-ee25c06d4fb7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_exploration_factor = 0.1  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            self.memory_exploration_factor = (self.memory_exploration_factor + np.random.uniform(0.05, 0.15)) / 2  # Modified line\n            exploration_factor = self.memory_exploration_factor * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  \n            if np.random.rand() < 0.15:  \n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance solution refinement by incorporating a memory-based adjustment mechanism for exploration factor.", "configspace": "", "generation": 6, "fitness": 0.3381783563990246, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.338 with standard deviation 0.008. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32686530072775766, 0.3451383448898262, 0.34253142357948985], "final_y": [0.0002530144586748067, 0.00017769161427315803, 0.0012013277291476438]}, "mutation_prompt": null}
{"id": "6df4c1e2-673a-4ceb-acba-2a9de20e8ca3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                gaussian_noise = np.random.normal(0, 0.1, self.dim)  # New line\n                trial_solution = best_solution + inertia_weight * (np.random.uniform(-1, 1, self.dim) + gaussian_noise) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration phase by introducing adaptive Gaussian noise to improve solution discovery.", "configspace": "", "generation": 7, "fitness": 0.3286517946695915, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.3391498585875735, 0.3188271504852218, 0.32797837493597914], "final_y": [4.729762796506504e-06, 0.00011701860434630446, 5.791759538264903e-05]}, "mutation_prompt": null}
{"id": "829e10c6-ef58-4fe2-bf31-856b92866954", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)  # Changed this line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            mutation_scale = 0.5 + 0.4 * np.random.rand()  # New line\n            if np.random.rand() < 0.2:  # Changed from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-mutation_scale, mutation_scale, self.dim) * (ub - lb) * exploration_factor  # Changed this line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            # Changed comparison for more robustness\n            if trial_value < best_value - 1e-8:  # Changed this line\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration mechanism with adaptive mutation scaling and improved solution comparison.", "configspace": "", "generation": 8, "fitness": 0.30056829716413996, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.29977363888797826, 0.2921037241490696, 0.3098275284553721], "final_y": [0.00256990834367748, 0.001490067651989829, 0.002420438456763865]}, "mutation_prompt": null}
{"id": "19eb4e0e-4f81-4349-a3b9-1a053dd47d27", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.95 - 0.85 * (evaluations / self.budget)  # Modified line\n            if np.random.rand() < 0.2:  # Modified from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by fine-tuning the inertia weight decay and adjusting random trial solutions frequency.", "configspace": "", "generation": 9, "fitness": 0.32065142771368876, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.321 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32328992894214026, 0.3188227837724109, 0.3198415704265152], "final_y": [6.522590474725796e-05, 1.579944823480418e-05, 2.630123607231089e-06]}, "mutation_prompt": null}
