{"id": "0343220f-e5cc-4747-a0e5-705d758f5976", "solution": "import numpy as np\n\nclass HDPE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.inertia_weight = 0.7  # Inertia weight\n        self.mutation_factor = 0.5  # Differential evolution mutation factor\n        self.crossover_prob = 0.7  # Differential evolution crossover probability\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(swarm)\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best_position = swarm[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.swarm_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best_positions - swarm) +\n                          self.c2 * r2 * (global_best_position - swarm))\n            swarm = np.clip(swarm + velocities, lb, ub)\n\n            # Differential Evolution mutation and crossover\n            for i in range(self.swarm_size):\n                a, b, c = np.random.choice(self.swarm_size, 3, replace=False)\n                mutant_vector = np.clip(swarm[a] +\n                                        self.mutation_factor * (swarm[b] - swarm[c]), lb, ub)\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob,\n                                        mutant_vector, swarm[i])\n\n                # Evaluate new trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best_position = trial_vector\n                        global_best_score = trial_score\n                        if evaluations >= self.budget:\n                            break\n\n        return global_best_position, global_best_score", "name": "HDPE", "description": "The proposed algorithm, called \"Hybrid Dynamic Particle Evolution (HDPE),\" combines principles of particle swarm optimization and differential evolution with dynamic adaptation to efficiently explore and exploit the solution space for diverse black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.805044397520458, "feedback": "The algorithm HDPE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.017. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7823105751723338, 0.8107380007440392, 0.8220846166450007], "final_y": [0.14276514227501447, 0.1417001869815525, 0.14523040746012916]}, "mutation_prompt": null}
