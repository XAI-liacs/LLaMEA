{"id": "8936e929-1182-4e08-9de9-6a800a5d806a", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "A hybrid global-local optimization algorithm combining Differential Evolution with periodicity-enforcing and local refinement strategies to find near-optimal multilayer structures.", "configspace": "", "generation": 0, "fitness": 0.860374217247364, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.014. And the mean value of best solutions found was 0.186 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8792803898986686, 0.8454809225965441, 0.8563613392468791], "final_y": [0.1919051801370837, 0.18597272559691458, 0.1791118600467816]}, "mutation_prompt": null}
{"id": "0a260c70-b4c4-42a0-8ec3-ff2f303778e7", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                self.f = 0.5 + np.random.rand() * 0.3  # Adaptive differential weight\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Improved periodicity enforcement\n                trial = self.enforce_periodicity(trial, ub, lb)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution, ub, lb):\n        # Improved periodicity by enforcing bounds and averaging\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            mean_val = np.mean(solution[start:end])\n            solution[start:end] = np.clip(mean_val, lb, ub)\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE algorithm with improved periodicity enforcement and adaptive differential weight for better performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (10,) into shape (2,)').", "error": "ValueError('could not broadcast input array from shape (10,) into shape (2,)')", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "ee0dfc8a-ba85-4255-ae83-0f5afb94a342", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        d = population[np.random.choice([i for i in range(self.population_size) if i not in [a, b, c]], 1)]\n        mutant = np.clip(a + self.f * (b - c + d - a), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Refined hybrid optimization algorithm combining enhanced mutation strategies with periodicity enforcement to improve performance in multilayer optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "c0604785-5b32-4e0e-81e2-ad55c8726324", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.95  # Crossover probability adjustment from 0.9 to 0.95\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "A refined HybridPeriodicDE algorithm increasing crossover probability to enhance solution diversity and convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "0d3390b8-9b43-4251-948d-636565f48122", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Adaptive periodicity enforcement during mutation\n                if np.random.rand() < self.periodicity_weight:\n                    a = self.enforce_periodicity(a)\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Introducing adaptive periodicity enforcement in the mutation step to further exploit constructive interference and solution modularity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "503461f6-0806-4346-be1e-95db0bf34907", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = np.mean(solution[start:end])\n            solution[start:end] = avg * (1 + self.periodicity_weight)  # Scale by periodicity weight\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced periodicity enforcement by scaling layer averages to improve constructive interference.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "0cd73c44-f4d9-4687-aa8a-f5fb779e6d27", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.5 + np.random.rand() * 0.3  # Adaptive Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Enhanced Periodicity enforcement\n                trial = self.enforce_periodicity(trial, period=4)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution, period=2):\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Improved hybrid optimization with enhanced periodicity enforcement and adaptive mutation for better reflectivity maximization.", "configspace": "", "generation": 2, "fitness": 0.6424401686846702, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.642 with standard deviation 0.215. And the mean value of best solutions found was 0.332 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.9468208617971515, 0.49220068012598717, 0.4882989641308718], "final_y": [0.17294342356364345, 0.4106266188352986, 0.4136927208600043]}, "mutation_prompt": null}
{"id": "a88da095-37cd-43de-9992-f09fc10c3bd6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.85  # Crossover probability adjusted for better local refinement\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE improves local refinement by adjusting crossover probability to balance exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.6154653319190514, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.615 with standard deviation 0.179. And the mean value of best solutions found was 0.333 (0. is the best) with standard deviation 0.114.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8686625491707166, 0.47712962805739645, 0.5006038185290413], "final_y": [0.17290482648414462, 0.4217448995036597, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "0391916c-548c-4389-a31c-20460477d2ab", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.85   # Differential weight adjusted slightly for better balance\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE by adjusting differential weight for improved exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.5640203833902852, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.564 with standard deviation 0.224. And the mean value of best solutions found was 0.379 (0. is the best) with standard deviation 0.146.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8783636602073509, 0.44204378137781086, 0.3716537085856937], "final_y": [0.1751693667025218, 0.44958983963414223, 0.511152496709788]}, "mutation_prompt": null}
{"id": "52c54e23-faba-4714-b90f-f6cb8e7692b4", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n\n                # Adaptive periodicity enforcement based on current best fitness\n                if fitness[best_idx] < 0.2:\n                    self.periodicity_weight = 0.2\n\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1)  # Slightly dynamic crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end]) * self.periodicity_weight\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced Hybrid DE with dynamic crossover and adaptive periodicity for improved optimization.", "configspace": "", "generation": 2, "fitness": 0.4688845223087474, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.469 with standard deviation 0.073. And the mean value of best solutions found was 0.432 (0. is the best) with standard deviation 0.055.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.44250436255030623, 0.39593375983405654, 0.5682154445418793], "final_y": [0.4497424805167226, 0.4885199473140439, 0.3581513569459748]}, "mutation_prompt": null}
{"id": "ad4590fa-0ad0-458d-8490-769b3ef674b4", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Introduce a diversity boost by random mutation\n                if np.random.rand() < 0.1:\n                    trial += np.random.normal(0, 0.1, self.dim)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "A hybrid global-local optimization algorithm that combines Differential Evolution with periodicity-enforcing strategies and integrates a diversity boost for improved exploration to find near-optimal multilayer structures.", "configspace": "", "generation": 2, "fitness": 0.6699522386256112, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.670 with standard deviation 0.101. And the mean value of best solutions found was 0.288 (0. is the best) with standard deviation 0.071.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8107176773671594, 0.6191401059962259, 0.5799989325134478], "final_y": [0.1881243890435308, 0.32676866849928066, 0.34954404120482696]}, "mutation_prompt": null}
{"id": "a5c2e24c-db83-420c-93f8-13ac75d75968", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.2  # Weight for periodicity enforcement (changed from 0.1)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Refined periodicity enforcement in Differential Evolution by updating the periodicity_weight for improved optimization.", "configspace": "", "generation": 3, "fitness": 0.883100279343064, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.038. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8796238433953938, 0.8386594679690269, 0.9310175266647716], "final_y": [0.1860698496350559, 0.17672660284101194, 0.17378106962544537]}, "mutation_prompt": null}
{"id": "a919c180-c488-490b-a139-22caec6207c7", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm using Differential Evolution with improved periodicity enforcement and adaptive crossover strategies for optimizing multilayer structures.", "configspace": "", "generation": 3, "fitness": 0.8834662819136002, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.049. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.9524842965455341, 0.8536605183705296, 0.8442540308247367], "final_y": [0.172772868317132, 0.17855612944111554, 0.17601472991788514]}, "mutation_prompt": null}
{"id": "2bc1417e-7f68-4c1e-aa37-792044474888", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 5 * dim)  # Reduced population size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Adjusted periodicity enforcement\n                trial = self.enforce_periodicity(trial, (self.budget - self.population_size - _) / self.budget)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution, adaptation_factor):\n        # Adaptive periodicity enforcement by dynamically adjusting the averaging based on adaptation_factor\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end]) * adaptation_factor + solution[start:end] * (1 - adaptation_factor)\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE with dynamic population size and adaptive periodicity enforcement for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.8641354413400945, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.031. And the mean value of best solutions found was 0.180 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.9069186901981303, 0.8340789296146589, 0.8514087042074941], "final_y": [0.17277350360438204, 0.18239888691378436, 0.18430321459121646]}, "mutation_prompt": null}
{"id": "7afac2ca-46a6-450b-8931-4036feccacf6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end]) * self.periodicity_weight\n        return solution", "name": "HybridPeriodicDE", "description": "A hybrid global-local optimization algorithm that combines Differential Evolution with enhanced periodicity-enforcing and local refinement strategies to find near-optimal multilayer structures.", "configspace": "", "generation": 3, "fitness": 0.7205077066961282, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.721 with standard deviation 0.158. And the mean value of best solutions found was 0.253 (0. is the best) with standard deviation 0.109.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.49666061503708203, 0.8405359482910212, 0.8243265567602812], "final_y": [0.4073425911909888, 0.17497561479031587, 0.17725537760584387]}, "mutation_prompt": null}
{"id": "64cf60ae-0005-4d01-957d-4501c13b8ca5", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n            \n            # Diversity enhancement\n            if _ % 10 == 0:\n                self.enhance_diversity(population, lb, ub)\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution\n    \n    def enhance_diversity(self, population, lb, ub):\n        # Introduce random individuals to enhance diversity\n        num_random = int(0.1 * self.population_size)\n        new_individuals = np.random.uniform(lb, ub, (num_random, self.dim))\n        population[:num_random] = new_individuals", "name": "HybridPeriodicDE", "description": "Enhanced hybrid optimization with a diversity-enhancing mechanism and improved periodicity enforcement to better explore complex landscapes.", "configspace": "", "generation": 3, "fitness": 0.8249716429828152, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.024. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.7938903779489359, 0.8533290119430708, 0.8276955390564391], "final_y": [0.1855571023209034, 0.18136035975730314, 0.1824628281559444]}, "mutation_prompt": null}
{"id": "de3fec4b-73be-42a5-b6aa-a34202cd02f6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.periodic_mutate(a, b, c, lb, ub, best)\n                trial = self.crossover(population[i], mutant, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def periodic_mutate(self, a, b, c, lb, ub, best):\n        # Enhanced mutation with periodicity awareness\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            mutant[start:end] = (mutant[start:end] + best[start:end]) / 2\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n", "name": "HybridPeriodicDE", "description": "Advanced hybrid optimization algorithm using Differential Evolution with periodicity-aware mutation and adaptive local exploration for optimizing multilayer structures.", "configspace": "", "generation": 4, "fitness": 0.829585122976301, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.185. And the mean value of best solutions found was 0.232 (0. is the best) with standard deviation 0.089.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9638677727300982, 0.9566721516569258, 0.5682154445418793], "final_y": [0.16555360582132728, 0.17277478178748895, 0.3581513569459748]}, "mutation_prompt": null}
{"id": "fdfca22c-13d0-4ea4-8309-7bd3a091fe92", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.adaptive_mutate(a, b, c, lb, ub, best)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def adaptive_mutate(self, a, b, c, lb, ub, best):\n        # Introduce adaptive mutation strategy\n        adapt_factor = np.random.rand() * (1 - np.linalg.norm(best - (a + b + c) / 3) / np.linalg.norm(ub - lb))\n        mutant = np.clip(a + self.f * (b - c) + adapt_factor, lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An improved hybrid Differential Evolution algorithm incorporating periodicity bias and adaptive mutation for optimizing complex multilayer structures.", "configspace": "", "generation": 4, "fitness": 0.4658877028844794, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.466 with standard deviation 0.375. And the mean value of best solutions found was 0.528 (0. is the best) with standard deviation 0.305.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9569830384357315, 0.04741838145630195, 0.39326168876140466], "final_y": [0.17277528882431614, 0.9183680855761402, 0.4915935044282741]}, "mutation_prompt": null}
{"id": "e2fa7a1b-57c4-4594-acea-3cd80b4c8d6d", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        self.primary_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.secondary_population = np.random.uniform(0, 1, (self.population_size, self.dim)) \n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        fitness = np.array([func(ind) for ind in self.primary_population])\n        best_idx = np.argmin(fitness)\n        best = self.primary_population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.primary_population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(self.primary_population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best, i)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    self.primary_population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best, index):\n        # Enhanced periodicity enforcement with dual population influence\n        period = 2\n        weight = (index % 10 + 1) / 10\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + weight * self.secondary_population[index][start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm using Differential Evolution with improved periodicity enforcement via adaptive weighting and a dual-population strategy for optimizing multilayer structures.", "configspace": "", "generation": 4, "fitness": 0.34429534631047715, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.344 with standard deviation 0.213. And the mean value of best solutions found was 0.581 (0. is the best) with standard deviation 0.240.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.04741841657354329, 0.533337823093756, 0.4521297992641321], "final_y": [0.9183683924215043, 0.3822094756469999, 0.44184678027911195]}, "mutation_prompt": null}
{"id": "9d1ba8a6-769d-40bd-a1b6-de08986931be", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                        self.periodicity_weight = 0.1 + 0.05 * (1 - trial_fitness / fitness[best_idx])  # Dynamic adjustment\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg) * self.periodicity_weight\n        return solution", "name": "HybridPeriodicDE", "description": "Incorporate dynamic adjustment of the periodicity weight based on fitness improvement to enhance convergence.", "configspace": "", "generation": 4, "fitness": 0.4949196341896651, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.495 with standard deviation 0.005. And the mean value of best solutions found was 0.409 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.49666061503708203, 0.48802396753046395, 0.5000743200014495], "final_y": [0.4073425911909888, 0.4135967802763709, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "911a6bbf-86fc-4ab7-8668-95fc6acd817f", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        scale_factor = np.random.rand() * self.f  # Adaptive scaling factor\n        mutant = np.clip(a + scale_factor * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "Improved hybrid optimization algorithm with enhanced periodicity enforcement and adaptive strategies for better convergence performance.", "configspace": "", "generation": 4, "fitness": 0.618594497215657, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.619 with standard deviation 0.245. And the mean value of best solutions found was 0.356 (0. is the best) with standard deviation 0.134.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9592707265074645, 0.3964384451380569, 0.5000743200014495], "final_y": [0.1729112269111609, 0.48879337276610557, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "ddd7062e-aa9f-46ca-b54b-537a4e9b3d7b", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] * 0.8 + best[start:end] * 0.2)  # Changed weighting factor\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An advanced hybrid global-local optimization algorithm using Differential Evolution with refined periodicity enforcement and adaptive crossover strategies for optimizing multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.9492907918702073, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.020. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9210041076040183, 0.9650110849617998, 0.961857183044804], "final_y": [0.17277297822315663, 0.16864169019537878, 0.16954733118618637]}, "mutation_prompt": null}
{"id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase and adaptive mutation to optimize multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.9611523736447131, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.961 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9644840671039296, 0.9627212244432524, 0.9562518293869569], "final_y": [0.16973151899707217, 0.1692734324476608, 0.16889037416292385]}, "mutation_prompt": null}
{"id": "85fc4224-68e4-47f9-ba01-a4a1637de9f8", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(solution[start:end])  # Alternate periodic adjustment\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced periodicity enforcement through alternate periodic adjustment for optimizing multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.926630606868442, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.927 with standard deviation 0.040. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.8709232153473194, 0.9491950147193482, 0.9597735905386583], "final_y": [0.1811872846610405, 0.16954702534467303, 0.16893374140812145]}, "mutation_prompt": null}
{"id": "c056c92b-6d06-4247-b16b-c5cefeb8be92", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                self.f = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg) * self.periodicity_weight  # Adjusted periodicity\n        return solution", "name": "HybridPeriodicDE", "description": "Optimized periodicity enforcement and adaptive mutation for enhanced multilayer structure optimization.", "configspace": "", "generation": 5, "fitness": 0.804596704725395, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.218. And the mean value of best solutions found was 0.248 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.49666061503708203, 0.9560559978524736, 0.9610735012866295], "final_y": [0.4073425911909888, 0.16762435059421432, 0.16951450424064385]}, "mutation_prompt": null}
{"id": "210784a3-dcfc-4b4f-a783-c1b8cb0de9e9", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.85  # Crossover probability\n        self.f = 0.5   # Differential weight\n        self.periodicity_weight = 0.15  # Increased weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.dynamic_mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Enhanced periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def dynamic_mutate(self, a, b, c, lb, ub):\n        f_dynamic = self.f * np.random.uniform(0.5, 1.0)\n        mutant = np.clip(a + f_dynamic * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = np.mean(solution[start:end])\n            solution[start:end] = avg\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm combining Differential Evolution with dynamic control parameters, improved periodicity enforcement, and adaptive mutation strategies for optimizing multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.9489213654209182, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.010. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9352485258313417, 0.9586188076879745, 0.9528967627434384], "final_y": [0.17277289068893997, 0.16964372446260012, 0.17094052023245332]}, "mutation_prompt": null}
{"id": "d439e634-ef82-40c6-87bc-400ba9be2a99", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "Incremental improvement of HybridPeriodicDE by increasing the population size for better exploration of the search space.", "configspace": "", "generation": 6, "fitness": 0.9537031005333869, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.004. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9585871967545087, 0.9534820324765507, 0.9490400723691015], "final_y": [0.16985754119955532, 0.17023233429880347, 0.1701770538095707]}, "mutation_prompt": null}
{"id": "141e2413-9174-4544-a286-35753b74bca2", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.2 * np.random.rand())  # Adaptive crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE with adaptive crossover probability for improved exploration.", "configspace": "", "generation": 6, "fitness": 0.9015550561426199, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.083. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9619423525810895, 0.7843998132084824, 0.9583230026382877], "final_y": [0.16942942667340588, 0.2303697693724287, 0.17057007799887314]}, "mutation_prompt": null}
{"id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase, adaptive mutation, and improved periodicity enforcement to optimize multilayer structures.", "configspace": "", "generation": 6, "fitness": 0.9636694695955489, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.004. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9692153050571763, 0.962756724122827, 0.9590363796066435], "final_y": [0.16888399658061437, 0.17045405854871676, 0.16990589007639734]}, "mutation_prompt": null}
{"id": "7c2da705-de91-4574-82e1-107264ad45dd", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.2  # Weight for periodicity enforcement (increased)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase, adaptive mutation, and increased periodicity weight to optimize multilayer structures.", "configspace": "", "generation": 6, "fitness": 0.9580655633472069, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.001. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9581685204682134, 0.9563465966000302, 0.9596815729733772], "final_y": [0.16984986068372554, 0.16980515280948394, 0.16902543733619757]}, "mutation_prompt": null}
{"id": "37add99a-f1f9-4bfe-812a-4e527fa0bed1", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                self.periodicity_weight = np.random.uniform(0.05, 0.15)  # Adaptive periodicity weight\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase and adaptive mutation to optimize multilayer structures, now with adaptive periodicity weighting for improved solution refinement.", "configspace": "", "generation": 6, "fitness": 0.9603055854349026, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.002. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9616763040837815, 0.9580125948420863, 0.9612278573788398], "final_y": [0.17014949618989605, 0.16897294648610994, 0.16995859708525107]}, "mutation_prompt": null}
