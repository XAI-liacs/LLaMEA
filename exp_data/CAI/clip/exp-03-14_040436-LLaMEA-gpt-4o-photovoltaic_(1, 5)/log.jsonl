{"id": "82c5a3ff-e706-4e1e-be76-d10c1be05afe", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Adaptive Swarm Gradient Descent (ASGD): Combines swarm intelligence and gradient estimation to explore and exploit search space efficiently.", "configspace": "", "generation": 0, "fitness": 0.8264407036439118, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.020. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8041324604654931, 0.8227266579918514, 0.8524629924743906], "final_y": [0.1412466306774247, 0.13112094863304602, 0.12789490696654837]}, "mutation_prompt": null}
{"id": "7feb2213-af12-426e-9cee-65aefdcf7d61", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n            # Dynamic population resizing\n            if evaluations < self.budget * 0.5:\n                self.population_size = min(self.population_size + 1, 20 + 2 * int(np.sqrt(dim)))\n            else:\n                self.population_size = max(self.population_size - 1, 5)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Introduces dynamic population resizing to adaptively refine exploration and exploitation phases.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'dim' is not defined\").", "error": "NameError(\"name 'dim' is not defined\")", "parent_id": "82c5a3ff-e706-4e1e-be76-d10c1be05afe", "metadata": {}, "mutation_prompt": null}
{"id": "38cfa48e-1931-4f41-85b3-f25678365b58", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.initial_population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.initial_population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            # Dynamically adjust population size\n            population_size = int(self.initial_population_size * (1 + adaptive_factor))\n\n            for i in range(population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Introduces dynamic population size to balance exploration and exploitation efficiently over iterations.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 16').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 16')", "parent_id": "82c5a3ff-e706-4e1e-be76-d10c1be05afe", "metadata": {}, "mutation_prompt": null}
{"id": "fe30a76b-a2cc-47b4-bfa1-99c911995f53", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * (1 - adaptive_factor)  # Modified line\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent: Introduces an adaptive personal cognitive coefficient that increases with evaluations to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 16').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 16')", "parent_id": "82c5a3ff-e706-4e1e-be76-d10c1be05afe", "metadata": {}, "mutation_prompt": null}
{"id": "8708a132-3c26-4420-97af-fb4b23f04a9f", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 * ((self.budget - evaluations) / self.budget)  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Introduce mutation for diversity\n            mutation_prob = 0.1 / self.dim  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:  # Changed line\n                    swarm[i] = np.random.uniform(lb, ub, self.dim)\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Introduces dynamic social coefficient and mutation for improved convergence and diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 16').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 16')", "parent_id": "82c5a3ff-e706-4e1e-be76-d10c1be05afe", "metadata": {}, "mutation_prompt": null}
{"id": "41e3c043-27b7-45b8-9ffa-505d007ae9fb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Line modified: Introduce non-linear adaptive inertia weight\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                # Line modified: Introduce dynamic mutation for diversity\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Introduces adaptive inertia weight and dynamic mutation to further improve exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.8339529657998241, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.015. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "82c5a3ff-e706-4e1e-be76-d10c1be05afe", "metadata": {"aucs": [0.8139719761153212, 0.8481633619151919, 0.8397235593689594], "final_y": [0.1372502497108271, 0.13625177895836083, 0.13235288646109056]}, "mutation_prompt": null}
{"id": "0a4f9064-d3e2-4944-a622-5d655d7601f5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Line modified: Introduce cosine-based adaptive inertia weight\n            adaptive_factor = np.cos(np.pi * (evaluations / self.budget))\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced inertia weight adaptation utilizing cosine-based modulation for improved global search capabilities.", "configspace": "", "generation": 2, "fitness": 0.8122694865494844, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.037. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "41e3c043-27b7-45b8-9ffa-505d007ae9fb", "metadata": {"aucs": [0.7604801160044214, 0.8458884167804508, 0.8304399268635809], "final_y": [0.16833066977534872, 0.13693258957793386, 0.14602371370802503]}, "mutation_prompt": null}
{"id": "74257e5c-4ef6-4603-926c-799e48bf98f9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:  # Mutation condition\n                    # Quantum-inspired differential mutation\n                    q_factor = np.random.uniform(-1, 1, self.dim)\n                    differential = np.random.randn(self.dim) * (ub - lb) / 10\n                    swarm[i] += q_factor * differential\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Hybrid Adaptive Swarm with Quantum-Inspired Differential Mutation: Combines quantum-inspired diversity boosting and adaptive swarm dynamics for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.8335509584666645, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.022. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "41e3c043-27b7-45b8-9ffa-505d007ae9fb", "metadata": {"aucs": [0.8308760256841408, 0.8086374850340827, 0.8611393646817701], "final_y": [0.14232891159150218, 0.13840198254011205, 0.13689642108818845]}, "mutation_prompt": null}
{"id": "f130681f-1a82-454e-b8b9-75c3c83e5a65", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            # Line modified: Introduce leader selection\n            leader = swarm[np.argmin(personal_best_value)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (leader - swarm[i]))  # Modified line\n                swarm[i] += self.velocity[i]\n\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n\n                # Line modified: Stochastic tunneling\n                if np.random.rand() < 0.05:\n                    swarm[i] = np.random.uniform(lb, ub)\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Hybrid Swarm Gradient Descent (A-HSGD): Enhances EASGD by incorporating a leader selection mechanism and stochastic tunneling to overcome local optima and improve solution quality.", "configspace": "", "generation": 2, "fitness": 0.8164179009923078, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.010. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "41e3c043-27b7-45b8-9ffa-505d007ae9fb", "metadata": {"aucs": [0.8029691486661794, 0.8194822925168546, 0.8268022617938896], "final_y": [0.14388413616681528, 0.14321708346579076, 0.1282161151173038]}, "mutation_prompt": null}
{"id": "5b02416a-18d3-48c0-92fd-00082042bd09", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    mutation_strength = 0.1 * (0.5 + 0.5 * np.abs(global_best_value - personal_best_value[i]))  # Modified line\n                    swarm[i] += np.random.normal(0, mutation_strength, self.dim)  # Modified line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD) with leader-driven exploration and adaptive boundary search to improve convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.8244526045405309, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.005. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "41e3c043-27b7-45b8-9ffa-505d007ae9fb", "metadata": {"aucs": [0.8283969287005511, 0.8173265196316106, 0.8276343652894309], "final_y": [0.13558705159348095, 0.13445737974583005, 0.13828547210216224]}, "mutation_prompt": null}
{"id": "1dbd446b-39ad-42c3-94c8-cc10c16afb9b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Line modified: Introduce non-linear adaptive inertia weight\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            # Line modified: Dynamic social coefficient for improved exploitation\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                # Line modified: Introduce dynamic mutation for diversity\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Further refines global convergence by adjusting social coefficient dynamically to improve exploitation.", "configspace": "", "generation": 2, "fitness": 0.8462287861220797, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.008. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "41e3c043-27b7-45b8-9ffa-505d007ae9fb", "metadata": {"aucs": [0.8569316821403336, 0.8439552127679173, 0.8377994634579883], "final_y": [0.1328587442776059, 0.1314753847357153, 0.13669471500072583]}, "mutation_prompt": null}
{"id": "f3432983-b3ac-4e48-95ee-d530eb4d1b2f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Line modified: Adjust cognitive coefficient dynamically over time\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * (0.5 + 0.5 * (evaluations / self.budget))  # Adjusted line\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introducing a time-varying learning strategy by adjusting the cognitive coefficient over time to balance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.8426100017269068, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.007. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1dbd446b-39ad-42c3-94c8-cc10c16afb9b", "metadata": {"aucs": [0.8331231034454187, 0.8508075856687897, 0.8438993160665121], "final_y": [0.1320039855874341, 0.13408033494669147, 0.13018659849150227]}, "mutation_prompt": null}
{"id": "16dc958f-75cf-445c-92ab-627f740328af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            # Line modified: Dynamic social coefficient for improved exploitation\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                # Line modified: Adaptive velocity scaling factor\n                velocity_scale = 0.9 * adaptive_factor + 0.1\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (velocity_scale * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved dynamic exploration using adaptive swarm velocity scaling for enhanced convergence.", "configspace": "", "generation": 3, "fitness": 0.8522691384851669, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.852 with standard deviation 0.021. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1dbd446b-39ad-42c3-94c8-cc10c16afb9b", "metadata": {"aucs": [0.8434768105198392, 0.8319516954565787, 0.8813789094790829], "final_y": [0.13030652254683472, 0.134015714766051, 0.12650650503161354]}, "mutation_prompt": null}
{"id": "34e15f39-fd4a-462c-afc2-e0a9ad1dee23", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                \n                # Line modified: Quantum-inspired position update\n                quantum_prob = 0.1 * adaptive_factor\n                self.velocity[i] += quantum_prob * np.random.uniform(-1, 1, self.dim)\n                \n                swarm[i] += self.velocity[i]\n                \n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                \n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Quantum-Inspired Swarm Gradient Descent (AQISGD): Utilizes quantum-inspired transformations to enhance convergence speed and solution diversity.", "configspace": "", "generation": 3, "fitness": 0.8418500165933333, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.010. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1dbd446b-39ad-42c3-94c8-cc10c16afb9b", "metadata": {"aucs": [0.8450512468942778, 0.8285066044649894, 0.8519921984207326], "final_y": [0.13716179231967918, 0.1373241268787534, 0.12587579106088476]}, "mutation_prompt": null}
{"id": "0b6fdc25-3014-41bd-ab71-9e924623a2f7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Line modified: Introduce non-linear adaptive inertia weight\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                # Line modified: Adaptive velocity scaling factor added to enhance convergence\n                velocity_scaling = (1 - adaptive_factor)**0.5\n                self.velocity[i] = velocity_scaling * (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive velocity scaling factor to improve convergence speed and accuracy.", "configspace": "", "generation": 3, "fitness": 0.8518281347516856, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.852 with standard deviation 0.011. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "1dbd446b-39ad-42c3-94c8-cc10c16afb9b", "metadata": {"aucs": [0.8418346617393675, 0.8665070647149551, 0.8471426778007345], "final_y": [0.11302137410012059, 0.13296929299881244, 0.13369690683799207]}, "mutation_prompt": null}
{"id": "ca028518-c9ed-4822-ac2a-38f867653051", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            # Line modified: Introduce adaptive learning rate\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]  # Line modified\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved EASGD with adaptive learning rate based on function evaluations for enhanced exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8539692339978427, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.008. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1dbd446b-39ad-42c3-94c8-cc10c16afb9b", "metadata": {"aucs": [0.8490695790801814, 0.8481355470367946, 0.8647025758765524], "final_y": [0.12871121550228903, 0.12746026233344754, 0.12489047850893953]}, "mutation_prompt": null}
{"id": "3ee03018-e948-4e0d-b480-790f5052db1c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.05, self.dim)  # Line modified\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced adaptive swarm gradient descent with dynamic particle adaptation and Gaussian perturbation.", "configspace": "", "generation": 4, "fitness": 0.8472757965963219, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.023. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "ca028518-c9ed-4822-ac2a-38f867653051", "metadata": {"aucs": [0.8654811680127253, 0.8141751497407637, 0.8621710720354766], "final_y": [0.12396899512777027, 0.14137277121819392, 0.12773631658843976]}, "mutation_prompt": null}
{"id": "c2a05c51-ec60-4f3a-91a8-3ebcd233bfd0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.3 * adaptive_factor  # Adjusted inertia\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.05 * adaptive_factor:  # Reduced perturbation probability\n                    swarm[i] += np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined EASGD with dynamic population size and selective perturbations for improved performance stability and convergence.", "configspace": "", "generation": 4, "fitness": 0.8529121436750708, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.024. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "ca028518-c9ed-4822-ac2a-38f867653051", "metadata": {"aucs": [0.8858443904935669, 0.8428155619703517, 0.8300764785612942], "final_y": [0.11961188423076563, 0.13381007682355195, 0.13495773980863845]}, "mutation_prompt": null}
{"id": "20663e95-8d3d-4f90-9f22-65dea91569ca", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            # Line modified: Adaptive mutation now depends on evaluations\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor: \n                    swarm[i] += np.random.normal(0, 0.1 * (1 - evaluations / self.budget), self.dim)  # Line modified\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation and velocity decay to enhance exploration and stability as evaluations progress.", "configspace": "", "generation": 4, "fitness": 0.8679771250584566, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.017. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ca028518-c9ed-4822-ac2a-38f867653051", "metadata": {"aucs": [0.8560667101818555, 0.8562783864037328, 0.8915862785897812], "final_y": [0.12733351107807322, 0.1316572257346269, 0.11864413201016755]}, "mutation_prompt": null}
{"id": "e0529ff4-6bf5-4ff2-8e99-db93a759b4e8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            # Line modified: Adapt population size dynamically\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic population size that changes with the adaptation factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.8874846622695588, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.016. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ca028518-c9ed-4822-ac2a-38f867653051", "metadata": {"aucs": [0.883502898690273, 0.8699149849855862, 0.909036103132817], "final_y": [0.12154976351841684, 0.125006367614923, 0.11238030522195397]}, "mutation_prompt": null}
{"id": "53a8f890-b3e1-4209-86ba-2a55c8cd11b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            # Line modified: Introduce decay factor to learning rate\n            learning_rate = 0.5 * (1 - evaluations / self.budget) ** 0.8\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]  # Line modified\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a decay factor to the learning rate for enhanced convergence control and stability.", "configspace": "", "generation": 4, "fitness": 0.8665829140413287, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.032. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "ca028518-c9ed-4822-ac2a-38f867653051", "metadata": {"aucs": [0.8259582452834693, 0.8695681293242224, 0.9042223675162947], "final_y": [0.13531954276649594, 0.1286538510459878, 0.11830638970272211]}, "mutation_prompt": null}
{"id": "5afe8d62-602b-4299-be8b-371df8cf43b4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            # Line modified: Dynamic learning rate for enhanced precision\n            learning_rate = 0.3 + 0.7 * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic learning rate that increases exploration toward the end of the budget to enhance solution precision.", "configspace": "", "generation": 5, "fitness": 0.8635540263168382, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.005. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "e0529ff4-6bf5-4ff2-8e99-db93a759b4e8", "metadata": {"aucs": [0.8600385162811007, 0.8602369110335484, 0.8703866516358658], "final_y": [0.12951553612592348, 0.13283261199669172, 0.12439167851130839]}, "mutation_prompt": null}
{"id": "b4d56495-e96d-45a9-adc4-11ab4c6f4f39", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce mutation for enhanced diversity\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce elite selection and a mutation mechanism to enhance diversity and convergence speed in the adaptive swarm optimization.", "configspace": "", "generation": 5, "fitness": 0.8645688837148816, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.022. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "e0529ff4-6bf5-4ff2-8e99-db93a759b4e8", "metadata": {"aucs": [0.8341283295331542, 0.8718977228893553, 0.8876805987221356], "final_y": [0.12932838509958433, 0.12535503952563087, 0.12034945722295798]}, "mutation_prompt": null}
{"id": "daf4fff8-18b6-4aa3-b8cd-c6f446cfed98", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Added mutation with Gaussian perturbation\n                if np.random.rand() < 0.05:\n                    swarm[i] += np.random.normal(0, 0.01, self.dim)\n                \n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a mutation strategy with Gaussian perturbation to enhance local exploration potential. ", "configspace": "", "generation": 5, "fitness": 0.853223440050176, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.023. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "e0529ff4-6bf5-4ff2-8e99-db93a759b4e8", "metadata": {"aucs": [0.8208339913854976, 0.8743170544752528, 0.8645192742897776], "final_y": [0.14296592386668705, 0.12736971315381496, 0.11687398823897543]}, "mutation_prompt": null}
{"id": "b3ef2abd-63d6-41a9-bf40-01575b272a2b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            # Line modified: Adaptive learning rate based on diversity\n            diversity = np.std(swarm, axis=0).mean()\n            learning_rate = 0.5 * (1 - evaluations / self.budget) * (1 + diversity)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce an adaptive learning rate based on swarm diversity to enhance convergence rates and avoid local optima.", "configspace": "", "generation": 5, "fitness": 0.8054152466751875, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.081. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.035.", "error": "", "parent_id": "e0529ff4-6bf5-4ff2-8e99-db93a759b4e8", "metadata": {"aucs": [0.6916056599335909, 0.857153759655521, 0.8674863204364508], "final_y": [0.20241087631020682, 0.13144307713389758, 0.12520315349734434]}, "mutation_prompt": null}
{"id": "4583617c-1a62-4a43-8e84-e87f89b74299", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if np.random.rand() < 0.05 * adaptive_factor:  # Line added: Mutate global best\n                    global_best += np.random.normal(0, 0.05, self.dim)\n                    global_best = np.clip(global_best, lb, ub)\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm convergence by adding a mutation mechanism where global best occasionally mutates to maintain diversity.", "configspace": "", "generation": 5, "fitness": 0.8529537325250596, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.031. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "e0529ff4-6bf5-4ff2-8e99-db93a759b4e8", "metadata": {"aucs": [0.892829727749479, 0.8480734779729995, 0.8179579918527004], "final_y": [0.11789766351516662, 0.13802024770633525, 0.14077320071017174]}, "mutation_prompt": null}
{"id": "1fceb3eb-2063-4f0d-9057-45e5e5e924c7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce adaptive mutation for enhanced diversity\n                adaptive_mutation_rate = 0.1 * (1 - evaluations / self.budget)  # Changed line\n                if np.random.rand() < adaptive_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce an adaptive mutation rate mechanism for improved exploration-exploitation balance in the enhanced adaptive swarm optimization.", "configspace": "", "generation": 6, "fitness": 0.8479561053888199, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.018. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b4d56495-e96d-45a9-adc4-11ab4c6f4f39", "metadata": {"aucs": [0.8235012743882016, 0.852257590088388, 0.8681094516898705], "final_y": [0.13268294667257396, 0.13663764036619186, 0.12935464797371887]}, "mutation_prompt": null}
{"id": "81c6caff-dbb5-4992-b445-a6b29516d585", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            adaptive_learning_rate = lambda t: 0.1 + (0.5 - 0.1) * (1 - t / self.budget)\n            learning_rate = adaptive_learning_rate(evaluations)\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce non-uniform mutation for enhanced diversity\n                if np.random.rand() < 0.1 * adaptive_factor:\n                    mutation_vector = np.random.normal(0, 0.1 * (1 - evaluations / self.budget), self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive learning rate and non-uniform mutation to enhance exploration and exploitation balance in the adaptive swarm optimization.", "configspace": "", "generation": 6, "fitness": 0.8491206407770289, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.009. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b4d56495-e96d-45a9-adc4-11ab4c6f4f39", "metadata": {"aucs": [0.8466511422538721, 0.8399854585200981, 0.8607253215571165], "final_y": [0.12720996467387824, 0.12758332526913618, 0.1310024832643646]}, "mutation_prompt": null}
{"id": "8a480b71-c130-4fb8-b420-3f046163f64d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.3 + 0.7 * adaptive_factor  # Change 1\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce mutation for enhanced diversity\n                if np.random.rand() < 0.2 * adaptive_factor:  # Change 2\n                    mutation_vector = np.random.normal(0, 0.05 * adaptive_factor, self.dim)  # Change 3\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm optimization by integrating nonlinear mutation and adaptive learning strategies to boost exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.843384299582202, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.018. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "b4d56495-e96d-45a9-adc4-11ab4c6f4f39", "metadata": {"aucs": [0.8600914265800983, 0.85135193512089, 0.8187095370456176], "final_y": [0.12904554595774342, 0.13289417728801078, 0.13841181578318962]}, "mutation_prompt": null}
{"id": "6b889fe4-55ee-422b-b161-351f82039d3b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)  # Dynamic mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce mutation for enhanced diversity\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation rate and environmental pressure to enhance exploration and exploitation in swarm optimization.", "configspace": "", "generation": 6, "fitness": 0.8508074391601994, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.851 with standard deviation 0.015. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "b4d56495-e96d-45a9-adc4-11ab4c6f4f39", "metadata": {"aucs": [0.8696850632882277, 0.8328396364865077, 0.849897617705863], "final_y": [0.12386611959342275, 0.13637005314592654, 0.13591423036179717]}, "mutation_prompt": null}
{"id": "540d4f5f-2508-4520-8581-8478129b70d2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Dynamic mutation scaling for enhanced diversity\n                mutation_prob = 0.1 * adaptive_factor * (1 - evaluations / self.budget)\n                if np.random.rand() < mutation_prob:\n                    mutation_strength = 0.1 * np.sqrt(adaptive_factor)\n                    mutation_vector = np.random.normal(0, mutation_strength, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Incorporate dynamic mutation scaling and environment-based velocity adjustment for improved exploration and convergence.", "configspace": "", "generation": 6, "fitness": 0.8385463245778242, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.013. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b4d56495-e96d-45a9-adc4-11ab4c6f4f39", "metadata": {"aucs": [0.8472689370119164, 0.848492189357731, 0.8198778473638251], "final_y": [0.1263558979730035, 0.13327531353725874, 0.14620328080909417]}, "mutation_prompt": null}
{"id": "52b65e89-5d67-44bc-b022-8838362381de", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches)\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.2 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.2:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement adaptive ecological niche partitioning and hybrid crossover to enhance solution diversity in swarm optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "6b889fe4-55ee-422b-b161-351f82039d3b", "metadata": {}, "mutation_prompt": null}
{"id": "73718fd9-dc50-47a8-a5b5-33711d86a19e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = (1 - (evaluations / self.budget)**2)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)  # Dynamic mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                momentum = 0.9  # Introduce momentum term\n                self.velocity[i] = (momentum * self.velocity[i] + \n                                    inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce mutation for enhanced diversity\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a non-linear convergence enhancer and momentum term to refine swarm dynamics.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "6b889fe4-55ee-422b-b161-351f82039d3b", "metadata": {}, "mutation_prompt": null}
{"id": "bc3c9ad6-f0c6-43ca-879b-1c3862aa95d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            # Remove dynamic_population_size as it is not used\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor) + 0.05 * np.random.rand()  # Self-adaptive mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce mutation for enhanced diversity\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on adaptive elite selection\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 10)]  # More selective elite group\n            elite_swarm = swarm[elite_indices]\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm optimization by employing an adaptive selection strategy and integrating a self-adaptive mutation mechanism to improve convergence and solution quality.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "6b889fe4-55ee-422b-b161-351f82039d3b", "metadata": {}, "mutation_prompt": null}
{"id": "692ffa91-e3fd-4e8f-a2ed-515508710848", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            # Select elite individuals\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]  # Changed line\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)  # Dynamic mutation rate\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Introduce mutation for enhanced diversity\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update global best based on elite swarm\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance selection pressure by slightly increasing the elite selection fraction to improve convergence speed.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "6b889fe4-55ee-422b-b161-351f82039d3b", "metadata": {}, "mutation_prompt": null}
{"id": "a64ec4ee-43c1-4411-8e69-1cdbf1799a6d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.5 + 0.4 * np.sin(np.pi * adaptive_factor)  # Hybrid inertia mechanism\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            dynamic_population_size = int(self.population_size * (1 + 0.1 * adaptive_factor))\n\n            learning_rate = 0.4 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor) \n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n                \n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a hybrid inertia mechanism and local search to enhance convergence efficiency in swarm optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "6b889fe4-55ee-422b-b161-351f82039d3b", "metadata": {}, "mutation_prompt": null}
{"id": "aaea20dd-b696-4baa-9677-eb19e12e4f87", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches, axis=0) \n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement niche adaptation with elite learning and improved mutation control in swarm optimization.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"choice() got an unexpected keyword argument 'axis'\").", "error": "TypeError(\"choice() got an unexpected keyword argument 'axis'\")", "parent_id": "52b65e89-5d67-44bc-b022-8838362381de", "metadata": {}, "mutation_prompt": null}
{"id": "46f91931-b83f-4ad8-86e7-3e368547e642", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches, axis=0)  # Change made: Added axis=0 for correct selection\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.2 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.2:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement adaptive ecological niche partitioning and hybrid crossover with corrected niche influence selection for enhanced diversity in swarm optimization.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"choice() got an unexpected keyword argument 'axis'\").", "error": "TypeError(\"choice() got an unexpected keyword argument 'axis'\")", "parent_id": "52b65e89-5d67-44bc-b022-8838362381de", "metadata": {}, "mutation_prompt": null}
{"id": "fd1ce9b5-5dc2-494d-8d8f-67c4ddae5364", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches)\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    influence_factor = 0.2 + 0.1 * adaptive_factor\n                    swarm[i] += influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.2:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_strength = 0.1 * adaptive_factor\n                    mutation_vector = np.random.normal(0, mutation_strength, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrate adaptive mutation scaling and improved niche influence for enhanced solution convergence in swarm optimization.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "52b65e89-5d67-44bc-b022-8838362381de", "metadata": {}, "mutation_prompt": null}
{"id": "512d1e2b-cf4f-47ff-bae3-733db5bed101", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:min(i+5, self.population_size)], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches, replace=False)\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.2 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.2:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve niche partitioning by ensuring niches have unique and valid population members.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "52b65e89-5d67-44bc-b022-8838362381de", "metadata": {}, "mutation_prompt": null}
{"id": "e3fc85e2-7ee8-4215-bad9-4d38f1313573", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.mean(niches, axis=0)  # Corrected dimensionality\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.2 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.2:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce scaling factor in ecological niche influence to correct dimensionality mismatch error.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "52b65e89-5d67-44bc-b022-8838362381de", "metadata": {}, "mutation_prompt": null}
{"id": "fbb3da56-968b-4e87-8ba1-bb5aecf5c023", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches)  # Fixed axis selection\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement niche adaptation with elite learning and improved mutation control in swarm optimization, fixing axis selection in niche influence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "aaea20dd-b696-4baa-9677-eb19e12e4f87", "metadata": {}, "mutation_prompt": null}
{"id": "6f1b05b4-e8b4-4663-80ab-ecd6a7a52a2f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches)  # Corrected by removing 'axis=0'\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement niche adaptation with elite learning and improved mutation control in swarm optimization using corrected niche influence selection.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "aaea20dd-b696-4baa-9677-eb19e12e4f87", "metadata": {}, "mutation_prompt": null}
{"id": "827814b0-e643-462d-8865-1ac4dc7f34a2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches)  # Fixed this line\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement niche adaptation with elite learning and improved mutation control in swarm optimization, fixing the niche influence selection.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "aaea20dd-b696-4baa-9677-eb19e12e4f87", "metadata": {}, "mutation_prompt": null}
{"id": "c234d527-c8a9-4a6a-b02e-74ebad654b6f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))] \n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, adaptive_factor * 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance niche adaptation and hybrid crossover with improved niche influence selection and mutation control in swarm optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "aaea20dd-b696-4baa-9677-eb19e12e4f87", "metadata": {}, "mutation_prompt": null}
{"id": "03c0d525-7f78-4c6b-b73f-fa035f6d6692", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05 * adaptive_factor, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve swarm optimization with niche adaptation by refining niche influence selection and mutation strategy.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "aaea20dd-b696-4baa-9677-eb19e12e4f87", "metadata": {}, "mutation_prompt": null}
{"id": "2519c88a-fe17-41b2-b0a6-d71d7beba581", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Enhancements in Niche Adaptation\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5) if i+5 <= self.population_size]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                if niches:  # Added check for non-empty niches\n                    niche_influence = np.random.choice(niches)\n                    niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                    if niche_distance < niche_radius:\n                        swarm[i] += 0.25 * (niche_influence - swarm[i])\n\n                # Refined Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner_idx = np.random.randint(self.population_size)\n                    partner = swarm[partner_idx]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance niche adaptation and hybrid crossover in swarm optimization with adaptive learning and mutation control.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "fbb3da56-968b-4e87-8ba1-bb5aecf5c023", "metadata": {}, "mutation_prompt": null}
{"id": "ba3fbdbd-f27f-4355-8dd9-b21e9a55fb3d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = np.random.choice(niches)\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_rate = 0.9\n                    if np.random.rand() < crossover_rate:\n                        crossover_point = np.random.randint(1, self.dim)\n                        swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.laplace(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve niche influence and mutation strategies with diverse techniques for enhanced adaptability in swarm optimization.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "fbb3da56-968b-4e87-8ba1-bb5aecf5c023", "metadata": {}, "mutation_prompt": null}
{"id": "a5f8db30-c78c-4e4b-bf18-5553c7fd0c34", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[i // 5]  # Use niche according to current segment\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05 * adaptive_factor, self.dim)  # Mutation adjusted by adaptive factor\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine niche influence selection and mutation strategy in adaptive swarm optimization for improved search efficiency.", "configspace": "", "generation": 10, "fitness": 0.8218921974968613, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.024. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "fbb3da56-968b-4e87-8ba1-bb5aecf5c023", "metadata": {"aucs": [0.7946724122837009, 0.8187033771061112, 0.8523008031007715], "final_y": [0.15432573938095118, 0.14476155970904037, 0.12950501256122982]}, "mutation_prompt": null}
{"id": "787b7740-e4f0-4752-aaf0-120c549115c3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))]  # Fixed indexing for niche influence\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05 * adaptive_factor, self.dim)  # Adjust mutation scale\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance niche influence selection by fixing dimensionality issues and adjust mutation strategy for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.8263345705004609, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.019. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "fbb3da56-968b-4e87-8ba1-bb5aecf5c023", "metadata": {"aucs": [0.8454688280136573, 0.8010702160280341, 0.8324646674596914], "final_y": [0.1386123932750316, 0.14135263518883523, 0.13984186030688228]}, "mutation_prompt": null}
{"id": "f14f8a72-51ee-45d2-8fbe-35dab292bcde", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))]  # Ensure valid index for niche influence\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a safer niche influence selection by ensuring selected niche is a valid candidate.", "configspace": "", "generation": 10, "fitness": 0.8339698274791952, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.018. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "fbb3da56-968b-4e87-8ba1-bb5aecf5c023", "metadata": {"aucs": [0.8094905338191974, 0.8495498892818076, 0.8428690593365809], "final_y": [0.13492928728957243, 0.13158762397541657, 0.12427854122852566]}, "mutation_prompt": null}
{"id": "2c8c3eff-5d93-44ed-9ca8-f89f379fa9cc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * adaptive_factor  # Updated inertia weight adaptation\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))]  # Ensure valid index for niche influence\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement an updated inertia weight adaptation to improve convergence speed while maintaining stability.", "configspace": "", "generation": 11, "fitness": 0.8577018856613896, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.020. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "f14f8a72-51ee-45d2-8fbe-35dab292bcde", "metadata": {"aucs": [0.8853915904898082, 0.841074968734707, 0.8466390977596536], "final_y": [0.12382818505274318, 0.14102997762140057, 0.1361692939836705]}, "mutation_prompt": null}
{"id": "6b0245eb-4e50-47dd-ba05-af4a1de9749e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = min(niches, key=lambda niche: np.linalg.norm(swarm[i] - niche))  # Dynamic niche evaluation selection\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance niche selection robustness by introducing dynamic niche evaluation.", "configspace": "", "generation": 11, "fitness": 0.8263144605981108, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.022. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "f14f8a72-51ee-45d2-8fbe-35dab292bcde", "metadata": {"aucs": [0.8003269939626627, 0.8247885180843326, 0.8538278697473369], "final_y": [0.14123815008055196, 0.14840488274200547, 0.13514280035965087]}, "mutation_prompt": null}
{"id": "3634f062-41e4-468b-b8f6-7aa065508946", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))]  # Ensure valid index for niche influence\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Elite-guided mutation strategy\n                if np.random.rand() < dynamic_mutation_rate:\n                    elite_partner = elite_swarm[np.random.randint(len(elite_swarm))]\n                    mutation_vector = np.random.normal(elite_partner, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce an elite-guided mutation to enhance convergence by replacing one mutation operation.", "configspace": "", "generation": 11, "fitness": 0.8454763502682757, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.040. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "f14f8a72-51ee-45d2-8fbe-35dab292bcde", "metadata": {"aucs": [0.7906959758451382, 0.861648742829406, 0.8840843321302831], "final_y": [0.14667598167924756, 0.13128248767369988, 0.12827014193471364]}, "mutation_prompt": null}
{"id": "aa7d04bd-437b-4c1c-9052-e9fb1295d7e7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            # Dynamic Mutation Rate based on Diversity\n            diversity = np.std(swarm, axis=0).mean()\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor) * (1 + diversity)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.random.randint(len(niches))]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.25 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement an adaptive mutation rate based on niche diversity to enhance exploration capabilities in variable environments.", "configspace": "", "generation": 11, "fitness": 0.8258939848463354, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.008. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "f14f8a72-51ee-45d2-8fbe-35dab292bcde", "metadata": {"aucs": [0.8142058431134396, 0.8328966246935601, 0.8305794867320064], "final_y": [0.14561587468281267, 0.14120943583700485, 0.14499543303308937]}, "mutation_prompt": null}
{"id": "10c9ea4f-657c-4e1e-8c70-ed50e36ce89b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                # Improved niche influence strategy\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.35 * (niche_influence - swarm[i])  # Increase niche influence factor\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve niche utilization and balance exploration by refining ecological niche partitioning and hybrid crossover.", "configspace": "", "generation": 11, "fitness": 0.8597506253601465, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.001. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "f14f8a72-51ee-45d2-8fbe-35dab292bcde", "metadata": {"aucs": [0.8610068400373021, 0.8590711121909224, 0.8591739238522149], "final_y": [0.12139724826397824, 0.13333138265033218, 0.13473555174660623]}, "mutation_prompt": null}
{"id": "fb3c562e-cd60-4583-9520-31b052da86fa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                # Improved niche influence strategy\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += adaptive_factor * (niche_influence - swarm[i])  # Modified line\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration by adjusting the niche influence factor based on the budget.", "configspace": "", "generation": 12, "fitness": 0.817935155249462, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.011. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "10c9ea4f-657c-4e1e-8c70-ed50e36ce89b", "metadata": {"aucs": [0.8053590347362365, 0.8311589992501554, 0.8172874317619941], "final_y": [0.1397989953636133, 0.12800909789523762, 0.1321073588948528]}, "mutation_prompt": null}
{"id": "59d90910-bee9-49bb-aa5e-bc741f1a4a89", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Modified from 0.7 + 0.3\n            cognitive_coeff = 1.7 * adaptive_factor  # Modified from 1.5\n            social_coeff = 1.3 - 0.3 * adaptive_factor  # Modified from 1.5 - 0.5\n\n            learning_rate = 0.55 * (1 - evaluations / self.budget)  # Modified from 0.5\n\n            elite_indices = np.argsort(personal_best_value)[:max(2, self.population_size // 4)]  # Modified 1 to 2\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.15 * (1 - adaptive_factor)  # Modified from 0.1\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.4 * (niche_influence - swarm[i])  # Modified from 0.35\n\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration-exploitation balance by integrating stochastic tunneling and adaptive multi-niche elitism.", "configspace": "", "generation": 12, "fitness": 0.8261891509771605, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.024. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "10c9ea4f-657c-4e1e-8c70-ed50e36ce89b", "metadata": {"aucs": [0.7926677927119062, 0.8413812454462031, 0.8445184147733724], "final_y": [0.1553955803890047, 0.13768194728720495, 0.13389109779812403]}, "mutation_prompt": null}
{"id": "61be1349-4d30-4e02-b14b-487d6900cd31", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])  # Increase niche influence factor\n\n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.35:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    if np.random.rand() < 0.5:\n                        swarm[i][:crossover_point] = partner[:crossover_point]\n                    else:\n                        swarm[i][crossover_point:] = partner[crossover_point:]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n            # Probabilistic Elite Perturbation\n            for elite in elite_swarm:\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.normal(0, 0.01, self.dim)\n                    elite += perturbation\n                    elite = np.clip(elite, lb, ub)\n                    f_value = func(elite)\n                    if f_value < global_best_value:\n                        global_best = elite\n                        global_best_value = f_value\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance adaptive dynamics with probabilistic elite perturbation and improved niche crossover. ", "configspace": "", "generation": 12, "fitness": 0.8204351700386834, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.009. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "10c9ea4f-657c-4e1e-8c70-ed50e36ce89b", "metadata": {"aucs": [0.8131629795968558, 0.8324950913947927, 0.8156474391244017], "final_y": [0.13873307719897554, 0.13952512809315165, 0.1349120749859617]}, "mutation_prompt": null}
{"id": "5bfb0d35-44eb-4285-8e1f-203bec28afda", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]  # Changed to 4\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)  # Changed to 0.05\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:  # Enhanced niche influence\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])  # Changed to 0.40\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine swarm dynamics by incorporating a dynamic elite selection and niche influence enhancement for improved convergence.", "configspace": "", "generation": 12, "fitness": 0.835642078768144, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.836 with standard deviation 0.020. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "10c9ea4f-657c-4e1e-8c70-ed50e36ce89b", "metadata": {"aucs": [0.8072272956008376, 0.8500658571971854, 0.849633083506409], "final_y": [0.14233779872971786, 0.1323891454185776, 0.13583863878007507]}, "mutation_prompt": null}
{"id": "9eed10f5-7d0b-4b88-a98b-49b14c541d25", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.4 + 0.1 * np.sin(np.pi * evaluations / self.budget)  # Modified learning rate\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)\n\n            # Ecological Niche Partitioning\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                # Improved niche influence strategy\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius:\n                    swarm[i] += 0.45 * (niche_influence - swarm[i])  # Increased niche influence factor\n                \n                # Hybrid Crossover Strategy\n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration-exploitation balance by refining niche influence strategy and adaptive learning rate.", "configspace": "", "generation": 12, "fitness": 0.8176791570971411, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.013. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "10c9ea4f-657c-4e1e-8c70-ed50e36ce89b", "metadata": {"aucs": [0.83276995248333, 0.8015426791567928, 0.8187248396513004], "final_y": [0.1380075450490159, 0.14839310879878997, 0.14704492015612192]}, "mutation_prompt": null}
{"id": "b01d1e95-eb15-45fa-9538-ecde1ea3b65d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * adaptive_factor * (1 - evaluations / self.budget)  # Changed this line\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]  # Changed to 4\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)  # Changed to 0.05\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:  # Enhanced niche influence\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])  # Changed to 0.40\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve convergence by refining the learning rate calculation based on the adaptive factor and evaluations.", "configspace": "", "generation": 13, "fitness": 0.8175563519649544, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.006. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "5bfb0d35-44eb-4285-8e1f-203bec28afda", "metadata": {"aucs": [0.8091916154926088, 0.8228290067566719, 0.8206484336455825], "final_y": [0.14385201133421632, 0.12065200923164254, 0.13238400757695723]}, "mutation_prompt": null}
{"id": "1bcc0f45-1876-4832-8d14-fc0b59494e56", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Changed from 0.3 to 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine swarm dynamics by incorporating a dynamic elite selection and niche influence enhancement for improved convergence with optimized crossover probability.", "configspace": "", "generation": 13, "fitness": 0.8455729710466334, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.013. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "5bfb0d35-44eb-4285-8e1f-203bec28afda", "metadata": {"aucs": [0.8593176295776979, 0.8282225125598011, 0.8491787710024012], "final_y": [0.1261213246510542, 0.14475058506834115, 0.1387154170876852]}, "mutation_prompt": null}
{"id": "403e01f9-ceea-4674-8d68-a8c20fcabc5c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor + 0.5 * (1 - adaptive_factor)  # Modified line\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a simple adaptive mechanism for cognitive and social coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 13, "fitness": 0.8319149390299606, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.020. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "5bfb0d35-44eb-4285-8e1f-203bec28afda", "metadata": {"aucs": [0.8048320580010556, 0.8403537549158158, 0.8505590041730104], "final_y": [0.13898027554790937, 0.14201670744403805, 0.12323711174205643]}, "mutation_prompt": null}
{"id": "871d0e17-974a-4a6c-a456-d20187fae79c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.7 * adaptive_factor  # Adjusted to improve exploration-exploitation balance\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm adaptability by adjusting cognitive and social coefficients to improve exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.8339403494458933, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.019. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "5bfb0d35-44eb-4285-8e1f-203bec28afda", "metadata": {"aucs": [0.8425561369318968, 0.8520402333131729, 0.8072246780926102], "final_y": [0.1409854016143457, 0.1336542580308674, 0.1447559383354674]}, "mutation_prompt": null}
{"id": "c4ee00de-8b7a-436c-96f9-3bbc4e96d9fd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.03, self.dim)  # Changed mutation stddev to 0.03\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine swarm dynamics by incorporating a dynamic elite selection and niche influence enhancement for improved convergence with a slight improvement in mutation strategy.", "configspace": "", "generation": 13, "fitness": 0.8232289500028206, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.030. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "5bfb0d35-44eb-4285-8e1f-203bec28afda", "metadata": {"aucs": [0.8001498347727234, 0.8043072061999662, 0.8652298090357721], "final_y": [0.14448810641976795, 0.14275597484372793, 0.1307978518616698]}, "mutation_prompt": null}
{"id": "139baee6-9152-4745-a7aa-019eb89187fa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Changed from 0.3 to 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)  # Changed from 0.05 to 0.1\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine swarm dynamics by incorporating dynamic elite selection and niche influence enhancement for improved convergence with optimized crossover probability and enhanced mutation diversity.", "configspace": "", "generation": 14, "fitness": 0.8390397752957686, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.010. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1bcc0f45-1876-4832-8d14-fc0b59494e56", "metadata": {"aucs": [0.8259671961343686, 0.8484420759909816, 0.8427100537619553], "final_y": [0.13198392326519226, 0.1327703515480706, 0.13510857772486085]}, "mutation_prompt": null}
{"id": "ac3f6fe4-8be0-4455-bf04-a06f2da6fb34", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector * adaptive_factor  # Modified line for enhanced mutation interaction\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm performance by refining niche influence and mutation interaction for more effective exploration.", "configspace": "", "generation": 14, "fitness": 0.8325050627092652, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.009. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1bcc0f45-1876-4832-8d14-fc0b59494e56", "metadata": {"aucs": [0.8211623993458731, 0.8346884010010736, 0.841664387780849], "final_y": [0.1404722378965123, 0.13996000328987823, 0.1298348379531037]}, "mutation_prompt": null}
{"id": "7db3d7a0-549a-459b-8e3a-5a58192111d7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)**1.5  # Change made here\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved swarm adaptability by finely tuning dynamic mutation rate based on evaluations.", "configspace": "", "generation": 14, "fitness": 0.8316347850532271, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.009. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1bcc0f45-1876-4832-8d14-fc0b59494e56", "metadata": {"aucs": [0.8190167611754782, 0.8344753037981005, 0.8414122901861026], "final_y": [0.133966607699452, 0.13398827517408263, 0.13014553615649804]}, "mutation_prompt": null}
{"id": "e69b09dc-43a2-413e-a4bb-e93bb2a0e383", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**3\n            inertia_weight = 0.5 + 0.5 * adaptive_factor  # Adjusted\n            cognitive_coeff = 1.2 * adaptive_factor  # Adjusted\n            social_coeff = 1.8 - 0.3 * adaptive_factor  # Adjusted\n\n            learning_rate = 0.4 * (1 - evaluations / self.budget)  # Adjusted\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]  # Adjusted\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)  # Adjusted\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.2:  # Adjusted\n                    swarm[i] += 0.35 * (niche_influence - swarm[i])  # Adjusted\n                \n                if np.random.rand() < 0.2:  # Adjusted\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)  # Adjusted\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance solution discovery by integrating adaptive inertia and mutation strategies with multi-niche selection for improved global exploration and convergence balance.", "configspace": "", "generation": 14, "fitness": 0.823891646041492, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.007. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1bcc0f45-1876-4832-8d14-fc0b59494e56", "metadata": {"aucs": [0.8237777925971987, 0.8325893506978953, 0.8153077948293821], "final_y": [0.14372479177437103, 0.1429296965335316, 0.136937820557111]}, "mutation_prompt": null}
{"id": "f79247a8-1caf-4504-927a-66865d78ac9f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.2:  # Changed from 1.1 to 1.2\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Changed from 0.3 to 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine swarm dynamics by adjusting niche influence interaction for enhanced exploration and convergence.", "configspace": "", "generation": 14, "fitness": 0.8315960229298142, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.022. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "1bcc0f45-1876-4832-8d14-fc0b59494e56", "metadata": {"aucs": [0.8177619019525334, 0.8143549515728722, 0.8626712152640366], "final_y": [0.14034652640086076, 0.14834591011669085, 0.12434300368222495]}, "mutation_prompt": null}
{"id": "157566c9-e959-4516-a8da-a96d21e7ef2c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)  # Changed from 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Changed from 0.3 to 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)  # Changed from 0.05 to 0.1\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce strategic inertia weight decay to balance exploration and exploitation more effectively.", "configspace": "", "generation": 15, "fitness": 0.8611068488733649, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.028. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "139baee6-9152-4745-a7aa-019eb89187fa", "metadata": {"aucs": [0.900667708118443, 0.8466188266318854, 0.8360340118697663], "final_y": [0.1132321952437233, 0.13963690125057682, 0.13420892389056338]}, "mutation_prompt": null}
{"id": "20219b9d-91d7-44f5-96c7-f6c55a5de48c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Changed from 0.7 + 0.3\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.04 * (1 - adaptive_factor)  # Changed from 0.05\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Changed from 0.3 to 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)  # Changed from 0.05 to 0.1\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce localized exploitation by adjusting inertia and mutation dynamics to improve convergence in swarm optimizations.", "configspace": "", "generation": 15, "fitness": 0.8418235548569313, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.008. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "139baee6-9152-4745-a7aa-019eb89187fa", "metadata": {"aucs": [0.8317043180150288, 0.8421996184735738, 0.8515667280821914], "final_y": [0.1326278894307883, 0.13047192646330075, 0.13642689889669557]}, "mutation_prompt": null}
{"id": "61f1bf21-d8bf-4dba-bf9a-eff0aaf0392c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 + 0.2 * adaptive_factor  # Changed from 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm adaptability by fine-tuning inertia weight dynamics for improved search efficiency.", "configspace": "", "generation": 15, "fitness": 0.8287636026342073, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.021. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "139baee6-9152-4745-a7aa-019eb89187fa", "metadata": {"aucs": [0.814660315294424, 0.8128803755036419, 0.8587501171045561], "final_y": [0.1401117965577331, 0.14447631257403182, 0.12383106894832885]}, "mutation_prompt": null}
{"id": "a09e84de-4e19-4624-9dae-c49fb29d5ac5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_size = max(1, (self.population_size // 4) + int(adaptive_factor * (self.population_size // 10)))\n            elite_indices = np.argsort(personal_best_value)[:elite_size]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor * (1 + 0.1 * np.random.randn())\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance elite selection by dynamically updating elite swarm size and improving niche diversity through adaptive radii adjustments.", "configspace": "", "generation": 15, "fitness": 0.8495293974037527, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.006. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "139baee6-9152-4745-a7aa-019eb89187fa", "metadata": {"aucs": [0.8406264470902696, 0.8547842550395046, 0.8531774900814841], "final_y": [0.134451379987382, 0.1270433521108616, 0.12225649912193226]}, "mutation_prompt": null}
{"id": "a3555e88-4ae5-4448-b3ea-a5534a61ba53", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.55 * adaptive_factor  # Changed from 1.5 to 1.55\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Changed from 0.3 to 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)  # Changed from 0.05 to 0.1\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance velocity update by slightly increasing cognitive coefficient to promote individual exploration.", "configspace": "", "generation": 15, "fitness": 0.827765668581598, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.033. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "139baee6-9152-4745-a7aa-019eb89187fa", "metadata": {"aucs": [0.7828258490006551, 0.8393256845057014, 0.8611454722384373], "final_y": [0.16094863576969676, 0.1342885319628755, 0.13201727004144403]}, "mutation_prompt": null}
{"id": "93ed18ae-2171-4cf5-af5f-0c913dd7dd8b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * np.sin(evaluations * np.pi / (2 * self.budget))  # Modified line\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance diversity by dynamically adjusting the cognitive coefficient using a sinusoidal function for improved exploration.", "configspace": "", "generation": 16, "fitness": 0.8774853761814855, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.035. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "157566c9-e959-4516-a8da-a96d21e7ef2c", "metadata": {"aucs": [0.8287744548129483, 0.8965845745948838, 0.9070970991366243], "final_y": [0.1332811526520874, 0.11640209206449004, 0.11483552670454134]}, "mutation_prompt": null}
{"id": "1a915ea7-4638-4063-bdde-fde08e39b0ad", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget) ** 2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i + 5], axis=0) for i in range(0, self.population_size, 5)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                # Apply temperature-based mutation schedule\n                temperature = max(0.01, (self.budget - evaluations) / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 * temperature, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement a temperature-based mutation schedule to enhance exploration in later stages.", "configspace": "", "generation": 16, "fitness": 0.8728625348049105, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.037. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "157566c9-e959-4516-a8da-a96d21e7ef2c", "metadata": {"aucs": [0.8339038575398905, 0.861813474775305, 0.9228702720995359], "final_y": [0.13356512563483236, 0.12902406823837664, 0.11326890506191545]}, "mutation_prompt": null}
{"id": "c3489afc-2f59-4a43-a97b-b2a0964e0970", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.1 * np.mean(elite_swarm, axis=0))  # Change\n\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce elite-based velocity influence to enhance convergence speed.", "configspace": "", "generation": 16, "fitness": 0.838043237460937, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.082. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "157566c9-e959-4516-a8da-a96d21e7ef2c", "metadata": {"aucs": [0.7226994431699831, 0.8967227094626583, 0.8947075597501697], "final_y": [0.18679775437015123, 0.12101233944462686, 0.12072808562384318]}, "mutation_prompt": null}
{"id": "d612e79e-4476-4531-aa55-072884b179ea", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.45  # Changed from 0.40 to 0.45\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.2:  # Changed mutation adjustment\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance niche influence and mutation flexibility to boost exploration and convergence.", "configspace": "", "generation": 16, "fitness": 0.8803454021647713, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.017. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "157566c9-e959-4516-a8da-a96d21e7ef2c", "metadata": {"aucs": [0.8575736119809908, 0.8870792572165227, 0.8963833372968006], "final_y": [0.12353396826873297, 0.12125371740050428, 0.11979922637592322]}, "mutation_prompt": null}
{"id": "3d413b6e-e620-485b-9dab-d98983d591dc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.5 + 0.4 * np.random.rand()  # Changed from 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Changed from 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += 0.40 * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.15:  # Changed from 0.25\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)  # Changed from 0.1 to 0.05\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Incorporate a stochastic adaptive inertia weight and leader perturbation to enhance convergence by dynamically adjusting the swarm's focus.", "configspace": "", "generation": 16, "fitness": 0.8660742224217691, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.034. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "157566c9-e959-4516-a8da-a96d21e7ef2c", "metadata": {"aucs": [0.8489561354081838, 0.91343898817386, 0.8358275436832635], "final_y": [0.1348883821643837, 0.11245858764068839, 0.14062847243374255]}, "mutation_prompt": null}
{"id": "951044fb-8f29-4883-9792-33b93ca11772", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.04 * (1 - adaptive_factor)  # Adjusted from 0.05 to 0.04\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.45\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.3:  # Increased mutation adjustment\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine swarm learning through elite retention and adaptive perturbation.", "configspace": "", "generation": 17, "fitness": 0.8812398082032762, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.015. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d612e79e-4476-4531-aa55-072884b179ea", "metadata": {"aucs": [0.8621589096017188, 0.8829435821945777, 0.8986169328135322], "final_y": [0.12644760654702059, 0.12479705674844987, 0.11519712234513468]}, "mutation_prompt": null}
{"id": "42f12847-fc62-474d-824a-a057ee90235c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.6 * (1 - evaluations / self.budget)  # Adjusted learning rate\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)  # Increased mutation rate\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.5  # Adjusted from 0.45 to 0.5\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:  # Increased crossover probability\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.3:  # Increased mutation strength\n                    mutation_vector = np.random.normal(0, 0.15, self.dim)  # Adjusted mutation vector\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance mutation strength and adaptive learning to improve exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.8799685403525, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.020. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d612e79e-4476-4531-aa55-072884b179ea", "metadata": {"aucs": [0.8519306219510011, 0.8880056976922894, 0.8999693014142094], "final_y": [0.11735564347914873, 0.11693229315452425, 0.1148054236740027]}, "mutation_prompt": null}
{"id": "5b8cc274-3763-4647-904a-91975de4cc9e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.85 - 0.35 * (evaluations / self.budget)  # Changed from 0.9 to 0.85 and 0.4 to 0.35\n            cognitive_coeff = 1.6 * adaptive_factor  # Changed from 1.5 to 1.6\n            social_coeff = 1.4 - 0.4 * adaptive_factor  # Changed from 1.5 - 0.5\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.055 * (1 - adaptive_factor)  # Changed from 0.05 to 0.055\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.45\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.2:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Fine-tune adaptive parameters and enhance niche collaboration to balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.8649851125597618, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.016. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d612e79e-4476-4531-aa55-072884b179ea", "metadata": {"aucs": [0.8422565323253605, 0.8731496315432012, 0.879549173810724], "final_y": [0.13494461508794597, 0.12479012683017632, 0.12169190421611675]}, "mutation_prompt": null}
{"id": "47c655cc-58cd-4b65-9971-2208fa488c10", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 - 0.5 * adaptive_factor\n\n            learning_rate = 0.5 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.45 \n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                \n                if evaluations > self.budget * 0.75:  # New learning adjustment\n                    learning_rate *= 1.1\n                \n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.2:  \n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance convergence by introducing a momentary global learning adjustment for better balance between exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.8745136625524091, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.009. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d612e79e-4476-4531-aa55-072884b179ea", "metadata": {"aucs": [0.8685062919962963, 0.8677840012776779, 0.887250694383253], "final_y": [0.11526075201766317, 0.12384490827030747, 0.11714207164479817]}, "mutation_prompt": null}
{"id": "e53691a3-6f01-4c94-af14-b3976240a1f4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)  # Modified\n            cognitive_coeff = 1.7 * adaptive_factor  # Modified\n            social_coeff = 1.3 - 0.3 * adaptive_factor  # Modified\n\n            learning_rate = 0.6 * (1 - evaluations / self.budget)  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.07 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.50  # Modified\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.2:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:  # Modified\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.3:  # Modified\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine niche mutation dynamics and enhance cognitive-social synergy for superior convergence.", "configspace": "", "generation": 17, "fitness": 0.8857548370353148, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.019. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d612e79e-4476-4531-aa55-072884b179ea", "metadata": {"aucs": [0.8601029573663033, 0.8919207681603745, 0.9052407855792666], "final_y": [0.12214635489934977, 0.11682958649168851, 0.11670635786660966]}, "mutation_prompt": null}
{"id": "eb16a4e4-06e7-4463-b4b2-ffd0d50bc9ab", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.4 * adaptive_factor  # Modified\n\n            learning_rate = 0.7 * (1 - evaluations / self.budget)  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.09 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.55  # Modified\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.4:  # Modified\n                    partner1, partner2 = np.random.choice(self.population_size, 2, replace=False)\n                    crossover_point = np.random.randint(1, self.dim)\n                    diff_mutation = swarm[partner1] - swarm[partner2]\n                    swarm[i][:crossover_point] = partner1[:crossover_point] + 0.5 * diff_mutation  # Modified\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:  # Modified\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrate adaptive differential mutation and enhanced partner selection to foster solution diversity and convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e53691a3-6f01-4c94-af14-b3976240a1f4", "metadata": {}, "mutation_prompt": null}
{"id": "bb342d14-fe13-4752-8832-27fa1b68444c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.3 * adaptive_factor\n\n            learning_rate = 0.6 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.05 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.55  # Modified\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.25:  # Modified\n                    partner = swarm[np.random.choice(elite_indices)]  # Modified\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:  # Modified\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)  # Modified\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce dynamic neighborhood crossover and adaptive mutation strategies to enhance exploratory and exploitative balance.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e53691a3-6f01-4c94-af14-b3976240a1f4", "metadata": {}, "mutation_prompt": null}
{"id": "b350ceb6-25b5-43cf-9dba-5a84e4974fe9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)  # Modified\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.3 * adaptive_factor\n\n            learning_rate = 0.6 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.07 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor * 1.1  # Modified\n            niche_influence_factor = 0.50\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.2:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.3:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce refined inertia weight decay and a dynamic niche radius adjustment for enhanced search capability.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e53691a3-6f01-4c94-af14-b3976240a1f4", "metadata": {}, "mutation_prompt": null}
{"id": "6dc56428-b797-4c00-aa6d-cea13d98abf4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.3 * adaptive_factor\n\n            learning_rate = 0.6 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.07 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.50\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.2:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.3:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Amplify niche influence through refined selection of influential candidates for enhanced exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e53691a3-6f01-4c94-af14-b3976240a1f4", "metadata": {}, "mutation_prompt": null}
{"id": "f02d9436-7593-4cfb-b709-90aad06a9807", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)  # Modified\n            cognitive_coeff = 1.7 * adaptive_factor  # Modified\n            social_coeff = 1.3 - 0.3 * adaptive_factor  # Modified\n\n            learning_rate = 0.6 * (1 - evaluations / self.budget)  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.60  # Modified\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.2:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.3:  # Modified\n                    partner = swarm[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim)\n                    swarm[i][:crossover_point] = partner[:crossover_point]\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:  # Modified\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Optimize swarm dynamics by dynamically adjusting niche influence and mutation rates for enhanced exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e53691a3-6f01-4c94-af14-b3976240a1f4", "metadata": {}, "mutation_prompt": null}
{"id": "9bec04a9-2500-4673-898e-ff732a3d0e4c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget) ** 2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.4 * adaptive_factor\n\n            learning_rate = 0.7 * (1 - evaluations / self.budget)\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.09 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.55\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                    \n                if np.random.rand() < 0.35:  # Modified\n                    partner1, partner2 = np.random.choice(self.population_size, 2, replace=False)\n                    crossover_point = np.random.randint(1, self.dim)\n                    diff_mutation = swarm[partner1] - swarm[partner2]\n                    swarm[i][:crossover_point] = partner1[:crossover_point] + 0.5 * diff_mutation\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve niche influence and mutation dynamics to enhance exploration and convergence in swarm-based optimization.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "eb16a4e4-06e7-4463-b4b2-ffd0d50bc9ab", "metadata": {}, "mutation_prompt": null}
{"id": "39bca8f9-07cc-4010-af79-65919c963206", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.4 * adaptive_factor  # Modified\n\n            learning_rate = 0.7 * (1 - evaluations / self.budget)  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.09 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.55  # Modified\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.4:  # Modified\n                    partner1_idx, partner2_idx = np.random.choice(self.population_size, 2, replace=False)\n                    crossover_point = np.random.randint(1, self.dim)\n                    diff_mutation = swarm[partner1_idx] - swarm[partner2_idx]\n                    swarm[i][:crossover_point] = swarm[partner1_idx][:crossover_point] + 0.5 * diff_mutation  # Changed\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:  # Modified\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve partner selection by using the indices directly for crossover.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,) (10,) ')", "parent_id": "eb16a4e4-06e7-4463-b4b2-ffd0d50bc9ab", "metadata": {}, "mutation_prompt": null}
{"id": "63d0e76e-f3eb-428c-9c7d-9b8f5f288548", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.4 * adaptive_factor  # Modified\n\n            learning_rate = 0.7 * (1 - evaluations / self.budget)  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.09 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.55  # Modified\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, min(self.population_size, len(swarm)-4), 5)]  # Modified\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.4:  # Modified\n                    partner1, partner2 = np.random.choice(self.population_size, 2, replace=False)\n                    crossover_point = np.random.randint(1, self.dim)\n                    diff_mutation = swarm[partner1] - swarm[partner2]\n                    swarm[i][:crossover_point] = partner1[:crossover_point] + 0.5 * diff_mutation  # Modified\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:  # Modified\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance dimensional handling to prevent index errors during niche influence calculations.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "eb16a4e4-06e7-4463-b4b2-ffd0d50bc9ab", "metadata": {}, "mutation_prompt": null}
{"id": "c461f7d3-c7b2-415a-bfe4-4410d27012c2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**2\n            inertia_weight = 0.8 - 0.3 * (evaluations / self.budget)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.3 - 0.4 * adaptive_factor\n\n            learning_rate = 0.5 + 0.2 * np.cos(np.pi * evaluations / self.budget)  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.1 * adaptive_factor  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.55\n            niches = [np.mean(swarm[i:i+5], axis=0) for i in range(0, self.population_size, 5)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.1:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                if np.random.rand() < 0.4:\n                    partner1, partner2 = np.random.choice(self.population_size, 2, replace=False)\n                    crossover_point = np.random.randint(1, self.dim)\n                    diff_mutation = swarm[partner1] - swarm[partner2]\n                    swarm[i][:crossover_point] = swarm[partner1][:crossover_point] + 0.5 * diff_mutation  # Modified\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate:  # Modified\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic learning rate and adaptive mutation control to enhance convergence and diversity.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (10,) into shape (1,)').", "error": "ValueError('could not broadcast input array from shape (10,) into shape (1,)')", "parent_id": "eb16a4e4-06e7-4463-b4b2-ffd0d50bc9ab", "metadata": {}, "mutation_prompt": null}
{"id": "1eb865bb-0409-4b7a-a91b-108493e14e94", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**1.5  # Modified\n            inertia_weight = 0.8 - 0.25 * (evaluations / self.budget)  # Modified\n            cognitive_coeff = 1.9 * adaptive_factor  # Modified\n            social_coeff = 1.1 - 0.4 * adaptive_factor\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]  # Modified\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.12 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.6  # Modified\n            niches = [np.mean(swarm[i:i+3], axis=0) for i in range(0, self.population_size, 3)]  # Modified\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:  # Modified\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]  # Modified: removed learning_rate\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce dynamic niche-based particle evolution and adaptive mutation influence to enhance convergence efficiency.", "configspace": "", "generation": 19, "fitness": 0.8899576894873951, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.890 with standard deviation 0.009. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "eb16a4e4-06e7-4463-b4b2-ffd0d50bc9ab", "metadata": {"aucs": [0.8924819448300116, 0.8781231551880997, 0.8992679684440736], "final_y": [0.1192186055191885, 0.11985004245560515, 0.11345254918100223]}, "mutation_prompt": null}
{"id": "ad815ae5-1e56-433a-b762-0d7cda904abb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**1.5\n            inertia_weight = 0.8 - 0.25 * (evaluations / self.budget)\n            cognitive_coeff = 1.9 * adaptive_factor\n            social_coeff = 0.9 + 0.2 * adaptive_factor  # Modified\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.12 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.6\n            niches = [np.mean(swarm[i:i+3], axis=0) for i in range(0, self.population_size, 3)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic adjustment to the social coefficient's range to improve convergence adaptability.", "configspace": "", "generation": 20, "fitness": 0.8877689781102317, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.013. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "1eb865bb-0409-4b7a-a91b-108493e14e94", "metadata": {"aucs": [0.8720486865066006, 0.8879430683325326, 0.9033151794915619], "final_y": [0.12045481591660856, 0.11775428087914397, 0.11158811347261499]}, "mutation_prompt": null}
{"id": "9fe00e42-f416-4765-8988-a5898aade36f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**1.5\n            inertia_weight = 0.8 - 0.25 * (evaluations / self.budget)\n            cognitive_coeff = 1.9 * adaptive_factor\n            social_coeff = 1.1 - 0.4 * adaptive_factor\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.12 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.6\n            niches = [np.mean(swarm[i:i+3], axis=0) for i in range(0, self.population_size, 3)]\n\n            velocity_scaling = np.std(self.velocity) / 10  # New line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i] * velocity_scaling  # Modified\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrate niche diversity and dynamic velocity scaling to enhance swarm adaptability and exploration efficiency.", "configspace": "", "generation": 20, "fitness": 0.8292954079890628, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.059. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "1eb865bb-0409-4b7a-a91b-108493e14e94", "metadata": {"aucs": [0.7462578395691672, 0.8759961991411582, 0.865632185256863], "final_y": [0.155044771024327, 0.12369753448705623, 0.12828691897629452]}, "mutation_prompt": null}
{"id": "220fef26-c44a-4bf1-a85b-266a3f5160c7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**1.5\n            inertia_weight = 0.7 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)  # Modified\n            cognitive_coeff = 1.9 * adaptive_factor\n            social_coeff = 1.1 - 0.4 * adaptive_factor\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.15 * (1 - adaptive_factor)  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.6 \n            niches = [np.mean(swarm[i:i+3], axis=0) for i in range(0, self.population_size, 3)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n                \n            # Randomly migrate elite to new positions\n            if np.random.rand() < 0.1:  # Modified\n                for idx in elite_indices:\n                    swarm[idx] = np.random.uniform(lb, ub, self.dim)  # Modified\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Augment swarm intelligence with variable inertia and random elite migration to boost exploration-exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.8828021672927874, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.030. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1eb865bb-0409-4b7a-a91b-108493e14e94", "metadata": {"aucs": [0.8417502515431068, 0.8932387562464997, 0.9134174940887556], "final_y": [0.12587868533568425, 0.11695011863375748, 0.11332669095113035]}, "mutation_prompt": null}
{"id": "e86d2729-42af-47f2-b248-b64c35e70941", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        elite_memory = global_best  # New storage for elite solution\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**1.5\n            inertia_weight = 0.8 - 0.25 * (evaluations / self.budget)\n            cognitive_coeff = 1.9 * adaptive_factor\n            social_coeff = 1.1 - 0.4 * adaptive_factor\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 5)]\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.12 * (1 - adaptive_factor)\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.6\n            niches = [np.mean(swarm[i:i+3], axis=0) for i in range(0, self.population_size, 3)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n                \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n            # Update elite-memory if a better solution is found\n            if global_best_value < func(elite_memory):\n                elite_memory = global_best\n        \n        return elite_memory, func(elite_memory)", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce an elite-memory mechanism to enhance the robustness of convergence through elite retention.", "configspace": "", "generation": 20, "fitness": 0.875507600155205, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.014. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1eb865bb-0409-4b7a-a91b-108493e14e94", "metadata": {"aucs": [0.8564673395588488, 0.8819393867532344, 0.8881160741535317], "final_y": [0.11443870347230611, 0.11647745284938249, 0.11971602321547048]}, "mutation_prompt": null}
{"id": "923d6e21-f54d-49a4-98c8-37e0661cf632", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - (evaluations / self.budget)**1.5\n            inertia_weight = 0.8 - 0.25 * (evaluations / self.budget)\n            cognitive_coeff = 1.9 * adaptive_factor\n            social_coeff = 1.1 - 0.4 * adaptive_factor\n\n            elite_indices = np.argsort(personal_best_value)[:max(1, self.population_size // 4)]  # Modified\n            elite_swarm = swarm[elite_indices]\n\n            dynamic_mutation_rate = 0.12 * (1 - adaptive_factor)\n            learning_rate = 0.5 + 0.5 * adaptive_factor  # Modified\n\n            niche_radius = np.sqrt(self.dim) * adaptive_factor\n            niche_influence_factor = 0.6\n            niches = [np.mean(swarm[i:i+3], axis=0) for i in range(0, self.population_size, 3)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                niche_influence = niches[np.argmin([np.linalg.norm(swarm[i] - niche) for niche in niches])]\n                niche_distance = np.linalg.norm(swarm[i] - niche_influence)\n                if niche_distance < niche_radius * 1.05:\n                    swarm[i] += niche_influence_factor * (niche_influence - swarm[i])\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += learning_rate * self.velocity[i]  # Modified\n\n                if np.random.rand() < dynamic_mutation_rate * 1.5:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation_vector\n\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_best_value = np.min([func(x) for x in elite_swarm])\n            if elite_best_value < global_best_value:\n                global_best_value = elite_best_value\n                global_best = elite_swarm[np.argmin([func(x) for x in elite_swarm])]\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Implement a dynamic learning rate and enhance elite selection for improved exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.8760445110227391, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.004. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1eb865bb-0409-4b7a-a91b-108493e14e94", "metadata": {"aucs": [0.872684240111048, 0.8732116507334403, 0.8822376422237287], "final_y": [0.11550527137437283, 0.1166200582924738, 0.11934690616587429]}, "mutation_prompt": null}
