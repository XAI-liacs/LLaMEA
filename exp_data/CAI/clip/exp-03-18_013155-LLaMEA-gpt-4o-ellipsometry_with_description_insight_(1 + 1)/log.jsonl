{"id": "b5f743d7-78d3-46f2-9b15-a61208b0a94c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses\n        num_initial_samples = min(10, self.budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Adaptive Bounded Local Search (ABLS) integrates uniform sampling, fast local optimization, and dynamic bounds adjustment for efficient exploration and exploitation in smooth parameter spaces.", "configspace": "", "generation": 0, "fitness": 0.8176881908763592, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.042. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8582692973357795, 0.8354760466442442, 0.7593192286490538], "final_y": [5.1396987557680065e-09, 4.837396502107826e-08, 1.1970378201664843e-07]}, "mutation_prompt": null}
{"id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search introduces a diversified sampling strategy by adjusting initial sample size based on budget and incorporates a stopping criterion for convergence.", "configspace": "", "generation": 1, "fitness": 0.8269935021758754, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b5f743d7-78d3-46f2-9b15-a61208b0a94c", "metadata": {"aucs": [0.8440960016827654, 0.8229201242113984, 0.8139643806334625], "final_y": [2.9512782856017006e-08, 2.891894446764021e-08, 6.671727112940063e-08]}, "mutation_prompt": null}
{"id": "960e4a5e-3ebd-45ac-a323-026f80d5f454", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Improved Adaptive Bounded Local Search by enhancing diversification with adaptive sampling based on parameter sensitivity.", "configspace": "", "generation": 2, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "cc43578f-c1d6-4daa-93da-c67a6a2a4b8c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.05 * (ub - lb))  # Slightly reduced factor\n            new_ub = np.minimum(ub, best_solution + 0.05 * (ub - lb))  # Slightly reduced factor\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with a refined boundary adjustment factor to improve convergence precision.", "configspace": "", "generation": 3, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "3305c272-1945-4771-b899-d1a6158a1631", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            perturbation_scale = 0.05  # Dynamically adjust perturbation scale\n            new_lb = np.maximum(lb, best_solution - perturbation_scale * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + perturbation_scale * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Local Exploration refines convergence by dynamically adjusting the perturbation scale during iterative bounds refinement.", "configspace": "", "generation": 4, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "2e528772-0026-47c0-9e29-20c9f15dc856", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, (self.budget - self.evaluations) // 5)  # Changed line\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with dynamic sample size scaling based on remaining budget and current evaluations.", "configspace": "", "generation": 5, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "63601501-86a5-41cd-a46c-04429add56ef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Dynamic sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, int(self.budget * 0.026))\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Introduced a dynamic adjustment of the initial sample size to optimize diversified sampling based on available budget.", "configspace": "", "generation": 6, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "4470d48d-7c8c-45be-93e9-654f10b12e08", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(10, self.budget // 5)  # Slight increase here\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Slightly increase the initial sample size to improve search efficiency and diversify initial guesses.", "configspace": "", "generation": 7, "fitness": 0.8152861029972334, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.7836262802950382, 0.8434082077909704, 0.8188238209056916], "final_y": [4.826980574904581e-08, 1.2983373254784277e-08, 5.8875448764355894e-08]}, "mutation_prompt": null}
