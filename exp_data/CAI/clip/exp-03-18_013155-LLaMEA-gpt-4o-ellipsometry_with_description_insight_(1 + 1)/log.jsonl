{"id": "b5f743d7-78d3-46f2-9b15-a61208b0a94c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses\n        num_initial_samples = min(10, self.budget // 3)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Adaptive Bounded Local Search (ABLS) integrates uniform sampling, fast local optimization, and dynamic bounds adjustment for efficient exploration and exploitation in smooth parameter spaces.", "configspace": "", "generation": 0, "fitness": 0.8176881908763592, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.042. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8582692973357795, 0.8354760466442442, 0.7593192286490538], "final_y": [5.1396987557680065e-09, 4.837396502107826e-08, 1.1970378201664843e-07]}, "mutation_prompt": null}
{"id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search introduces a diversified sampling strategy by adjusting initial sample size based on budget and incorporates a stopping criterion for convergence.", "configspace": "", "generation": 1, "fitness": 0.8269935021758754, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b5f743d7-78d3-46f2-9b15-a61208b0a94c", "metadata": {"aucs": [0.8440960016827654, 0.8229201242113984, 0.8139643806334625], "final_y": [2.9512782856017006e-08, 2.891894446764021e-08, 6.671727112940063e-08]}, "mutation_prompt": null}
{"id": "960e4a5e-3ebd-45ac-a323-026f80d5f454", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Improved Adaptive Bounded Local Search by enhancing diversification with adaptive sampling based on parameter sensitivity.", "configspace": "", "generation": 2, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "cc43578f-c1d6-4daa-93da-c67a6a2a4b8c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.05 * (ub - lb))  # Slightly reduced factor\n            new_ub = np.minimum(ub, best_solution + 0.05 * (ub - lb))  # Slightly reduced factor\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with a refined boundary adjustment factor to improve convergence precision.", "configspace": "", "generation": 3, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "3305c272-1945-4771-b899-d1a6158a1631", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            perturbation_scale = 0.05  # Dynamically adjust perturbation scale\n            new_lb = np.maximum(lb, best_solution - perturbation_scale * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + perturbation_scale * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Local Exploration refines convergence by dynamically adjusting the perturbation scale during iterative bounds refinement.", "configspace": "", "generation": 4, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "2e528772-0026-47c0-9e29-20c9f15dc856", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, (self.budget - self.evaluations) // 5)  # Changed line\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with dynamic sample size scaling based on remaining budget and current evaluations.", "configspace": "", "generation": 5, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "63601501-86a5-41cd-a46c-04429add56ef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Dynamic sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, int(self.budget * 0.026))\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Introduced a dynamic adjustment of the initial sample size to optimize diversified sampling based on available budget.", "configspace": "", "generation": 6, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "4470d48d-7c8c-45be-93e9-654f10b12e08", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(10, self.budget // 5)  # Slight increase here\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Slightly increase the initial sample size to improve search efficiency and diversify initial guesses.", "configspace": "", "generation": 7, "fitness": 0.8152861029972334, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.7836262802950382, 0.8434082077909704, 0.8188238209056916], "final_y": [4.826980574904581e-08, 1.2983373254784277e-08, 5.8875448764355894e-08]}, "mutation_prompt": null}
{"id": "fc00df60-c439-4a90-954d-c08eb359d215", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B', jac='2-point')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Improved convergence speed by incorporating gradient information into the initial sampling strategy of AdaptiveBoundedLocalSearch.", "configspace": "", "generation": 8, "fitness": 0.7941703592741756, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.7683576632869772, 0.8212247506825308, 0.7929286638530186], "final_y": [4.748027705437603e-08, 5.3506778454104116e-08, 1.0784428753292603e-07]}, "mutation_prompt": null}
{"id": "0d98b6fb-4562-4e7c-b9b8-a54e4db9dbc1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n            # Introduce a convergence acceleration step\n            if self.evaluations > self.budget * 0.8:\n                new_lb = np.maximum(lb, best_solution - 0.2 * (ub - lb))\n                new_ub = np.minimum(ub, best_solution + 0.2 * (ub - lb))\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search incorporates a convergence acceleration step by increasing the exploration intensity when approaching optimal solutions.", "configspace": "", "generation": 9, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "874360df-2f95-485f-ad0b-dfd3651003ee", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-7:  # Increased precision here\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "AdaptiveBoundedLocalSearch with improved convergence threshold focusing on precision enhancement.", "configspace": "", "generation": 10, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "49c9c7b9-5213-4371-b3ef-cbefab4509ad", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution with adaptive step size\n            step_size = 0.05 * (ub - lb)  # Adaptive step size control\n            new_lb = np.maximum(lb, best_solution - step_size)\n            new_ub = np.minimum(ub, best_solution + step_size)\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Bounded Local Search with adaptive step size control improves exploration within bounds.", "configspace": "", "generation": 11, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "d202174e-4b21-4252-b7f3-dd86779797f7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Dynamically adjust bounds based on feedback\n            new_lb = np.maximum(lb, best_solution - 0.15 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.15 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with dynamic bounds adjustment based on feedback from previous evaluations.", "configspace": "", "generation": 12, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "9a50eec8-2aaf-489e-9e25-123875d93946", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.05 * (ub - lb))  # Adjusted scaling factor\n            new_ub = np.minimum(ub, best_solution + 0.05 * (ub - lb))  # Adjusted scaling factor\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Improved Adaptive Bounded Local Search that adjusts the bounds scaling factor for better local refinement based on the current best solution's performance.", "configspace": "", "generation": 13, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "cda25b2e-3617-41cf-86e9-be8510058a4c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Added line for random perturbations\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb) + perturbation)\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb) + perturbation)\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Introduced random perturbations in bounds adjustment to enhance exploration and prevent early convergence.", "configspace": "", "generation": 14, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "e972d98c-54d4-43c4-a1db-9418513b70c5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        # Improved initial sampling strategy using latin hypercube sampling\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with improved initial sampling strategy based on distributed random sampling.", "configspace": "", "generation": 15, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "3eb7f619-ac15-4f64-80c8-d04c0c68e5d0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 4)  # Updated sample size formula\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with an improved initial sampling strategy by updating sample size formula for better exploration.", "configspace": "", "generation": 16, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "aa980fe9-e4eb-452d-89d0-4b43e2b2e430", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                # Random restart mechanism\n                best_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search is improved by including a random restart mechanism upon convergence to explore the search space more diversely.", "configspace": "", "generation": 17, "fitness": 0.8182938659577643, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.810352406339649, 0.8350855828200643, 0.8094436087135797], "final_y": [3.558274218756223e-08, 3.0928325976864806e-08, 6.276575842557371e-08]}, "mutation_prompt": null}
{"id": "ef0302d0-ca3d-446e-b2b4-a701fa055ef0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n            # Add random restart mechanism\n            if np.random.rand() < 0.1:\n                random_point = np.random.uniform(lb, ub, self.dim)\n                res = minimize(func, random_point, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                self.evaluations += res.nfev\n                if res.fun < best_value:\n                    best_value = res.fun\n                    best_solution = res.x\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search introduces a diversified sampling strategy by adjusting initial sample size based on budget and incorporates a stopping criterion for convergence, and integrates a random restart mechanism to escape local minima.", "configspace": "", "generation": 18, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "d7a654d6-8806-4c6b-9d40-1b5a50deb3ec", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n            \n            # Random restart if stagnation detected\n            if self.evaluations < self.budget and abs(res.fun - best_value) < 1e-6:\n                sample = np.random.uniform(lb, ub, self.dim)\n                continue\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Incorporate a random restart mechanism when stagnation is detected in the optimization process to escape local optima.", "configspace": "", "generation": 19, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "5721ed8c-8dbd-42a8-9dce-8bdc1f0104bd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Adjusted dynamic stopping criterion for convergence\n            if abs(res.fun - best_value) < max(1e-6, 0.001 * abs(best_value)):\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Optimized Adaptive Bounded Local Search enhances convergence by adjusting convergence criteria dynamically based on recent progress.", "configspace": "", "generation": 20, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "083cf2f5-ee2b-4806-9eb8-1d22a02d834d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on convergence speed\n        num_initial_samples = max(5, self.budget // (5 if self.evaluations == 0 else int(self.evaluations // 100 + 1)))\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with dynamic sampling scales the initial sample size based on convergence speed for improved solution refinement.", "configspace": "", "generation": 21, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "e8f767f9-7aea-4913-a3e6-e48b12a0145a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        perturbation_factor = 0.1  # Start with 10% perturbation\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - perturbation_factor * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + perturbation_factor * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n                perturbation_factor = max(0.05, perturbation_factor * 0.9)  # Decrease perturbation\n            else:\n                perturbation_factor = min(0.2, perturbation_factor * 1.1)  # Increase perturbation\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Improved Adaptive Bounded Local Search enhances exploration by adjusting the perturbation factor dynamically based on progress, refining search space adaptively for convergence.", "configspace": "", "generation": 22, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "7a86f4d0-c0b0-4837-a2fe-5271f62555ca", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, adjusted based on budget\n        num_initial_samples = max(5, self.budget // 5)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        # Change: Add sampling around midpoint of bounds\n        midpoint = (lb + ub) / 2\n        samples = np.vstack((samples, np.random.normal(midpoint, 0.1 * (ub - lb), (num_initial_samples, self.dim))))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search now includes initial sampling around the midpoint of the bounds for improved exploration. ", "configspace": "", "generation": 23, "fitness": 0.8226902771791055, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8550945672238822, 0.8170013907143231, 0.7959748735991112], "final_y": [2.7399721472939854e-08, 5.6564342256081776e-08, 4.647456715158197e-08]}, "mutation_prompt": null}
{"id": "ff2a4cb2-a9f8-4b69-81ff-9d56746d4bf4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, dynamically adjusted based on remaining budget\n        num_initial_samples = max(5, (self.budget - self.evaluations) // 6)  # Changed from 5 to 6\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search now incorporates dynamic sample size adjustment based on remaining budget to improve convergence speed.", "configspace": "", "generation": 24, "fitness": 0.84666915394237, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9c099148-0a32-4f14-a57d-5102aa7582a7", "metadata": {"aucs": [0.8769806456433578, 0.838516650209424, 0.8245101659743284], "final_y": [2.308019799297587e-08, 3.9908994719751035e-08, 8.80943475737391e-08]}, "mutation_prompt": null}
{"id": "94f8ca6d-c961-43c2-b83d-2697aed413fd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, non-linearly adjusted based on remaining budget\n        num_initial_samples = max(5, int((self.budget - self.evaluations) // (1 + 0.1 * self.evaluations)))  # Updated line\n        \n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search now employs a non-linear reduction in sample size with budget depletion for more efficient exploration.", "configspace": "", "generation": 25, "fitness": 0.8293836108584474, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff2a4cb2-a9f8-4b69-81ff-9d56746d4bf4", "metadata": {"aucs": [0.8683381936342733, 0.7939695850298485, 0.8258430539112204], "final_y": [2.4205836750810023e-09, 8.043789637803222e-08, 1.1194987721403838e-07]}, "mutation_prompt": null}
{"id": "11d1e01b-d274-4e2a-8791-029525ecd831", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, dynamically adjusted based on remaining budget\n        num_initial_samples = max(5, (self.budget - self.evaluations) // 6)  # Changed from 5 to 6\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            learning_factor = 0.05 + 0.15 * (1 - self.evaluations / self.budget)  # Dynamic learning rate\n            new_lb = np.maximum(lb, best_solution - learning_factor * (ub - lb))  # Adjusted\n            new_ub = np.minimum(ub, best_solution + learning_factor * (ub - lb))  # Adjusted\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Stopping criterion if convergence is achieved\n            if abs(res.fun - best_value) < 1e-6:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Improved convergence by incorporating dynamic learning rates based on the budget and function evaluations. ", "configspace": "", "generation": 26, "fitness": 0.8136196824214809, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff2a4cb2-a9f8-4b69-81ff-9d56746d4bf4", "metadata": {"aucs": [0.8000275106201045, 0.846305588449214, 0.7945259481951245], "final_y": [8.456824328747515e-08, 7.099835820711106e-09, 9.614237553102968e-08]}, "mutation_prompt": null}
{"id": "b7149ec5-bc76-4e26-8ab6-eefb7d449944", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveBoundedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Extract bounds\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Uniform sampling for initial guesses, dynamically adjusted based on remaining budget\n        num_initial_samples = max(5, (self.budget - self.evaluations) // 6)\n        samples = np.random.uniform(lb, ub, (num_initial_samples, self.dim))\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        # Begin search\n        for sample in samples:\n            # Local optimization using L-BFGS-B\n            res = minimize(func, sample, bounds=list(zip(lb, ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            if self.evaluations >= self.budget:\n                break\n\n        # Iteratively adjust bounds and refine\n        while self.evaluations < self.budget:\n            # Narrow the bounds based on current best solution\n            new_lb = np.maximum(lb, best_solution - 0.1 * (ub - lb))\n            new_ub = np.minimum(ub, best_solution + 0.1 * (ub - lb))\n            \n            # Local optimization within adjusted bounds\n            res = minimize(func, best_solution, bounds=list(zip(new_lb, new_ub)), method='L-BFGS-B')\n            self.evaluations += res.nfev\n            \n            if res.fun < best_value:\n                best_value = res.fun\n                best_solution = res.x\n            \n            # Early stopping criterion if convergence is significantly achieved\n            if abs(res.fun - best_value) < 1e-6 or self.evaluations + 10 > self.budget:\n                break\n\n        return best_solution", "name": "AdaptiveBoundedLocalSearch", "description": "Enhanced Adaptive Bounded Local Search with budget-constrained early stopping for improved efficiency.", "configspace": "", "generation": 27, "fitness": 0.8293836108584474, "feedback": "The algorithm AdaptiveBoundedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff2a4cb2-a9f8-4b69-81ff-9d56746d4bf4", "metadata": {"aucs": [0.8683381936342733, 0.7939695850298485, 0.8258430539112204], "final_y": [2.4205836750810023e-09, 8.043789637803222e-08, 1.1194987721403838e-07]}, "mutation_prompt": null}
