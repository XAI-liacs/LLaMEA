{"id": "817ec622-6752-4957-9a42-495225e8c04f", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters for Differential Evolution (DE)\n        pop_size = 10 * self.dim\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        \n        # Initialize parameters for Particle Swarm Optimization (PSO)\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        w = 0.5   # Inertia weight\n        \n        # Initialize population\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        \n        # Initialize personal best and global best\n        p_best = np.copy(population)\n        p_best_fitness = np.copy(fitness)\n        g_best = population[np.argmin(fitness)]\n        g_best_fitness = np.min(fitness)\n\n        evaluations = pop_size\n\n        while evaluations < self.budget:\n            for i in range(pop_size):\n                # Differential Evolution Mutation and Crossover\n                indices = list(range(pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + F * (population[b] - population[c])\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                # Select between trial and original\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < p_best_fitness[i]:\n                        p_best[i] = trial\n                        p_best_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < g_best_fitness:\n                    g_best = trial\n                    g_best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Update\n            r1, r2 = np.random.rand(2)\n            velocity = w * velocity + c1 * r1 * (p_best - population) + c2 * r2 * (g_best - population)\n            population = population + velocity\n            population = np.clip(population, func.bounds.lb, func.bounds.ub)\n\n        return g_best", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining differential evolution and a swarm-based strategy for diverse exploration and exploitation in black box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.807939505663703, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.017. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7843981372874468, 0.8188228860279289, 0.8205974936757332], "final_y": [0.14854888364773733, 0.1383770052937483, 0.13773485275207953]}, "mutation_prompt": null}
