{"id": "bf03b512-b944-441d-9ff5-1bfdb5dd9ba7", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Adaptive Swarm Gradient Descent (ASGD): Combines swarm intelligence and gradient estimation to explore and exploit search space efficiently.", "configspace": "", "generation": 0, "fitness": 0.8264407036439118, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.020. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8041324604654931, 0.8227266579918514, 0.8524629924743906], "final_y": [0.1412466306774247, 0.13112094863304602, 0.12789490696654837]}, "mutation_prompt": null}
{"id": "59f1b3a2-b32a-4b0c-8006-38b59a0f0e9d", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor  # Change made here: diversified initialization\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (E-ASGD): Introduces a diverse initialization strategy for swarm particles to enhance exploration and solution quality.", "configspace": "", "generation": 1, "fitness": 0.8264407036439118, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.020. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "bf03b512-b944-441d-9ff5-1bfdb5dd9ba7", "metadata": {"aucs": [0.8041324604654931, 0.8227266579918514, 0.8524629924743906], "final_y": [0.1412466306774247, 0.13112094863304602, 0.12789490696654837]}, "mutation_prompt": null}
{"id": "23879751-ed9f-4a83-82b3-1a2ff82e8fec", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.1  # Added mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 10).astype(int)  # Gradual layer increase\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Introduces adaptive mutation and layer-wise learning to improve exploration and modularity detection.", "configspace": "", "generation": 2, "fitness": 0.8308808347514077, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.036. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "bf03b512-b944-441d-9ff5-1bfdb5dd9ba7", "metadata": {"aucs": [0.7795634218856938, 0.8562059346837771, 0.8568731476847521], "final_y": [0.15592911380391872, 0.13046751835058212, 0.12534853835401816]}, "mutation_prompt": null}
{"id": "728169c4-e7e4-40db-916d-de082a63863b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.2, self.dim)  # Increase mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Dynamic Layer Increment: Integrates dynamic layer handling and enhanced mutation strategy for improved exploration and convergence.", "configspace": "", "generation": 3, "fitness": 0.8593484653468909, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.012. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "23879751-ed9f-4a83-82b3-1a2ff82e8fec", "metadata": {"aucs": [0.8598968219103943, 0.8443128552166081, 0.8738357189136701], "final_y": [0.1326114914193769, 0.13419399445487656, 0.12434723631504063]}, "mutation_prompt": null}
{"id": "2b70456e-3d10-49c0-9ef5-2a6caa85d2b7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.2 * adaptive_factor, self.dim)  # Adjusted mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Intelligent Mutation Rate: Incorporates dynamic adjustment of mutation rate based on convergence progress for improved balance between exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8592083771964024, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.012. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "728169c4-e7e4-40db-916d-de082a63863b", "metadata": {"aucs": [0.8606816070898163, 0.8440340213009759, 0.8729095031984151], "final_y": [0.13139300427963163, 0.13430729725502666, 0.12532949571215402]}, "mutation_prompt": null}
{"id": "0fc63f3b-f7da-41fd-8c7b-e80eac855282", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.1  # Adjusted mutation rate for balance\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.1, self.dim)  # Reduced mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Optimized Mutation Strategy: Fine-tunes mutation strategy for better convergence performance.", "configspace": "", "generation": 5, "fitness": 0.8308808347514077, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.036. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "728169c4-e7e4-40db-916d-de082a63863b", "metadata": {"aucs": [0.7795634218856938, 0.8562059346837771, 0.8568731476847521], "final_y": [0.15592911380391872, 0.13046751835058212, 0.12534853835401816]}, "mutation_prompt": null}
{"id": "761d6b40-c201-415e-8e77-73c748839e26", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity and adaptive control\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.15 * adaptive_factor, self.dim)  # Adjusted mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best with gradient feedback\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Swarm Gradient Descent with Enhanced Local Search: Incorporates an improved local optimization phase via gradient feedback and adaptive mutation impact control for effective convergence.", "configspace": "", "generation": 6, "fitness": 0.8592857394149158, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.012. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "728169c4-e7e4-40db-916d-de082a63863b", "metadata": {"aucs": [0.8607384292642336, 0.8438788436556636, 0.8732399453248504], "final_y": [0.13137807148227787, 0.13440391666738627, 0.12534388208246772]}, "mutation_prompt": null}
{"id": "77034f8d-3b57-4169-b864-e523afda255f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce layer-wise mutation for enhanced diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.2, self.layer_increase_step)  # Apply mutation per layer\n                    swarm[i][:self.layer_increase_step] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Layered Mutation Strategy: Refines diversity control by introducing layer-wise mutation for improved optimization in high-dimensional settings.", "configspace": "", "generation": 7, "fitness": 0.8289885821189668, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.033. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "728169c4-e7e4-40db-916d-de082a63863b", "metadata": {"aucs": [0.7968176054870578, 0.8160874920077886, 0.8740606488620539], "final_y": [0.1480448227489014, 0.13904365148707576, 0.11881453297990352]}, "mutation_prompt": null}
{"id": "ad66dcab-4851-4347-a1af-1be7396191fa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.2, self.dim)  # Increase mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved velocity update by incorporating an adaptive scaling factor for enhanced exploration and exploitation balance. ", "configspace": "", "generation": 8, "fitness": 0.8636648357093925, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.015. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "728169c4-e7e4-40db-916d-de082a63863b", "metadata": {"aucs": [0.8693554956477652, 0.8781852243472658, 0.8434537871331466], "final_y": [0.12778747323564343, 0.11811778125435834, 0.13077790293221436]}, "mutation_prompt": null}
{"id": "7b3dda91-aa90-4e51-922e-b989dd06dadd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.linalg.norm(global_best - swarm[i]) / (ub - lb)  # New line\n                    mutation = np.random.normal(0, 0.2 * mutation_scale, self.dim)  # New line\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "EnhancedAdaptiveSwarmGradientDescent with dynamic mutation scaling based on proximity to global best to improve diversity and convergence.", "configspace": "", "generation": 9, "fitness": 0.862928756433392, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.015. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8697086939734353, 0.8765248176361311, 0.8425527576906091], "final_y": [0.12750707075990486, 0.11945131454712532, 0.13292891465977608]}, "mutation_prompt": null}
{"id": "4289bce5-552f-46bb-a933-eac950f89326", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.15 * np.sin(evaluations / self.budget * np.pi)  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.25, self.dim)  # Modified line\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration and exploitation balance through improved adaptive scaling and mutation strategies.", "configspace": "", "generation": 10, "fitness": 0.8536764190058884, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.015. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8603017094371468, 0.8681493589338328, 0.8325781886466858], "final_y": [0.1303168830409912, 0.1175339708318126, 0.13654047328609054]}, "mutation_prompt": null}
{"id": "bc2b05a1-9620-4efb-a94a-71734ad512dc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutation_intensity = 0.1 + 0.1 * (evaluations / self.budget)  # Adjust mutation intensity\n                    mutation = np.random.normal(0, mutation_intensity, self.dim)  # Use dynamic mutation intensity\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced mutation strategy with dynamic adjustment for improved diversity and convergence.", "configspace": "", "generation": 11, "fitness": 0.8633276822618644, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.014. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8688753647349878, 0.8774662871554811, 0.8436413948951245], "final_y": [0.12140714723296753, 0.11883876351853606, 0.13120893230512565]}, "mutation_prompt": null}
{"id": "c0f0f56e-5aa4-4124-a915-35fddf305e1e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_strength = 0.2 * adaptive_factor  # Dynamically adjust mutation impact\n                    mutation = np.random.normal(0, mutation_strength, self.dim)  # Change line\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploitation by dynamically adjusting mutation impact based on progress towards the budget.", "configspace": "", "generation": 12, "fitness": 0.8635047098788299, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.014. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8695475445491074, 0.8774321766037446, 0.8435344084836375], "final_y": [0.12763939953473413, 0.11879486614476809, 0.13062471606302029]}, "mutation_prompt": null}
{"id": "fd2086d3-6f6a-46a8-a0b8-2e749ab8a515", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Dynamic mutation based on solution quality\n                if np.random.rand() < self.mutation_rate * (global_best_value / f_value):  # Changed line\n                    mutation = np.random.normal(0, 0.2 * (1 - adaptive_factor), self.dim)  # Changed line\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation strategy that adapts based on solution quality to enhance exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'f_value' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'f_value' where it is not associated with a value\")", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {}, "mutation_prompt": null}
{"id": "bac8495c-15f2-4d43-a2e6-f102eb0f5f5b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor + 0.5 * np.random.rand()  # Refined line\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate * adaptive_factor:  # Refined line\n                    mutation = np.random.normal(0, 0.2, self.dim)  # Increase mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration capabilities with adaptive cognitive coefficient and mutation strategy refinement.", "configspace": "", "generation": 14, "fitness": 0.8278630637455309, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.016. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8069102432677207, 0.8324692827380262, 0.8442096652308458], "final_y": [0.13266023453490206, 0.12014964842440046, 0.12690111632332457]}, "mutation_prompt": null}
{"id": "6d0938e5-f892-485a-b754-f16b97de0747", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                dynamic_mutation_rate = self.mutation_rate * (1 - evaluations / self.budget)  # Change\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation = np.random.normal(0, 0.2, self.dim)  # Increase mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation rate that decreases over time to maintain exploration initially and focus on exploitation towards the end.", "configspace": "", "generation": 15, "fitness": 0.8403949089050942, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.017. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.859994343422848, 0.8179263523451359, 0.8432640309472983], "final_y": [0.13201118411142643, 0.13605572874159744, 0.1339842034926202]}, "mutation_prompt": null}
{"id": "5ac79b82-7802-4834-89aa-55d8f052958e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * (0.5 + 0.5 * adaptive_factor)  # Changed line\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.8 + 0.2 * np.sin(evaluations / self.budget * np.pi)  # Changed line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.2, self.dim)  # Increase mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introducing a dynamic cognitive coefficient and enhancing adaptive scaling to better balance exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.8600499335346434, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.011. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8681243454291394, 0.8678548337436446, 0.8441706214311462], "final_y": [0.12897174481674922, 0.11666366692535579, 0.13137783008927018]}, "mutation_prompt": null}
{"id": "75d57dda-d47e-4cb3-b5a5-666b3f760dda", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.3 * adaptive_factor, self.dim)  # Dynamic mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration with dynamic inertia and mutation adaptation for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.8680403476108332, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.014. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ad66dcab-4851-4347-a1af-1be7396191fa", "metadata": {"aucs": [0.8770037475797382, 0.8794761395028508, 0.8476411557499108], "final_y": [0.12480486088967213, 0.11747507541062929, 0.12296503594547781]}, "mutation_prompt": null}
{"id": "bfd3e96b-8539-4a3c-831e-2fe9e445f921", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + adaptive_factor  # Modified social coefficient for enhanced exploration\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.3 * adaptive_factor, self.dim)  # Dynamic mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration by introducing a dynamic learning factor for improved convergence.", "configspace": "", "generation": 18, "fitness": 0.8384014238996692, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.024. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "75d57dda-d47e-4cb3-b5a5-666b3f760dda", "metadata": {"aucs": [0.8049414924142351, 0.8509864716220893, 0.8592763076626833], "final_y": [0.1465156148145892, 0.1212635008015811, 0.12951020924304457]}, "mutation_prompt": null}
{"id": "4d92bec3-e75c-4dd9-adee-ae6455a9b4c6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Modified social coefficient for enhanced exploration\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.normal(0, 0.2 * adaptive_factor, self.dim)  # Reduced mutation impact\n                    swarm[i] += mutation\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration with adaptive social factor and noise reduction for improved convergence.", "configspace": "", "generation": 19, "fitness": 0.8137153430503182, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.028. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "75d57dda-d47e-4cb3-b5a5-666b3f760dda", "metadata": {"aucs": [0.8151041544668948, 0.8478691539775366, 0.7781727207065235], "final_y": [0.13654494667832195, 0.12729860367808155, 0.15859182914359127]}, "mutation_prompt": null}
{"id": "e649fa81-fae6-4f48-879b-145b02585caa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved mutation strategy by incorporating adaptive scaling for enhanced exploration.", "configspace": "", "generation": 20, "fitness": 0.8684036894196479, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.014. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "75d57dda-d47e-4cb3-b5a5-666b3f760dda", "metadata": {"aucs": [0.8768393167091368, 0.8796434647470023, 0.8487282868028045], "final_y": [0.12493575642473742, 0.11791192015538288, 0.12218303504012407]}, "mutation_prompt": null}
{"id": "e7429c6d-d593-4850-a697-e611d456c96e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)  # New line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration-exploitation balance with adaptive social coefficient.", "configspace": "", "generation": 21, "fitness": 0.816071911016787, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.026. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "e649fa81-fae6-4f48-879b-145b02585caa", "metadata": {"aucs": [0.8163613521200381, 0.8474020806767811, 0.7844523002535417], "final_y": [0.13589514819888437, 0.12864044031156452, 0.14786154515158412]}, "mutation_prompt": null}
{"id": "94e141cb-8f54-491c-8c74-f80b9fa03fc9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.2  # Increase mutation rate for greater diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor  # Altered inertia weight for enhanced exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined swarm dynamics by adjusting inertia weight and mutation rate for improved diversity and convergence.", "configspace": "", "generation": 22, "fitness": 0.8388201024312587, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.004. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "e649fa81-fae6-4f48-879b-145b02585caa", "metadata": {"aucs": [0.8385219658939946, 0.8438002321094897, 0.8341381092902919], "final_y": [0.13231919112204082, 0.12657109491491847, 0.12461435584036373]}, "mutation_prompt": null}
{"id": "1863fba0-61f0-42ce-bf10-216318d7b310", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.2  # Modified mutation rate\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor  # Adjusted inertia weight\n            cognitive_coeff = 1.7 * adaptive_factor  # Adjusted cognitive coefficient\n            social_coeff = 1.3  # Adjusted social coefficient\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.2 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced adaptive mutation and dynamic velocity updating strategy to enhance exploration and convergence.", "configspace": "", "generation": 23, "fitness": 0.8612133972691037, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.032. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "e649fa81-fae6-4f48-879b-145b02585caa", "metadata": {"aucs": [0.815585432000552, 0.8833322753537103, 0.8847224844530488], "final_y": [0.13171656796686293, 0.12041077689608837, 0.11603813544953578]}, "mutation_prompt": null}
{"id": "2d0ccfbf-f0da-43ba-b307-34d0f876df97", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                adaptive_scaling = 0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi / 2)  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.2 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced adaptive mutation and dynamic velocity scaling for enhanced convergence in noisy environments.", "configspace": "", "generation": 24, "fitness": 0.8136713822547751, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.019. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "e649fa81-fae6-4f48-879b-145b02585caa", "metadata": {"aucs": [0.8116255481776616, 0.837701951765755, 0.7916866468209086], "final_y": [0.13543565962162452, 0.1277464420509149, 0.14625021562079477]}, "mutation_prompt": null}
{"id": "b823322f-a30e-43cd-b066-8193c92d9431", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced layer-wise adaptive scaling to refine exploration-exploitation balance in particle updates.", "configspace": "", "generation": 25, "fitness": 0.8800290385252761, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.010. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "e649fa81-fae6-4f48-879b-145b02585caa", "metadata": {"aucs": [0.8768393167091368, 0.8930898777405879, 0.8701579211261037], "final_y": [0.12493575642473742, 0.11434504025811054, 0.12461208058232887]}, "mutation_prompt": null}
{"id": "9a2e7335-af16-475e-a8f7-3c28effef974", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Dynamic mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce dynamic mutation for diversity\n                dynamic_mutation_rate = 0.15 + 0.1 * (1 - adaptive_factor)  # Dynamic mutation rate\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation rate based on the evaluation budget to enhance diversity and convergence speed.", "configspace": "", "generation": 26, "fitness": 0.8535386416796401, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.020. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.880720257218645, 0.8333246395597246, 0.8465710282605505], "final_y": [0.1153692155086562, 0.13385368914855555, 0.12181450401891647]}, "mutation_prompt": null}
{"id": "718a1944-fe17-44fa-842c-14169167e41e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling * layer_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced adaptive mutation scaling and layer-wise perturbation to enhance exploration in swarm updates.", "configspace": "", "generation": 27, "fitness": 0.8798975019946296, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.010. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8768393167091368, 0.8931180124566549, 0.869735176818097], "final_y": [0.12493575642473742, 0.11371761741670638, 0.1251690222004055]}, "mutation_prompt": null}
{"id": "cfcbb1bc-10e0-477c-a2ab-48e5e307a30b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                dynamic_mutation_rate = self.mutation_rate * adaptive_factor  # New line\n                if np.random.rand() < dynamic_mutation_rate:  # Modified line\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced the swarm diversity by varying mutation rates dynamically based on progress.", "configspace": "", "generation": 28, "fitness": 0.8690447339582353, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.004. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8639034737687165, 0.870583857847112, 0.8726468702588775], "final_y": [0.12869969223893396, 0.11812106801861033, 0.11526571881660941]}, "mutation_prompt": null}
{"id": "9e045d61-2358-48a5-854d-599591d2e187", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced dynamic exploration with refined velocity adjustment for layers.", "configspace": "", "generation": 29, "fitness": 0.8658568927012641, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.007. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8642390159322493, 0.8580216359544159, 0.8753100262171271], "final_y": [0.12947589398706516, 0.12722410166512965, 0.11540624050449144]}, "mutation_prompt": null}
{"id": "6676b373-2dcc-4781-a356-ccb5c97ffa7c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.8 * adaptive_factor  # Modified line\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration-exploitation balance by refining cognitive coefficient and mutation scaling.", "configspace": "", "generation": 30, "fitness": 0.8525451284517348, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.015. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8710492832283943, 0.851966171427797, 0.8346199306990133], "final_y": [0.12814982127034846, 0.1204328757184473, 0.13723206787386055]}, "mutation_prompt": null}
{"id": "0bd0a771-029a-491b-93a9-4ca61b2961c8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                self.velocity[i] = np.clip(self.velocity[i], -1, 1)  # New line for adaptive velocity bounds\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling * (1 - adaptive_factor), self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration-exploitation via adaptive velocity bounds and dynamic mutation rate scaling.", "configspace": "", "generation": 31, "fitness": 0.7396091780762156, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.740 with standard deviation 0.022. And the mean value of best solutions found was 0.174 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.7194926586378203, 0.770814667566035, 0.7285202080247914], "final_y": [0.17580820096082883, 0.16799541968919207, 0.17879595432877948]}, "mutation_prompt": null}
{"id": "e9294709-4df3-42a8-80ba-1080fb14ede1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) * 0.8)  # Modified line\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced gradient-based exploration by modifying velocity update and adjusting mutation strategy.", "configspace": "", "generation": 32, "fitness": 0.8572530855021548, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.016. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8775568298150738, 0.8371837759046669, 0.8570186507867241], "final_y": [0.11772808900967457, 0.12623306660386513, 0.12290683953353143]}, "mutation_prompt": null}
{"id": "b54226bb-64c1-43d5-bb55-d62ca8d0bbf4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.5 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced momentum and crossover techniques in adaptive swarm to refine search space navigation.", "configspace": "", "generation": 33, "fitness": 0.8534370403304158, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.006. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8599971188239466, 0.8456888246903419, 0.854625177476959], "final_y": [0.13175021986978686, 0.13092763419920317, 0.1274829848221326]}, "mutation_prompt": null}
{"id": "85ab71a8-307d-41f8-9e87-ac238802bc0e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 - adaptive_factor)  # Changed line: Shift towards exploitation\n            social_coeff = 1.5 * adaptive_factor  # Changed line: Shift towards exploration\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploitation by dynamically shifting cognitive and social coefficients based on budget consumption.", "configspace": "", "generation": 34, "fitness": 0.8672238092991497, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.016. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8728386678819287, 0.8838715052347614, 0.8449612547807589], "final_y": [0.12780143207460604, 0.11250136206776629, 0.12908188129402665]}, "mutation_prompt": null}
{"id": "8e6d02cc-d4c7-4d5b-b634-823f796d7c05", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    performance_based_mutation_scale = np.random.normal(0, \n                        0.3 * adaptive_scaling * (1 + (global_best_value - f_value) / (global_best_value + 1e-10)), \n                        self.dim)  # Changed line\n                    swarm[i] += performance_based_mutation_scale  # Changed line\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced selective mutation strategy improves diversity and convergence by adapting mutation based on performance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {}, "mutation_prompt": null}
{"id": "80bb1c04-eaaf-4bb1-b926-903d5f8cba97", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor * (1 + 0.1 * np.mean(personal_best_value)) / np.std(personal_best_value)  # Adjusted line\n            social_coeff = 1.5 * (1 - 0.1 * np.mean(personal_best_value) / np.std(personal_best_value))  # Adjusted line\n\n            for i in the range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adjusts cognitive and social coefficients based on layer-specific performance to enhance convergence and diversity.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 28, 26, '            for i in the range(self.population_size):\\n', 28, 31)).", "error": "SyntaxError('invalid syntax', ('<string>', 28, 26, '            for i in the range(self.population_size):\\n', 28, 31))", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {}, "mutation_prompt": null}
{"id": "76904e94-c1ad-42c1-939f-ebd90907ec3f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n        self.population_adaptive_rate = 0.1  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            self.population_size = max(5, int((1.0 - adaptive_factor) * self.population_size))  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * (adaptive_scaling + adaptive_factor), self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced dynamic population resizing and adaptive mutation strategy for enhanced exploration-exploitation balance.", "configspace": "", "generation": 37, "fitness": 0.8630698495186301, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.025. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8388191448167561, 0.8525309383425046, 0.8978594653966296], "final_y": [0.12837044694884991, 0.13369714708245095, 0.1133138051738305]}, "mutation_prompt": null}
{"id": "fb9e95d0-e767-4805-a218-c5f8db4cbb92", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = np.cos(evaluations / self.budget * np.pi / 2)  # Improved adaptive factor\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.5 * adaptive_scaling, self.dim)  # Dynamic mutation scaling\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration through dynamic mutation scaling and improved adaptive factor.", "configspace": "", "generation": 38, "fitness": 0.850493070396249, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.011. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8637548845113907, 0.8373525904271754, 0.850371736250181], "final_y": [0.1262411136693844, 0.131957156888037, 0.12750626572961776]}, "mutation_prompt": null}
{"id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced dynamic cognitive and social coefficients to balance exploration and exploitation based on progress.", "configspace": "", "generation": 39, "fitness": 0.8804416680189443, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.007. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "b823322f-a30e-43cd-b066-8193c92d9431", "metadata": {"aucs": [0.8749251392276257, 0.8760274969773542, 0.8903723678518528], "final_y": [0.12409488992807849, 0.11491010985443983, 0.116083571697005]}, "mutation_prompt": null}
{"id": "d6d1fe4d-876b-4cb6-85b8-024f569e4ea6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate * adaptive_factor:  # Changed line\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Tweaked adaptive mutation rate and velocity update to enhance exploration and solution diversity.", "configspace": "", "generation": 40, "fitness": 0.8700399715952752, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.009. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.864540114087704, 0.8623864181903277, 0.8831933825077943], "final_y": [0.11612648643921564, 0.11731973423004471, 0.11702521366053675]}, "mutation_prompt": null}
{"id": "54afcd77-6069-4836-a27c-1e9f0785be8c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate * (1 - adaptive_factor):  # Modified line\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced a decaying mutation rate to dynamically balance exploration and exploitation as evaluations progress.", "configspace": "", "generation": 41, "fitness": 0.8597283126964247, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.003. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8629741500513224, 0.8565548392611241, 0.8596559487768274], "final_y": [0.12026894725593196, 0.1221299227631718, 0.12088542800919921]}, "mutation_prompt": null}
{"id": "639558da-38f3-427e-8056-b85c8defc16e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n        self.quasi_random_seed = np.random.rand(dim)  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            if evaluations % (self.budget // 10) == 0:  # New block\n                self.population_size = min(self.population_size + 1, int(np.sqrt(self.dim) * 5))  # New block\n                swarm = np.vstack((swarm, np.random.uniform(lb, ub, (1, self.dim))))  # New block\n                self.velocity = np.vstack((self.velocity, np.zeros((1, self.dim))))  # New block\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Quasi-random perturbation for diversity\n                quasi_random_perturbation = 0.01 * (np.sin(self.quasi_random_seed * evaluations) - 0.5)  # New line\n                swarm[i] += quasi_random_perturbation  # New line\n                swarm[i] = np.clip(swarm[i], lb, ub)  # New line\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced adaptive swarm gradient descent with adaptive population size and quasi-random sampling for improved diversity and exploration.", "configspace": "", "generation": 42, "fitness": 0.856885369135617, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.011. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8553746278881939, 0.8438418727187336, 0.8714396067999235], "final_y": [0.11506468260351532, 0.11587718952588544, 0.12370309422375692]}, "mutation_prompt": null}
{"id": "2d237635-6a45-436a-854c-25dc33c3b7ba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  \n        self.layer_increase_step = np.ceil(dim / 8).astype(int) \n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  \n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  \n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  \n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step \n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  \n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Dynamic mutation rate adjustment based on solution quality\n                if np.random.rand() < self.mutation_rate * (1 - f_value / global_best_value):\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim) \n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced local search by dynamic adjustment of mutation rate based on solution quality.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'f_value' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'f_value' where it is not associated with a value\")", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {}, "mutation_prompt": null}
{"id": "a69b151e-ea2a-4d6e-9057-666f3626ae4f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate + 0.05 * adaptive_factor:  # Modified line\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced the algorithm with adaptive mutation rate and inertia weight adjustments for improved exploration and exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.8576494068203081, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.009. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8510589143209943, 0.8516860064225176, 0.8702032997174124], "final_y": [0.12617164103683554, 0.1269164693228373, 0.11209425786393978]}, "mutation_prompt": null}
{"id": "eb4f5266-913c-4c0b-87f2-0d3565aca6f5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.2 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.4 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced dynamic scaling and mutation strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.8482274261803244, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.024. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8518584291483613, 0.816590424448677, 0.876233424943935], "final_y": [0.12119795011739976, 0.1264834865811284, 0.12268939160753412]}, "mutation_prompt": null}
{"id": "9e0ca109-9925-4c60-8c91-e4d7ad27716b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved EnhancedAdaptiveSwarmGradientDescent by fine-tuning inertia weight adjustment and mutation strategy for better convergence.", "configspace": "", "generation": 46, "fitness": 0.8633297113537685, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.029. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8633387209876165, 0.8275631454179742, 0.8990872676557148], "final_y": [0.12805169995575993, 0.13269132013935325, 0.12048393220826781]}, "mutation_prompt": null}
{"id": "146cb187-fc9a-4444-aacc-96ad2129126b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * np.cos(evaluations / self.budget * np.pi))  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * np.cos(evaluations / self.budget * np.pi))  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adjusted cognitive and social coefficients dynamically using a cosine function to improve balance between exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.8687067805862677, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.025. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8678413722068391, 0.8385669097610406, 0.8997120597909235], "final_y": [0.12563891483132827, 0.12923459148433225, 0.11564246423122304]}, "mutation_prompt": null}
{"id": "7fa7bf67-9667-41de-82fb-a11e242b0fa6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling * np.std(swarm, axis=0), self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced swarm intelligence with a dynamic mutation rate scaling based on swarm diversity.", "configspace": "", "generation": 48, "fitness": 0.8616993430873979, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.009. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8617207831416881, 0.8512671815402935, 0.8721100645802123], "final_y": [0.12491411967330224, 0.12549795691413435, 0.12622444274122602]}, "mutation_prompt": null}
{"id": "3dfcc219-06d0-4598-8ce0-2ffc5fb1a5a8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                mutation_rate_progress = self.mutation_rate * (0.5 + 0.5 * adaptive_factor)  # Modified line\n                if np.random.rand() < mutation_rate_progress:  # Modified line\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced exploration-exploitation balance using adaptive mutation rate based on progress.", "configspace": "", "generation": 49, "fitness": 0.8675398835115068, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.010. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8554268959301191, 0.8681169351088688, 0.8790758194955325], "final_y": [0.12819771181575124, 0.11601521610975651, 0.12352828482520206]}, "mutation_prompt": null}
{"id": "0c847081-f0b2-4f49-9a23-1a363082cac9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * np.cos(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce adaptive mutation for improved diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.2 * (1 - adaptive_factor), self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved inertia and mutation adaptation to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 50, "fitness": 0.8758207430213375, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.025. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8451497404910437, 0.8751807321011755, 0.9071317564717932], "final_y": [0.12445091847104295, 0.12238187278285118, 0.11319051238916578]}, "mutation_prompt": null}
{"id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced adaptive scaling and mutation to improve exploration and convergence.", "configspace": "", "generation": 51, "fitness": 0.8823759482178924, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.017. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e36a0066-588c-4e4e-90d8-1650babffaf6", "metadata": {"aucs": [0.8678645372437527, 0.8733985969027636, 0.9058647105071612], "final_y": [0.11909077566270132, 0.1226840035693052, 0.11694644555466016]}, "mutation_prompt": null}
{"id": "7b103930-546a-4417-9349-7560ea8977cd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced adaptive exploration and exploitation using improved velocity and mutation strategies.", "configspace": "", "generation": 52, "fitness": 0.8819822260952662, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.017. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8678491611508801, 0.8722542952311754, 0.9058432219037433], "final_y": [0.11914710981591137, 0.1231473231789244, 0.11690412113104909]}, "mutation_prompt": null}
{"id": "2212daeb-cb02-4565-8369-445ab755fa85", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced dynamic mutation and velocity adjustments for improved exploration and convergence.", "configspace": "", "generation": 53, "fitness": 0.8819822260952662, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.017. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8678491611508801, 0.8722542952311754, 0.9058432219037433], "final_y": [0.11914710981591137, 0.1231473231789244, 0.11690412113104909]}, "mutation_prompt": null}
{"id": "5a422003-a3f4-4dda-8c62-eee8690c0800", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive scaling factor adjusted for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.8477680386263121, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.027. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8415335006132183, 0.8187789430527017, 0.8829916722130163], "final_y": [0.11511668599004321, 0.12428986966763522, 0.11679780400770912]}, "mutation_prompt": null}
{"id": "c700ed10-07f9-4ac6-8658-f491b23f8f91", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced dynamic exploration strategies and refined mutation effects for improved optimization.", "configspace": "", "generation": 55, "fitness": 0.88175677561322, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.017. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8678124901413862, 0.871350970348355, 0.9061068663499187], "final_y": [0.1192182992684101, 0.12376850269777784, 0.11497662018209054]}, "mutation_prompt": null}
{"id": "e3ac5636-d489-4c9f-950b-e2ca320f94ea", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                dynamic_mutation_rate = self.mutation_rate * (0.5 + adaptive_factor)  # Changed line\n                if np.random.rand() < dynamic_mutation_rate:  # Changed line\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced adaptive mutation rate to enhance diversity and convergence dynamically.", "configspace": "", "generation": 56, "fitness": 0.8758772892074639, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.017. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8706150739186266, 0.8577274358289176, 0.8992893578748475], "final_y": [0.11735363528588882, 0.11942941100056892, 0.11470734204004862]}, "mutation_prompt": null}
{"id": "636f9a4c-20c7-4c44-b963-151189b29de1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    improvement_rate = np.abs(f_value - personal_best_value[i]) / (1 + personal_best_value[i])  # New line\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * (1 + improvement_rate), self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introducing adaptive mutation scale based on personal best improvement rate to enhance diversity while maintaining focus.  ", "configspace": "", "generation": 57, "fitness": 0.8823620685019476, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.017. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8679592555200488, 0.8730926842616066, 0.9060342657241877], "final_y": [0.11907422302850446, 0.12448076798949648, 0.11618543853519447]}, "mutation_prompt": null}
{"id": "af78279b-9cf3-4764-afea-2e8b225c999f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Adjusted inertia weight for better exploration\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step  # New line\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Modified line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)  # New line\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a non-uniform mutation scale that adapts based on distance from the global best to enhance exploration and convergence.", "configspace": "", "generation": 58, "fitness": 0.8840697620770871, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.019. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "241c6d38-4f06-4ceb-a14e-2bc1c9a7211e", "metadata": {"aucs": [0.8568604630861629, 0.9015192502931231, 0.8938295728519754], "final_y": [0.12038878521240104, 0.11720893925342235, 0.11666884434361191]}, "mutation_prompt": null}
{"id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Employ a sine-modulated inertia weight combined with a dynamic mutation rate for enhanced adaptation and solution quality.", "configspace": "", "generation": 59, "fitness": 0.8940748639808134, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.021. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "af78279b-9cf3-4764-afea-2e8b225c999f", "metadata": {"aucs": [0.8661035744069914, 0.9004577465539315, 0.9156632709815172], "final_y": [0.12880254224016507, 0.11871225955292952, 0.11634364790355733]}, "mutation_prompt": null}
{"id": "8b46b199-74c2-415a-9601-55eb28374ab5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale * (1 + 0.1 * adaptive_factor), self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrate an adaptive mutation factor based on the global best to enhance exploration in the EnhancedAdaptiveSwarmGradientDescent algorithm.", "configspace": "", "generation": 60, "fitness": 0.8776001614029346, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.021. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8664084901465001, 0.8598857782714299, 0.9065062157908739], "final_y": [0.1290298807685607, 0.12813008442579277, 0.11954368784492375]}, "mutation_prompt": null}
{"id": "938c1ff2-26b0-4653-8d28-102334fe524b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i] + np.random.normal(0, 0.01, self.dim)  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm diversity using stochastic noise addition and adaptive velocity scaling for robust convergence.", "configspace": "", "generation": 61, "fitness": 0.8891472555566157, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.013. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8792721932669114, 0.880720151588579, 0.9074494218143565], "final_y": [0.12445354466130187, 0.12714639814769602, 0.1172193901639863]}, "mutation_prompt": null}
{"id": "37c90f98-f630-4b94-a2d1-07526dc9c0cc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.4 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (0.5 + 0.5 * np.sin(evaluations / self.budget * np.pi)) # Modified line\n                if np.random.rand() < adjusted_mutation_rate:  # Modified line\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a dynamic mutation rate and adapt the cognitive coefficient to enhance convergence speed and diversity balance.", "configspace": "", "generation": 62, "fitness": 0.8711503034947893, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.022. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.840884329870499, 0.8779519788703604, 0.8946146017435084], "final_y": [0.1345855631810584, 0.12397368337791181, 0.11743429029333552]}, "mutation_prompt": null}
{"id": "3eb7e983-c40e-4b00-9af6-57e3827b1a97", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                self.mutation_rate = 0.15 + 0.05 * np.cos(evaluations / self.budget * np.pi)  # Modified line\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a time-varying mutation rate based on the cosine function to balance exploration and exploitation.", "configspace": "", "generation": 63, "fitness": 0.8879992145107564, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.021. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8629344968208923, 0.9150205816602078, 0.8860425650511686], "final_y": [0.13404575362170457, 0.1150840540880429, 0.1164667274475446]}, "mutation_prompt": null}
{"id": "c3f57e7b-6531-4ee2-bcf9-7b69edaac2cc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            diversity = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor) * (1 - diversity)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor) * (1 + diversity)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration by adapting cognitive and social coefficients based on diversity.", "configspace": "", "generation": 64, "fitness": 0.8696353332428858, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.009. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8812599789407496, 0.869134866679011, 0.858511154108897], "final_y": [0.12510004157708376, 0.12607760314663286, 0.12312235812779304]}, "mutation_prompt": null}
{"id": "79c88698-7fb6-4eb6-aee7-3b6246dba970", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Dynamic mutation based on convergence speed\n                convergence_speed = np.linalg.norm(global_best - np.mean(swarm, axis=0))\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = convergence_speed / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a mutation mechanism influenced by convergence speed to dynamically balance exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.8798794668992619, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.039. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8807819137464447, 0.8320769506404317, 0.926779536310909], "final_y": [0.1272075596113934, 0.1458081985431946, 0.11238842692350781]}, "mutation_prompt": null}
{"id": "953015b0-5b69-4653-b70e-b7ff47008a67", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                dispersion = np.std(swarm, axis=0).mean()\n                if np.random.rand() < self.mutation_rate * (1 + dispersion):\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance solution diversity by adjusting mutation rate based on swarm dispersion.", "configspace": "", "generation": 66, "fitness": 0.852937401392463, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.006. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8481210711923108, 0.8612015960290064, 0.8494895369560717], "final_y": [0.13289353717536978, 0.13312685213248165, 0.12551650756836996]}, "mutation_prompt": null}
{"id": "e14114db-3878-4a3b-8b6a-2abd4a1b952b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + adaptive_factor)  # Improved convergence\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce adaptive mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale * adaptive_factor, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation based on diversity and improve cognitive coefficient for better convergence.", "configspace": "", "generation": 67, "fitness": 0.8552703113650687, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.021. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8459377868996898, 0.8355216592215214, 0.8843514879739947], "final_y": [0.13762985032803987, 0.13854084114196052, 0.1177778445932014]}, "mutation_prompt": null}
{"id": "2601935f-6e1f-4b8f-bdfb-d0275ce277b6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce layer-specific inertia weight scaling to enhance convergence in hierarchical structures.", "configspace": "", "generation": 68, "fitness": 0.8940748639808134, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.021. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8661035744069914, 0.9004577465539315, 0.9156632709815172], "final_y": [0.12880254224016507, 0.11871225955292952, 0.11634364790355733]}, "mutation_prompt": null}
{"id": "5dcd1d02-0af9-43ab-91ce-79356399fb24", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Changed line\n            social_coeff = 1.5 * (1 + 0.3 * np.cos(adaptive_factor * np.pi))  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance solution diversity by dynamically adjusting cognitive and social coefficients within a constrained change limit.", "configspace": "", "generation": 69, "fitness": 0.8575004895908792, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.016. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8591016461319487, 0.8366231312272633, 0.8767766914134257], "final_y": [0.13370810701948388, 0.13146112169615287, 0.12303865347208631]}, "mutation_prompt": null}
{"id": "2b799bc8-7778-43f6-b975-1009f637c6de", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.25 * layer_scaling * non_uniform_scale, self.dim)  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive mutation scale and improve diversity with layer-specific scaling for better convergence.", "configspace": "", "generation": 70, "fitness": 0.8878909273087437, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.007. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8784394063229372, 0.8901154802323958, 0.895117895370898], "final_y": [0.12296020400293572, 0.11991371107955562, 0.12125465343829944]}, "mutation_prompt": null}
{"id": "450ee244-3671-4426-9761-f6c9b5860d74", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15  # Increase mutation rate for diversity\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)  # Adjust layer increase strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)  # Modified line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)  # Modified line\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.uniform(-0.3, 0.3, self.dim) * adaptive_scaling * non_uniform_scale  # Modified line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Modify the mutation scale and velocity update to boost exploration and convergence consistency.", "configspace": "", "generation": 71, "fitness": 0.8910644580123718, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.013. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.8735890288372656, 0.8932941648491693, 0.9063101803506806], "final_y": [0.1265136941966416, 0.12242677814152902, 0.11948724146795231]}, "mutation_prompt": null}
{"id": "bd23bbf4-eeaf-4eda-8f5c-d36604ed2b57", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * np.sin(adaptive_factor * np.pi)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)  # Modified line\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale, self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration by dynamically adjusting mutation rate based on the swarm's diversity.", "configspace": "", "generation": 72, "fitness": 0.8957825146673274, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.012. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "ef5f2ce5-16eb-44d6-8946-4df4507142bd", "metadata": {"aucs": [0.9101370522005138, 0.8958982364337102, 0.8813122553677579], "final_y": [0.11806825875835902, 0.12212688451397158, 0.12565758059829457]}, "mutation_prompt": null}
{"id": "26d7d47a-6675-4416-a10a-af234275dc5b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * np.cos(adaptive_factor * np.pi)  # Changed line\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale, self.dim)  # Changed line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine the velocity update and include a non-uniform mutation to balance exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.8987275331317992, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.013. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "bd23bbf4-eeaf-4eda-8f5c-d36604ed2b57", "metadata": {"aucs": [0.880355948071534, 0.9067889337447071, 0.9090377175791564], "final_y": [0.12520388926287473, 0.11633686807971944, 0.11093859359627689]}, "mutation_prompt": null}
{"id": "c6798ffc-f847-4ad4-9535-e324dc6260b0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n        self.diversity_threshold = 0.1  # Added line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * np.cos(adaptive_factor * np.pi)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                velocity_damping = 0.2 + 0.8 * (evaluations / self.budget)  # Changed line\n                self.velocity[i] = (velocity_damping * inertia_weight * self.velocity[i] +  # Changed line\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale, self.dim)\n                    if diversity_factor < self.diversity_threshold:  # Changed line\n                        mutation_scale *= 2  # Changed line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm diversity and convergence efficiency by introducing dynamic mutation scaling and adaptive velocity damping.", "configspace": "", "generation": 74, "fitness": 0.8790468080997925, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "26d7d47a-6675-4416-a10a-af234275dc5b", "metadata": {"aucs": [0.865812182104144, 0.8877840383635978, 0.8835442038316359], "final_y": [0.12583400608664708, 0.11801414036694746, 0.11180830979389111]}, "mutation_prompt": null}
{"id": "f8d39c90-22e9-488b-8884-9fe13376364e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 10).astype(int)  # Changed line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * np.cos(adaptive_factor * np.pi)  # Changed line\n            cognitive_coeff = 1.7 * (1 + 0.5 * adaptive_factor)  # Changed line\n            social_coeff = 1.3 * (1 - 0.5 * adaptive_factor)  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.15 * (i % self.layer_increase_step) / self.layer_increase_step  # Changed line\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Changed line\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n                adjusted_mutation_rate = self.mutation_rate * (1 + 0.8 * diversity_factor)  # Changed line\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale, self.dim)  # Changed line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Hybridize swarm dynamics with dynamic layer optimization and adaptive feedback mechanisms to enhance convergence and robustness in noisy environments.", "configspace": "", "generation": 75, "fitness": 0.8666569374528322, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.017. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "26d7d47a-6675-4416-a10a-af234275dc5b", "metadata": {"aucs": [0.8474243907550643, 0.8641191573326522, 0.8884272642707807], "final_y": [0.12800666559378848, 0.12115763279577785, 0.11170472573271495]}, "mutation_prompt": null}
{"id": "a730aca0-57f9-488e-b201-bb3e13abb43a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * np.cos(adaptive_factor * np.pi)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * np.cos(adaptive_factor * np.pi), self.dim)  # Changed line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a cosine-based adaptive mutation scale for enhanced diversity and exploration.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "26d7d47a-6675-4416-a10a-af234275dc5b", "metadata": {}, "mutation_prompt": null}
{"id": "f980eb16-7454-4fb6-80e6-66eb3e51d6d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * np.cos(adaptive_factor * np.pi)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * (1 - adaptive_factor), self.dim)  # Changed line 1\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce an adaptive mutation scale based on evaluations and a nonlinear velocity update for improved exploration-exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.9047754786499912, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.905 with standard deviation 0.006. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "26d7d47a-6675-4416-a10a-af234275dc5b", "metadata": {"aucs": [0.910562739457365, 0.8972105934507695, 0.906553103041839], "final_y": [0.11220217556094225, 0.11700417714019917, 0.11532663789936681]}, "mutation_prompt": null}
{"id": "b0f6e753-68de-421d-a547-da4ee1a1ab05", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)  # Changed line 1\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * (1 - adaptive_factor), self.dim)\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive inertia weight based on swarm diversity to enhance convergence.", "configspace": "", "generation": 78, "fitness": 0.9214429152855166, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.921 with standard deviation 0.008. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "f980eb16-7454-4fb6-80e6-66eb3e51d6d5", "metadata": {"aucs": [0.9245085628054855, 0.9106826723107604, 0.9291375107403036], "final_y": [0.11179350326581772, 0.11634444488476625, 0.1109135184790514]}, "mutation_prompt": null}
{"id": "b1152495-053e-4e49-982e-71032ef8710b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))  # Changed line 1\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance convergence by adjusting mutation scale based on function evaluations and diversity.", "configspace": "", "generation": 79, "fitness": 0.9251173404382659, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.003. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "b0f6e753-68de-421d-a547-da4ee1a1ab05", "metadata": {"aucs": [0.9244968506913167, 0.9211847392353697, 0.9296704313881115], "final_y": [0.111767699914049, 0.11243832647537755, 0.11088284895081846]}, "mutation_prompt": null}
{"id": "d3c95839-8b12-42a1-bc7c-1c66ba7e2a3d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.2  # Adjusted for more exploration\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n        self.modular_detection_threshold = 0.5  # New parameter for modularity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.6 + 0.4 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.8 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.8 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))  # Changed line 1\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescentV2", "description": "Enhance diversity and convergence by integrating adaptive mutation and modular structure detection.", "configspace": "", "generation": 80, "fitness": 0.912249102883017, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.009. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9093918579613978, 0.9241085395784835, 0.9032469111091698], "final_y": [0.11245736680859209, 0.11255015437693883, 0.11593914505985436]}, "mutation_prompt": null}
{"id": "5de50287-0ee7-450e-9aab-4ddee1639e0e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + \n                                    0.2 * np.sin(i % self.layer_increase_step)))  # Changed line\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance solution diversity by adjusting mutation scale based on layer-specific roles during optimization.", "configspace": "", "generation": 81, "fitness": 0.9250862148605469, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.004. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9247576139624487, 0.9207261658691871, 0.9297748647500045], "final_y": [0.11176563442810783, 0.11256969760674851, 0.11064365022017575]}, "mutation_prompt": null}
{"id": "78f9bfea-bf53-4902-8487-4606b29ddb0b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.2  # Changed line 1\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.9 + 0.1 * np.cos(adaptive_factor * np.pi)) * (1 + 0.5 * diversity_factor)  # Changed line 2\n            cognitive_coeff = 1.6 * (1 + 0.3 * adaptive_factor)  # Changed line 3\n            social_coeff = 1.4 * (1 - 0.3 * adaptive_factor)  # Changed line 4\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.15 * (i % self.layer_increase_step) / self.layer_increase_step  # Changed line 5\n                adaptive_scaling = (0.8 + 0.2 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Changed line 6\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce enhanced mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + 1.5 * diversity_factor)  # Changed line 7\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.15))  # Changed line 8\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce diversity-enhancing mutation and adaptive learning strategies for efficient exploration and convergence.", "configspace": "", "generation": 82, "fitness": 0.8701589837919173, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.011. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8708543350084936, 0.856555803256751, 0.8830668131105075], "final_y": [0.12809840928680516, 0.13317074568283616, 0.12561389591016037]}, "mutation_prompt": null}
{"id": "59b0b904-b21c-42d5-9f30-5631599226d6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.15))  # Changed line 1\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved solution diversity and convergence by refining adaptive mutation strategies.", "configspace": "", "generation": 83, "fitness": 0.9247715510627527, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.003. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.924316335323734, 0.9219458986353729, 0.9280524192291512], "final_y": [0.1118717894368032, 0.11200598825122976, 0.11114705097449384]}, "mutation_prompt": null}
{"id": "17621c54-8c7f-4769-b6c1-afdee08a9f1c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor**2), self.dim) * (diversity_factor + 0.1))  # Changed line 1\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Incorporate nonlinear scaling into mutation to enhance exploration while maintaining diversity.", "configspace": "", "generation": 84, "fitness": 0.9188333583686447, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.919 with standard deviation 0.011. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9244597396701204, 0.9039990072134925, 0.928041328222321], "final_y": [0.11184465174354996, 0.1170003994084663, 0.11116639362598857]}, "mutation_prompt": null}
{"id": "9ac81c3f-de04-41f7-8e6f-c1e3fdddc9bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale *  # Changed line 1\n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.2))  # Changed line 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrate a dynamic step size adaptation and selective mutation strategy to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": 0.9239380165670044, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.003. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9239858691995284, 0.9197938562511767, 0.9280343242503082], "final_y": [0.11208807647088803, 0.11324943063276138, 0.11114054569575327]}, "mutation_prompt": null}
{"id": "c43033fc-8116-4e60-862c-9b58b2728876", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.2))  # Changed line 1 & 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve diversity and convergence by adjusting mutation scale based on evaluations and diversity metrics.", "configspace": "", "generation": 86, "fitness": 0.9239380165670044, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.003. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9239858691995284, 0.9197938562511767, 0.9280343242503082], "final_y": [0.11208807647088803, 0.11324943063276138, 0.11114054569575327]}, "mutation_prompt": null}
{"id": "c68a3059-fe8a-474e-8442-3bd6a8bf66c8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.cos(evaluations / self.budget * np.pi)) * layer_scaling  # Changed line 1\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (0.5 - adaptive_factor), self.dim) * (diversity_factor + 0.1))  # Changed line 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance convergence by refining diversity measures and adaptive scaling based on evaluation stages.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {}, "mutation_prompt": null}
{"id": "f4672682-d413-41f8-bdca-5a002e5d39cd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.7 * (1 + 0.5 * adaptive_factor)  # Changed line 1\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = np.random.normal(0, 0.3 * adaptive_scaling * non_uniform_scale *  # Changed line 2\n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1)  # Changed line 3\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance swarm diversity and adaptability by modifying mutation scale and cognitive coefficient.", "configspace": "", "generation": 88, "fitness": 0.9132529124448358, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.008. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9082050426539554, 0.9064846559581529, 0.9250690387223992], "final_y": [0.11532772788761902, 0.11699347395160686, 0.11049879576272115]}, "mutation_prompt": null}
{"id": "2a46191b-66d5-4a40-bbb4-032795a499d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                self.velocity[i] = np.clip(self.velocity[i], -0.1*(ub-lb), 0.1*(ub-lb))  # Changed line 1\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.15))  # Changed line 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Optimize convergence by adjusting velocity update and mutation scale based on evaluations and diversity.", "configspace": "", "generation": 89, "fitness": 0.9032344873418029, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.007. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8948529385389989, 0.9037601795734063, 0.9110903439130035], "final_y": [0.1171308334346417, 0.11394393406033965, 0.11399245103581657]}, "mutation_prompt": null}
{"id": "1f091716-5c5e-4a53-865a-5899b9635a80", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                nonlinear_scaling = 0.5 + 0.5 * np.sin(evaluations / self.budget * np.pi)  # Changed line 1\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * nonlinear_scaling * (global_best - swarm[i]))  # Changed line 2\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrate a dynamic velocity update strategy for enhanced exploration based on nonlinear scaling of cognitive and social influences.", "configspace": "", "generation": 90, "fitness": 0.8980379605739626, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.006. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8908264537818669, 0.8985512903446466, 0.9047361375953743], "final_y": [0.11243019225815631, 0.1163692684259483, 0.11195071004317814]}, "mutation_prompt": null}
{"id": "92ac9c14-3a08-44e5-8110-afc98b4303ab", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.5 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)  # Changed line 1\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.35 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))  # Changed line 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine convergence by dynamic inertia weight and adaptive mutation scale based on layer-specific roles.", "configspace": "", "generation": 91, "fitness": 0.8984452345310232, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.012. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8816798864203185, 0.9110539369428684, 0.9026018802298827], "final_y": [0.12468207506291085, 0.11675923375477781, 0.11295481285480247]}, "mutation_prompt": null}
{"id": "04a7869a-3621-4271-b69b-8b350ed7397b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.5 + 0.5 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)  # Changed line 1\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale *\n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.15))  # Changed line 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance convergence by adapting inertia weight and mutation scale using cosine function and layer scaling.", "configspace": "", "generation": 92, "fitness": 0.8705088959980319, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.012. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8553045240627279, 0.8724927565833858, 0.883729407347982], "final_y": [0.13074736755897864, 0.12367323539421726, 0.12061638553802034]}, "mutation_prompt": null}
{"id": "29304217-0ac0-45eb-8165-0d5a112673f9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                individual_scaling = np.random.uniform(0.9, 1.1)  # Changed line 1\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i])) * individual_scaling  # Changed line 2\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration by introducing adaptive individual scaling and dynamic mutation rates.", "configspace": "", "generation": 93, "fitness": 0.9010798155475798, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.007. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8906090151683556, 0.9057521673720823, 0.9068782641023013], "final_y": [0.12021107852967305, 0.12058990381265144, 0.11369649314759755]}, "mutation_prompt": null}
{"id": "c4737f8a-b783-4b39-b2d7-71677de83f90", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor) * (1 - 0.5 * adaptive_factor)  # Changed line 1\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance exploration and exploitation balance by introducing a decay factor for mutation rate and velocity updates.", "configspace": "", "generation": 94, "fitness": 0.9019996205173255, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.014. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.884974978121124, 0.902371415879732, 0.9186524675511203], "final_y": [0.12544482455400763, 0.11687241669200632, 0.11393299789724542]}, "mutation_prompt": null}
{"id": "cb66af7b-d6f1-43fd-93ee-490225ed0a91", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor * diversity_factor)  # Changed line 1\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor * diversity_factor)  # Changed line 2\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1)) \n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improve convergence by adjusting cognitive and social coefficients dynamically based on population diversity.", "configspace": "", "generation": 95, "fitness": 0.8974533449102627, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.897 with standard deviation 0.023. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.8682329256959159, 0.9243082758068638, 0.8998188332280086], "final_y": [0.13048285347786392, 0.1133307835427314, 0.11977297336045745]}, "mutation_prompt": null}
{"id": "4ac95c12-0867-418e-8430-913774cb6137", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.5 + 0.5 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)  # Changed line 1\n            cognitive_coeff = 2.0 * (1 + 0.5 * adaptive_factor)  # Changed line 2\n            social_coeff = 2.0 * (1 - 0.5 * adaptive_factor)  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling  # Changed line 4\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.2 * adaptive_scaling * non_uniform_scale *  # Changed line 5\n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))\n                    hybrid_mutation = 0.5 * mutation_scale + 0.5 * np.random.normal(0, 0.1, self.dim)  # Changed line 6\n                    swarm[i] += hybrid_mutation  # Changed line 7\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescentV2", "description": "Improve convergence by adaptive layer scaling and hybrid mutation integration for noise robustness.", "configspace": "", "generation": 96, "fitness": 0.8798146114965918, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.028. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.84426495255657, 0.9122717932011628, 0.8829070887320427], "final_y": [0.13727854461969402, 0.11663867660945815, 0.12640377742575748]}, "mutation_prompt": null}
{"id": "ead5335f-a062-4e5d-9305-6830e9e5ff1d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            avg_fitness_improvement = np.mean(personal_best_value) - global_best_value # Changed line 1\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + avg_fitness_improvement) # Changed line 2\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Fine-tune diversity by scaling mutation rate based on the average fitness improvement instead of diversity factor.", "configspace": "", "generation": 97, "fitness": 0.9177957676689443, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.918 with standard deviation 0.010. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9315022409386223, 0.9122491801757235, 0.9096358818924872], "final_y": [0.11115334361432083, 0.11656838283429283, 0.11165812055100688]}, "mutation_prompt": null}
{"id": "b3fbf637-23ba-4f31-81bd-34d873501569", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.2  # Changed line 1\n        self.layer_increase_step = np.ceil(dim / 6).astype(int)  # Changed line 2\n        self.initial_dim = 6\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        current_dim = self.initial_dim  # Changed line 3\n        swarm = np.random.uniform(lb, ub, (self.population_size, current_dim))  # Changed line 4\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(np.pad(x, (0, self.dim-current_dim), \n                                        'constant')) for x in swarm])  # Changed line 5\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            if evaluations / self.budget > 0.5 and current_dim < self.dim:  # Changed line 6\n                current_dim = min(current_dim + self.layer_increase_step, self.dim)  # Changed line 7\n                swarm = np.pad(swarm, ((0, 0), (0, current_dim - swarm.shape[1])), \n                               'constant', constant_values=0)  # Changed line 8\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(current_dim), np.random.random(current_dim)  # Changed line 9\n                role_based_factor = np.sin(np.pi * i / self.population_size)  # Changed line 10\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi))\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i][:current_dim] +  # Changed line 11\n                                    cognitive_coeff * r1 * (personal_best[i][:current_dim] - swarm[i]) +  # Changed line 12\n                                    social_coeff * r2 * (global_best[:current_dim] - swarm[i]) +  # Changed line 13\n                                    role_based_factor * np.random.normal(0, 0.1, current_dim))  # Changed line 14\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best[:current_dim] - swarm[i]) / np.sqrt(current_dim)  # Changed line 15\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), current_dim) * (diversity_factor + 0.1))  # Changed line 16\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(np.pad(swarm[i], (0, self.dim-current_dim), 'constant'))  # Changed line 17\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = np.pad(swarm[i], (0, self.dim-current_dim), 'constant')  # Changed line 18\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce adaptive dimensional growth and dynamic role-based mutation for enhanced convergence in high-dimensional noisy optimization.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (16, 6) and arg 1 with shape (10,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (16, 6) and arg 1 with shape (10,).')", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {}, "mutation_prompt": null}
{"id": "159284fc-354d-42a8-b14c-6f4f03520d6b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i] * (1 + diversity_factor)  # Changed line 1\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.25 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.1))  # Changed line 2\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine diversity adaptation by scaling swarm update with both adaptive factor and diversity factor.", "configspace": "", "generation": 99, "fitness": 0.9143680693814403, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.009. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9058565058864801, 0.9108781078456156, 0.9263695944122253], "final_y": [0.11269388122469215, 0.11315639419222856, 0.11330567450885287]}, "mutation_prompt": null}
{"id": "a525e1f1-ec68-4749-b44f-ec9b74df61b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_rate = 0.15\n        self.layer_increase_step = np.ceil(dim / 8).astype(int)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            diversity_factor = np.std(swarm, axis=0).mean() / (ub - lb).mean()\n            inertia_weight = (0.7 + 0.3 * np.cos(adaptive_factor * np.pi)) * (1 + diversity_factor)\n            cognitive_coeff = 1.5 * (1 + 0.5 * adaptive_factor)\n            social_coeff = 1.5 * (1 - 0.5 * adaptive_factor)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                layer_scaling = 1 + 0.1 * (i % self.layer_increase_step) / self.layer_increase_step\n                adaptive_scaling = (0.85 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * layer_scaling\n                self.velocity[i] = (adaptive_scaling * inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Introduce mutation for diversity\n                adjusted_mutation_rate = self.mutation_rate * (1 + diversity_factor)\n                if np.random.rand() < adjusted_mutation_rate:\n                    non_uniform_scale = np.linalg.norm(global_best - swarm[i]) / np.sqrt(self.dim)\n                    mutation_scale = (np.random.normal(0, 0.5 * adaptive_scaling * non_uniform_scale * \n                                    (1 - adaptive_factor), self.dim) * (diversity_factor + 0.05))  # Changed line 1\n                    swarm[i] += mutation_scale\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refine convergence by introducing layer-aware mutation scaling and improved inertia dynamics.", "configspace": "", "generation": 100, "fitness": 0.9242625584255585, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.003. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b1152495-053e-4e49-982e-71032ef8710b", "metadata": {"aucs": [0.9241891639879719, 0.9205371974565044, 0.9280613138321991], "final_y": [0.11193086574874467, 0.11212987911595651, 0.1111593366413316]}, "mutation_prompt": null}
