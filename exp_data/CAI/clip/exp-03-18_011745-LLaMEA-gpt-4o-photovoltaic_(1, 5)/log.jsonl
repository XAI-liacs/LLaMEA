{"id": "7df4c885-3487-4ad0-88e8-2ecc603543f1", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "A hybrid Grasshopper Optimization Algorithm (GOA) combined with a Differential Evolution (DE) strategy for enhanced exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.8119488668054929, "feedback": "The algorithm HybridGOA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.033. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7770025852439605, 0.8553019528551533, 0.8035420623173655], "final_y": [0.1572232861474393, 0.12978249073475956, 0.13498667603997672]}, "mutation_prompt": null}
{"id": "a77a20b6-9924-45a5-b75a-5975f66fc201", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            mutation_scale = 0.8 * np.exp(-evaluations / (0.1 * self.budget))  # Dynamic mutation scaling\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + mutation_scale * (b - c), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "A refined hybrid Grasshopper Optimization Algorithm (GOA) with Differential Evolution (DE) that improves elite solution handling through dynamic mutation scaling in black box optimization.", "configspace": "", "generation": 1, "fitness": 0.8042450759282532, "feedback": "The algorithm HybridGOA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.014. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "7df4c885-3487-4ad0-88e8-2ecc603543f1", "metadata": {"aucs": [0.7849447212442029, 0.813672092117259, 0.8141184144232978], "final_y": [0.16036440355760806, 0.1359390451226543, 0.13136916913464747]}, "mutation_prompt": null}
{"id": "48765f6b-f477-4988-9e15-c3028b3e4ccd", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Changed scaling factor from 0.8 to 0.9\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Improved selection strategy by adjusting Differential Evolution parameters for enhanced convergence.", "configspace": "", "generation": 1, "fitness": 0.8048827259967188, "feedback": "The algorithm HybridGOA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.010. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7df4c885-3487-4ad0-88e8-2ecc603543f1", "metadata": {"aucs": [0.8195911734567803, 0.7985170992606546, 0.7965399052727214], "final_y": [0.13636405887177083, 0.14194989868168795, 0.14059953594205665]}, "mutation_prompt": null}
{"id": "2e2991f7-939e-49dc-96c5-92db2ca78666", "solution": "# Description: Introducing adaptive mutation factor in DE to dynamically balance exploration and exploitation.\n# Code:\nimport numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                f_mut = 0.8 + 0.2 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(a + f_mut * (b - c), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Introducing adaptive mutation factor in DE to dynamically balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.7932751724341923, "feedback": "The algorithm HybridGOA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.023. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "7df4c885-3487-4ad0-88e8-2ecc603543f1", "metadata": {"aucs": [0.7609227565462507, 0.8132247544827064, 0.8056780062736201], "final_y": [0.1560270219971257, 0.14303942495569133, 0.13234241808037983]}, "mutation_prompt": null}
{"id": "9b1318be-9cf2-486b-873e-722bc88ff9bd", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.22  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Enhanced hybrid optimization by slightly increasing elite_rate for more exploration.", "configspace": "", "generation": 1, "fitness": 0.766160586814768, "feedback": "The algorithm HybridGOA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.007. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "7df4c885-3487-4ad0-88e8-2ecc603543f1", "metadata": {"aucs": [0.7608977491746429, 0.775572059287136, 0.7620119519825246], "final_y": [0.1629561000264348, 0.1590676385801989, 0.14396157362099682]}, "mutation_prompt": null}
{"id": "2774279e-c7fd-4bdf-97b0-7cf059356548", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c) + 0.1 * (population[np.random.randint(self.population_size)] - a), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Refined Hybrid GOA-DE algorithm with an enhanced DE mutation strategy for improved diversity and convergence speed.", "configspace": "", "generation": 1, "fitness": 0.7635501344987148, "feedback": "The algorithm HybridGOA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.764 with standard deviation 0.011. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7df4c885-3487-4ad0-88e8-2ecc603543f1", "metadata": {"aucs": [0.7560652173509785, 0.7787039085028454, 0.7558812776423205], "final_y": [0.1651658442041496, 0.16617062657289727, 0.1625778175120488]}, "mutation_prompt": null}
{"id": "b103b756-167d-4302-977f-94deefd8ebf1", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Adjust elite_rate adaptively based on evaluations\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Changed scaling factor from 0.8 to 0.9\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Introduced adaptive elite_rate based on convergence progress to improve exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "48765f6b-f477-4988-9e15-c3028b3e4ccd", "metadata": {}, "mutation_prompt": null}
{"id": "f64d2a9f-656c-4e44-953b-5dd054b2e7a3", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # Initial proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Dynamically adjust elite_rate based on remaining budget\n            self.elite_rate = max(0.1, 0.3 - 0.2 * (evaluations / self.budget))\n            \n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Changed scaling factor from 0.8 to 0.9\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Introduces a dynamic elite_rate to adaptively control exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "48765f6b-f477-4988-9e15-c3028b3e4ccd", "metadata": {}, "mutation_prompt": null}
{"id": "f31fa2a7-4a60-492a-b656-86037538bfce", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 1.1 * (b - c), lb, ub)  # Changed scaling factor from 0.9 to 1.1\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Refined mutation strategy by adjusting the scaling factor for enhanced exploration.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "48765f6b-f477-4988-9e15-c3028b3e4ccd", "metadata": {}, "mutation_prompt": null}
{"id": "c5840f3c-0c48-421d-aaef-b5756f15bce2", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00005  # Convergence constant - Changed from 0.00001 to 0.00005\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.95 * (b - c), lb, ub)  # Changed scaling factor from 0.9 to 0.95\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Enhanced mutation strategy and convergence constant for improved exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "48765f6b-f477-4988-9e15-c3028b3e4ccd", "metadata": {}, "mutation_prompt": null}
{"id": "a8b8fb51-0572-4322-b881-857317e8a479", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.85 * (b - c), lb, ub)  # Modified scaling factor from 0.9 to 0.85\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Enhanced mutation strategy to improve convergence by adapting the differential weight.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "48765f6b-f477-4988-9e15-c3028b3e4ccd", "metadata": {}, "mutation_prompt": null}
{"id": "a0b2e60f-69ba-4759-86fd-72a5a10bec7a", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Adjust elite_rate adaptively based on evaluations\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                if elite_count < 3:  # Ensure there are at least 3 solutions to select\n                    continue\n                a, b, c = np.random.choice(elite_solutions, 3, replace=False)\n                adaptive_factor = 0.5 + 0.4 * (1 - evaluations / self.budget)\n                mutant = np.clip(a + adaptive_factor * (b - c), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Enhanced the mutation strategy by introducing an adaptive scaling factor and improved selection mechanism to mitigate ValueError.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "b103b756-167d-4302-977f-94deefd8ebf1", "metadata": {}, "mutation_prompt": null}
{"id": "5f472dd5-8141-4867-8182-b201764bb721", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Adjust elite_rate adaptively based on evaluations\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                indices = np.random.choice(elite_count, 3, replace=False)  # Ensuring distinct indices\n                a, b, c = elite_solutions[indices]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Changed scaling factor from 0.8 to 0.9\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Enhances robustness by ensuring distinct indices for mutation in Differential Evolution step.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b103b756-167d-4302-977f-94deefd8ebf1", "metadata": {}, "mutation_prompt": null}
{"id": "bc7593e3-8bd3-448a-8552-5edad2a6338b", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Adjust elite_rate adaptively based on evaluations\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(np.arange(len(elite_solutions)), 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Changed scaling factor from 0.8 to 0.9\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Adjusted DE mutation process to account for elite pool size constraints safely.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b103b756-167d-4302-977f-94deefd8ebf1", "metadata": {}, "mutation_prompt": null}
{"id": "1d51dd11-3347-4b07-8a3c-398a6e6d5dff", "solution": "import numpy as np\n\nclass HybridGOA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Number of grasshoppers\n        self.c = 0.00001  # Convergence constant\n        self.f_min, self.f_max = 0.00001, 1.0  # Attraction intensity range\n        self.elite_rate = 0.2  # The proportion of elite solutions for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Adjust elite_rate adaptively based on evaluations\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            # Differential Evolution step on the top elite_rate percent solutions\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n            for idx in elite_indices:\n                if elite_count > 2:  # Fix for sampling issue\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                else:  # If elite_count <= 2, select with replacement\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=True)]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE", "description": "Fix sampling issue in Differential Evolution by ensuring unique elite indices selection.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "b103b756-167d-4302-977f-94deefd8ebf1", "metadata": {}, "mutation_prompt": null}
{"id": "298c5a59-fbc5-4997-af4f-ed75e3b2145e", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhanced strategy by introducing a local search mechanism and random perturbation to improve exploration.", "configspace": "", "generation": 3, "fitness": 0.7369220468926004, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.737 with standard deviation 0.054. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "b103b756-167d-4302-977f-94deefd8ebf1", "metadata": {"aucs": [0.6816331241193212, 0.8095860045519132, 0.719547012006567], "final_y": [0.20668317599100927, 0.1502291693949065, 0.19074850244259733]}, "mutation_prompt": null}
{"id": "493ecb9b-d9e9-4c67-8c67-f3f64210b1fc", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Integrate adaptive mutation scaling and crossover rate adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.782183067926824, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.782 with standard deviation 0.028. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "298c5a59-fbc5-4997-af4f-ed75e3b2145e", "metadata": {"aucs": [0.7434032359786233, 0.8086043457839917, 0.7945416220178569], "final_y": [0.15481203191502957, 0.15453994626470802, 0.1528383892419577]}, "mutation_prompt": null}
{"id": "83a1231e-9a27-4cd3-ab40-a861234df750", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                # Modified line: Adjusting perturbation scale dynamically based on current evaluation progress\n                if np.random.rand() < 0.1:\n                    perturbation_scale = 1.0 - evaluations / self.budget\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim) * perturbation_scale\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhanced local search through dynamic perturbation to improve convergence.", "configspace": "", "generation": 4, "fitness": 0.7592258837618125, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.759 with standard deviation 0.030. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "298c5a59-fbc5-4997-af4f-ed75e3b2145e", "metadata": {"aucs": [0.7220936730491144, 0.7951403121891814, 0.7604436660471416], "final_y": [0.1868736659888427, 0.15845777309069975, 0.17138619826231527]}, "mutation_prompt": null}
{"id": "e356110b-fcc3-4537-9fbb-4d7b8afeb5ab", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + f * (b - c), lb, ub)  # Adjust mutation strength\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + f * (b - a), lb, ub)  # Adjust mutation strength\n\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim) * f  # Adaptive perturbation\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introducing adaptive mutation strategy and learning rate adjustment for enhanced exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.7415651431517946, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.742 with standard deviation 0.022. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "298c5a59-fbc5-4997-af4f-ed75e3b2145e", "metadata": {"aucs": [0.7193204038117725, 0.7706396644925038, 0.7347353611511072], "final_y": [0.1856185088876986, 0.16928513284658797, 0.1832796449656151]}, "mutation_prompt": null}
{"id": "3c9a63b0-042b-4fab-8f37-b597c60acc08", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c) * (evaluations / self.budget), lb, ub)  # Changed line\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Fine-tuned mutation factor for better convergence by changing from a constant to a dynamic adjustment based on evaluations.", "configspace": "", "generation": 4, "fitness": 0.774806326176384, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.018. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "298c5a59-fbc5-4997-af4f-ed75e3b2145e", "metadata": {"aucs": [0.770308298403766, 0.7982183142346017, 0.7558923658907845], "final_y": [0.16702043732174343, 0.15786522717129492, 0.17376407542481442]}, "mutation_prompt": null}
{"id": "d6821ecf-cb48-4c52-836b-e97ed0fa22a4", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Refined elite solution selection and perturbation mechanism for improved exploitation and exploration balance.", "configspace": "", "generation": 4, "fitness": 0.7616638130451491, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.762 with standard deviation 0.015. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "298c5a59-fbc5-4997-af4f-ed75e3b2145e", "metadata": {"aucs": [0.7450780353389552, 0.7808949589934941, 0.759018444802998], "final_y": [0.1773067204411064, 0.16465530084836866, 0.17207083957985636]}, "mutation_prompt": null}
{"id": "fd7a5af5-d1f6-424d-a1a2-aab43cd74d30", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.population_size = max(4, int(20 - 18 * (evaluations / self.budget)))  # Dynamic population size\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduced dynamic population size adjustment to enhance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 5, "fitness": 0.7657618559077871, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.038. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "493ecb9b-d9e9-4c67-8c67-f3f64210b1fc", "metadata": {"aucs": [0.7219602600259484, 0.8148208120249055, 0.7605044956725073], "final_y": [0.18751921331316834, 0.1457574938297891, 0.1677047913717047]}, "mutation_prompt": null}
{"id": "9df17521-794e-4fa4-aa5d-0697dfaf6014", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    scale_factor = 0.8 + 0.2 * np.random.rand()  # Line changed\n                    mutant = np.clip(a + scale_factor * (b - c), lb, ub)  # Line changed\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    scale_factor = 0.8 + 0.2 * np.random.rand()  # Line changed\n                    mutant = np.clip(a + scale_factor * (b - a), lb, ub)  # Line changed\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation_factor = np.exp(-evaluations / self.budget)  # Line changed\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim) * perturbation_factor  # Line changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive scaling factor and dynamic elite perturbation to enhance convergence and solution quality.", "configspace": "", "generation": 5, "fitness": 0.7934668225567322, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.010. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "493ecb9b-d9e9-4c67-8c67-f3f64210b1fc", "metadata": {"aucs": [0.7898444306921864, 0.8077191943152294, 0.7828368426627811], "final_y": [0.14961631128535358, 0.14767609802637083, 0.15983795518979882]}, "mutation_prompt": null}
{"id": "cbf205b0-b6ae-42ec-848e-c3d56ca67a6b", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Increased perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Enhanced perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Integrate dynamic population size adjustment and elite preservation mechanism for enhanced adaptability and convergence.", "configspace": "", "generation": 5, "fitness": 0.7960062951317998, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.024. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "493ecb9b-d9e9-4c67-8c67-f3f64210b1fc", "metadata": {"aucs": [0.7642363315991408, 0.8229955784304653, 0.8007869753657935], "final_y": [0.16448197723869618, 0.14511910043460652, 0.14813625721469037]}, "mutation_prompt": null}
{"id": "f837d760-b070-45ea-8fe0-ef1b65b93cfa", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[np.random.choice(elite_indices, elite_count, replace=False)]  # changed line\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation_scale = 0.2 * (1 - evaluations / self.budget)  # changed line\n                    perturbation = np.random.uniform(-perturbation_scale, perturbation_scale, self.dim)  # changed line\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce stochastic elite selection and adaptive perturbation for enhanced diversity and convergence.", "configspace": "", "generation": 5, "fitness": 0.7725449226312916, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.773 with standard deviation 0.040. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "493ecb9b-d9e9-4c67-8c67-f3f64210b1fc", "metadata": {"aucs": [0.739190570083656, 0.829185183584374, 0.7492590142258451], "final_y": [0.17999561770293016, 0.14376778024642334, 0.17373599840620513]}, "mutation_prompt": null}
{"id": "08000ff1-9ffc-48ef-8189-b791bdacb51a", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            ranked_indices = np.argsort(new_fitness)\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c), lb, ub)  # Changed mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)  # Changed mutation factor\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[ranked_indices[idx]])  # Changed trial selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce rank-based selection and adaptive elite mutation to enhance convergence in HybridGOA_DE_Enhanced algorithm.", "configspace": "", "generation": 5, "fitness": 0.7612900924173229, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.761 with standard deviation 0.026. And the mean value of best solutions found was 0.162 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "493ecb9b-d9e9-4c67-8c67-f3f64210b1fc", "metadata": {"aucs": [0.7539038261267033, 0.7959077782189264, 0.7340586729063392], "final_y": [0.16360912598004296, 0.1504393512202603, 0.17243716003233533]}, "mutation_prompt": null}
{"id": "5433bfc5-205d-47a7-98ca-57efb961215d", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    scale = 0.5 + 0.4 * (1 - evaluations / self.budget)\n                    mutant = np.clip(a + scale * (b - c), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:  # Adjusted perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Enhanced perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance convergence by introducing adaptive mutation scaling and stochastic perturbation for robust global search.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'mutant' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'mutant' where it is not associated with a value\")", "parent_id": "cbf205b0-b6ae-42ec-848e-c3d56ca67a6b", "metadata": {}, "mutation_prompt": null}
{"id": "78f60116-7a9a-46a0-a54e-429dba9dae16", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c), lb, ub)  # Adjusted scaling factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)  # Adjusted scaling factor\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))  # Modified crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:  # Adjusted perturbation chance\n                    perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Enhanced perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introducing adaptive scaling factor and crossover rate refinement for enhanced search capability and convergence in HybridGOA_DE_Enhanced.", "configspace": "", "generation": 6, "fitness": 0.7722281837076798, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.772 with standard deviation 0.038. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "cbf205b0-b6ae-42ec-848e-c3d56ca67a6b", "metadata": {"aucs": [0.7708199994148788, 0.8194058718556604, 0.7264586798525003], "final_y": [0.15188145481029236, 0.1451144453371065, 0.18498692728465427]}, "mutation_prompt": null}
{"id": "9a037419-ad49-4300-8d73-38e86fc8dbc0", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)  # Adjusted mutation factor\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:  # Increased perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive mutation strategies and dynamic perturbation control to enhance exploration and convergence efficiency.", "configspace": "", "generation": 6, "fitness": 0.810095986700691, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.021. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "cbf205b0-b6ae-42ec-848e-c3d56ca67a6b", "metadata": {"aucs": [0.8257902404211298, 0.8239225085009385, 0.7805752111800046], "final_y": [0.13382579164599306, 0.14324724967871227, 0.15933753872017975]}, "mutation_prompt": null}
{"id": "4e2c36fd-cdce-4a81-a8f0-2ee90f067a60", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Increased perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Enhanced perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance the algorithm by minimizing evaluation count in differential evolution for improved efficiency.", "configspace": "", "generation": 6, "fitness": 0.7660447308724434, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.023. And the mean value of best solutions found was 0.164 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "cbf205b0-b6ae-42ec-848e-c3d56ca67a6b", "metadata": {"aucs": [0.739235546855417, 0.796380776097289, 0.7625178696646242], "final_y": [0.1727069883674569, 0.15664875064145034, 0.16331451178609213]}, "mutation_prompt": null}
{"id": "020d00b8-0bc1-4839-93e6-38dd3f3555b1", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < (0.2 * (1 - evaluations / self.budget)):  # Dynamic perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Enhanced perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic strategy for perturbation probability based on the optimization progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.7961031217205083, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.028. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "cbf205b0-b6ae-42ec-848e-c3d56ca67a6b", "metadata": {"aucs": [0.7662024601780663, 0.8343873139763638, 0.7877195910070948], "final_y": [0.16288881164124513, 0.13691295763287026, 0.13962304882468535]}, "mutation_prompt": null}
{"id": "7ead6e22-0ab1-4c2a-93c1-7b694a459096", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)  # Adjusted mutation factor\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:  # Increased perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) * (1 - evaluations / self.budget)  # Dynamic perturbation factor\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic and adaptive perturbation factor to enhance local search capability.", "configspace": "", "generation": 7, "fitness": 0.7801084897160323, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.780 with standard deviation 0.032. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "9a037419-ad49-4300-8d73-38e86fc8dbc0", "metadata": {"aucs": [0.7499771998169065, 0.8248302505600822, 0.7655180187711083], "final_y": [0.17277530513070227, 0.1431819211640597, 0.1657071256015109]}, "mutation_prompt": null}
{"id": "338c8bab-69a0-45e6-98b3-6079cb0feeab", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Changed population size for enhanced diversity\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.25  # Changed initial elite rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.15, 0.25 * (1 - evaluations / self.budget))  # Adjusted elite adaptation\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.85 * (b - c), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.85 * (b - a), lb, ub)  # Adjusted mutation factor\n\n                cr = 0.75 - (0.65 * (evaluations / self.budget))  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.35:  # Increased perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Dual-phase perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Integrate adaptive elite strategies and dual-phase perturbation to enhance exploration and convergence in black box optimization.", "configspace": "", "generation": 7, "fitness": 0.7788680202464556, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.053. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "9a037419-ad49-4300-8d73-38e86fc8dbc0", "metadata": {"aucs": [0.7683873997431212, 0.8488347261737748, 0.7193819348224707], "final_y": [0.15584668587467743, 0.1357207315393365, 0.19086865315937684]}, "mutation_prompt": null}
{"id": "d855fbf6-c13a-45cf-96bc-13ebb9d8760c", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                stochastic_perturbation = np.random.randn(self.dim) * 0.05  # Added stochastic perturbation\n                new_position = c_i * s_i + population[i] + stochastic_perturbation\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.15, 0.2 * (1 - evaluations / self.budget))  # Increased minimum elite rate\n            elite_count = max(2, int(self.population_size * self.elite_rate))  # Ensured more elite members\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Increased mutation factor\n\n                cr = 0.75 - (0.6 * (evaluations / self.budget))  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.35:  # Increased perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Adjusted perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance exploration by introducing stochastic differential perturbations and refining selection pressure to improve convergence.", "configspace": "", "generation": 7, "fitness": 0.7940801371644816, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.014. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "9a037419-ad49-4300-8d73-38e86fc8dbc0", "metadata": {"aucs": [0.8116472206763428, 0.7935611969446936, 0.7770319938724081], "final_y": [0.14431143165865323, 0.15689751806589147, 0.16233418583809234]}, "mutation_prompt": null}
{"id": "5beb5b03-5625-43ff-b201-e27cefa3fbc2", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 1.5)  # Changed here: Adjusting power for c_i\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.05, 0.2 * (1 - evaluations / self.budget))  # Changed here: Lowered min elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.9 * (b - c), lb, ub)  # Changed here: Increased mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)  # Changed here: Increased mutation factor\n\n                cr = 0.7 - (0.6 * (evaluations / self.budget))  # Changed here: Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.35:  # Changed here: Increased perturbation chance\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # Changed here: Adjusted perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population  # Preserve elite solutions\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive parameter scaling and dynamic elitism to enhance convergence and robustness in diverse environments.", "configspace": "", "generation": 7, "fitness": 0.7753565099792493, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.040. And the mean value of best solutions found was 0.162 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "9a037419-ad49-4300-8d73-38e86fc8dbc0", "metadata": {"aucs": [0.7213871990613159, 0.8181431344922612, 0.7865391963841708], "final_y": [0.18510964193452117, 0.1418567641728139, 0.15785836119590335]}, "mutation_prompt": null}
{"id": "1aba6713-2c69-44ca-b7a5-91d6f182f474", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c) * np.sqrt(evaluations / self.budget), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a non-linear adaptive mutation and a decaying perturbation strategy to boost convergence.", "configspace": "", "generation": 7, "fitness": 0.8165758490480798, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.019. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "9a037419-ad49-4300-8d73-38e86fc8dbc0", "metadata": {"aucs": [0.7933343629612096, 0.8386751286599021, 0.8177180555231277], "final_y": [0.15608719151405637, 0.13605308299769803, 0.14652779794573312]}, "mutation_prompt": null}
{"id": "51e240b3-0594-49be-9a23-954b25f61c68", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20  # Adjusted for dynamic population size\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size  # Dynamic adjustment starts here\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c) * np.sqrt(evaluations / self.budget), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n            # Dynamically adjust population size based on convergence rate\n            if evaluations / self.budget > 0.5:\n                population_size = max(10, int(self.initial_population_size * (1 + 0.5 * (1 - evaluations / self.budget))))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic population size that adapts based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "1aba6713-2c69-44ca-b7a5-91d6f182f474", "metadata": {}, "mutation_prompt": null}
{"id": "c87ebd01-3841-4b9e-8c72-cf4c87d333e2", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += population_size\n\n            population_size = max(10, int(self.initial_population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c) * np.sqrt(evaluations / self.budget), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + np.random.uniform(0.5, 0.9) * (b - a), lb, ub)  # Diversified mutation factor\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce dynamic population size adjustment and diversified mutation strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.7469053359488519, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.747 with standard deviation 0.052. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "1aba6713-2c69-44ca-b7a5-91d6f182f474", "metadata": {"aucs": [0.7008197600085115, 0.8196210893379761, 0.7202751585000683], "final_y": [0.19741484533079057, 0.14914763758995309, 0.19031120907896848]}, "mutation_prompt": null}
{"id": "3e86fb66-3495-4982-96ef-2e562e47996c", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate * (1 + np.std(fitness) / np.mean(fitness))))  # Adjusted elite count\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c) * np.sqrt(evaluations / self.budget), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic elite strategy to adaptively adjust the number of elite solutions based on convergence rate.", "configspace": "", "generation": 8, "fitness": 0.7429008590837372, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.743 with standard deviation 0.041. And the mean value of best solutions found was 0.180 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "1aba6713-2c69-44ca-b7a5-91d6f182f474", "metadata": {"aucs": [0.7093333831070547, 0.8001415478578617, 0.719227646286295], "final_y": [0.19331546558243895, 0.15681198860081047, 0.19094227512994033]}, "mutation_prompt": null}
{"id": "b4d5048d-2be5-4f60-9331-bc45e3d444da", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand()) * (b - c), lb, ub)  # Dynamic mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive elite selection and dynamic mutation factor scaling to improve convergence and solution quality.", "configspace": "", "generation": 8, "fitness": 0.8125940143899801, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.032. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "1aba6713-2c69-44ca-b7a5-91d6f182f474", "metadata": {"aucs": [0.8301161837800952, 0.839769432833005, 0.7678964265568401], "final_y": [0.13628370148983027, 0.14226483349363028, 0.16859518214084113]}, "mutation_prompt": null}
{"id": "f23a1abe-40af-4b15-95f6-b3c7caee9118", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.2 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9) # New line\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.5 + 0.3 * fitness_diversity) * (b - c), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget)) * fitness_diversity  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance exploitation by introducing dynamic crossover and adaptive mutation based on fitness diversity.", "configspace": "", "generation": 8, "fitness": 0.7978130405222537, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.008. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "1aba6713-2c69-44ca-b7a5-91d6f182f474", "metadata": {"aucs": [0.7994474832903327, 0.8063103695534785, 0.7876812687229496], "final_y": [0.14957327468888604, 0.1540466649640263, 0.1590075936265205]}, "mutation_prompt": null}
{"id": "0c74033a-817c-4a00-8a98-4e92c881732c", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand()) * (b - c), lb, ub)  # Dynamic mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive crossover probability scaling to improve exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.8396585806709824, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.009. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "b4d5048d-2be5-4f60-9331-bc45e3d444da", "metadata": {"aucs": [0.8449525206207469, 0.8466422387637935, 0.8273809826284068], "final_y": [0.1280462315450671, 0.1360775454780656, 0.13869105013670102]}, "mutation_prompt": null}
{"id": "28d0beda-96a6-4d66-9376-81b5b2f7f998", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.25 * (1 - evaluations / self.budget))  # Slightly reduced elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.85 + 0.15 * np.random.rand()) * (b - c), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Improve performance by refining elite selection criteria and dynamic mutation factor adjustment.", "configspace": "", "generation": 9, "fitness": 0.8043003272794599, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.018. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "b4d5048d-2be5-4f60-9331-bc45e3d444da", "metadata": {"aucs": [0.789421084402461, 0.793982949989742, 0.8294969474461766], "final_y": [0.14991144885148244, 0.15097222991610904, 0.13751479783040144]}, "mutation_prompt": null}
{"id": "38b94af6-ed30-424a-b044-f2b6a529ed03", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    fitness_diff = np.abs(new_fitness[idx] - np.min(fitness))\n                    mutation_factor = 0.8 + 0.4 * (fitness_diff / (np.max(fitness) - np.min(fitness) + 1e-9))\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)  # Fitness-based adaptive mutation\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce fitness-based adaptive mutation to enhance exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.804494345561045, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.011. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "b4d5048d-2be5-4f60-9331-bc45e3d444da", "metadata": {"aucs": [0.7973576433283167, 0.8193432302831685, 0.7967821630716496], "final_y": [0.1447272710616585, 0.13384544183274305, 0.13467724095087819]}, "mutation_prompt": null}
{"id": "342d7c68-f5a5-4d36-accf-4c0d75eddcaf", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.9 + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adjusted mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.4 * (1 - evaluations / self.budget):  # Adjusted perturbation chance\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Increased perturbation range\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Integrate self-adaptive learning rates and improved diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8115325731015988, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.020. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b4d5048d-2be5-4f60-9331-bc45e3d444da", "metadata": {"aucs": [0.7832159553784899, 0.8228093761683368, 0.8285723877579698], "final_y": [0.14961800193694885, 0.14303427241796896, 0.13093786148707676]}, "mutation_prompt": null}
{"id": "b4a1c707-ec6b-4410-8d74-c7215f5e49a9", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.9 + 0.3 * np.random.rand()) * (b - c), lb, ub)  # Aggressive mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.8 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a more aggressive mutation factor scaling at later stages to enhance exploration.", "configspace": "", "generation": 9, "fitness": 0.8024415115611258, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.802 with standard deviation 0.007. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "b4d5048d-2be5-4f60-9331-bc45e3d444da", "metadata": {"aucs": [0.7963187237753417, 0.7994819024392621, 0.8115239084687733], "final_y": [0.1418626450853382, 0.1438603562238111, 0.15194899706669074]}, "mutation_prompt": null}
{"id": "07d1c2d8-38a9-4ae8-a9db-a5fecd3db409", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand() + 0.05 * np.random.randn()) * (b - c), lb, ub)  # Dynamic mutation factor with slight randomness\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a small exploration boost by adding slight randomness to the dynamic mutation factor.", "configspace": "", "generation": 10, "fitness": 0.7979181899505218, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.014. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "0c74033a-817c-4a00-8a98-4e92c881732c", "metadata": {"aucs": [0.7780407948535678, 0.8059576074985819, 0.8097561674994159], "final_y": [0.15298593965349983, 0.13042261516693332, 0.14604193590383685]}, "mutation_prompt": null}
{"id": "da3b7dd9-2485-420a-8dfa-903fcd71c536", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand()) * (b - c), lb, ub)  # Dynamic mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    elite_attraction = 0.1 * (population[elite_indices[0]] - new_population[i])  # Attraction to best elite\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) + elite_attraction\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce elite-solution attraction for enhanced convergence in HybridGOA_DE_Enhanced.", "configspace": "", "generation": 10, "fitness": 0.7804427957910244, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.780 with standard deviation 0.027. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "0c74033a-817c-4a00-8a98-4e92c881732c", "metadata": {"aucs": [0.8096508322569117, 0.7866630476011448, 0.7450145075150163], "final_y": [0.1347416575627809, 0.15073432260401098, 0.16276677765435021]}, "mutation_prompt": null}
{"id": "013fb95a-5534-4252-b1f8-d692c19ebea8", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))) * (b - c), lb, ub)  # Dynamic mutation factor based on fitness\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic mutation strategy based on current fitness to enhance adaptation and convergence. ", "configspace": "", "generation": 10, "fitness": 0.8082307688564576, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.036. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "0c74033a-817c-4a00-8a98-4e92c881732c", "metadata": {"aucs": [0.8591480354579758, 0.7884291613350938, 0.7771151097763036], "final_y": [0.13092617411869556, 0.14925926920668142, 0.15717485468138515]}, "mutation_prompt": null}
{"id": "be63293d-8b44-4181-bed0-3f25f306bc43", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n            new_population = np.zeros_like(population)\n\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.4 * np.random.rand()) * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            if np.random.rand() < 0.5 * (1 - evaluations / self.budget):\n                for i in range(self.population_size):\n                    perturbation = np.random.uniform(-0.15, 0.15, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            if evaluations < self.budget * 0.75:  # Dynamic population management\n                self.population_size = min(50, self.population_size + 1)\n                additional_population = np.random.uniform(lb, ub, (1, self.dim))\n                new_population = np.vstack((new_population, additional_population))\n                new_fitness = np.append(new_fitness, func(additional_population[0]))\n                evaluations += 1\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce dynamic population management and diversity preservation for enhanced exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.7728797290931325, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.773 with standard deviation 0.033. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "0c74033a-817c-4a00-8a98-4e92c881732c", "metadata": {"aucs": [0.7292420986905813, 0.8076870285483417, 0.7817100600404745], "final_y": [0.16391255947681693, 0.13949548320925464, 0.14605371847271154]}, "mutation_prompt": null}
{"id": "75111f6d-f06d-4f24-a027-9148cdf17939", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand()) * (b - c), lb, ub)  # Dynamic mutation factor\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation_strength = 0.25 * (1 - evaluations / self.budget)  # Self-adaptive perturbation strength\n                    perturbation = np.random.uniform(-perturbation_strength, perturbation_strength, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Implement a self-adaptive perturbation strength based on the generations to improve solution exploration.", "configspace": "", "generation": 10, "fitness": 0.783908399328857, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.033. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "0c74033a-817c-4a00-8a98-4e92c881732c", "metadata": {"aucs": [0.7383765979883797, 0.8006724783251836, 0.8126761216730077], "final_y": [0.1625354371697807, 0.149252454437517, 0.1394282821685745]}, "mutation_prompt": null}
{"id": "343bde4d-760a-4b10-b4b1-bd89461ed899", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Integrate an adaptive exploration-exploitation trade-off mechanism to enhance solution diversity and convergence rate.", "configspace": "", "generation": 11, "fitness": 0.8126927077018964, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.022. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "013fb95a-5534-4252-b1f8-d692c19ebea8", "metadata": {"aucs": [0.7829398825610446, 0.8210924393536684, 0.8340458011909762], "final_y": [0.15441755856996597, 0.14115789384066335, 0.12655347515677096]}, "mutation_prompt": null}
{"id": "56032949-c1cb-4ea8-ad30-84f98a864a2c", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))) * (b - c), lb, ub)  # Dynamic mutation factor based on fitness\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            # Introduce small random perturbation to elite solutions\n            new_population[elite_indices] += np.random.uniform(-0.01, 0.01, new_population[elite_indices].shape)\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance exploration by introducing a small random perturbation to elite solutions for greater diversity.", "configspace": "", "generation": 11, "fitness": 0.7999342811714792, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.048. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "013fb95a-5534-4252-b1f8-d692c19ebea8", "metadata": {"aucs": [0.8097426322780858, 0.8537134593655343, 0.7363467518708174], "final_y": [0.14516341733775062, 0.13679857039467236, 0.17415981850383366]}, "mutation_prompt": null}
{"id": "3dd006b1-b0ac-4562-9620-f070834735ed", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                diversity_factor = np.std(fitness) / (np.mean(fitness) + 1e-9)  # Adaptive scaling based on diversity\n                new_position = (c_i * s_i + population[i]) * diversity_factor  # Apply diversity factor\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))) * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Refine mutation by introducing adaptive scaling based on population diversity and dynamic inertia weight.", "configspace": "", "generation": 11, "fitness": 0.7758267677122145, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.776 with standard deviation 0.037. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "013fb95a-5534-4252-b1f8-d692c19ebea8", "metadata": {"aucs": [0.7237288571738091, 0.8082891774867793, 0.795462268476055], "final_y": [0.18799222648755443, 0.13950952065859157, 0.15152192685282218]}, "mutation_prompt": null}
{"id": "44e890a6-6e7d-4fd8-a166-7bfc6f889cb2", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))  # Increased elite rate\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))) * (b - c), lb, ub)  # Dynamic mutation factor based on fitness\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))  # Adaptive crossover probability scaling\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                perturb_scale = 0.25 * (0.5 + 0.5 * (evaluations / self.budget))  # Adaptive scaling of perturbation\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):  # Decaying perturbation chance\n                    perturbation = np.random.uniform(-perturb_scale, perturb_scale, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive scaling of perturbation based on the remaining budget to enhance exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.8081293640352915, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.023. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "013fb95a-5534-4252-b1f8-d692c19ebea8", "metadata": {"aucs": [0.8221975672971726, 0.8259922018765027, 0.7761983229321994], "final_y": [0.13186683053529058, 0.1342690402695229, 0.14939195268717675]}, "mutation_prompt": null}
{"id": "481abce2-2374-4290-bf61-8b6338cad0ba", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget ** 0.5))  # Dynamic elite rate adjustment\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutant = np.clip(a + (0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))) * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n            \n            for i in range(self.population_size):\n                if np.random.rand() < 0.3 * (1 - evaluations / self.budget):\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Incorporate a dynamic elite selection strategy to balance exploration and exploitation by adapting the elite rate more frequently.", "configspace": "", "generation": 11, "fitness": 0.775573417722689, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.776 with standard deviation 0.018. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "013fb95a-5534-4252-b1f8-d692c19ebea8", "metadata": {"aucs": [0.7522896145982481, 0.795350922914039, 0.7790797156557798], "final_y": [0.17081660639543406, 0.15521195850244396, 0.14543715858335682]}, "mutation_prompt": null}
{"id": "a121ca32-0d5f-46f0-a55e-05ad899daf29", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.2 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.normal(0, 0.1, self.dim)  # Changed from uniform to normal distribution\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce Gaussian perturbation in the exploration phase to enhance solution robustness and convergence.", "configspace": "", "generation": 12, "fitness": 0.8029840519538306, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.016. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "343bde4d-760a-4b10-b4b1-bd89461ed899", "metadata": {"aucs": [0.8038676839929348, 0.8215218158496115, 0.7835626560189459], "final_y": [0.14116149543278578, 0.14592645044572972, 0.1561774816984507]}, "mutation_prompt": null}
{"id": "8485c39c-3c3c-4a46-a47b-0514150764a9", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.25 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance convergence by introducing dynamic mutation factors and improved exploration mechanisms.", "configspace": "", "generation": 12, "fitness": 0.8156492085686123, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.012. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "343bde4d-760a-4b10-b4b1-bd89461ed899", "metadata": {"aucs": [0.8268765956912779, 0.8210226809478025, 0.7990483490667566], "final_y": [0.1321465979489892, 0.1384617508198871, 0.13708419780165526]}, "mutation_prompt": null}
{"id": "8ecb22d4-a8fd-407f-9974-61867019997b", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.15 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))  # Changed line\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.6 * (evaluations / self.budget))  # Changed line\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive mutation and crossover rates to enhance the diversity and convergence speed of the optimization process.", "configspace": "", "generation": 12, "fitness": 0.7843746389944563, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.032. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "343bde4d-760a-4b10-b4b1-bd89461ed899", "metadata": {"aucs": [0.7538813203207827, 0.8278954162948622, 0.7713471803677239], "final_y": [0.16520784243199493, 0.13299751129848303, 0.1586692842091959]}, "mutation_prompt": null}
{"id": "b0a2673f-ddba-4256-a6e2-439785a9ea75", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.9 + 0.1 * np.random.rand() * (1 - fitness[idx]/np.max(fitness))\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.95 - (0.7 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Slightly adjust mutation and crossover rates to balance exploration and exploitation effectively.", "configspace": "", "generation": 12, "fitness": 0.8027622470721552, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.023. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "343bde4d-760a-4b10-b4b1-bd89461ed899", "metadata": {"aucs": [0.7769979107508693, 0.7981970845681072, 0.8330917458974889], "final_y": [0.1518226298546964, 0.15185411051359354, 0.13212789041051332]}, "mutation_prompt": null}
{"id": "0be8eb1b-17cc-4551-b68b-2532b2ded92d", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)  # Modified line\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic mutation factor based on the fitness variance to improve exploration and convergence balance.", "configspace": "", "generation": 12, "fitness": 0.8194461032508539, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.006. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "343bde4d-760a-4b10-b4b1-bd89461ed899", "metadata": {"aucs": [0.8202173680167038, 0.8259025656055015, 0.8122183761303567], "final_y": [0.13644844226501074, 0.14046448191273198, 0.13424386913196962]}, "mutation_prompt": null}
{"id": "94cc7e86-3e6b-4036-8e58-77e2779061f6", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * (np.std(fitness) / (np.mean(fitness) + 1e-9))  # Modified line\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Modify the dynamic mutation factor to enhance exploration and convergence based on both fitness variance and relative improvement.", "configspace": "", "generation": 13, "fitness": 0.8122760791980409, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.021. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "0be8eb1b-17cc-4551-b68b-2532b2ded92d", "metadata": {"aucs": [0.8088625417307502, 0.8395095260636651, 0.7884561697997075], "final_y": [0.13890671710440716, 0.1317512110410528, 0.1478349049558495]}, "mutation_prompt": null}
{"id": "5d756adf-d481-4037-a367-8fd81dc89dd4", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * (np.std(fitness) + 0.1 * (np.mean(fitness) - fitness[idx]))  # Modified line\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance mutation adaptability by adjusting the mutation factor based on the fitness variance and trend direction, improving convergence.", "configspace": "", "generation": 13, "fitness": 0.8037218269967505, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.012. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "0be8eb1b-17cc-4551-b68b-2532b2ded92d", "metadata": {"aucs": [0.8167025912272716, 0.8058860857168982, 0.7885768040460819], "final_y": [0.14716388541168013, 0.13427905884304914, 0.1504153651532817]}, "mutation_prompt": null}
{"id": "3e4acc6a-ab3b-4c11-9d51-c205ff2703de", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)  # Modified line\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a scaling factor to the mutation step size to better adapt to the problem landscape.", "configspace": "", "generation": 13, "fitness": 0.8304937314420063, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.003. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "0be8eb1b-17cc-4551-b68b-2532b2ded92d", "metadata": {"aucs": [0.8258473008824125, 0.8333403936934839, 0.8322934997501226], "final_y": [0.13911683632532024, 0.12915027619833375, 0.1341804322006137]}, "mutation_prompt": null}
{"id": "69542e5b-8436-41c8-920d-cf9f4275d28c", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)  # Modified line\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.7 + 0.2 * (1 - evaluations / self.budget)  # Modified line\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic crossover rate and elitism threshold based on the budget to enhance adaptability and convergence.", "configspace": "", "generation": 13, "fitness": 0.818714942822781, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.025. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "0be8eb1b-17cc-4551-b68b-2532b2ded92d", "metadata": {"aucs": [0.7887837481586635, 0.8499537795572604, 0.8174073007524194], "final_y": [0.15100381529811202, 0.13410453082620277, 0.14811276913598492]}, "mutation_prompt": null}
{"id": "553ae72d-3f39-4023-abe5-4b4f089b6756", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = (0.8 + 0.5 * np.std(fitness)) * (1 - evaluations / self.budget)  # Modified line\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive mutation factor scaling based on evaluation progress to balance exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.8078875237330391, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.024. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "0be8eb1b-17cc-4551-b68b-2532b2ded92d", "metadata": {"aucs": [0.8348104528317363, 0.8123295996422556, 0.7765225187251253], "final_y": [0.12942256657578666, 0.1471720799041054, 0.1595158114463151]}, "mutation_prompt": null}
{"id": "3be84df2-a399-47d4-baf3-a685ad6810b4", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)  # Modified line\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget) * np.random.rand()  # Adjusted line\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Incorporate a variable exploration factor to enhance solution diversity and convergence timing.", "configspace": "", "generation": 14, "fitness": 0.8162283535559189, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.013. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "3e4acc6a-ab3b-4c11-9d51-c205ff2703de", "metadata": {"aucs": [0.8034754741194002, 0.834490633458703, 0.8107189530896535], "final_y": [0.1453210244104285, 0.1419839356542998, 0.13451795824444102]}, "mutation_prompt": null}
{"id": "9597e89e-1416-4fb2-99d4-74890a37384f", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) * diversity  # Adjust perturbation\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Incorporate adaptive exploration by adjusting the perturbation based on the population's diversity to enhance global search capabilities.", "configspace": "", "generation": 14, "fitness": 0.8428344089470734, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.026. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "3e4acc6a-ab3b-4c11-9d51-c205ff2703de", "metadata": {"aucs": [0.8311197185776582, 0.81907142744002, 0.8783120808235421], "final_y": [0.1319556172902463, 0.13363938430865452, 0.12283256324675873]}, "mutation_prompt": null}
{"id": "8cb02fbb-342a-4e3d-a103-060ba29526bd", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget)) + 0.1 * np.mean(np.std(population, axis=0))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget) + 0.1 * np.std(fitness)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Integrate a dynamic crossover rate and adaptive exploration based on population diversity to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": 0.7851038947678693, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.031. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "3e4acc6a-ab3b-4c11-9d51-c205ff2703de", "metadata": {"aucs": [0.7471166070657216, 0.8236456164132336, 0.7845494608246529], "final_y": [0.1750835067379224, 0.13778427257794923, 0.1462001565169888]}, "mutation_prompt": null}
{"id": "f5f334ba-2470-4690-84f2-227eb2b1fb23", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)  # Modified line\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget) + 0.1 * np.std(fitness)  # Modified line\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Incorporate dynamic adjustment of exploration factor based on fitness variance to improve convergence.", "configspace": "", "generation": 14, "fitness": 0.8149223922577172, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.012. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "3e4acc6a-ab3b-4c11-9d51-c205ff2703de", "metadata": {"aucs": [0.8108327205116859, 0.8032128912305427, 0.8307215650309232], "final_y": [0.138411869833873, 0.15149718056754236, 0.1378285493668442]}, "mutation_prompt": null}
{"id": "893650fe-3764-451c-a755-1fa461b32274", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)  # Modified line\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.5 - 0.2 * (evaluations / self.budget)  # Changed line\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim)\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Refine the exploration factor formula to enhance adaptive exploration.", "configspace": "", "generation": 14, "fitness": 0.8262019951037815, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.011. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "3e4acc6a-ab3b-4c11-9d51-c205ff2703de", "metadata": {"aucs": [0.8226613936794106, 0.8150929913948308, 0.8408516002371028], "final_y": [0.1406835302312186, 0.14537343454324891, 0.13375543410935775]}, "mutation_prompt": null}
{"id": "6aae7c20-2162-4276-be66-95f2f74e94be", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness) * (1 - evaluations / self.budget)  # Dynamic scaling\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) * diversity  # Adjust perturbation\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic scaling factor for mutation to balance exploration and exploitation effectively.", "configspace": "", "generation": 15, "fitness": 0.8229836089396252, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.018. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "9597e89e-1416-4fb2-99d4-74890a37384f", "metadata": {"aucs": [0.7978122214004053, 0.8367532579456716, 0.8343853474727986], "final_y": [0.1456182287544433, 0.1386978168021611, 0.12904775463188567]}, "mutation_prompt": null}
{"id": "aa179dd2-470a-4560-991e-e481387f73a3", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.15, 0.15, self.dim) * diversity  # Adjust perturbation\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce controlled perturbations in exploration to enhance adaptability and diversity management for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.8330772197601913, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.027. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "9597e89e-1416-4fb2-99d4-74890a37384f", "metadata": {"aucs": [0.847338974980733, 0.8571891101730755, 0.7947035741267654], "final_y": [0.1304788539268823, 0.13215054794818815, 0.14918815678188635]}, "mutation_prompt": null}
{"id": "c0dbc5a6-c3d7-4d77-b9a7-306e7c46a206", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness) * np.sqrt(evaluations / self.budget)  # Adjusted line\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) * diversity\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic mutation factor to enhance convergence by adapting the exploration-exploitation balance based on the current iteration.", "configspace": "", "generation": 15, "fitness": 0.8313553014867576, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.023. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "9597e89e-1416-4fb2-99d4-74890a37384f", "metadata": {"aucs": [0.8372148659570775, 0.8560093959177364, 0.800841642585459], "final_y": [0.12548746556202983, 0.13068582435178921, 0.1410004334269378]}, "mutation_prompt": null}
{"id": "64c1ded4-88c4-46f2-befe-1b0ee2e6e987", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(fitness)  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance the adaptability of exploration and exploitation by integrating randomness in mutation and crossover strategies based on population diversity.", "configspace": "", "generation": 15, "fitness": 0.8331950159628594, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.014. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9597e89e-1416-4fb2-99d4-74890a37384f", "metadata": {"aucs": [0.8340419435180245, 0.8499625491474241, 0.8155805552231292], "final_y": [0.13806662288432892, 0.13151938460251278, 0.1301239416293145]}, "mutation_prompt": null}
{"id": "574ec631-5658-4a9c-83e6-35249044ef0c", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n        self.history = []  # Track history of best solutions\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                # Incorporate historical best direction\n                historical_direction = np.mean(self.history, axis=0) if self.history else np.zeros(self.dim)\n                new_position = c_i * s_i + population[i] + 0.05 * historical_direction\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.8 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) * (1 + evaluations / self.budget) * diversity\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            self.history.append(population[best_idx])  # Update history\n\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced_Refined", "description": "Improve convergence by integrating historical information to guide search directions and enhance diversification through dynamic perturbation based on evaluation stages.", "configspace": "", "generation": 15, "fitness": 0.7874529307099855, "feedback": "The algorithm HybridGOA_DE_Enhanced_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.026. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "9597e89e-1416-4fb2-99d4-74890a37384f", "metadata": {"aucs": [0.7539796293901244, 0.7899630756750385, 0.8184160870647932], "final_y": [0.17262173734801545, 0.16104270709160795, 0.15038558293377258]}, "mutation_prompt": null}
{"id": "bf676e13-313c-4cd4-901c-3059ffd5e0d3", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(population, axis=0).mean()  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Refine the mutation strategy by dynamically adjusting mutation factor based on diversity and improve exploration with adaptive perturbation.", "configspace": "", "generation": 16, "fitness": 0.8193701174436269, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.036. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "64c1ded4-88c4-46f2-befe-1b0ee2e6e987", "metadata": {"aucs": [0.7700867560081219, 0.8325658155584128, 0.8554577807643458], "final_y": [0.15136930210717103, 0.14122028565266764, 0.12916452427847502]}, "mutation_prompt": null}
{"id": "d602512f-3a8f-4508-8de0-6d2478092728", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * diversity  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Adjust mutation factor dynamically based on diversity to enhance adaptability during optimization.", "configspace": "", "generation": 16, "fitness": 0.8104350534035559, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.026. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "64c1ded4-88c4-46f2-befe-1b0ee2e6e987", "metadata": {"aucs": [0.7765090634117041, 0.8141665954177026, 0.8406295013812612], "final_y": [0.1520912858409431, 0.1391268237290827, 0.1290856488558344]}, "mutation_prompt": null}
{"id": "09a6e376-0748-4e65-b482-18e2d26e40db", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 1.0 * np.random.rand() * np.std(fitness)  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce adaptive mutation scaling with fitness variance to enhance exploration in later stages.", "configspace": "", "generation": 16, "fitness": 0.8062230720957818, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.806 with standard deviation 0.021. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "64c1ded4-88c4-46f2-befe-1b0ee2e6e987", "metadata": {"aucs": [0.8357217361136042, 0.7966933507023557, 0.7862541294713855], "final_y": [0.13085712158471707, 0.14742778935451906, 0.15397295647136833]}, "mutation_prompt": null}
{"id": "3abe5571-f39e-42ff-8151-6b1da4394e4f", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(fitness) * (1 + np.mean(np.std(population, axis=0)))  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Optimize balance between exploitation and exploration by dynamically adjusting the mutation factor in the differential evolution strategy based on the current diversity of the population.", "configspace": "", "generation": 16, "fitness": 0.7935237850180075, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.019. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "64c1ded4-88c4-46f2-befe-1b0ee2e6e987", "metadata": {"aucs": [0.7729431255579869, 0.8196351762865667, 0.7879930532094688], "final_y": [0.15453107456065673, 0.13470435378313972, 0.1336346711123898]}, "mutation_prompt": null}
{"id": "900471a4-dedf-4cbc-b828-2de861861bb4", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(fitness)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))\n            for i in range(self.population_size):\n                exploration_factor = 0.5 * (1 - evaluations / self.budget)  # Changed\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Refine the exploration by adjusting the exploration factor to better balance exploration and exploitation phases.", "configspace": "", "generation": 16, "fitness": 0.8146602460860013, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.024. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "64c1ded4-88c4-46f2-befe-1b0ee2e6e987", "metadata": {"aucs": [0.8410814698842943, 0.819374538095804, 0.7835247302779056], "final_y": [0.13302561337466368, 0.14623689571879073, 0.15289711238904846]}, "mutation_prompt": null}
{"id": "3a489975-1b3b-4668-b8ee-5457ab38747a", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(population, axis=0).mean()  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.5, 0.5, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Enhance exploration by increasing perturbation range dynamically based on diversity to maintain a balance between exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.7883417295024487, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.033. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "bf676e13-313c-4cd4-901c-3059ffd5e0d3", "metadata": {"aucs": [0.770374518729608, 0.834679325591348, 0.7599713441863902], "final_y": [0.14673407676828032, 0.13018896594556006, 0.15588732501817193]}, "mutation_prompt": null}
{"id": "0ddee3ff-a64f-4e2e-aef7-3176a8196b4b", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    # Changed mutation factor to include diversity and remaining budget influence\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(population, axis=0).mean() * (1 - evaluations / self.budget)\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                exploration_factor = 0.3 * (1 - evaluations / self.budget)\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Improve stabilization and adaptability of the algorithm by modifying the mutation factor to dynamically adjust based on current diversity and remaining budget.", "configspace": "", "generation": 17, "fitness": 0.8041833286146162, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.020. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "bf676e13-313c-4cd4-901c-3059ffd5e0d3", "metadata": {"aucs": [0.7840520111173762, 0.8314611789788442, 0.7970367957476279], "final_y": [0.1480898908523408, 0.1353967550467543, 0.1436728545489886]}, "mutation_prompt": null}
{"id": "ed3af27b-33dd-4832-818c-ff7efaa5dfd6", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Changed\n        self.c = 0.00002  # Changed\n        self.f_min, self.f_max = 0.00005, 1.0  # Changed\n        self.elite_rate = 0.25  # Changed\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.15, 0.3 * (1 - evaluations / self.budget))  # Changed\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.9 + 0.4 * np.random.rand() * np.std(population, axis=0).mean()  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c), lb, ub)  # Changed\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.9 * (b - a), lb, ub)  # Changed\n\n                cr = 0.8 - (0.4 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))\n            for i in range(self.population_size):\n                exploration_factor = 0.35 * (1 - evaluations / self.budget)  # Changed\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.25, 0.25, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic exploration-exploitation balance and optimized mutation strategy to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 17, "fitness": 0.7634388565334648, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.763 with standard deviation 0.012. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "bf676e13-313c-4cd4-901c-3059ffd5e0d3", "metadata": {"aucs": [0.748281951553423, 0.7768091734449808, 0.7652254446019902], "final_y": [0.1685674249346113, 0.16343120250555176, 0.1666860756906946]}, "mutation_prompt": null}
{"id": "e8659bfe-3c4d-471a-beb8-8719af781390", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n        self.adaptive_lr = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                mutation_factor = 0.8 + 0.3 * np.random.rand() * np.std(population, axis=0).mean()  # Changed\n                mutant = np.clip(a + mutation_factor * (b - a) * self.adaptive_lr, lb, ub)  # Changed\n\n                cr = 0.8 - (0.4 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))\n            for i in range(self.population_size):\n                exploration_factor = 0.25 * (1 - evaluations / self.budget)  # Changed\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim) * diversity  # Changed\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced_Adaptive", "description": "Enhance exploitation by tuning elite strategy and add adaptive learning rate for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.7854164014558567, "feedback": "The algorithm HybridGOA_DE_Enhanced_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.042. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "bf676e13-313c-4cd4-901c-3059ffd5e0d3", "metadata": {"aucs": [0.7341063147119495, 0.7842692834649044, 0.837873606190716], "final_y": [0.15921710741314066, 0.14129858033719145, 0.13159199925316833]}, "mutation_prompt": null}
{"id": "5c3981e9-a8c9-4719-83ca-3e3732825096", "solution": "import numpy as np\n\nclass HybridGOA_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c = 0.00001\n        self.f_min, self.f_max = 0.00001, 1.0\n        self.elite_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            f = self.f_max - evaluations / self.budget * (self.f_max - self.f_min)\n            c_i = self.c * np.power(f, 2)\n\n            new_population = np.zeros_like(population)\n            for i in range(self.population_size):\n                s_i = np.zeros(self.dim)\n                for j in range(self.population_size):\n                    if i != j:\n                        r_ij = np.linalg.norm(population[j] - population[i])\n                        s_ij = (population[j] - population[i]) * np.exp(-r_ij/self.f_max)\n                        s_i += s_ij\n                new_position = c_i * s_i + population[i]\n                new_population[i] = np.clip(new_position, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            self.elite_rate = max(0.1, 0.3 * (1 - evaluations / self.budget))\n            elite_count = max(1, int(self.population_size * self.elite_rate))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elite_solutions = population[elite_indices]\n\n            for idx in elite_indices:\n                if elite_count > 2:\n                    a, b, c = elite_solutions[np.random.choice(elite_count, 3, replace=False)]\n                    mutation_factor = 0.8 + 0.5 * np.random.rand() * np.std(population, axis=0).mean()  # Changed\n                    mutant = np.clip(a + mutation_factor * (b - c) * 0.5, lb, ub)\n                else:\n                    a, b = elite_solutions[np.random.choice(elite_count, 2, replace=True)]\n                    mutant = np.clip(a + 0.8 * (b - a), lb, ub)\n\n                cr = 0.9 - (0.5 * (evaluations / self.budget))  # Changed\n                trial = np.where(np.random.rand(self.dim) < cr, mutant, new_population[idx])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[idx]:\n                    new_population[idx] = trial\n                    new_fitness[idx] = trial_fitness\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                convergence_factor = np.mean(np.std(new_population, axis=0))  # Calculate convergence\n                exploration_factor = 0.3 * (1 - evaluations / self.budget) * convergence_factor  # Changed\n                if np.random.rand() < exploration_factor:\n                    perturbation = np.random.uniform(-0.3, 0.3, self.dim) * diversity\n                    candidate = np.clip(new_population[i] + perturbation, lb, ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < new_fitness[i]:\n                        new_population[i] = candidate\n                        new_fitness[i] = candidate_fitness\n\n            population = new_population\n            fitness = new_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridGOA_DE_Enhanced", "description": "Introduce a dynamic exploration factor adjustment based on population convergence to enhance balance between exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.7934545165425178, "feedback": "The algorithm HybridGOA_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.015. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "bf676e13-313c-4cd4-901c-3059ffd5e0d3", "metadata": {"aucs": [0.7810673919099049, 0.8145186162133021, 0.7847775415043464], "final_y": [0.1476594607430004, 0.14614076591683556, 0.1433895069775496]}, "mutation_prompt": null}
