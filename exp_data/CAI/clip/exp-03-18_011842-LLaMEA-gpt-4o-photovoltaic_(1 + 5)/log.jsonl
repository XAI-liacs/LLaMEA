{"id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5  # Mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A hybrid metaheuristic combining differential evolution with adaptive Lévy flights for enhanced exploration and exploitation in black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.8028074043180262, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.009. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8044662754783449, 0.8123362157208858, 0.791619721754848], "final_y": [0.15658611197316297, 0.14331871712995803, 0.1503035974768956]}, "mutation_prompt": null}
{"id": "727588f7-f975-4bbd-a062-4cb3bd020ba0", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / (2 * dim))  # Adjusted population size\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.6  # Adjusted mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid metaheuristic with adjusted mutation factors and adaptive population size for enhanced exploration and faster convergence in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.7806439804443491, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.012. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7673533765217255, 0.7955364415852331, 0.7790421232260887], "final_y": [0.15251502347883383, 0.14937577355391873, 0.14477894079605302]}, "mutation_prompt": null}
{"id": "94601034-acb6-4d64-b53f-4d3a3ba47275", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.8  # Mutation factor (adjusted from 0.5 to 0.8)\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Refinement of HybridLevyDifferentialEvolution by adjusting the mutation factor for enhanced exploration capabilities.", "configspace": "", "generation": 1, "fitness": 0.7912702310142968, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.013. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.78834322317993, 0.8081374614686085, 0.7773300083943522], "final_y": [0.1518152237431286, 0.14863528720692165, 0.1564262384837214]}, "mutation_prompt": null}
{"id": "32d7548c-f84e-437a-ba8a-0f1d2401228a", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A hybrid metaheuristic combining differential evolution with adaptive Lévy flights, now using adaptive mutation factor F for improved exploration and exploitation in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.7873440188772838, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.022. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7719745727151187, 0.8186920060864574, 0.7713654778302752], "final_y": [0.15607878516993934, 0.14352776505136933, 0.1668765536537643]}, "mutation_prompt": null}
{"id": "4474d1fa-7769-49dd-a505-26db6cc5773f", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5  # Mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR_dynamic = 0.9 * (1 - (self.best_fitness / func(x)))  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A hybrid metaheuristic utilizing differential evolution with adaptive Lévy flights for enhanced exploration, now featuring adaptive crossover probability to improve convergence.", "configspace": "", "generation": 1, "fitness": 0.7852505525061894, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.025. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7504263466135646, 0.8041645577912622, 0.8011607531137415], "final_y": [0.15194750885683983, 0.1460084935119904, 0.15133079665830418]}, "mutation_prompt": null}
{"id": "db0caf79-2f73-4ae0-a254-f74b4a0706a6", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.F = 0.5  # Base mutation factor\n        self.CR = 0.9  # Base crossover probability\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = self.F * np.random.uniform(0.5, 1.5)  # Self-adaptive mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An improved hybrid metaheuristic that integrates self-adaptive parameters in differential evolution and adaptive Lévy flights for more efficient exploration and exploitation in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.7856582318772487, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.013. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7675023049357627, 0.7972472120554994, 0.7922251786404839], "final_y": [0.16041369760459379, 0.15518177977302272, 0.1524326479885727]}, "mutation_prompt": null}
{"id": "11159d71-1d75-4305-bdf5-2374392da887", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                F = 0.5 + 0.3 * np.random.rand()  # Dynamic mutation factor\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhanced exploration and convergence by dynamically adjusting mutation factor in differential evolution.", "configspace": "", "generation": 2, "fitness": 0.7949903097239668, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.795 with standard deviation 0.027. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.8284433306297708, 0.7948375115852253, 0.7616900869569039], "final_y": [0.14259944998046237, 0.15164951927250192, 0.16709923890620515]}, "mutation_prompt": null}
{"id": "3588c8bc-85dc-4c64-a597-3abf9086f2f6", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step * 0.5  # Adjusted step size for better control\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5  # Mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A novel hybrid metaheuristic integrating differential evolution with tailored Lévy flights to enhance both exploration and exploitation in black-box optimization.", "configspace": "", "generation": 2, "fitness": 0.7809113237012739, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.018. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7758871330411703, 0.804799668658186, 0.7620471694044656], "final_y": [0.15353112052840556, 0.15286616381006124, 0.16773510727179375]}, "mutation_prompt": null}
{"id": "b30da2a5-7f61-4a57-95e9-cc831e6c1375", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5 + np.random.rand() * 0.3  # Mutation factor\n\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid metaheuristic combining differential evolution with adaptive Lévy flights, now with dynamic mutation factor for improved exploration.", "configspace": "", "generation": 2, "fitness": 0.7938415877376702, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.027. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7564095187956204, 0.8059139425122805, 0.8192013019051101], "final_y": [0.1564447448244043, 0.1514279242214619, 0.14256121634370367]}, "mutation_prompt": null}
{"id": "d6db3c0a-87b1-4f50-90a0-f56c40da2977", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def adaptive_parameters(self, iter, max_iter):\n        self.F = 0.4 + 0.3 * (1 - iter / max_iter)  # adapt F\n        self.CR = 0.9 - 0.5 * (iter / max_iter)  # adapt CR\n\n    def differential_evolution(self, func, lb, ub):\n        max_iter = self.budget // self.population_size\n        for iter in range(max_iter):\n            self.adaptive_parameters(iter, max_iter)\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhanced HybridLevyDifferentialEvolution with dynamic parameter adaptation for improved convergence in black-box optimization.", "configspace": "", "generation": 2, "fitness": 0.7902231905014064, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.790 with standard deviation 0.018. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7663006732059402, 0.8100321777829401, 0.7943367205153393], "final_y": [0.15269818916729638, 0.15034776125169125, 0.15709204568815827]}, "mutation_prompt": null}
{"id": "b2b943fa-381c-4f58-96a4-6fb66231c005", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5  # Mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                \n                # Added dynamic adjustment to improve exploration\n                F_dynamic = 0.4 + np.random.rand() * 0.6 \n                \n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F_dynamic * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid algorithm combining adaptive Lévy flights, dynamic differential evolution, and population diversification for improved exploration and exploitation in black-box optimization.", "configspace": "", "generation": 2, "fitness": 0.7909615459088624, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.007. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7958861236646253, 0.7963519696133501, 0.7806465444486115], "final_y": [0.13666326070787738, 0.15885609888433938, 0.13556033874721551]}, "mutation_prompt": null}
{"id": "80a3252c-aa58-4b09-8f1e-1c24b2390250", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.7  # Mutation factor adjusted for better balance between exploration and exploitation\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid metaheuristic combining differential evolution with adaptive Lévy flights for improved balance between exploration and exploitation in black-box optimization.", "configspace": "", "generation": 3, "fitness": 0.7905171754577527, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.029. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7500594443696419, 0.8121248279693564, 0.8093672540342599], "final_y": [0.16764261272626635, 0.13135582689753333, 0.14383611476899383]}, "mutation_prompt": null}
{"id": "27a402ae-8645-4c33-b24f-33071b4bd524", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        for generation in range(self.budget):\n            F = 0.5 + 0.3 * np.sin(np.pi * generation / self.budget)  # Dynamic mutation factor\n            CR = 0.9 - 0.5 * np.sin(np.pi * generation / self.budget)  # Dynamic crossover probability\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduced dynamic mutation factor and crossover probability for adaptive balance between exploration and exploitation in differential evolution.", "configspace": "", "generation": 3, "fitness": 0.8088060829919694, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.021. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.8069498974837166, 0.8348349797543808, 0.7846333717378109], "final_y": [0.15416851534243858, 0.13629665661755064, 0.1467465388132112]}, "mutation_prompt": null}
{"id": "daef807b-ba82-4b7b-8c8f-2934b3cb58a0", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_init = 0.5  # Initial mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                # Adjust mutation factor based on current convergence speed\n                F = F_init + 0.1 * ((self.best_fitness - func(self.population[i])) / abs(self.best_fitness))\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Modified HybridLevyDifferentialEvolution to include adaptive mutation factor based on convergence speed for enhanced performance.", "configspace": "", "generation": 3, "fitness": 0.7890671589918209, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.036. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7379471265103307, 0.8133423789837222, 0.8159119714814099], "final_y": [0.17924064183162647, 0.14610627814870525, 0.14364371669877796]}, "mutation_prompt": null}
{"id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid approach utilizing adaptive Levy flights and a refined mutation strategy to improve convergence in black-box optimization.", "configspace": "", "generation": 3, "fitness": 0.817663658636068, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.034. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7771925906836773, 0.8160311735595209, 0.8597672116650061], "final_y": [0.15287266086883744, 0.15078822469618225, 0.129583956894067]}, "mutation_prompt": null}
{"id": "27228cbd-2949-40a9-b56f-f906cd4253cc", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5\n        CR = 0.9\n        fitness_values = np.array([func(ind) for ind in self.population])  # Cache fitness values\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                trial_fitness = func(trial)\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                \n                if trial_fitness < fitness_values[i]:  # Use cached fitness value\n                    self.population[i] = trial\n                    fitness_values[i] = trial_fitness  # Update cached fitness value\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhanced hybrid metaheuristic combining differential evolution with adaptive Lévy flights and elitism strategy for improved convergence in black-box optimization.", "configspace": "", "generation": 3, "fitness": 0.7956653090668135, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.007. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "metadata": {"aucs": [0.7928578342093582, 0.8050820953430535, 0.7890559976480288], "final_y": [0.1506780344108395, 0.13598842848694948, 0.14758525112924248]}, "mutation_prompt": null}
{"id": "00677a64-49df-478b-b314-3ac0cf04e850", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.95  # Crossover probability (modified from 0.9 to 0.95)\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid approach utilizing adaptive Levy flights with modified crossover probability and a refined mutation strategy to improve convergence in black-box optimization.", "configspace": "", "generation": 4, "fitness": 0.8006813451337411, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.005. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8060873090823836, 0.7933958828962611, 0.8025608434225786], "final_y": [0.1440759152963479, 0.1601017669387199, 0.14802956404665046]}, "mutation_prompt": null}
{"id": "a1556816-6ca8-48c4-8515-f97d73ac525e", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.8  # Crossover probability (modified)\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "This algorithm enhances convergence by fine-tuning the crossover probability and introducing dynamic recombination, while balancing exploration and exploitation effectively.", "configspace": "", "generation": 4, "fitness": 0.7982803358176339, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.017. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8176392380784734, 0.8013455376512988, 0.7758562317231299], "final_y": [0.15016028460701947, 0.14925802051403447, 0.16237199873150976]}, "mutation_prompt": null}
{"id": "094bad79-5540-4551-b5b1-cd81a1501f66", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_start, CR_end = 0.6, 0.95  # Adaptive crossover probability range\n\n        for generation in range(self.budget):\n            CR = CR_start + (CR_end - CR_start) * (generation / self.budget)\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Incorporated dynamic population sizing and adaptive crossover probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.775290908060095, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.013. And the mean value of best solutions found was 0.162 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7618103662241712, 0.79370084800128, 0.7703615099548338], "final_y": [0.165976209107487, 0.15558469591573254, 0.16563367980030985]}, "mutation_prompt": null}
{"id": "0e9fd2d7-b9d0-4f48-a103-de8b354d09e9", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR_min, CR_max = 0.7, 1.0  # Adaptive crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                CR = np.random.uniform(CR_min, CR_max)  # Adaptive crossover probability\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach with adaptive crossover probability and enhanced exploration-exploitation balance for improved black-box optimization.", "configspace": "", "generation": 4, "fitness": 0.7880634264870853, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.025. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7638597209131357, 0.8226655922305994, 0.7776649663175204], "final_y": [0.16680404687398032, 0.14592683956963004, 0.16124572187767794]}, "mutation_prompt": null}
{"id": "7a5bdb9b-7c08-4d02-81f7-3e6bc61d4e06", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR_min = 0.5  # Adaptive crossover range\n        self.CR_max = 1.0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.3, 0.8  # Adjusted mutation factor range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Adaptive mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.random.uniform(self.CR_min, self.CR_max)  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introducing adaptive crossover and mutation strategies to enhance convergence speed and solution quality in HybridLevyDifferentialEvolution.", "configspace": "", "generation": 4, "fitness": 0.7769975795806916, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.777 with standard deviation 0.015. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7580314460081604, 0.7934943089726061, 0.7794669837613081], "final_y": [0.1659234157289674, 0.1601017669387199, 0.14224780135980253]}, "mutation_prompt": null}
{"id": "9cb02414-bea0-4af3-a428-3cfc2ad6399e", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, max(F_max * (1 - func(x) / self.best_fitness), F_min))  # Adaptive mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved mutation factor adaptation based on individual fitness to enhance convergence in black-box optimization.", "configspace": "", "generation": 5, "fitness": 0.786816988652979, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.014. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7712035753608907, 0.8058999998817462, 0.7833473907163], "final_y": [0.15962110569092214, 0.14901994188962497, 0.14066080768526978]}, "mutation_prompt": null}
{"id": "dbbcbb33-b3f7-4e76-87e7-7e5b09416989", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = 0.5 + 0.4 * np.random.rand()  # Dynamic crossover probability\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduce dynamic crossover probability to enhance exploration and exploitation balance in the optimization process.", "configspace": "", "generation": 5, "fitness": 0.7825378460383464, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.783 with standard deviation 0.012. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7679389880041023, 0.7965665920392935, 0.7831079580716434], "final_y": [0.16351633517957442, 0.1579307673131528, 0.1569559793169618]}, "mutation_prompt": null}
{"id": "803b639c-1569-4210-b828-daf50759bb54", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        # CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                CR = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Integrating adaptive mutation and crossover rates into the Levy flight-enhanced differential evolution for improved exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.7898828531807047, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.790 with standard deviation 0.007. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7923561198084691, 0.7963595198915356, 0.7809329198421094], "final_y": [0.15859670986866348, 0.15748520343759165, 0.1496003279038859]}, "mutation_prompt": null}
{"id": "b1f177d9-55c6-44f0-8812-fe49dd6c4cb3", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.history = []\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                \n                # Dynamic mutation factor based on iteration progress\n                F = np.random.uniform(F_min, F_max) * (1 - _/self.budget)\n                \n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n                self.history.append(fitness)\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved candidate selection by incorporating history-based adaptivity and dynamic mutation factor adjustment.", "configspace": "", "generation": 5, "fitness": 0.7864448827186036, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.012. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7701623014503972, 0.7942040215351984, 0.794968325170215], "final_y": [0.1519716136903625, 0.15235172404086705, 0.1528160242413421]}, "mutation_prompt": null}
{"id": "e6ca7c92-8e1b-4c12-9516-49fecea7fa17", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.2, 0.8  # Adjusted mutation factor range\n        CR = 0.7  # Adjusted crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved balance between exploration and exploitation by adjusting crossover probability and mutation factor range adaptively.", "configspace": "", "generation": 5, "fitness": 0.7842450841557197, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.017. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7908132693737923, 0.800869621110778, 0.7610523619825889], "final_y": [0.1474916082634118, 0.15346404876095887, 0.17064618335923876]}, "mutation_prompt": null}
{"id": "f4b26f11-8b69-403f-955c-4614f4aa2d09", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                # Adaptive crossover probability based on population diversity\n                diversity = np.std(self.population, axis=0).mean()\n                CR = max(0.1, min(1.0, 1 / (1 + diversity)))\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduced adaptive crossover probability based on population diversity to enhance solution exploration and convergence.", "configspace": "", "generation": 6, "fitness": 0.7884457776227651, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.021. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7586376046606624, 0.8005228787669253, 0.8061768494407077], "final_y": [0.16455022764491856, 0.15607960573631574, 0.15563963021337857]}, "mutation_prompt": null}
{"id": "f39e57e0-45eb-4812-a6c5-62a68b4455f5", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max) * (1 - _ / self.budget)  # Dynamic mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Incorporating dynamic mutation scaling into the differential evolution process to enhance convergence.", "configspace": "", "generation": 6, "fitness": 0.7859742201566146, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.024. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7520743547951304, 0.7996714562340056, 0.8061768494407077], "final_y": [0.16217895931074955, 0.1557435670398477, 0.15563963021337857]}, "mutation_prompt": null}
{"id": "068130e4-432d-4dcb-8bac-07782c20cddb", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for gen in range(self.budget):\n            CR = 0.9 - (0.5 * gen / self.budget)  # Adjust CR dynamically\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved convergence by dynamically adjusting the crossover probability (CR) based on iteration progress.", "configspace": "", "generation": 6, "fitness": 0.7921963128733974, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.792 with standard deviation 0.016. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7722996178164891, 0.8117375043010557, 0.7925518165026473], "final_y": [0.15062100568438042, 0.1501504935272241, 0.15033299765595842]}, "mutation_prompt": null}
{"id": "97a51c08-0601-4256-b096-53bbae11d868", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max) * (1 - _ / self.budget)  # Dynamic mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid approach with adaptive Levy flights and a dynamic mutation factor to improve black-box optimization convergence.", "configspace": "", "generation": 6, "fitness": 0.7887839859518743, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.007. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7807922390085033, 0.7982117998930693, 0.7873479189540501], "final_y": [0.1505669481356805, 0.15386011303953329, 0.15141375691496972]}, "mutation_prompt": null}
{"id": "310a08f3-9767-47b9-be29-012f10091a78", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.1, 0.9  # Adjusted crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                CR = np.random.uniform(CR_min, CR_max)  # Dynamic crossover probability\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Incorporate dynamic adjustment of crossover probability to enhance diversity and exploration in the search space.", "configspace": "", "generation": 6, "fitness": 0.7976521789985617, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.042. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7445662147080113, 0.8467725806995384, 0.8016177415881355], "final_y": [0.17051508543966165, 0.13975746146103862, 0.15055401504219845]}, "mutation_prompt": null}
{"id": "15fd78d4-31ba-4f29-9a33-13c525b1fcb9", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.5, 0.9  # Crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = CR_min + (CR_max - CR_min) * ((_ + 1) / self.budget)  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introducing adaptive crossover probability to dynamically balance exploration and exploitation in the HybridLevyDifferentialEvolution algorithm.", "configspace": "", "generation": 7, "fitness": 0.7855572254682178, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.015. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7678316102241908, 0.8053262243904966, 0.7835138417899665], "final_y": [0.1676949590106096, 0.15542190328691474, 0.15081535549356173]}, "mutation_prompt": null}
{"id": "0de0220e-0063-410e-8bee-de098ea260d4", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.5, 0.9  # Increased minimum mutation factor\n        CR = 0.8  # Adjusted crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            elite_count = self.population_size // 10  # Select top 10% elite solutions\n            elite_indices = np.argsort([func(ind) for ind in self.population])[:elite_count]\n            for i in elite_indices:\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An adaptive hybrid optimization algorithm integrating elite selection with Levy flights and differential evolution to enhance convergence on black-box functions.", "configspace": "", "generation": 7, "fitness": 0.788917567732936, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.021. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7706952334782976, 0.8189826238205933, 0.7770748458999169], "final_y": [0.15575623564350238, 0.1424656711964113, 0.14956058848780573]}, "mutation_prompt": null}
{"id": "2594060e-ea69-4411-9116-156726e3ab6e", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=None):\n        if beta is None:\n            beta = np.random.uniform(1.2, 1.8)  # Adaptive beta within a range\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduce adaptive β in Levy flights to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.797125809206238, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.020. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7698211384635496, 0.8165206706845494, 0.8050356184706153], "final_y": [0.16082336692586752, 0.1525407792965705, 0.15563963021337857]}, "mutation_prompt": null}
{"id": "44d8deac-8790-45a0-a027-86ed3fd75ed9", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.7, 0.95  # Crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.interp(self.best_fitness, [0, 1], [CR_max, CR_min])  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved balance between exploration and exploitation by adjusting the crossover rate dynamically based on performance.", "configspace": "", "generation": 7, "fitness": 0.7813798591380942, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.022. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7507597096098356, 0.7969660501808085, 0.7964138176236384], "final_y": [0.17132821542903864, 0.15775024351491085, 0.15176950226530073]}, "mutation_prompt": null}
{"id": "cfbcb412-73e9-4c7a-9cb6-bd911b105a77", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n                    CR = 0.5 + 0.5 * np.random.rand()  # Dynamic crossover adjustment\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduce dynamic crossover probability adjustment based on fitness improvement to refine the existing strategy.", "configspace": "", "generation": 7, "fitness": 0.7876954163994062, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.005. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7873886886883783, 0.7939310162868597, 0.7817665442229804], "final_y": [0.15914244572546665, 0.15930067339322673, 0.1527885195421086]}, "mutation_prompt": null}
{"id": "f277f754-e226-4b20-b35f-11ae0ffb0385", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(budget / (2*dim)))\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.5, 0.9  # Adjusted mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach integrating adaptive Levy flights with dynamic population resizing and enhanced mutation strategy for improved convergence in black-box optimization.", "configspace": "", "generation": 8, "fitness": 0.7975155706732081, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.014. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7980730017548556, 0.814556105296848, 0.7799176049679207], "final_y": [0.15103517371938746, 0.15094322474801625, 0.14066297917669224]}, "mutation_prompt": null}
{"id": "871240e7-1b7b-436c-8df4-d8f37e80c8ea", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_initial, CR_final = 0.9, 0.5  # Initial and final crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                # Dynamic crossover probability\n                CR = CR_initial - (CR_initial - CR_final) * (_ / self.budget)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid optimization approach enhancing convergence by dynamically adjusting crossover probability in differential evolution.", "configspace": "", "generation": 8, "fitness": 0.7971831510114077, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.007. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7879378204373058, 0.798324687187587, 0.8052869454093303], "final_y": [0.15839250487092316, 0.15308426069003755, 0.15563963021337857]}, "mutation_prompt": null}
{"id": "ad0788a2-a61d-4017-a63e-a21300046867", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.8, 0.95  # Adaptive crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n\n                CR = np.random.uniform(CR_min, CR_max)  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach leveraging adaptive Levy flights and variable crossover strategies to enhance convergence in black-box optimization.", "configspace": "", "generation": 8, "fitness": 0.7958767510639825, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.023. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7639401640867258, 0.8125843757250429, 0.8111057133801789], "final_y": [0.16071172687571889, 0.130149322906993, 0.1482761686322024]}, "mutation_prompt": null}
{"id": "65fc51a2-4b26-4e07-9fbf-383559cf48d5", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(budget / (2 * dim)))  # Adjusted population size\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step * (0.5 + 0.5 * np.sin(np.pi * u))  # Added chaotic element\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR = 0.9\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach incorporating adaptive population sizing and chaotic Levy flights to enhance exploration and exploitation in black-box optimization.", "configspace": "", "generation": 8, "fitness": 0.7798174171616381, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.780 with standard deviation 0.011. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7784490652146178, 0.793594550317602, 0.7674086359526946], "final_y": [0.1402597249415397, 0.1601017669387199, 0.1522288879581004]}, "mutation_prompt": null}
{"id": "500ebc1c-83c5-429b-86ef-ab176bcb046e", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        initial_CR = 0.9\n        CR_decay = 0.95\n\n        for _ in range(self.budget // self.population_size):\n            CR = initial_CR * (CR_decay ** _)\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = 0.5 * self.levy_flight()  # Reduce step size for precision\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An advanced hybrid method integrating adaptive Levy flights with dynamic crossover and mutation strategies to enhance black-box optimization.", "configspace": "", "generation": 8, "fitness": 0.7865368986294095, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.020. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7766037045710781, 0.8139106600673778, 0.7690963312497725], "final_y": [0.1383061676938162, 0.1367997724557216, 0.1539084319037045]}, "mutation_prompt": null}
{"id": "d4817662-222f-47fa-8247-383fc349298c", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for generation in range(self.budget):\n            CR = 0.9 - 0.5 * (generation / self.budget)  # Adjust CR over generations\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid algorithm enhancing mutation diversity by adjusting crossover probability and mutation factor adaptively over iterations.", "configspace": "", "generation": 9, "fitness": 0.7848169447588136, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.015. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7903283405104466, 0.7999925942525092, 0.7641298995134849], "final_y": [0.15593522435104956, 0.14695551500390003, 0.17017877625842603]}, "mutation_prompt": null}
{"id": "d09e6e1a-63c4-4fb8-9709-46a2886acffe", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max) * (1 - np.std(self.population) / (ub - lb))  # Dynamic mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhance mutation strategy by dynamically adjusting the mutation factor based on population diversity to boost convergence.", "configspace": "", "generation": 9, "fitness": 0.8039505674034394, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.015. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7926452363032632, 0.7936118230241088, 0.825594642882946], "final_y": [0.1566558775097009, 0.1601017669387199, 0.14132716452960348]}, "mutation_prompt": null}
{"id": "2c37fa58-c2e0-4060-b052-8b3b0e7d1c9d", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.5, 0.8  # Adjusted mutation factor range\n        CR = 0.85  # Adjusted crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n            \n            # Dynamic population resizing\n            if _ % (self.budget // 10) == 0:\n                self.population_size = max(5, self.population_size // 2)\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach using adaptive Levy flights, dynamic population resizing, and improved mutation strategy for enhanced convergence in black-box optimization.", "configspace": "", "generation": 9, "fitness": 0.7896230795003637, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.790 with standard deviation 0.020. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7624860542965028, 0.7965252554987264, 0.8098579287058614], "final_y": [0.15159016978322204, 0.15764355725905788, 0.14825609040687826]}, "mutation_prompt": null}
{"id": "920feb6f-e7fb-4b25-bc8b-3dd7bddfd516", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.3, 0.8  # Adjusted mutation factor range\n        CR_min, CR_max = 0.8, 1.0  # Dynamic crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.random.uniform(CR_min, CR_max)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A hybrid optimization algorithm integrating adaptive Levy flights with a dynamic mutation strategy to improve robustness and convergence speed in black-box optimization.", "configspace": "", "generation": 9, "fitness": 0.7932647738021327, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.027. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7556087875850725, 0.8042227873755186, 0.8199627464458066], "final_y": [0.1559663695905278, 0.13990261548318594, 0.14970738152671226]}, "mutation_prompt": null}
{"id": "af0811d3-c744-4cb5-92ae-e6f65316e5ef", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.1, 0.9  # Crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.random.uniform(CR_min, CR_max)  # Variable crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhanced Hybrid Levy Differential Evolution with variable crossover probability for better exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.7864595406978987, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.011. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7743502586685636, 0.8005450308355944, 0.7844833325895384], "final_y": [0.1585107571532347, 0.14418753331516754, 0.15394873543069876]}, "mutation_prompt": null}
{"id": "7a2a1640-2360-4ced-809e-38f46e340ec4", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                # Adjusted crossover strategy\n                cross_points = np.random.rand(self.dim) < (CR * np.abs(mutant - x).sum() / (ub - lb).sum())\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach with optimized mutation factor strategy and adaptive crossover probability to enhance convergence efficiency.", "configspace": "", "generation": 10, "fitness": 0.7805926766763137, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.015. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7605876017644151, 0.7957546528947705, 0.7854357753697555], "final_y": [0.16787511769548913, 0.15074582610472997, 0.14823249919329295]}, "mutation_prompt": null}
{"id": "63bf76ec-484e-4b50-b6a2-a889b48864cc", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR_min, CR_max = 0.1, 0.9  # Adaptive crossover range\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                CR = np.random.uniform(CR_min, CR_max)  # Adaptive crossover probability\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introducing adaptive crossover probability for enhanced exploration-exploitation balance in Levy-Differential Evolution.", "configspace": "", "generation": 10, "fitness": 0.7931927639846886, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.032. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7495674522781262, 0.8026571872982968, 0.8273536523776426], "final_y": [0.16021166536710552, 0.15403971164828656, 0.1365072223187831]}, "mutation_prompt": null}
{"id": "68eb98ae-d084-4c28-99e5-184c8e91b76e", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.7, 1.0 # Crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.random.uniform(CR_min, CR_max)  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introducing adaptive crossover probability to enhance exploration and exploitation balance in black-box optimization.", "configspace": "", "generation": 10, "fitness": 0.8048201988332305, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.022. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8259002248560002, 0.813765111226379, 0.7747952604173124], "final_y": [0.1426883955145003, 0.14397155091716085, 0.15115020309913407]}, "mutation_prompt": null}
{"id": "e6b0abbb-e35c-4add-9f00-360f568a037f", "solution": "import numpy as np\n\nclass HybridParticleLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.velocities = None  # New: Initialize velocities for Particle Swarm Optimization\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def particle_swarm_update(self, lb, ub):  # New: Implement Particle Swarm update rule\n        w, c1, c2 = 0.5, 1.5, 1.5  # Inertia weight, cognitive and social constants\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (w * self.velocities[i] +\n                                  c1 * r1 * (self.best_solution - self.population[i]))  # Cognitive component\n            self.velocities[i] += c2 * r2 * (self.population[np.random.randint(self.population_size)] - self.population[i])  # Social component\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], lb, ub)\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR = 0.9\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))  # New: Initialize velocities\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            self.particle_swarm_update(lb, ub)  # New: Use Particle Swarm update\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridParticleLevyDifferentialEvolution", "description": "Hybridize Particle Swarm Optimization with Levy flights to enhance exploration and convergence speed in black-box optimization.", "configspace": "", "generation": 10, "fitness": 0.7984213978198381, "feedback": "The algorithm HybridParticleLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.005. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7941085931231701, 0.7949787508956363, 0.8061768494407077], "final_y": [0.14661396987755182, 0.1563914690488032, 0.15563963021337857]}, "mutation_prompt": null}
{"id": "a885f1c1-5f60-4566-8dd1-4b06e85d71bb", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.3, 0.8  # Adjusted mutation factor range\n        CR = 0.8  # Adjusted crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid approach using adaptive Levy flights with dynamic population resizing and adaptive mutation strategy to accelerate convergence.", "configspace": "", "generation": 10, "fitness": 0.7928355589089436, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.009. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7826073236869108, 0.8050827046302004, 0.7908166484097194], "final_y": [0.15189317597829644, 0.1545218147941363, 0.1531468190547104]}, "mutation_prompt": null}
{"id": "99400c50-a91b-4ab1-82ce-2b339bb6e654", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                random_perturbation = np.random.uniform(-0.1, 0.1, size=self.dim)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]) + random_perturbation, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduced diversity preservation by adding a random perturbation in the mutation strategy to enhance exploration and convergence.", "configspace": "", "generation": 11, "fitness": 0.7855117676328938, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.006. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7816458395683314, 0.7935949898691768, 0.7812944734611733], "final_y": [0.15769990789582744, 0.1601017669387199, 0.1637619766334366]}, "mutation_prompt": null}
{"id": "259c3269-1cea-4ac9-9397-8e2283bcbdad", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR = 0.9\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                # Change 1: Dynamic mutation factor scaling based on iteration\n                F = np.random.uniform(F_min, F_max) * (_ / self.budget + 0.5)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                # Change 2: Improved survival selection method\n                if fitness < func(x) or np.random.rand() < 0.1:\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach incorporating dynamic mutation factor scaling and enhanced survival selection for improved optimization performance.", "configspace": "", "generation": 11, "fitness": 0.7788871735266838, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.020. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7702223376519712, 0.8064466780664103, 0.7599925048616696], "final_y": [0.1608978823582733, 0.1511761600330398, 0.16978405225418502]}, "mutation_prompt": null}
{"id": "d1b0c281-3fe0-46ab-a202-64d8704dce41", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = 0.5 * self.levy_flight()  # Dynamic scaling of Levy flight\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved exploration-exploitation balance through adaptive crossover probability and dynamic Levy flight scaling in hybrid optimization.", "configspace": "", "generation": 11, "fitness": 0.7844614284441537, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.013. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7912830097877406, 0.7952605862757742, 0.7668406892689459], "final_y": [0.14767691561052776, 0.15533924593926707, 0.15920335030093735]}, "mutation_prompt": null}
{"id": "ec14d68c-44f2-4586-9b18-3e439fd8e7f0", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        CR_min, CR_max = 0.1, 0.9  # Updated crossover probability range\n        F_min, F_max = 0.3, 0.9  # Updated mutation factor range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Adaptive mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.random.uniform(CR_min, CR_max)  # Stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduce adaptive mutation factor and stochastic crossover to enhance exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.7721094628673892, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.772 with standard deviation 0.018. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7492697044352079, 0.7935949898691768, 0.7734636942977829], "final_y": [0.16992708300732007, 0.1601017669387199, 0.15353719955143574]}, "mutation_prompt": null}
{"id": "224b4cab-99c4-4bed-b1c5-7b118df76108", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.5, 0.9  # Adjusted mutation factor range\n        CR = 0.85  # Adjusted crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)  \n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def stochastic_ranking(self, func, candidate):\n        fitness = func(candidate)\n        energy = np.linalg.norm(candidate)  # Energy-based perturbation\n        return fitness * 0.8 + energy * 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                ranked_fitness = self.stochastic_ranking(func, candidate)\n\n                if ranked_fitness < self.stochastic_ranking(func, self.population[i]):\n                    self.population[i] = candidate\n\n                if ranked_fitness < self.best_fitness:\n                    self.best_fitness = ranked_fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An innovative adaptation of HybridLevyDifferentialEvolution using stochastic ranking and energy-based perturbation for improved solution accuracy.", "configspace": "", "generation": 11, "fitness": 0.7909453672032773, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.011. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8028897581848685, 0.7940639011691708, 0.7758824422557928], "final_y": [0.1519302464181732, 0.15698944892446876, 0.16253839486685395]}, "mutation_prompt": null}
{"id": "0970be58-879c-4a1f-94fc-ce447e31d22d", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.5, 0.9  # Dynamic crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                CR = np.random.uniform(CR_min, CR_max)  # Dynamic crossover probability\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced hybrid approach utilizing adaptive Levy flights and dynamic crossover probability to improve convergence in black-box optimization.", "configspace": "", "generation": 12, "fitness": 0.7910132000548499, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.011. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7949517966584905, 0.8015732438590351, 0.7765145596470242], "final_y": [0.15108616073306502, 0.15506290863683936, 0.1568416374724998]}, "mutation_prompt": null}
{"id": "b412ab4a-e125-462a-87cd-80ea8eb3e334", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR_min, CR_max = 0.5, 1.0  # Dynamically adjust crossover probability\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                CR = np.random.uniform(CR_min, CR_max)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A modified hybrid algorithm utilizing adaptive Levy flights with dynamic crossover probability to enhance exploration and exploitation balance in black-box optimization.", "configspace": "", "generation": 12, "fitness": 0.7818590842241123, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.782 with standard deviation 0.011. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7679201947501602, 0.793594550317602, 0.7840625076045749], "final_y": [0.15354279023234862, 0.1601017669387199, 0.1601653686146266]}, "mutation_prompt": null}
{"id": "560b2cae-2e80-49b1-a794-80ac2c140210", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n            # Stochastic ranking to encourage exploration\n            if np.random.rand() < 0.1:\n                ranked_population = sorted(self.population, key=func)\n                self.population = np.array(ranked_population)\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid method incorporating adaptive Levy flights with stochastic ranking to enhance convergence accuracy in black-box optimization.", "configspace": "", "generation": 12, "fitness": 0.7971967028849275, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.025. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8028138126035058, 0.8241486109824712, 0.7646276850688053], "final_y": [0.12587174224086173, 0.13588594480418237, 0.16750676568250988]}, "mutation_prompt": null}
{"id": "188a4daa-460a-48f2-a6ea-d767584aec47", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.5, 0.9  # Mutation factor range, slight modification here\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined mutation strategy incorporating dynamic adjustment of mutation factor range to enhance exploration and convergence in black-box optimization.", "configspace": "", "generation": 12, "fitness": 0.7872553212368345, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.024. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7626038779150711, 0.8202707685426862, 0.7788913172527459], "final_y": [0.16626720854863009, 0.14984696979749712, 0.1616414013309947]}, "mutation_prompt": null}
{"id": "fe3865cc-1fdb-403b-b6d9-3c14c21b7101", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_archive = []\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                F = F_min + (F_max - F_min) * np.random.uniform(0, 1)**2  # Dynamic F\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                    self.elite_archive.append(trial)\n\n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n                    self.elite_archive.append(candidate)\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach integrating dynamic parameter adaptation and elite archiving for enhanced convergence in black-box optimization.", "configspace": "", "generation": 12, "fitness": 0.8003802608847991, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.015. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8209117706281019, 0.793594550317602, 0.7866344617086931], "final_y": [0.13851247181067383, 0.1601017669387199, 0.15794424060335566]}, "mutation_prompt": null}
{"id": "fd06b697-8bbf-4bb3-8b6b-4c28554c8d30", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.5, 0.9  # Adjusted mutation factor range\n        CR = 0.8  # Adjusted crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Advanced hybrid approach integrating adaptive Levy flights with dynamic mutation and crossover strategies for enhanced convergence in black-box optimization.", "configspace": "", "generation": 13, "fitness": 0.7776885593663277, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.778 with standard deviation 0.012. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7712043233909888, 0.7939269125190844, 0.7679344421889099], "final_y": [0.1648209175115356, 0.1530542548196414, 0.1520552838071868]}, "mutation_prompt": null}
{"id": "f6f6254c-0b6b-4a44-9f89-c058ecc1b81b", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        # Changed line: Adaptive crossover probability based on iteration\n        CR_min, CR_max = 0.5, 0.9  \n\n        for iter in range(self.budget):\n            CR = CR_min + (CR_max - CR_min) * (iter / self.budget)  # Adaptive CR\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduced adaptive crossover probability to enhance exploration-exploitation balance in the algorithm.", "configspace": "", "generation": 13, "fitness": 0.7808417075472848, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.009. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7763092930540613, 0.793594550317602, 0.7726212792701908], "final_y": [0.146799648387674, 0.1601017669387199, 0.15549098541398665]}, "mutation_prompt": null}
{"id": "3c8f80ff-ad63-4a10-a0f7-3b5537c1dfba", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.1  # Mutation probability added for diversity\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.3, 0.8  # Adjusted mutation factor range\n        CR_min, CR_max = 0.7, 0.95  # Dynamic crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < np.random.uniform(CR_min, CR_max)\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:  # Apply mutation with a certain probability\n                    step = self.levy_flight()\n                    candidate = np.clip(self.population[i] + step, lb, ub)\n                else:\n                    candidate = self.population[i]\n                \n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A novel hybrid optimization approach that integrates adaptive Levy flights with enhanced differential evolution and dynamic parameter adjustment to improve convergence in black-box optimization.", "configspace": "", "generation": 13, "fitness": 0.7909118408133846, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.009. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7997576349342452, 0.793594550317602, 0.7793833371883065], "final_y": [0.15299373170625263, 0.1601017669387199, 0.14702856323626012]}, "mutation_prompt": null}
{"id": "28d64da2-9b8d-40b9-b16e-6fa9939a8505", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9\n        CR = 0.9\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = F_min + (F_max - F_min) * (self.budget - _) / self.budget  # Adaptive mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach incorporating adaptive mutation scaling for improved exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.7890265979783998, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.022. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.758772668411046, 0.7983474955738575, 0.8099596299502958], "final_y": [0.17078774292574295, 0.15743592177457055, 0.14538796006691412]}, "mutation_prompt": null}
{"id": "300e4ef5-e706-4621-9758-1da4830d496a", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.7, 1.0  # Adaptive crossover probability range\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                CR = np.random.uniform(CR_min, CR_max)  # Adaptive crossover probability\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Introduced adaptive crossover probability to enhance exploration-exploitation balance in differential evolution.", "configspace": "", "generation": 13, "fitness": 0.7790376138654124, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.025. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7442688849589149, 0.8003863169823833, 0.7924576396549389], "final_y": [0.16381625273372413, 0.155331396060977, 0.15544217497321233]}, "mutation_prompt": null}
{"id": "d405dc0c-cd3c-49fc-929c-1e4a2b8b9654", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR_min, CR_max = 0.7, 0.9  # Adjusted Crossover probability range\n        CR = np.random.uniform(CR_min, CR_max)  # Dynamic crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Integrate a learning-based adaptation to refine mutation and crossover parameters dynamically in the algorithm.", "configspace": "", "generation": 14, "fitness": 0.7936781061974916, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.008. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7881424552661229, 0.8046453682035917, 0.78824649512276], "final_y": [0.15305988359626432, 0.1547890569481004, 0.1531687996582659]}, "mutation_prompt": null}
{"id": "42a78bd5-8a0b-4773-ab7d-7b180ff37713", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        initial_CR, final_CR = 0.5, 0.9  # Dynamic Crossover probability range\n\n        for generation in range(self.budget):\n            CR = initial_CR + (final_CR - initial_CR) * (generation / self.budget)  # Dynamic CR\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Improved mutation strategy using dynamic crossover probability for better exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.7976675887693782, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.017. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.801055735868218, 0.8171023923787806, 0.7748446380611358], "final_y": [0.15063621483748835, 0.14100440606671938, 0.16516654882635495]}, "mutation_prompt": null}
{"id": "42c942e9-310e-46d9-a264-80f5ed2b3857", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                # Change: Introduce dynamic mutation factor based on iteration progress\n                F = F_min + (F_max - F_min) * (_ / self.budget)  \n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhanced exploration by introducing dynamic mutation factor adaptation in differential evolution for improved convergence.", "configspace": "", "generation": 14, "fitness": 0.7910060316037782, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.015. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.8080773517056676, 0.7943611781382681, 0.7705795649673993], "final_y": [0.15142308614179723, 0.15881138071308143, 0.1594381816760424]}, "mutation_prompt": null}
{"id": "7f45b555-dca6-4f68-b9a5-a7c69402fb7a", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid algorithm leveraging adaptive Levy flights and dynamic mutation factor for enhanced convergence.", "configspace": "", "generation": 14, "fitness": 0.7843697329623919, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.032. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7396955847357429, 0.7985292728070046, 0.814884341344428], "final_y": [0.17532750504777284, 0.15146056906821337, 0.1383763879557084]}, "mutation_prompt": null}
{"id": "2a303d85-4711-4a2a-8743-5a95af2710ce", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.3, 0.9  # Adjusted mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach using adaptive Levy flights and a refined mutation strategy with enhanced mutation factor range to improve convergence in black-box optimization.", "configspace": "", "generation": 14, "fitness": 0.7927392279594446, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.016. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7773475802198861, 0.8153503931513263, 0.7855197105071214], "final_y": [0.15718478060227625, 0.13993625782778218, 0.1500914045352787]}, "mutation_prompt": null}
{"id": "252aa26c-c7a9-4b47-8bed-a9b0e96fb8d4", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = F_min + (F_max - F_min) * (self.budget - _) / self.budget  # Dynamic mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined hybrid approach using adaptive Levy flights with dynamic mutation rate scaling for enhanced convergence in black-box optimization.", "configspace": "", "generation": 15, "fitness": 0.7778300710958496, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.778 with standard deviation 0.027. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7572641234457168, 0.8165243777661733, 0.7597017120756586], "final_y": [0.15679702875527557, 0.1525407792965705, 0.17296403364081692]}, "mutation_prompt": null}
{"id": "b0c7400d-2ba3-40f2-a67b-b473cbe6d47b", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        # Changed line introducing dynamic crossover probability\n        CR = np.random.uniform(0.8, 1.0)  # Dynamic crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Refined mutation strategy by introducing a dynamic crossover probability to enhance exploitation-exploration balance.", "configspace": "", "generation": 15, "fitness": 0.7871740907462615, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.005. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7821014162265283, 0.793594550317602, 0.7858263056946546], "final_y": [0.16095870573865068, 0.1601017669387199, 0.16160158098888588]}, "mutation_prompt": null}
{"id": "bc5a66e1-b155-4de7-9fe8-9fc8b78e7856", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max) + 0.1 * (1 - _/self.budget)  # Random mutation factor with enhancement\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "Enhanced mutation factor adaptation in hybrid Levy differential evolution to improve solution convergence.  ", "configspace": "", "generation": 15, "fitness": 0.7843984390641762, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.008. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7743245322797174, 0.7945160969619671, 0.7843546879508443], "final_y": [0.16610711542739942, 0.15815002530970412, 0.1435486229645807]}, "mutation_prompt": null}
{"id": "7b3450a4-cd65-44bc-b5b6-fd5f8599bdaa", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n\n                # Modified line\n                F = np.random.normal((F_min + F_max) / 2, 0.1)  # Adaptive mutation factor\n\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A refined adaptive mutation strategy in differential evolution enhancing exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.7886335562023836, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.033. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7662150364151836, 0.8354418374977437, 0.7642437946942234], "final_y": [0.1601565149608125, 0.14292428690691583, 0.15649812642220895]}, "mutation_prompt": null}
{"id": "db9dc18a-38b9-49cc-b512-8ccd918cd6f6", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F_min, F_max = 0.4, 0.9  # Mutation factor range\n        CR = 0.8  # Crossover probability reduced from 0.9 to 0.8\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                F = np.random.uniform(F_min, F_max)  # Random mutation factor\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "An enhanced strategy using a reduced crossover probability to improve solution diversity and exploration in differential evolution.", "configspace": "", "generation": 15, "fitness": 0.7813767536870548, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.009. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "2e4fbd33-fe03-428d-9a0e-97242bb8c033", "metadata": {"aucs": [0.7734575287997774, 0.7936264013570657, 0.7770463309043213], "final_y": [0.16426762054255306, 0.1599668603588854, 0.1588880938230396]}, "mutation_prompt": null}
