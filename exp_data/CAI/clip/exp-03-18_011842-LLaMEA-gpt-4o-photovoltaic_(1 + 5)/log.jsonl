{"id": "9bb174d2-fcb3-4774-8b4f-1c89a75d103f", "solution": "import numpy as np\n\nclass HybridLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget / dim)\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def differential_evolution(self, func, lb, ub):\n        F = 0.5  # Mutation factor\n        CR = 0.9  # Crossover probability\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                x = self.population[i]\n                mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, x)\n                fitness = func(trial)\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = trial\n                \n                if fitness < func(x):\n                    self.population[i] = trial\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(lb, ub)\n        self.differential_evolution(func, lb, ub)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                step = self.levy_flight()\n                candidate = np.clip(self.population[i] + step, lb, ub)\n                fitness = func(candidate)\n                \n                if fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = candidate\n\n        return self.best_solution", "name": "HybridLevyDifferentialEvolution", "description": "A hybrid metaheuristic combining differential evolution with adaptive LÃ©vy flights for enhanced exploration and exploitation in black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.8028074043180262, "feedback": "The algorithm HybridLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.009. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8044662754783449, 0.8123362157208858, 0.791619721754848], "final_y": [0.15658611197316297, 0.14331871712995803, 0.1503035974768956]}, "mutation_prompt": null}
