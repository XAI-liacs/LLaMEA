{"id": "a1f04b9c-c3d5-4ede-bf50-736ddcfd7ffe", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9\n        self.F = 0.8  # Differential weight\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.1234, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A novel hybrid metaheuristic combining Differential Evolution with adaptive chaos-based parameter control to efficiently explore and exploit complex search spaces.", "configspace": "", "generation": 0, "fitness": 0.28644618074455874, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.092. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3515864271046544, 0.35152936856076555, 0.1562227465682563], "final_y": [1.692082063235886e-05, 3.614934720349906e-05, 0.02332898585784688]}, "mutation_prompt": null}
{"id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.8\n        self.F = 0.5  # Reduced differential weight for better stability\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map with enhanced parameters\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.9 * x * (1.0 - x)  # Slightly altered logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.5678, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F  # Initialize adaptive control\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.9  # Decrease F to favor stability\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "An improved hybrid metaheuristic combining Differential Evolution with chaotic sequences and adaptive parameter control for enhanced exploration and exploitation in complex search spaces.", "configspace": "", "generation": 1, "fitness": 0.373021161433195, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.103. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.041.", "error": "", "parent_id": "a1f04b9c-c3d5-4ede-bf50-736ddcfd7ffe", "metadata": {"aucs": [0.3762980119112991, 0.24479663454922773, 0.4979688378390583], "final_y": [0.00021545688039615156, 0.08684230389779497, 9.819821693805445e-07]}, "mutation_prompt": null}
{"id": "fd75560f-9287-4914-925d-0c41ebbf0307", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.8\n        self.F = 0.5  # Reduced differential weight for better stability\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map with enhanced parameters\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.9 * x * (1.0 - x)  # Slightly altered logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.5678, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F  # Initialize adaptive control\n        adaptive_crossover_rate = self.crossover_rate  # Initialize adaptive crossover\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate  # Adaptive crossover\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.9  # Decrease F to favor stability\n                        adaptive_crossover_rate *= 1.1  # Increase crossover rate to boost exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover for improved exploration-exploitation balance in optimization tasks.", "configspace": "", "generation": 2, "fitness": 0.29414758855439055, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.294 with standard deviation 0.089. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.235.", "error": "", "parent_id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "metadata": {"aucs": [0.1861496810542308, 0.2924240070851737, 0.4038690775237672], "final_y": [0.5120233722235759, 0.025036998813300182, 0.0008431983552902737]}, "mutation_prompt": null}
{"id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic incorporating a chaotic sequence variant and adaptive mutation strategies for enhanced diversity and convergence in complex search spaces.", "configspace": "", "generation": 3, "fitness": 0.4285978597707123, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.429 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "metadata": {"aucs": [0.41978739312779245, 0.4413266493603967, 0.4246795368239479], "final_y": [1.4554628945852391e-05, 3.922742352513682e-07, 5.564048674166954e-06]}, "mutation_prompt": null}
{"id": "498ebbd8-d6bd-463d-970d-17547adc9d2c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Increased influence of fourth individual\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # Adjust F more aggressively\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "An adaptive chaotic differential evolution algorithm with enhanced mutation and crossover strategies for improved optimization of black box functions.", "configspace": "", "generation": 4, "fitness": 0.37254909854456614, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.055. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.37866482601141216, 0.4361707274925579, 0.3028117421297284], "final_y": [0.0005129195744817855, 6.631841507733155e-07, 0.010456270487603893]}, "mutation_prompt": null}
{"id": "ba360809-4834-4d71-9903-a36202b902a9", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Increased for more exploration\n        self.F = 0.6  # Adjusted to improve exploration\n        self.lb, self.ub = None, None\n        self.chaotic_seed1 = 0.5678\n        self.chaotic_seed2 = 0.8765  # Second chaotic sequence seed for diversity\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq1 = self.chaotic_sequence(self.chaotic_seed1, self.population_size * self.dim)\n        chaotic_seq2 = self.chaotic_sequence(self.chaotic_seed2, self.population_size * self.dim)\n        mixed_seq = [(a + b) / 2 for a, b in zip(chaotic_seq1, chaotic_seq2)]\n        population = np.array(mixed_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.93  # Further adjust F for optimized exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dual-chaos sequences and adaptive mutation strategy to improve diversity and convergence.", "configspace": "", "generation": 5, "fitness": 0.4054061940951248, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.405 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.43689585536279407, 0.37292982605050484, 0.40639290087207547], "final_y": [2.193930478858568e-05, 0.00033923029450914764, 7.495838963892912e-06]}, "mutation_prompt": null}
{"id": "0798a0df-5883-4168-81b5-3079d73af128", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted for better exploration\n        self.crossover_rate = 0.9  # Increased for more diverse solutions\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Seed for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # More intense logistic map for enhanced chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Adjusted factor\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.92  # More fine-tuned adjustment of F\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with a dynamic chaotic sequence and adaptive parameter control for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.3933764113432702, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.393 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.3737255901263914, 0.39804882058491486, 0.40835482331850426], "final_y": [5.193756056036208e-05, 3.540649713181473e-06, 9.202725949612548e-06]}, "mutation_prompt": null}
{"id": "8f5fadcb-a8f8-428a-9c95-119edf94d764", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * (1.0 - evaluations / self.budget)  # Adaptive crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover rate for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.27076425304456, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.042. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.21261153113816256, 0.29236601959761355, 0.3073152083979038], "final_y": [0.03889476805054915, 0.009334752281167672, 0.0069768953953484565]}, "mutation_prompt": null}
{"id": "4f5fa72b-edc4-4da4-bcf9-b76c8e5556d5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # Adjusted F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic incorporating chaotic sequence variant, adaptive mutation strategies, and improved crossover for enhanced diversity and convergence in complex search spaces.", "configspace": "", "generation": 8, "fitness": 0.18671778340122244, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.103. And the mean value of best solutions found was 1.821 (0. is the best) with standard deviation 1.590.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.13566934551815413, 0.09468967753475299, 0.3297943271507602], "final_y": [1.580894613847943, 3.877917246755667, 0.004595887657131064]}, "mutation_prompt": null}
{"id": "e4d6e9fd-a085-4e3f-a48a-782ab498f247", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive crossover rate based on fitness improvement\n                self.crossover_rate = 0.8 + 0.2 * (fitness[best_idx] / (fitness[i] + 1e-9))\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced chaotic differential evolution with adaptive crossover for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.4072814621080327, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.407 with standard deviation 0.038. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.4476531091563867, 0.35571843047729745, 0.41847284669041385], "final_y": [2.9399173859245022e-05, 0.0012426734325576916, 1.352669777377892e-06]}, "mutation_prompt": null}
