{"id": "a1f04b9c-c3d5-4ede-bf50-736ddcfd7ffe", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9\n        self.F = 0.8  # Differential weight\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.1234, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A novel hybrid metaheuristic combining Differential Evolution with adaptive chaos-based parameter control to efficiently explore and exploit complex search spaces.", "configspace": "", "generation": 0, "fitness": 0.28644618074455874, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.092. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3515864271046544, 0.35152936856076555, 0.1562227465682563], "final_y": [1.692082063235886e-05, 3.614934720349906e-05, 0.02332898585784688]}, "mutation_prompt": null}
{"id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.8\n        self.F = 0.5  # Reduced differential weight for better stability\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map with enhanced parameters\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.9 * x * (1.0 - x)  # Slightly altered logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.5678, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F  # Initialize adaptive control\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.9  # Decrease F to favor stability\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "An improved hybrid metaheuristic combining Differential Evolution with chaotic sequences and adaptive parameter control for enhanced exploration and exploitation in complex search spaces.", "configspace": "", "generation": 1, "fitness": 0.373021161433195, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.103. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.041.", "error": "", "parent_id": "a1f04b9c-c3d5-4ede-bf50-736ddcfd7ffe", "metadata": {"aucs": [0.3762980119112991, 0.24479663454922773, 0.4979688378390583], "final_y": [0.00021545688039615156, 0.08684230389779497, 9.819821693805445e-07]}, "mutation_prompt": null}
{"id": "fd75560f-9287-4914-925d-0c41ebbf0307", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.8\n        self.F = 0.5  # Reduced differential weight for better stability\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map with enhanced parameters\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.9 * x * (1.0 - x)  # Slightly altered logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.5678, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F  # Initialize adaptive control\n        adaptive_crossover_rate = self.crossover_rate  # Initialize adaptive crossover\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate  # Adaptive crossover\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.9  # Decrease F to favor stability\n                        adaptive_crossover_rate *= 1.1  # Increase crossover rate to boost exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover for improved exploration-exploitation balance in optimization tasks.", "configspace": "", "generation": 2, "fitness": 0.29414758855439055, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.294 with standard deviation 0.089. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.235.", "error": "", "parent_id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "metadata": {"aucs": [0.1861496810542308, 0.2924240070851737, 0.4038690775237672], "final_y": [0.5120233722235759, 0.025036998813300182, 0.0008431983552902737]}, "mutation_prompt": null}
{"id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic incorporating a chaotic sequence variant and adaptive mutation strategies for enhanced diversity and convergence in complex search spaces.", "configspace": "", "generation": 3, "fitness": 0.4285978597707123, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.429 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "metadata": {"aucs": [0.41978739312779245, 0.4413266493603967, 0.4246795368239479], "final_y": [1.4554628945852391e-05, 3.922742352513682e-07, 5.564048674166954e-06]}, "mutation_prompt": null}
{"id": "498ebbd8-d6bd-463d-970d-17547adc9d2c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Increased influence of fourth individual\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # Adjust F more aggressively\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "An adaptive chaotic differential evolution algorithm with enhanced mutation and crossover strategies for improved optimization of black box functions.", "configspace": "", "generation": 4, "fitness": 0.37254909854456614, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.055. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.37866482601141216, 0.4361707274925579, 0.3028117421297284], "final_y": [0.0005129195744817855, 6.631841507733155e-07, 0.010456270487603893]}, "mutation_prompt": null}
{"id": "ba360809-4834-4d71-9903-a36202b902a9", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Increased for more exploration\n        self.F = 0.6  # Adjusted to improve exploration\n        self.lb, self.ub = None, None\n        self.chaotic_seed1 = 0.5678\n        self.chaotic_seed2 = 0.8765  # Second chaotic sequence seed for diversity\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq1 = self.chaotic_sequence(self.chaotic_seed1, self.population_size * self.dim)\n        chaotic_seq2 = self.chaotic_sequence(self.chaotic_seed2, self.population_size * self.dim)\n        mixed_seq = [(a + b) / 2 for a, b in zip(chaotic_seq1, chaotic_seq2)]\n        population = np.array(mixed_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.93  # Further adjust F for optimized exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dual-chaos sequences and adaptive mutation strategy to improve diversity and convergence.", "configspace": "", "generation": 5, "fitness": 0.4054061940951248, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.405 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.43689585536279407, 0.37292982605050484, 0.40639290087207547], "final_y": [2.193930478858568e-05, 0.00033923029450914764, 7.495838963892912e-06]}, "mutation_prompt": null}
{"id": "0798a0df-5883-4168-81b5-3079d73af128", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted for better exploration\n        self.crossover_rate = 0.9  # Increased for more diverse solutions\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Seed for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # More intense logistic map for enhanced chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Adjusted factor\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.92  # More fine-tuned adjustment of F\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with a dynamic chaotic sequence and adaptive parameter control for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.3933764113432702, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.393 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.3737255901263914, 0.39804882058491486, 0.40835482331850426], "final_y": [5.193756056036208e-05, 3.540649713181473e-06, 9.202725949612548e-06]}, "mutation_prompt": null}
{"id": "8f5fadcb-a8f8-428a-9c95-119edf94d764", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * (1.0 - evaluations / self.budget)  # Adaptive crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover rate for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.27076425304456, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.042. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.21261153113816256, 0.29236601959761355, 0.3073152083979038], "final_y": [0.03889476805054915, 0.009334752281167672, 0.0069768953953484565]}, "mutation_prompt": null}
{"id": "4f5fa72b-edc4-4da4-bcf9-b76c8e5556d5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # Adjusted F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic incorporating chaotic sequence variant, adaptive mutation strategies, and improved crossover for enhanced diversity and convergence in complex search spaces.", "configspace": "", "generation": 8, "fitness": 0.18671778340122244, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.103. And the mean value of best solutions found was 1.821 (0. is the best) with standard deviation 1.590.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.13566934551815413, 0.09468967753475299, 0.3297943271507602], "final_y": [1.580894613847943, 3.877917246755667, 0.004595887657131064]}, "mutation_prompt": null}
{"id": "e4d6e9fd-a085-4e3f-a48a-782ab498f247", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive crossover rate based on fitness improvement\n                self.crossover_rate = 0.8 + 0.2 * (fitness[best_idx] / (fitness[i] + 1e-9))\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced chaotic differential evolution with adaptive crossover for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.4072814621080327, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.407 with standard deviation 0.038. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.4476531091563867, 0.35571843047729745, 0.41847284669041385], "final_y": [2.9399173859245022e-05, 0.0012426734325576916, 1.352669777377892e-06]}, "mutation_prompt": null}
{"id": "9f4f1cc4-7123-4a73-9b72-daa9b1f3721e", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # Enhanced chaos with logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.15 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.93  # Further adjust F for exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced chaotic strategy and adaptive mutation dynamics for robust search convergence.", "configspace": "", "generation": 10, "fitness": 0.40352313285029534, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.404 with standard deviation 0.073. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.46150761946362795, 0.4481679441391516, 0.3008938349481065], "final_y": [4.8764127660356105e-06, 3.7753002191294022e-06, 0.002962830601808253]}, "mutation_prompt": null}
{"id": "a00573d3-3928-428a-b9f6-6b14f4c0020c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # More aggressive F adjustment for controlling exploration\n\n                # Introduce tournament selection to maintain diversity\n                tournament_indices = np.random.choice(self.population_size, 2, replace=False)\n                if fitness[tournament_indices[0]] < fitness[tournament_indices[1]]:\n                    loser = tournament_indices[1]\n                else:\n                    loser = tournament_indices[0]\n                if trial_fitness < fitness[loser]:\n                    population[loser] = trial\n                    fitness[loser] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing the mutation strategy with dynamic adaptation and introducing tournament selection for better exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.25310751306207063, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.253 with standard deviation 0.062. And the mean value of best solutions found was 0.250 (0. is the best) with standard deviation 0.227.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.33653041555283447, 0.23627280769000292, 0.18651931594337456], "final_y": [0.013415206562173432, 0.17953385602024302, 0.5557369722167725]}, "mutation_prompt": null}
{"id": "cc633490-6286-4b71-9a9e-4749ed86950f", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        golden_ratio = 1.618  # Added golden ratio for mutation scaling\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant *= golden_ratio  # Use golden ratio for mutation scaling\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improve convergence by enhancing mutation using golden ratio scaling for diversity.", "configspace": "", "generation": 12, "fitness": 0.1589746817457076, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.159 with standard deviation 0.011. And the mean value of best solutions found was 0.880 (0. is the best) with standard deviation 0.566.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.17406356494963948, 0.15176817182863478, 0.15109230845884858], "final_y": [0.08168278633950932, 1.3257654813729427, 1.2323026451331216]}, "mutation_prompt": null}
{"id": "5c4f2d14-844b-48e0-a3d4-9c03d90ec5d4", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        adaptive_CR = self.crossover_rate  # Added adaptive crossover rate\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR  # Use adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n                        adaptive_CR *= 0.98  # Adjust crossover rate\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic that enhances diversity and convergence by integrating a chaotic sequence with adaptive mutation and crossover strategies, now incorporating adaptive crossover rate for improved exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.4180476324463073, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.418 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.43538930782387275, 0.4128313965549354, 0.4059221929601138], "final_y": [1.662107055867211e-06, 2.156808019657389e-05, 4.397672024612987e-06]}, "mutation_prompt": null}
{"id": "a6451727-5344-4477-8b09-b1e5db9ea534", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        adaptive_crossover_rate = self.crossover_rate\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n                        adaptive_crossover_rate *= 0.98  # Adjust crossover rate for balance\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover rate for better balance between exploration and exploitation.", "configspace": "", "generation": 14, "fitness": 0.32301814307096255, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.323 with standard deviation 0.145. And the mean value of best solutions found was 0.695 (0. is the best) with standard deviation 0.982.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.46001993422122456, 0.12211189018020296, 0.3869226048114601], "final_y": [2.325279776491135e-06, 2.0835923350200036, 1.2974986137844609e-05]}, "mutation_prompt": null}
{"id": "61d52090-b06f-4ed1-a7e1-d77397079026", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()  # Compute population diversity\n            adaptive_CR = 0.5 + 0.5 * (1 - diversity)  # Adjust crossover rate based on diversity\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR  # Use adaptive crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Chaotic Adaptive DE variant balancing exploration and exploitation using adaptive scaling and crossover rates based on population diversity.", "configspace": "", "generation": 15, "fitness": 0.17232479084368843, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.009. And the mean value of best solutions found was 0.415 (0. is the best) with standard deviation 0.248.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.18355930888061034, 0.16238129554354064, 0.17103376810691429], "final_y": [0.09287495375769317, 0.6976851210569631, 0.45396296177711937]}, "mutation_prompt": null}
{"id": "49e9d0e4-4027-4198-966f-52083d00a1b7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Adjusted dynamically in the loop\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = 0.8 + 0.2 * (fitness[i] - fitness[best_idx]) / (fitness[i] + fitness[best_idx])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution by dynamically adjusting crossover rate and integrating elitism to enhance exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.44099633662845167, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.441 with standard deviation 0.052. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.38632731806485043, 0.4249236189271278, 0.5117380728933766], "final_y": [0.0001445495552728142, 1.3931906721536147e-05, 2.2842020716525611e-07]}, "mutation_prompt": null}
{"id": "570bb3f0-b7c3-40d0-9f20-f7ca34b74fe5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Adjusted dynamically in the loop\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                adaptive_F = 0.4 + 0.6 * np.random.rand()  # Adaptive mutation factor\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = 0.7 + 0.3 * (fitness[i] - fitness[best_idx]) / (fitness[i] + fitness[best_idx])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive mutation and dynamic crossover for improved convergence and robustness.", "configspace": "", "generation": 17, "fitness": 0.34454583516538956, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.345 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "49e9d0e4-4027-4198-966f-52083d00a1b7", "metadata": {"aucs": [0.3187681013307453, 0.37654147777579916, 0.3383279263896243], "final_y": [0.0003380140302123144, 2.544881960013884e-05, 5.3736581111096636e-05]}, "mutation_prompt": null}
{"id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with dynamic scaling factor and chaotic crossover rate for improved balance.", "configspace": "", "generation": 18, "fitness": 0.5230666321472787, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.523 with standard deviation 0.031. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "49e9d0e4-4027-4198-966f-52083d00a1b7", "metadata": {"aucs": [0.4934882251209114, 0.5654811450292025, 0.5102305262917219], "final_y": [4.982374068297639e-07, 3.699743000155531e-08, 6.148716632008198e-08]}, "mutation_prompt": null}
{"id": "53384fbd-7c25-4f66-85e1-e65bd7ec2cc2", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.mutation_factor = 0.2\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def chaotic_mutation_factor(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, 1)\n        return 0.1 + chaotic_seq[0] * 0.9\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                adaptive_mutation_factor = self.chaotic_mutation_factor()\n                mutant = population[a] + adaptive_mutation_factor * (population[b] - population[c]) + self.mutation_factor * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Advanced Chaotic Differential Evolution with dynamic chaotic mutation and adaptive crossover for enhanced exploration and exploitation.", "configspace": "", "generation": 19, "fitness": 0.2770352145863906, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.016. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.29654961369436794, 0.27657066241435946, 0.25798536765044433], "final_y": [0.00027735055161332776, 0.0027159158024587333, 0.012717298736042985]}, "mutation_prompt": null}
{"id": "27412d7b-52d4-4b9c-9a32-7c46edd33c62", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.5:\n                self.population_size = int(self.population_size * 0.9)  # Reduce population size\n                self.dim = max(1, self.dim - 1)  # Reduce dimensionality\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Chaotic Differential Evolution with Time-Varying Population and Dimensionality Reduction for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "037509ae-a84d-4b99-82e7-d1fd9f083548", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                chaotic_mutation_factor = 0.1 * self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + chaotic_mutation_factor * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with a dynamic and chaotic mutation strategy for improved exploration.", "configspace": "", "generation": 21, "fitness": 0.4698137356415046, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.470 with standard deviation 0.032. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.45055745439632755, 0.44360812331591737, 0.5152756292122689], "final_y": [1.5515802228124561e-06, 1.3500625201056557e-06, 2.6275326596098903e-07]}, "mutation_prompt": null}
{"id": "0ba97f2e-8553-4db1-ae0d-4e698a2150e4", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_population_adaptation(self, evaluations):\n        if evaluations > self.budget // 2:\n            self.population_size = max(5, self.population_size // 2)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            self.dynamic_population_adaptation(evaluations)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + np.random.uniform(-0.1, 0.1, self.dim)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with enhanced mutation strategy and dynamic population adaptation for better exploration and exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.2542283609215958, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.254 with standard deviation 0.007. And the mean value of best solutions found was 0.037 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.26435479775857673, 0.2474141730937377, 0.2509161119124729], "final_y": [0.023287941727443764, 0.06509393720701995, 0.024047754861912764]}, "mutation_prompt": null}
{"id": "ae91082a-cec1-4018-bc10-a9de608f40d2", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamically reduce population size\n            if evaluations % (self.budget // 5) == 0:\n                self.population_size = max(4, int(self.population_size * 0.9))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing dynamic population size reduction to enhance convergence efficiency in Chaotic Differential Evolution.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 18').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 18')", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "ded90d95-8cdc-4076-aab6-9c0ffdd901bf", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.15 * (population[d] - population[i])  # Increased mutation step\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with dynamic scaling factor, chaotic crossover rate, and refined mutation step for improved solution quality.", "configspace": "", "generation": 24, "fitness": 0.41620171362956065, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.416 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.423381793165465, 0.425124414892896, 0.40009893283032094], "final_y": [6.016170781698728e-07, 9.551532079822043e-07, 1.558491116291989e-06]}, "mutation_prompt": null}
{"id": "2f2ba23d-d75c-4263-9b9a-1ad9dd68e701", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.chaotic_sequence_cache = {}\n\n    def chaotic_sequence(self, seed, n):\n        if (seed, n) in self.chaotic_sequence_cache:\n            return self.chaotic_sequence_cache[(seed, n)]\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        self.chaotic_sequence_cache[(seed, n)] = result\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_mutation_strategy(self, population, best_solution, i, a, b, c):\n        mutation_rate = 0.3 + 0.7 * np.mean(population, axis=0)\n        mutant = best_solution + mutation_rate * (population[a] - population[b] + population[c] - population[i])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.dynamic_mutation_strategy(population, best_solution, i, a, b, c)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with dynamic mutation strategy and enhanced chaotic crossover to boost exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.09735329218511964, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.002. And the mean value of best solutions found was 4.194 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.09645149598433256, 0.09610188392469188, 0.09950649664633449], "final_y": [4.211640247576694, 4.195930450224511, 4.173338903361582]}, "mutation_prompt": null}
{"id": "a1faeca0-7149-4d90-8aab-124262fbc4b5", "solution": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # Improved chaotic sequence for better exploration\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def update_population(self, population, fitness, best_idx):  # New helper method\n        inertia_weight = 0.5 + np.random.rand() / 2\n        best_pos = population[best_idx]\n        for i in range(self.population_size):\n            if i != best_idx:\n                population[i] = inertia_weight * population[i] + (best_pos - population[i])\n                population[i] = np.clip(population[i], self.lb, self.ub)\n        return population, fitness\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            population, fitness = self.update_population(population, fitness, best_idx)  # Swarm intelligence update\n\n        return best_solution", "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dynamic swarm intelligence and improved chaotic sequence for global exploration.", "configspace": "", "generation": 26, "fitness": 0.19026057262756732, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.190 with standard deviation 0.044. And the mean value of best solutions found was 0.647 (0. is the best) with standard deviation 0.566.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.18373272436145938, 0.14034553445534548, 0.24670345906589708], "final_y": [0.4334673392003505, 1.4213785975363502, 0.08611608643783004]}, "mutation_prompt": null}
{"id": "b9539e53-a5fb-45a3-897d-4429f444c842", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self, size):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, size * self.dim)\n        population = np.array(chaotic_seq).reshape(size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size / (1 + 0.1 * evaluations / self.budget)))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = self.initialize_population(population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            population_size = self.dynamic_population_size(evaluations)\n            for i in range(population_size):\n                indices = list(range(population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                r = np.random.rand()\n                mutant = population[a] + r * adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive population size and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.3731216904257617, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.128. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.186.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.5048091209600788, 0.19895501603192212, 0.41560093428528433], "final_y": [1.5368615256041256e-05, 0.39595447943874196, 0.0010504195174418159]}, "mutation_prompt": null}
{"id": "48461118-e90e-47be-a933-d8be9ab7d292", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.95 * x * (1.0 - x)  # Slightly changed chaotic sequence multiplier\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.9 + 0.1 * chaotic_cross  # Adjusted crossover rate calculation\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with improved chaotic sequences and crossover strategy.", "configspace": "", "generation": 28, "fitness": 0.5116429135106234, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.512 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.5007325200614308, 0.5250905182891643, 0.5091057021812754], "final_y": [4.949261673432147e-08, 1.2084964477633582e-07, 5.423969718499872e-08]}, "mutation_prompt": null}
{"id": "07888386-4e21-4577-85bc-0a367d6b8a05", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def nonlinear_chaotic_mutation(self, x, y, z, w):\n        chaotic_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n        return x + chaotic_factor * ((y - z) * np.cos(w))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = self.nonlinear_chaotic_mutation(population[a], population[b], population[c], population[d])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a Nonlinear Chaotic Mutation Strategy for Enhanced Exploration in Chaotic Differential Evolution.", "configspace": "", "generation": 29, "fitness": 0.36440069630805144, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.364 with standard deviation 0.044. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.31909451519740817, 0.424480822958341, 0.3496267507684051], "final_y": [2.890874490780302e-05, 2.4801629364311214e-06, 1.6383710629097216e-05]}, "mutation_prompt": null}
{"id": "90614179-579b-4386-a75d-fdbe5735b984", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def levy_flight(self, L):\n        return np.random.normal(0, 1, self.dim) / np.power(np.random.normal(0, 1), 1/L)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        L = 1.5  # Levy flight index\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                levy_step = self.levy_flight(L)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + levy_step\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.6 + 0.4 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with Lvy Flight for exploration and novel adaptive crossover rate for balance.", "configspace": "", "generation": 30, "fitness": 0.18201436295589635, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.182 with standard deviation 0.003. And the mean value of best solutions found was 0.457 (0. is the best) with standard deviation 0.145.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.17813265240701803, 0.18212014241863428, 0.18579029404203673], "final_y": [0.5026101648355845, 0.6075346337909904, 0.2602580000649294]}, "mutation_prompt": null}
