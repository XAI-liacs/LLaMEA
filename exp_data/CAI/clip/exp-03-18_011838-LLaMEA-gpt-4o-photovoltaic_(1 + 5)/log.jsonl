{"id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump\n                if np.random.rand() < self.quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) leverages quantum-inspired particle movement with adaptive convergence strategies to explore and exploit solution spaces effectively.", "configspace": "", "generation": 0, "fitness": 0.8312645776685378, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.028. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8703718442422566, 0.8177184255774798, 0.8057034631858772], "final_y": [0.12538000498599444, 0.14528866189325462, 0.14565935931096685]}, "mutation_prompt": null}
