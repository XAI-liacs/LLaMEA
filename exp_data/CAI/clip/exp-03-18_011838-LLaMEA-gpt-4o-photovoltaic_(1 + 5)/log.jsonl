{"id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump\n                if np.random.rand() < self.quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) leverages quantum-inspired particle movement with adaptive convergence strategies to explore and exploit solution spaces effectively.", "configspace": "", "generation": 0, "fitness": 0.8312645776685378, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.028. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8703718442422566, 0.8177184255774798, 0.8057034631858772], "final_y": [0.12538000498599444, 0.14528866189325462, 0.14565935931096685]}, "mutation_prompt": null}
{"id": "999669c8-5b7d-4682-9306-17d7af71b377", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump\n                if np.random.rand() < self.quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (0.5 + evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                if evaluations > self.budget // 2:  # Dynamic population resizing\n                    self.population_size = min(self.population_size + 5, 100)\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer Plus\" (AQSOP) enhances exploration with adaptive velocity scaling and dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "metadata": {}, "mutation_prompt": null}
{"id": "c3c8a4da-5317-45cb-8dba-e5a832f31255", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump\n                if np.random.rand() < self.quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.quantum_prob += 0.01  # Increase quantum probability over time\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The enhanced \"Adaptive Quantum Swarm Optimizer\" (AQSO) now benefits from a dynamic quantum probability, increasing the likelihood of quantum-inspired jumps over time to boost exploration capabilities.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "metadata": {}, "mutation_prompt": null}
{"id": "d0edfc55-052f-4409-a75f-08b4b3b7e500", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.15  # Probability for quantum-inspired jump (increased from 0.1)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump\n                if np.random.rand() < self.quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "Enhanced Adaptive Quantum Swarm Optimizer with increased quantum probability for more diverse exploration.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "metadata": {}, "mutation_prompt": null}
{"id": "8d1708c4-7664-4159-96fe-e3682946a9bb", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump\n                if np.random.rand() < self.quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95 - 0.05 * (evaluations / self.budget)  # Adjust exploration reduction\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) refines its adaptive parameter adjustment strategy by introducing a dynamic rate for exploration reduction, leading to enhanced convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "metadata": {}, "mutation_prompt": null}
{"id": "3cb91aaf-69f0-4cca-86da-b5ad39721e03", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) introduces dynamic quantum probabilities and velocity scaling to improve exploration and convergence precision.", "configspace": "", "generation": 1, "fitness": 0.837332813604266, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.014. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "f07fc2b4-9b6a-4e73-b6ce-1e717482ed79", "metadata": {"aucs": [0.8551173071339837, 0.8205494215422608, 0.8363317121365532], "final_y": [0.12297836287081687, 0.14303401165045382, 0.12417010661656769]}, "mutation_prompt": null}
{"id": "581b830e-053d-4624-9eec-487e8ce946b7", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now incorporates a dynamic beta adjustment for enhanced adaptation and convergence precision.", "configspace": "", "generation": 2, "fitness": 0.8521949660068054, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.852 with standard deviation 0.034. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "3cb91aaf-69f0-4cca-86da-b5ad39721e03", "metadata": {"aucs": [0.8812229152351662, 0.8051861166065559, 0.8701758661786944], "final_y": [0.12385926813374948, 0.15134753868429507, 0.12244901127960217]}, "mutation_prompt": null}
{"id": "2d9e6abe-f1ff-458a-a6b9-0b51efcf3c51", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n            self.beta = 1.5 * (1 - evaluations / self.budget)  # Adaptive beta scaling\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now features adaptive beta scaling based on the convergence rate for enhanced exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8343273686201075, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.021. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "3cb91aaf-69f0-4cca-86da-b5ad39721e03", "metadata": {"aucs": [0.8628828270087543, 0.8254338203199945, 0.8146654585315736], "final_y": [0.1293041594113341, 0.14287359455622917, 0.13910192073588645]}, "mutation_prompt": null}
{"id": "60127e4e-33f9-4429-ba2a-838313da3209", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.98  # Decrease exploration over time\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now incorporates momentum adaptation to enhance balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.8281408754799987, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.013. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "3cb91aaf-69f0-4cca-86da-b5ad39721e03", "metadata": {"aucs": [0.8339513889822009, 0.840670855257711, 0.8098003822000841], "final_y": [0.13581283104779618, 0.12977753688112437, 0.1344739188903128]}, "mutation_prompt": null}
{"id": "0ee31809-a207-4371-a573-faab59dd8613", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n            \n            # Dynamic population size adjustment\n            if evaluations % (self.budget // 5) == 0:\n                new_size = max(10, int(self.population_size * 0.9))\n                position = position[:new_size]\n                personal_best_position = personal_best_position[:new_size]\n                personal_best_value = personal_best_value[:new_size]\n                self.velocities = self.velocities[:new_size]\n                self.population_size = new_size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) introduces a dynamic population size and enhanced personal best evaluation for improved adaptability and precision.", "configspace": "", "generation": 2, "fitness": 0.8213967882292937, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.015. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "3cb91aaf-69f0-4cca-86da-b5ad39721e03", "metadata": {"aucs": [0.8419901064567628, 0.8105800081910997, 0.8116202500400186], "final_y": [0.13381399801923965, 0.15224390876804283, 0.13670237027772547]}, "mutation_prompt": null}
{"id": "5a973928-01d0-44cd-a726-b831d600f278", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9  # Initial inertia weight\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.mutation_rate = 0.05  # Initial mutation rate\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Mutation strategy for additional exploration\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    position[i] += mutation_vector\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.mutation_rate *= 0.9  # Decrease mutation rate over time\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) leverages adaptive inertia and mutation strategies for enhanced exploration-exploitation balance and improved convergence accuracy.", "configspace": "", "generation": 2, "fitness": 0.8273568250937914, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.021. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "3cb91aaf-69f0-4cca-86da-b5ad39721e03", "metadata": {"aucs": [0.8488657291906712, 0.7983740633619221, 0.8348306827287809], "final_y": [0.12344631174530707, 0.15231617114533713, 0.1385506779307063]}, "mutation_prompt": null}
{"id": "6584869c-df0a-4439-b9ae-1e70a499cfdd", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 + evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now increases the probability of quantum-inspired jumps towards the end for potential last-minute improvements.", "configspace": "", "generation": 3, "fitness": 0.8466409459757993, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.026. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.871272507184108, 0.811311211518452, 0.8573391192248381], "final_y": [0.1275415133593013, 0.14390450187669146, 0.12687287580838358]}, "mutation_prompt": null}
{"id": "d5dfc177-ccd2-40af-94db-8b966f3c7409", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = max(10, self.population_size - 1)  # Dynamically adjust population size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes a dynamic population size adjustment to enhance exploration and convergence balance.", "configspace": "", "generation": 3, "fitness": 0.8214723670256001, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.005. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8243182476632009, 0.81473164002638, 0.8253672133872192], "final_y": [0.1358732637613409, 0.14017007612613985, 0.13662292829942901]}, "mutation_prompt": null}
{"id": "0c307c2d-80bf-43dc-b3e6-041dea4c1d43", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.inertia_weight = 0.72  # Added inertial weight\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +  # Use inertial weight\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes inertial weight decay for improved convergence balance.", "configspace": "", "generation": 3, "fitness": 0.8340495213001636, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.008. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8454035095834924, 0.828446548869062, 0.8282985054479362], "final_y": [0.1329361282613748, 0.14162887803510138, 0.1256382576684164]}, "mutation_prompt": null}
{"id": "dfe515b3-6987-43b0-8f9b-eb17064e4eeb", "solution": "import numpy as np\n\nclass RefinedQuantumSwarmOptimizer:  # Name change\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Modified quantum-inspired jump with refined adaptive probability\n                adaptive_quantum_prob = self.quantum_prob * np.exp(-evaluations / self.budget)\n                if np.random.rand() < adaptive_quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95\n                self.beta *= 0.97\n\n        return global_best_position, global_best_value", "name": "RefinedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) now incorporates an adaptive quantum probability function for more precise exploration and convergence.", "configspace": "", "generation": 3, "fitness": 0.832305143684629, "feedback": "The algorithm RefinedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.019. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8572301411726064, 0.8278291505051546, 0.8118561393761263], "final_y": [0.1319986721696529, 0.14158338728388276, 0.13368393625799857]}, "mutation_prompt": null}
{"id": "eb15c59c-a0ce-4ef1-87d5-2150c35c89b2", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                momentum = 1 - evaluations / self.budget  # Adaptive momentum factor\n                self.velocities[i] = (momentum * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Introduced adaptive momentum factor to enhance exploration and convergence balance in the Enhanced Quantum Swarm Optimizer.", "configspace": "", "generation": 3, "fitness": 0.8178202290407676, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.019. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8424183865956623, 0.8158695443566336, 0.7951727561700068], "final_y": [0.13918235739093476, 0.14778523472095106, 0.14379793962292953]}, "mutation_prompt": null}
{"id": "67873a1e-65f0-4615-a08c-fa3dc203487e", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                if evaluations < self.budget / 2:  # Dynamic population size adjustment\n                    self.population_size = min(100, self.population_size + 5)\n                else:\n                    self.population_size = max(10, self.population_size - 5)\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Enhanced Quantum Swarm Optimizer with dynamic population size adjustment for better exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "99d9084c-87dc-4bd4-9664-ae5bac84402d", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                adaptive_quantum_prob = self.quantum_prob * (1 - evaluations / (2 * self.budget))  # Modified line\n                if np.random.rand() < adaptive_quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Enhanced Quantum Swarm Optimizer with adaptive scaling of quantum-inspired jumps for improved exploration.", "configspace": "", "generation": 4, "fitness": 0.8342975233270034, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.019. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.836548373147087, 0.8099293199471309, 0.8564148768867921], "final_y": [0.13109799766906238, 0.14575048084419306, 0.12495291171919898]}, "mutation_prompt": null}
{"id": "3cc7d2e3-8fec-4fbf-834b-b602ecf42269", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Elite learning mechanism\n                elite_index = np.argmin(personal_best_value)\n                elite_force = 0.05 * (personal_best_position[elite_index] - position[i])\n                self.velocities[i] += elite_force\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) integrates elite learning to enhance exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.8269484683089227, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.008. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8308443347910933, 0.8155913448731182, 0.8344097252625564], "final_y": [0.13819916800367738, 0.1401522804925226, 0.1319960383135489]}, "mutation_prompt": null}
{"id": "24d499e4-c999-437d-9ab3-0818e3b09fe1", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)**1.2):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) introduces a strategic quantum probability decay adjustment to balance exploration and exploitation more effectively.", "configspace": "", "generation": 4, "fitness": 0.8286027251585867, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.014. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8469103866257623, 0.8134722413721538, 0.8254255474778439], "final_y": [0.13667345844162082, 0.1477659737364212, 0.13329242213629966]}, "mutation_prompt": null}
{"id": "37adabda-cff1-4af3-9ca8-30ad07ae569a", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = int(self.initial_population_size * (1 - evaluations / self.budget)) + 1  # Dynamic population size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now incorporates a dynamic population size adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.8214017649484121, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.025. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8478027672750146, 0.8281587324010633, 0.7882437951691585], "final_y": [0.13735961477278957, 0.14132658953179467, 0.15783609917610752]}, "mutation_prompt": null}
{"id": "ccd1037d-a858-4c9b-8352-b7bf56c38bba", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.2  # Increased probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) improves convergence by increasing diversity with a modified quantum-inspired jump probability.", "configspace": "", "generation": 5, "fitness": 0.8172827980126369, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.004. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8182943529639451, 0.8115533894603035, 0.8220006516136624], "final_y": [0.13917065016700814, 0.1447582016332858, 0.12965001692912104]}, "mutation_prompt": null}
{"id": "c3028d46-f763-4138-9376-c6c320e19d31", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = max(10, int(self.population_size * 0.9))  # Dynamically reduce population size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now features a dynamic population size reduction to improve convergence speed and efficiency.", "configspace": "", "generation": 5, "fitness": 0.811506584660907, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.020. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8378579339859454, 0.807699347227116, 0.7889624727696596], "final_y": [0.13338158547191414, 0.15319524451376054, 0.15611555154139956]}, "mutation_prompt": null}
{"id": "4217297e-581e-42f2-b756-cf56baea0191", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * np.sin(r2 * np.pi) * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - np.sqrt(evaluations / self.budget))):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) now utilizes a nonlinear velocity update and dynamic quantum probability for improved exploration and convergence.", "configspace": "", "generation": 5, "fitness": 0.8389004514570292, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.018. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8469000187396167, 0.8557233396814768, 0.8140779959499935], "final_y": [0.1298764731155989, 0.13371188239420506, 0.13520979242048026]}, "mutation_prompt": null}
{"id": "1da119a8-82a2-4c2a-bfe9-3451c8060bac", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n                # Stochastic personal best resetting\n                if np.random.rand() < 0.05:\n                    personal_best_position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                    personal_best_value[i] = float('inf')\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) introduces stochastic personal best resetting for improved exploration diversity.", "configspace": "", "generation": 5, "fitness": 0.8176786564030555, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.005. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8120498351568187, 0.81705530913213, 0.8239308249202179], "final_y": [0.14672949977657812, 0.14379741447761507, 0.1286334978291923]}, "mutation_prompt": null}
{"id": "b952bedc-02fe-46fa-89d6-041a7d4b6133", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.15  # Adjusted probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now adjusts quantum jump probability for better exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.8081350101347078, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.014. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8228508076679877, 0.8127272150902897, 0.7888270076458461], "final_y": [0.1358449266048556, 0.14928470565084784, 0.15302704248451282]}, "mutation_prompt": null}
{"id": "64057a9a-b585-4fee-a7cc-e7068ff0568a", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.inertia_weight = 0.5  # New line: Adaptive inertia weight\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +  # Modified line\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95\n                self.beta *= 0.97\n                self.inertia_weight *= 0.98  # New line: Adapt inertia weight\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) integrates an adaptive inertia weight for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedQuantumSwarmOptimizer' object has no attribute 'velocities'\").", "error": "AttributeError(\"'EnhancedQuantumSwarmOptimizer' object has no attribute 'velocities'\")", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "8dea3548-1eb0-4039-a053-3defc11110f7", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.inertia_weight = 0.5  # Initial inertia weight\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Stochastic position update\n                if np.random.rand() < self.quantum_prob:\n                    position[i] += np.random.normal(0, 0.1, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            self.inertia_weight *= 0.98  # Dynamic inertia adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Quantum Adaptive Swarm Optimizer\" (QASO) introduces dynamic inertia weight adjustment and enhanced exploration through stochastic position updates.", "configspace": "", "generation": 6, "fitness": 0.8397349715355839, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.026. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8758386923355733, 0.8135608398288414, 0.8298053824423369], "final_y": [0.11935630082545978, 0.14423210428353517, 0.13184357996262175]}, "mutation_prompt": null}
{"id": "b92fd76c-97df-42e2-88ff-a2328f9cbbec", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.92  # Decrease exploration over time based on performance\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Quantum Swarm Optimizer with Adaptive Exploration\" (QSO-AE) integrates an adaptive alpha reduction rate based on performance to enhance convergence precision and adaptability.", "configspace": "", "generation": 6, "fitness": 0.8238864295683785, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.018. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8472696359143856, 0.8038814547926484, 0.8205081979981017], "final_y": [0.13315597617165975, 0.1527664389458635, 0.13222079246414387]}, "mutation_prompt": null}
{"id": "9a3dd540-6811-4aa2-a7e9-a5c920717e99", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * ((self.budget-evaluations) / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer v2\" (EQSOv2) now features an adaptive quantum probability to enhance exploration efficiency during convergence.", "configspace": "", "generation": 6, "fitness": 0.8330022892780983, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.018. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8520048929695059, 0.8095395940276471, 0.8374623808371415], "final_y": [0.13202242258812347, 0.14630763337683705, 0.1273883719836365]}, "mutation_prompt": null}
{"id": "cc0188d0-2dfe-44ce-a3ec-4f9f6d0eecb2", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.gamma = 0.5  # New inertia weight\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.gamma * self.velocities[i] +  # Adjusted inertia weight\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.gamma *= 1.02  # Gradually increase inertia for stability\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) introduces inertia weight adjustment and enhanced exploration-exploitation balance for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.847828108027448, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.014. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8669157001558068, 0.8332959714142527, 0.8432726525122844], "final_y": [0.12511431445762056, 0.13855967902621136, 0.1270955253536974]}, "mutation_prompt": null}
{"id": "c7447f92-9886-4489-ba38-ed81043271e4", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Change made here for velocity scaling\n                self.velocities[i] *= 0.9  # Scaling factor for better control\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now incorporates velocity scaling for improved exploration control.", "configspace": "", "generation": 7, "fitness": 0.8320792275248611, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.002. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8348626999872331, 0.8288364513823107, 0.8325385312050397], "final_y": [0.1371495823856309, 0.14173902738539346, 0.13990972797832724]}, "mutation_prompt": null}
{"id": "4e9f5c4b-9f2c-4fe6-b4f6-5cc835a437f1", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:  # 1. Changed class name\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Improved Quantum-inspired jump\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget) * 1.2):  # 2. Improved quantum jump probability\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95\n                self.beta *= 0.97\n                # Dynamic swarm size adjustment\n                if np.random.rand() < 0.2:  # 3. Added condition for dynamic swarm size\n                    self.population_size = max(10, self.population_size - 1)  # 4. Adjust population size\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) integrates a dynamic swarm size adjustment and improved quantum jumps for quicker convergence and adaptability.", "configspace": "", "generation": 7, "fitness": 0.8251838671740183, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.017. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8452550430125815, 0.8026272096983356, 0.8276693488111373], "final_y": [0.13757988711786828, 0.15282305589270484, 0.12641823038820466]}, "mutation_prompt": null}
{"id": "dbe818f8-236f-4674-bdf7-0c40ffc6a058", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - (evaluations / self.budget)**2)):  # Modified line\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes an adaptive quantum-inspired jump mechanism for improved exploration.", "configspace": "", "generation": 7, "fitness": 0.8384842090965495, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.032. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8820051443513882, 0.8046904103798915, 0.8287570725583687], "final_y": [0.12513665257883233, 0.15282323800923958, 0.12395828336119197]}, "mutation_prompt": null}
{"id": "a02bb236-f9f2-4fbe-a56f-cfb2591da92c", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.inertia_weight = 0.9  # Added inertia weight for velocity update\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta = 1.5 - 0.5 * (evaluations / self.budget)  # Time-varying adjustment\n                self.inertia_weight *= 0.98  # Reduce inertia weight over time\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer v2\" (EQSOv2) integrates adaptive inertia weight and time-varying acceleration coefficients for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8199852695988176, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.012. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8321612389809345, 0.8028443141378446, 0.8249502556776735], "final_y": [0.13906469230556262, 0.15224115073935074, 0.13388606599869346]}, "mutation_prompt": null}
{"id": "5098f29a-d827-4759-b644-f2ce2a52b6f2", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.93  # Decrease exploration over time\n                self.quantum_prob *= 0.95  # Adjust jump probability adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "An enhanced quantum swarm optimizer with dynamic exploration-convergence adjustment and improved quantum jump probability.", "configspace": "", "generation": 7, "fitness": 0.8142077520838084, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.026. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8446849387412207, 0.8166167572523061, 0.7813215602578983], "final_y": [0.13335348392638668, 0.1471404579048925, 0.15867499773357785]}, "mutation_prompt": null}
{"id": "ffa7e196-2d40-48a1-b43d-68aa083b3fc8", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        self.population_size = max(10, int(50 * (1 - evaluations / self.budget)))  # Dynamic population size adjustment\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now features a dynamic population size adjustment for improved resource allocation and convergence speed.", "configspace": "", "generation": 8, "fitness": 0.8487486355696654, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.032. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8944681129153202, 0.8249144262531451, 0.8268633675405309], "final_y": [0.11953911709185883, 0.14148399873780793, 0.12950189941053525]}, "mutation_prompt": null}
{"id": "279ad503-52e6-4b3c-bba2-4b76dc368ff0", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            current_population_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))  # Decrease population\n            for i in range(current_population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(current_population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" now utilizes a decreasing population size to focus search intensity as evaluations progress.", "configspace": "", "generation": 8, "fitness": 0.8210387692536597, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.012. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8286497343580231, 0.8310068132765186, 0.8034597601264376], "final_y": [0.13038684466681671, 0.14110679243276547, 0.14569389767151086]}, "mutation_prompt": null}
{"id": "ded550c2-186a-4c24-8cb2-d7073bcd64d1", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.diversity_threshold = 0.1  # Threshold for adaptive diversity\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        def calculate_diversity():\n            return np.mean(np.std(position, axis=0))\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                chaotic_factor = np.sin(evaluations) * 0.1  # Introduce chaotic perturbation\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]) +\n                                      chaotic_factor)\n\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            diversity = calculate_diversity()\n            if diversity < self.diversity_threshold:\n                self.alpha *= 1.05  # Increase exploration if diversity is low\n\n            if evaluations % (self.budget // 10) == 0:\n                self.beta *= 0.97\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) introduces an adaptive diversity mechanism and chaotic velocity perturbation to enhance global exploration and local exploitation.", "configspace": "", "generation": 8, "fitness": 0.8259100027785379, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.012. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8423613904569852, 0.8158588209384444, 0.819509796940184], "final_y": [0.13817049776142487, 0.14166636798810794, 0.12850821649080002]}, "mutation_prompt": null}
{"id": "3eb3e76a-baaf-4d8d-8a44-97869d534d02", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                adapt_prob = self.quantum_prob * (1 - evaluations/self.budget) * 2\n                if np.random.rand() < adapt_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) introduces adaptive quantum probability and synergistic velocity updates for enhanced exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.8383068700362705, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.014. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8332716985988518, 0.8245949597712394, 0.8570539517387206], "final_y": [0.138382070740103, 0.14458071352125568, 0.1169684205634629]}, "mutation_prompt": null}
{"id": "6f37a9cf-ae80-46eb-956c-aef3cd52d285", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        position[:int(self.population_size*0.2)] = np.random.uniform(lower_bound, upper_bound, (int(self.population_size*0.2), self.dim))  # Diversified initialization\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + np.random.rand() * 0.5  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" now utilizes a diversified initialization strategy and an adaptive inertia weight for improved convergence and exploration balance.", "configspace": "", "generation": 8, "fitness": 0.8173586956284292, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.024. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8475567860725537, 0.8147482869216407, 0.7897710138910933], "final_y": [0.13542556616181767, 0.1410870615349542, 0.1496241593326071]}, "mutation_prompt": null}
{"id": "45734231-b27c-4e95-9e57-2250e138842a", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.inertia_weight = 0.9  # Initial inertia weight\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Dynamic inertia weight adjustment\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Introduced dynamic inertia weight adjustment to EQSO to enhance exploration-exploitation balance for improved optimization performance.", "configspace": "", "generation": 9, "fitness": 0.8248554040849742, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.007. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8316543768434128, 0.827477596487075, 0.8154342389244345], "final_y": [0.13799834800987743, 0.14037230560218872, 0.130996935007341]}, "mutation_prompt": null}
{"id": "ce28020e-7f73-4ca3-b6ea-233dd9960a7c", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)**0.5):  # Modified scaling\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes a dynamic quantum probability scaling to foster exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8291934853304501, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.009. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8409757891201022, 0.8267094638877207, 0.8198952029835276], "final_y": [0.13475697156226596, 0.14341003581620515, 0.13149933489877053]}, "mutation_prompt": null}
{"id": "f54a3316-8c8d-4e03-80ee-716991ef4a9c", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.15  # Increased probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Enhanced Quantum Swarm Optimizer with a refined quantum jump probability for improved exploration in later stages.", "configspace": "", "generation": 9, "fitness": 0.8340523324051533, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.013. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8278738733923385, 0.8226478732861902, 0.8516352505369311], "final_y": [0.14268767032167184, 0.14276074009408934, 0.12856992954943458]}, "mutation_prompt": null}
{"id": "e8c9b103-a9cb-4372-a514-938627299180", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                if np.random.rand() < (self.quantum_prob * 0.5 * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                if np.random.rand() < 0.1:  # Velocity inversion mechanism\n                    self.velocities[i] *= -1\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95\n                self.beta *= 0.97\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) introduces a velocity inversion mechanism and enhanced quantum jump for improved exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8444468216937567, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.009. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8533241522162955, 0.8325205438472394, 0.8474957690177355], "final_y": [0.12538223044633368, 0.13021533257318407, 0.12429372096480551]}, "mutation_prompt": null}
{"id": "171a962c-c4d5-49ba-aeb7-c2011a69c2e2", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * np.sqrt(1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes an adaptive quantum probability factor for enhanced exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8147383708406423, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.026. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8461615634257573, 0.8162868741702749, 0.7817666749258945], "final_y": [0.1345227854992208, 0.14270256536362091, 0.1587105550299286]}, "mutation_prompt": null}
{"id": "e613e483-aa47-4db0-9d49-b53c6637ff0e", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n    \n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n        \n        global_best_position = None\n        global_best_value = float('inf')\n        \n        evaluations = 0\n        inertia_weight = 0.9  # Initial inertia weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n                \n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n                \n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                inertia_weight *= 0.95  # Adaptive inertia weight reduction\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer 2.0\" (EQSO 2.0) introduces adaptive inertia weight and stochastic component scaling to further refine convergence and exploration balance.", "configspace": "", "generation": 10, "fitness": 0.8195061148064658, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.014. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8301086865215486, 0.8287474358929682, 0.7996622220048808], "final_y": [0.1332611716429558, 0.14176954102311645, 0.136123231367007]}, "mutation_prompt": null}
{"id": "28d519f5-db96-4923-982c-bd6c98299499", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (0.1 * self.velocities[i] +  # Added momentum term\n                                      self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now refines convergence by incorporating momentum into velocity updates, promoting smoother and more consistent adaptations.", "configspace": "", "generation": 10, "fitness": 0.8089588700295733, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.008. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.815893638090432, 0.7971074861979801, 0.8138754858003077], "final_y": [0.13830954185490163, 0.1582490970938748, 0.13663572327675233]}, "mutation_prompt": null}
{"id": "9f398671-313b-41a5-aa54-572fcf961dac", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with more adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - (evaluations / (2 * self.budget)))):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) introduces a more adaptive quantum-inspired jump probability for balanced exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.8381293975877425, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.016. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8607218415940435, 0.8278112364534899, 0.8258551147156941], "final_y": [0.12594904167741594, 0.1408974010548707, 0.13149377265734108]}, "mutation_prompt": null}
{"id": "634fca3d-7149-4904-a9de-5c4447059164", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                decay_factor = 0.99  # Introduce decay factor\n                self.velocities[i] = (decay_factor * self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Improved velocity update mechanism by introducing a decay factor to enhance convergence precision over time.", "configspace": "", "generation": 10, "fitness": 0.8405999637435055, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.841 with standard deviation 0.029. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8737544055607074, 0.8035170173994031, 0.8445284682704064], "final_y": [0.12952330096710796, 0.1544953760808141, 0.12146973232572866]}, "mutation_prompt": null}
{"id": "c9ebfc4e-395a-42df-8823-f966908ed3c6", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Dynamic quantum-inspired jump probability\n                if np.random.rand() < self.quantum_prob * (1 - evaluations / self.budget) + 0.05:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now uses a dynamic quantum probability for improved exploration during initial stages.", "configspace": "", "generation": 10, "fitness": 0.8161699526604105, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.027. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8522694887425424, 0.8092448178794878, 0.7869955513592012], "final_y": [0.13486679537146806, 0.14971597457622965, 0.15557931966814442]}, "mutation_prompt": null}
{"id": "3a583645-102f-4264-ad77-047f9c36a6df", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = max(10, self.population_size - 5)  # Dynamically reduce population\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Enhanced Quantum Swarm Optimizer with a dynamic population size to balance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.8386662951551557, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.015. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8393742708547735, 0.8200679547970772, 0.8565566598136165], "final_y": [0.13694316697133924, 0.14319619444748055, 0.11733867364431771]}, "mutation_prompt": null}
{"id": "0bb3aa4b-6346-4814-bdb9-6ee8f98bfa38", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 + evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes a controlled increase in quantum probability, boosting exploration capabilities early on.", "configspace": "", "generation": 11, "fitness": 0.8211934029855449, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.011. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8337688138085543, 0.807978651154743, 0.8218327439933375], "final_y": [0.1356399854651763, 0.1510347281201443, 0.13122341226743628]}, "mutation_prompt": null}
{"id": "08052928-fb85-43dc-bf58-42e041e79bcc", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i])) * (1 - evaluations / self.budget)\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i]\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = max(10, int(self.population_size * 0.98))\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Dynamic Quantum Swarm Optimizer\" (DQSO) enhances exploration by dynamically adjusting population size and velocity scaling with budget usage.", "configspace": "", "generation": 11, "fitness": 0.8346956756220112, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.032. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8586877325436736, 0.8564368215527005, 0.7889624727696596], "final_y": [0.12911912519425772, 0.13028655923442034, 0.15611555154139956]}, "mutation_prompt": null}
{"id": "ae64f554-0f00-41e7-b263-ba0cc02f559b", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.inertia_weight = 0.7  # New inertia weight\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +  # Adjusted line\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.inertia_weight *= 0.98  # New adaptive inertia adjustment\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now utilizes adaptive inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.8466517538996365, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.040. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.9011446854515665, 0.8084434813212992, 0.8303670949260441], "final_y": [0.11793022571538936, 0.14214416360833337, 0.12137016169273396]}, "mutation_prompt": null}
{"id": "bf558090-4b88-47b4-a8a5-53c2392eab7e", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.15  # Adjusted probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now fine-tunes the quantum probability for improved exploration and convergence balance.", "configspace": "", "generation": 11, "fitness": 0.8188441653665096, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.019. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.845055380314738, 0.8127272150902897, 0.7987499006945011], "final_y": [0.13653897146593896, 0.14928470565084784, 0.14796474940270665]}, "mutation_prompt": null}
{"id": "3f0bd044-8e6b-4d5d-9812-cd630e6fd0ca", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment and crowding distance\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = min(self.population_size + 1, 100)  # Increase diversity\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now incorporates crowding distance for diversity preservation and better convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "b67b7cd8-902c-462e-bdc6-c7c3c24538a8", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Adjusted quantum-inspired jump with improved dynamic probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / (self.budget * 0.5))):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n            if evaluations % (self.budget // 5) == 0 and self.population_size < 100:\n                self.population_size += 5  # Increase population size adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Enhanced Quantum Swarm Optimizer\" (REQSO) introduces a dynamic population size strategy and improves quantum jump adaptation for better convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "6133dd65-a3be-4e55-8d20-c383409ae24c", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / (self.budget * 0.8))):  # Modified line\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.95  # Adjust convergence adaptively  # Modified line\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) improves convergence by dynamically tuning velocity influence and quantum jump probability.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "e3f3046e-b4a1-403d-b8ed-a5828a92b7ab", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.initial_population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.initial_population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.initial_population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Adjust population size dynamically\n            adaptive_population_size = max(10, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n            for i in range(adaptive_population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(adaptive_population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95\n                self.beta *= 0.97\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Quantum-Inspired Adaptive Swarm Optimizer\" (QIASO) introduces a variable population size and adaptive velocity control to enhance convergence and exploration.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "097460b3-f088-48d2-941e-e72327be807a", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget) * 1.1):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now utilizes an adaptive quantum probability for improved exploration and convergence during the optimization process.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {}, "mutation_prompt": null}
{"id": "a64e502d-3f48-4e25-8e93-6d7737d2b0e4", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n            # Adaptive population size adjustment\n            self.population_size = max(10, int(50 * (1 - evaluations / self.budget)))\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Incorporating adaptive population size adjustment based on convergence to enhance performance.", "configspace": "", "generation": 13, "fitness": 0.82543207702843, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.020. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8535252914706936, 0.8127632490899422, 0.8100076905246545], "final_y": [0.13442274733137605, 0.1378857482474155, 0.13486651188683174]}, "mutation_prompt": null}
{"id": "a2dc21ed-1497-4b49-9ea7-92a65b1927f7", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = max(10, int(50 * (1 - evaluations / self.budget)))  # Adjust population size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" now features a dynamic population size adjustment to improve exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.816354088302087, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.013. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8336665821572784, 0.8125050338959395, 0.8028906488530427], "final_y": [0.13833492373833, 0.14797878802653686, 0.13688239812850256]}, "mutation_prompt": null}
{"id": "90767157-3751-43dc-bab0-afa6712bb28b", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                global_best_position = np.random.uniform(lower_bound, upper_bound, self.dim)  # Reset global best\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now uses a random position reset for global best, enhancing global exploration.", "configspace": "", "generation": 13, "fitness": 0.8065704710658214, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.807 with standard deviation 0.002. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8080850916691015, 0.8073504650121061, 0.8042758565162568], "final_y": [0.15366146428093974, 0.15094197744071436, 0.14344507570511966]}, "mutation_prompt": null}
{"id": "b9deb77d-6d8f-4f22-afeb-fdd1a5a5deed", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * np.exp(-evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Enhanced Quantum Swarm Optimizer with adaptive quantum probability adjustment for improved solution exploration.", "configspace": "", "generation": 13, "fitness": 0.8294685017678048, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.027. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8680104142572941, 0.8094321239544368, 0.8109629670916837], "final_y": [0.12937600802944493, 0.14960479176703056, 0.13911319648844]}, "mutation_prompt": null}
{"id": "0c9ebdb5-f9e0-45bd-850b-cd6d52305099", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (0.1 * (1 - evaluations / self.budget)**2):  # Modified line\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now uses adaptive quantum_prob scaling for improved convergence control.", "configspace": "", "generation": 13, "fitness": 0.823833432832204, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.018. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8445104800588534, 0.82622391746399, 0.8007659009737684], "final_y": [0.13406041651820566, 0.1405353826252158, 0.14104411492057112]}, "mutation_prompt": null}
{"id": "c058eb3b-4f77-4347-81cd-b63f89430780", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.mutation_rate = 0.05  # Added: Mutation rate for exploration\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Mutation for diversified exploration\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    position[i] += mutation_vector\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.mutation_rate *= 0.95  # Reduce mutation over time\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The Enhanced Quantum Swarm Optimizer with adaptive mutation rate for diversified exploration.", "configspace": "", "generation": 14, "fitness": 0.8217258194012161, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8130937165062854, 0.8217897664337572, 0.830293975263606], "final_y": [0.13745159920616878, 0.1302227661537413, 0.13529291571324287]}, "mutation_prompt": null}
{"id": "6bea872c-96fe-4791-a42a-534f3c30c0cb", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                adaptive_quantum_prob = self.quantum_prob * (1 - evaluations / self.budget) # Modified line\n                if np.random.rand() < adaptive_quantum_prob:  # Modified line\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "\"Enhanced Quantum Swarm Optimizer with Adaptive Quantum Probability (EQSO-AQP): Incorporates adaptive quantum probability and velocity scaling for improved exploration and convergence.\"", "configspace": "", "generation": 14, "fitness": 0.8384123402975989, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.034. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8845261180778368, 0.8257211747163984, 0.8049897280985616], "final_y": [0.12274108185308175, 0.14116773732815413, 0.13309493444348708]}, "mutation_prompt": null}
{"id": "cf6fdc0c-a24e-4e79-a350-59ccc88146c8", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            scaling_factor = 1.0 + (0.5 * evaluations / self.budget)  # New scaling factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * scaling_factor  # Apply scaling factor\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Introduces an adaptive scaling factor for velocities to enhance convergence speed without compromising exploration.", "configspace": "", "generation": 14, "fitness": 0.8173457903781379, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.005. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8190918698621497, 0.8227429374006755, 0.8102025638715885], "final_y": [0.13625753353893244, 0.1444243410484407, 0.13412647984491732]}, "mutation_prompt": null}
{"id": "d2608424-df64-41d9-8eb6-5d10bf9ba9f4", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                adaptive_prob = self.quantum_prob * (1 + 0.1 * np.sin(np.pi * evaluations / self.budget)) # Change here\n                if np.random.rand() < adaptive_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) introduces adaptive quantum probability scaling to further enhance global exploration capabilities.", "configspace": "", "generation": 14, "fitness": 0.8226332156050181, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.007. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8309332654202461, 0.8240719092655109, 0.8128944721292976], "final_y": [0.14249426490061956, 0.1410525195362683, 0.13674039895593748]}, "mutation_prompt": null}
{"id": "78db0d14-8c0a-48b7-b9a4-107be51c81ed", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget) * 1.1):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The Enhanced Quantum Swarm Optimizer (EQSO) now incorporates a dynamic quantum probability adjustment to enhance exploration capabilities.", "configspace": "", "generation": 14, "fitness": 0.7972334270043726, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.028. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8298898653151591, 0.8011253777285391, 0.7606850379694197], "final_y": [0.1423075977411875, 0.15056495370167555, 0.1610074783737192]}, "mutation_prompt": null}
{"id": "657cdffc-96eb-4c1e-8237-7e6db3fe7024", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Adaptive velocity scaling\n                velocity_scale = 1 - (evaluations / self.budget)\n                position[i] = np.clip(position[i] + self.velocities[i] * velocity_scale, lower_bound, upper_bound)\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Improved Quantum Swarm Optimizer with adaptive velocity scaling for better convergence and precision.", "configspace": "", "generation": 15, "fitness": 0.849097220371402, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.022. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8795566770982356, 0.831017575824821, 0.8367174081911495], "final_y": [0.12372946066278656, 0.13730417666467343, 0.12699346705787484]}, "mutation_prompt": null}
{"id": "b87983ca-4e70-40b1-aa9c-e035cf3b27d5", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = int(self.population_size * 0.98)  # Reduced population size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes a dynamic population size adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.800382669454886, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.005. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8037811080234646, 0.804268212411143, 0.7930986879300502], "final_y": [0.14635683978361191, 0.1518759197123546, 0.15433706280165527]}, "mutation_prompt": null}
{"id": "6311c5a8-2c9f-420b-84ad-e94b8e739ab8", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                adaptive_quantum_prob = self.quantum_prob * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_quantum_prob:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) is refined with an adaptive quantum probability and learning coefficients to enhance diversity and convergence.", "configspace": "", "generation": 15, "fitness": 0.836702768307334, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.007. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8442833138044741, 0.8271275605456778, 0.8386974305718501], "final_y": [0.13612233731124734, 0.1418464503967244, 0.12224678279193524]}, "mutation_prompt": null}
{"id": "647b8c29-6e3c-45e0-abc6-c4a14f7c31eb", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget) * 1.1):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.95  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Improved exploration-exploitation balance in EQSO by altering beta decay and quantum jump logic for better convergence.", "configspace": "", "generation": 15, "fitness": 0.8139420568807548, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.022. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8304567888820981, 0.8287474358929682, 0.7826219458671986], "final_y": [0.13424762967910697, 0.14176954102311645, 0.15509859131354575]}, "mutation_prompt": null}
{"id": "ea961514-5d0a-4f9c-aae4-9cca8e5576b8", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                self.quantum_prob = 0.1 + 0.4 * (evaluations / self.budget)\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now includes a dynamic adaptation of quantum probability for improved exploration and convergence.", "configspace": "", "generation": 15, "fitness": 0.8098608641358388, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.009. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8215756444915239, 0.8083248641676325, 0.7996820837483601], "final_y": [0.1385614540881266, 0.1492544357531279, 0.14743161214917666]}, "mutation_prompt": null}
{"id": "bf6e007c-351f-483d-9d0a-c36c819bb57e", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations**1.2 / self.budget)):  # Adjusted probability calculation\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) introduces an adaptive quantum probability adjustment for improved exploration dynamics.", "configspace": "", "generation": 16, "fitness": 0.8249442841753994, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.024. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8589672348804016, 0.8132833851490583, 0.8025822324967382], "final_y": [0.12019029863437747, 0.1463906059300658, 0.1472750938489248]}, "mutation_prompt": null}
{"id": "a57e4bd6-30ed-47e1-90c1-4e696da046ad", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(50 * (1 + 0.05 * (budget / 1000)), 10, 100))  # Adaptive population size\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now features an adaptive population size to boost exploration and convergence rates.", "configspace": "", "generation": 16, "fitness": 0.8274533240335463, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.041. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8841268515476994, 0.8081739613313779, 0.7900591592215614], "final_y": [0.12455514367784726, 0.1510496505511718, 0.15010914830865651]}, "mutation_prompt": null}
{"id": "08a2c2ce-602e-432c-a3a6-89a5fd779653", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        # Initialize individual adaptive learning rates\n        self.adaptive_alpha = np.full(self.population_size, self.alpha)\n        self.adaptive_beta = np.full(self.population_size, self.beta)\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n                    # Increase learning rates for improvement\n                    self.adaptive_alpha[i] = min(self.adaptive_alpha[i] * 1.05, 1.5)\n                    self.adaptive_beta[i] = min(self.adaptive_beta[i] * 1.05, 2.0)\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.adaptive_alpha[i] * self.velocities[i] +\n                                      self.adaptive_beta[i] * r1 * (personal_best_position[i] - position[i]) +\n                                      self.adaptive_beta[i] * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer with Adaptive Learning Rates\" (EQSOLAR) refines EQSO by incorporating self-adjusting learning rates for individual particles, improving convergence precision and robustness.", "configspace": "", "generation": 16, "fitness": 0.8350608444401205, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.002. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.832815063388531, 0.8383049677007434, 0.8340625022310875], "final_y": [0.1440795777533339, 0.12892718894671196, 0.13041787575597452]}, "mutation_prompt": null}
{"id": "b90e8aaf-d10f-49f6-b035-7badd38de3cf", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with enhanced probability adjustment\n                if np.random.rand() < (self.quantum_prob * ((1 - evaluations / self.budget) ** 2)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Diversity preservation: small random perturbation\n                position[i] += np.random.normal(0, 0.01, self.dim)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer\" (EQSO) now incorporates a diversity preservation mechanism and an enhanced quantum probability adjustment for improved exploration-exploitation balance and convergence precision.", "configspace": "", "generation": 16, "fitness": 0.8217387851122885, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.007. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8308898388305046, 0.8194641894563839, 0.8148623270499769], "final_y": [0.13717206944557314, 0.13140906184043, 0.13075211923808838]}, "mutation_prompt": null}
{"id": "223e5142-dccf-46d8-a9d5-2d9134a674c9", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        mutation_rate = 0.05  # New variable for mutation rate\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Diversity preservation strategy\n                if np.random.rand() < mutation_rate:\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment with mutation rate\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95\n                self.beta *= 0.97\n                mutation_rate = max(mutation_rate * 0.9, 0.01)  # Decrease mutation rate over time\n\n        return global_best_position, global_best_value", "name": "AdaptiveQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) incorporates variable mutation rates and a diversity preservation strategy for improved exploration and convergence.", "configspace": "", "generation": 16, "fitness": 0.8291768134156022, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.011. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.841192600059093, 0.8146190382362957, 0.8317188019514181], "final_y": [0.13783495785376365, 0.146971225330903, 0.13400780375297294]}, "mutation_prompt": null}
{"id": "389f6365-7b10-46f3-afde-b9034c35691c", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.965  # Refined decrease in exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Refined Quantum Swarm Optimizer\" (RQSO) enhances exploration through a refined dynamic alpha adjustment for better convergence balance.", "configspace": "", "generation": 17, "fitness": 0.8157362214834118, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.013. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8316942187213707, 0.8149801191238213, 0.8005343266050435], "final_y": [0.13570986579995992, 0.14283746461720448, 0.14693633106502257]}, "mutation_prompt": null}
{"id": "40038c2f-a3b8-473d-9aa7-f898cb63d14f", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n                self.population_size = max(10, self.population_size - 5)  # Adaptively reduce population size\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Enhanced Quantum Swarm Optimizer with Adaptive Population\" (EQSO-AP) reduces population size adaptively to improve local search precision.", "configspace": "", "generation": 17, "fitness": 0.8098162683150236, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.031. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8482146849312278, 0.8091493686666844, 0.7720847513471586], "final_y": [0.13409929002687904, 0.14998619621112352, 0.15419341723675384]}, "mutation_prompt": null}
{"id": "f1eb5160-805a-428b-a968-a8b1c2fcbbb9", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Levy flight step for exploration\n                if np.random.rand() < 0.05:\n                    position[i] += np.random.standard_normal(self.dim) * np.random.pareto(1.5)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Incorporate a probabilistic \"Levy Flight\" step to enhance exploration capabilities of the EQSO.", "configspace": "", "generation": 17, "fitness": 0.8240495900032072, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.011. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.838626931938987, 0.8116822135736228, 0.8218396244970118], "final_y": [0.1383638598626319, 0.15031976092812172, 0.12782342735677732]}, "mutation_prompt": null}
{"id": "04338364-ac80-422d-a34b-3e70934191b3", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget) * 1.05):  # Increased adaptivity\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "Improved Quantum Swarm Optimizer with adaptive quantum probability for enhanced convergence.", "configspace": "", "generation": 17, "fitness": 0.839523955948524, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.019. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.83318935078496, 0.8203888617452733, 0.8649936553153386], "final_y": [0.13818374488886265, 0.14497562844909495, 0.1192970762069635]}, "mutation_prompt": null}
{"id": "ab6949a6-4fa9-41e5-bd26-82373388f76b", "solution": "import numpy as np\n\nclass EnhancedQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.alpha = 0.9\n        self.beta = 1.5\n        self.quantum_prob = 0.1  # Probability for quantum-inspired jump\n        self.velocities = np.random.rand(self.initial_population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        position = np.random.uniform(lower_bound, upper_bound, (self.initial_population_size, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.full(self.initial_population_size, float('inf'))\n\n        global_best_position = None\n        global_best_value = float('inf')\n\n        evaluations = 0\n        current_population_size = self.initial_population_size  # Track current population size\n\n        while evaluations < self.budget:\n            for i in range(current_population_size):\n                current_value = func(position[i])\n                evaluations += 1\n\n                if current_value < personal_best_value[i]:\n                    personal_best_value[i] = current_value\n                    personal_best_position[i] = position[i]\n\n                if current_value < global_best_value:\n                    global_best_value = current_value\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for i in range(current_population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.alpha * self.velocities[i] +\n                                      self.beta * r1 * (personal_best_position[i] - position[i]) +\n                                      self.beta * r2 * (global_best_position - position[i]))\n\n                # Quantum-inspired jump with adaptive probability\n                if np.random.rand() < (self.quantum_prob * (1 - evaluations / self.budget)):\n                    position[i] = np.random.uniform(lower_bound, upper_bound, self.dim)\n                else:\n                    position[i] = position[i] + self.velocities[i] * (1 - evaluations / self.budget)\n\n                # Clamp positions to bounds\n                position[i] = np.clip(position[i], lower_bound, upper_bound)\n\n            # Adaptive parameter adjustment\n            if evaluations % (self.budget // 10) == 0:\n                self.alpha *= 0.95  # Decrease exploration over time\n                self.beta *= 0.97  # Adjust convergence adaptively\n            \n            # Decrease population size as convergence progresses\n            if evaluations % (self.budget // 5) == 0:\n                current_population_size = max(10, int(current_population_size * 0.9))\n\n        return global_best_position, global_best_value", "name": "EnhancedQuantumSwarmOptimizer", "description": "The \"Adaptive Quantum Swarm Optimizer\" (AQSO) introduces adaptive population size for enhanced convergence and efficiency.", "configspace": "", "generation": 17, "fitness": 0.8301496116749579, "feedback": "The algorithm EnhancedQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.022. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "581b830e-053d-4624-9eec-487e8ce946b7", "metadata": {"aucs": [0.8607986348801456, 0.8168842020515195, 0.8127659980932087], "final_y": [0.12952520519790078, 0.14297988429033226, 0.14015946435559623]}, "mutation_prompt": null}
