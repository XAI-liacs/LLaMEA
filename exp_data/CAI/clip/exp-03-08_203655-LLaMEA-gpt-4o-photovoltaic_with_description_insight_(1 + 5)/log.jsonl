{"id": "6f8b6c35-cd1d-49ef-a496-f32e39ffab42", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, donor):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Hybrid Hierarchical Differential Evolution with Local Search (HHDES) that dynamically adapts layer complexity and optimizes modular structures for high-dimensional noisy problems.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 281, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 143, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 66, in __call__\n  File \"<string>\", line 63, in optimize_layers\n  File \"<string>\", line 50, in local_search\nAttributeError: 'NoneType' object has no attribute 'shape'\n.", "error": "AttributeError(\"'NoneType' object has no attribute 'shape'\")Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 281, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 143, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 66, in __call__\n  File \"<string>\", line 63, in optimize_layers\n  File \"<string>\", line 50, in local_search\nAttributeError: 'NoneType' object has no attribute 'shape'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, plus a fix for local_search initialization error.  ", "configspace": "", "generation": 1, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6f8b6c35-cd1d-49ef-a496-f32e39ffab42", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "4e084370-b069-4c6c-aef3-ab52628a6cfe", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, donor):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        if solution is None:\n            return None, np.inf\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.random.rand(self.dim)\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES algorithm with robustness in local search and layer optimization for high-dimensional noisy problems.", "configspace": "", "generation": 1, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6f8b6c35-cd1d-49ef-a496-f32e39ffab42", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "17be6d75-5c80-4c1c-a988-6ccb72a5130a", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, donor):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        if solution is None:\n            return np.copy(solution), self.best_fitness\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved Hybrid Hierarchical Differential Evolution with Local Search (HHDES) by ensuring robust local search handling.", "configspace": "", "generation": 1, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6f8b6c35-cd1d-49ef-a496-f32e39ffab42", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "71b5f18d-b140-4dc9-ad36-f80435a0dbbe", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialize best_solution\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, donor):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved error handling and initialization to prevent NoneType issues in the local search phase.", "configspace": "", "generation": 1, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6f8b6c35-cd1d-49ef-a496-f32e39ffab42", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "6aa381ee-0fa6-40aa-ae9b-dae0e0834d22", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = self.population[0]  # Initial best solution for valid shape\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, donor):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Hybrid Hierarchical Differential Evolution with Local Search (HHDES) that dynamically adapts layer complexity, optimizes modular structures for high-dimensional noisy problems, and ensures valid initial best solution.", "configspace": "", "generation": 1, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6f8b6c35-cd1d-49ef-a496-f32e39ffab42", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "2b269255-14fb-4b51-b426-f405c65bff67", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        elite_idx = np.argmin([self.evaluate(func, self.population[j]) for j in indices])\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[elite_idx] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Smaller perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improve HHDES by tweaking local search to use a smaller perturbation and updating mutation strategy with an elite selection.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "7beec9f3-df60-48dc-9801-10f0c09cf55e", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.local_search_budget = int(budget * 0.3)  # Allocate more budget for local search\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget - self.local_search_budget):  # Adjust DE budget\n            if self.evaluate_budget >= self.budget - self.local_search_budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget - self.local_search_budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        for _ in range(self.local_search_budget):  # Budget-controlled local search\n            if self.evaluate_budget >= self.budget:\n                break\n            perturbation = np.random.normal(0, 0.1, solution.shape)\n            candidate = solution + perturbation\n            candidate = np.clip(candidate, 0, 1)\n            candidate_fitness = self.evaluate(func, candidate)\n            if candidate_fitness < self.evaluate(func, solution):\n                solution, fitness = candidate, candidate_fitness\n        return solution, fitness\n\n    def optimize_layers(self, func):\n        self.differential_evolution(func)\n        self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with adaptive budget allocation focusing on local search for enhanced convergence.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'fitness' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'fitness' referenced before assignment\")", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "f030941e-38f0-4a55-8519-55886d6826c9", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        chaotic_F = 0.5 + (np.random.rand() * 0.3) * (0.7 + 0.3 * np.sin(self.evaluate_budget))  # Chaos-based mutation factor\n        mutant = self.population[a] + chaotic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhance HHDES by introducing a chaos-based mechanism for adaptive parameter adjustments to improve exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'fitness' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'fitness' referenced before assignment\")", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "313fb0ce-c011-4db2-8110-e1b477f92cea", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation scale\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved local search by reducing perturbation scale for finer solution refinement.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'fitness' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'fitness' referenced before assignment\")", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "d8d56360-3754-40d6-8402-681764ff8147", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05 + 0.05 * np.random.rand(), solution.shape)  # Dynamic perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, plus a dynamic local search perturbation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'fitness' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'fitness' referenced before assignment\")", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "3f8bccd9-078d-47bd-9ed5-e7e6d85605b3", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            # Scaling population size based on budget usage\n            self.pop_size = max(10, int(20 * (1 - self.evaluate_budget / self.budget)))\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            # Self-adaptive local search step\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introducing a self-adaptive local search step and dynamic population scaling based on budget usage.", "configspace": "", "generation": 3, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "3cc89395-8d5a-4046-8b6e-8d9eaa7b6243", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        gradient = np.gradient(solution)  # Calculate gradient\n        step_size = 0.05  # Define a small step size\n        candidate = solution - step_size * gradient  # Use gradient descent\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES leveraging gradient-based adjustments to enhance local search and convergence speed.", "configspace": "", "generation": 3, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "8ae51ffc-5f0e-4c22-9f88-f201448c2e34", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            if self.evaluate_budget > self.budget // 2:  # Change: Adjust pop_size based on progress\n                self.pop_size = max(10, self.pop_size - 1)\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved convergence by adjusting population size based on progress.", "configspace": "", "generation": 3, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "327a0bd5-6b45-4e69-b53d-fa4fc524093d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + np.random.rand() * 0.2  # Changed mutation factor range\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3  # Changed crossover rate range\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // (self.dim + 5)):  # Adjusted optimization scheduling\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "HHDES with enhanced adaptive strategies and layer optimization scheduling for better convergence.", "configspace": "", "generation": 3, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "714048b1-7a3a-44b9-aed4-88318c859dcd", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(5, 20 - (dim // 10))  # Dynamic population size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with adaptive local search and enhanced exploitation through dynamic population size.", "configspace": "", "generation": 3, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "3887fadd-0c1b-4e09-ba8c-c9e68b6aebe8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        learning_rate = 0.05 + np.random.rand() * 0.05  # Adaptive learning rate for perturbation\n        perturbation = np.random.normal(0, learning_rate, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive learning rate for perturbations, improving local search efficiency.", "configspace": "", "generation": 4, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "5ffe16b0-b250-4314-9334-393c215a3f6b", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.improved_mutate(i)  # Changed to improved mutation\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def improved_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.7 + np.random.rand() * 0.4  # Improved mutation factor for diversity\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved global exploration by adjusting mutation strategy for better diversity and convergence.", "configspace": "", "generation": 4, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "accba44a-892f-4ec7-aa98-0e6df26ad74a", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        # New mutation: introduce secondary mutation mechanism\n        if np.random.rand() < 0.1:  # 10% chance to apply secondary mutation\n            mutant += 0.1 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced a secondary mutation mechanism to diversify population and improve convergence.", "configspace": "", "generation": 4, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "0fc0fdc9-adf5-4cb0-b42a-d228664327e8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        # Averaging fitness over multiple evaluations for noise-tolerance\n        num_evaluations = 5\n        fitness_values = [func(candidate) for _ in range(num_evaluations)]\n        return np.mean(fitness_values)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES by introducing a noise-tolerant fitness evaluation mechanism for better robustness in noisy environments.", "configspace": "", "generation": 4, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "61bd7b5c-1225-418b-ab7a-65f6e76294ad", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i, func)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx, func):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        current_fitness = self.evaluate(func, self.population[current_idx])\n        F = 0.5 + (current_fitness / self.best_fitness) * 0.3  # Adaptive mutation factor based on relative fitness\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improve the mutation strategy by making the mutation factor adaptively depend on the current solution's relative fitness.", "configspace": "", "generation": 4, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "bcf0cf69-07eb-44a5-b14c-d274d8d368f4", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            # Begin dynamic population size adjustment\n            self.pop_size = 20 + int((self.budget - self.evaluate_budget) / 50)\n            self.population = self.population[:self.pop_size, :]\n            # End dynamic population size adjustment\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduce adaptive population size to dynamically balance exploration and exploitation based on remaining budget.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 27 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 27 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "731bf24a-1661-4cbe-a43b-c15a2cc6674e", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 22  # Adjusted population size\n        self.CR = 0.85  # Adjusted crossover rate\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Slightly adjust the population size and crossover rate in HHDES to enhance exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "9bfd9dd1-115b-4a93-afed-10525700828d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + np.random.rand() * 0.2  # Adjusted adaptive mutation factor range\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Refined the adaptive mutation factor range to enhance exploration and convergence efficiency.", "configspace": "", "generation": 5, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "acd2e1a7-5326-4077-9a4a-05e4880529a2", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.3 + np.random.rand() * 0.5  # Expanded adaptive mutation factor range\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            # Enhanced local search with adaptivity\n            perturbation = np.random.normal(0, 0.05 + np.random.rand() * 0.05, self.best_solution.shape)\n            candidate = self.best_solution + perturbation\n            candidate = np.clip(candidate, 0, 1)\n            candidate_fitness = self.evaluate(func, candidate)\n            if candidate_fitness < self.best_fitness:\n                self.best_solution = candidate\n                self.best_fitness = candidate_fitness\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive multi-strategy local search and improved mutation factor dynamic range.", "configspace": "", "generation": 5, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "8091e7ac-4670-46e4-8275-40c59f28ba04", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Enhanced perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        layers_increment = self.dim // 10  # Hierarchical layer optimization\n        for _ in range(self.budget // layers_increment):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with hierarchical layer optimization and enhanced perturbation in local search for better convergence.", "configspace": "", "generation": 5, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "4259700e-dc9e-46df-8ea2-c9e64680e001", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, int(20 * (budget / (10 * dim))))  # Adaptive population size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced an adaptive population size to improve exploration and convergence efficiency.", "configspace": "", "generation": 6, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "fc05ecb0-b71e-447c-91b4-ddbb1a8a184c", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.3 + np.random.rand() * 0.5  # Adjusted adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved mutation factor range for enhanced exploration in HHDES.", "configspace": "", "generation": 6, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "9b08b1e9-2734-4d42-baf8-28f5ef524d8f", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        scaling_factor = 0.1 + 0.4 * np.random.rand()  # Dynamic scaling factor\n        perturbation = np.random.normal(0, scaling_factor, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced a dynamic scaling factor in local search to enhance exploration.", "configspace": "", "generation": 6, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "3ab6a8d6-be6c-486b-a386-ed453e226601", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Adjusted perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        self.pop_size = max(10, self.dim // 2)  # Dynamic population size adjustment\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic population size adjustment and optimized local search perturbation.", "configspace": "", "generation": 6, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "fb8b0fdd-1ff0-4d9f-9f87-65a33d8ba59e", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, budget // (10 * dim))  # Dynamic population size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + np.random.rand() * 0.2  # More adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3  # More adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive CR and F strategies, and a dynamic population size based on budget.", "configspace": "", "generation": 6, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "52fa7e6b-4036-4972-858c-6e4c4c0af39b", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3 * (self.evaluate_budget / self.budget)  # Weight decay mechanism\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3  # Tuned crossover rate for better exploration\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced a weight decay mechanism in adaptive mutation and tuned the crossover rate for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "5ad72f42-adda-4321-8f83-ecbe48bcf879", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            if self.evaluate_budget > self.budget / 2:  # Dynamic population resizing\n                self.pop_size = max(10, self.pop_size // 2)\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // (self.dim // 2)):  # Increased local search frequency\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced dynamic population resizing and increased local search frequency for enhanced exploration and fine-tuning.", "configspace": "", "generation": 7, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "86ab1a9d-66a9-4013-b36a-6cc18ad1530b", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(20, dim + 5)  # Dynamic population size based on dimension\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced a dynamic population size strategy to enhance exploration and exploitation balance in HHDES.", "configspace": "", "generation": 7, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "99bcf448-5bc9-4055-911c-a65205738a2d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation scale\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "HHDES uses enhanced local search with smaller perturbation for finer exploration.", "configspace": "", "generation": 7, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "9f86cf28-43c5-482d-af1c-35921d90f1ce", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                elif np.random.rand() < 0.1:  # Introduce random selection for diversity\n                    self.population[i] = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Incorporate diversity preservation by modifying the selection process for better exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "de221a69-7809-4163-9ef0-9a8a8fce14b9", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased from 20 to 25 for improved diversity\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, plus a fix for local_search initialization error and increased population size for better diversity.", "configspace": "", "generation": 8, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "b6422ad1-d3d3-45b0-8b46-9e246512cf59", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        gradient = np.zeros_like(solution)\n        eps = 1e-5\n        for i in range(self.dim):\n            perturbed = np.copy(solution)\n            perturbed[i] += eps\n            gradient[i] = (self.evaluate(func, perturbed) - self.evaluate(func, solution)) / eps\n        candidate = solution - 0.1 * gradient  # Gradient descent step\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with improved local search using gradient approximation for better refinement.", "configspace": "", "generation": 8, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "fdc41638-12ef-4bf8-8f70-905793755278", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        layer_blocks = int(self.dim / 10)  # Adjust optimization granularity\n        for layer_group in range(layer_blocks):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improve HHDES by integrating layer-wise consideration and adaptive resource allocation for enhanced exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "b2b039f2-806e-4a5b-8037-058fb00c74c9", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.layer_adaptive_mutate(i)  # Changed to layer-adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def layer_adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.4 + np.random.rand() * 0.6  # More adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with layer-adaptive strategies and improved local search for better convergence and solution robustness.", "configspace": "", "generation": 8, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "48bd62a7-ee43-420f-b484-14fbad5b9f2e", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES by increasing population size for better exploration.", "configspace": "", "generation": 8, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "d10bb5c0-aa38-4a61-985a-902b7af74466", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.4\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        layer_step = max(1, self.dim // 10)\n        for layers in range(layer_step, self.dim + 1, layer_step):\n            self.dim = layers\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Refined HHDES with enhanced adaptive strategies and multi-phase optimization involving dynamic layer increase.", "configspace": "", "generation": 9, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "cccbbf99-34ea-4b56-899d-d52b9195d7b3", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        gradient_step = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution - np.sign(gradient_step) * 0.01  # Gradient-based refinement\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n            self.pop_size = max(10, int(self.pop_size * 0.9))  # Dynamic population size adjustment\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic population size adjustment and gradient-based local search for improved exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "682dfd9f-7c55-49da-b230-96ddda242dca", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.4  # Adaptive mutation factor increased diversity\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved mutation strategy by increasing diversity with self-adaptive parameter F.", "configspace": "", "generation": 9, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "8d2898be-25dc-4cc7-9c61-81958e8508ef", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, int(budget / dim))  # Dynamic population size scaling\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Smaller perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic pop_size scaling and improved local_search perturbation for better exploration.", "configspace": "", "generation": 9, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "b847db06-7127-4134-98e6-0310a734b37c", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.layer_adaptive_mutate(i)  # Layer-adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def layer_adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        if self.evaluate_budget + 10 >= self.budget:  # Budget-aware local search\n            return solution, self.evaluate(func, solution)\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Refined HHDES with layer-adaptive mutation and budget-aware local search for enhanced performance.", "configspace": "", "generation": 9, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "7e9518f9-4c86-4c7e-bad9-b9c0fecde374", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Changed population size from 20 to 25\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES by adjusting the initial population size for better exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "382fa61a-c9b4-4965-8ea2-e33ade093b10", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(20, int(self.dim / 2))  # Dynamic population size adjustment\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Adjusted perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic population size adjustment and improved local search perturbation for better convergence.", "configspace": "", "generation": 10, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "b3f3ba57-4196-4d2c-9386-fc6b4aed6183", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        # Adjust CR based on population diversity for better balance\n        diversity = np.mean(np.std(self.population, axis=0))\n        CR = 0.8 + np.random.rand() * 0.2 * (1 - diversity)\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved adaptive crossover strategy by adjusting the crossover rate based on population diversity for better exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "5f5ad3df-bb58-4d78-abb1-64fdc718c579", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation for fine search\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // (self.dim * 2)):  # Adjusted loop for gradual layer increase\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with strategic layer adaptation and refined local search for improved multi-layer optimization.", "configspace": "", "generation": 10, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "efb87e93-0b8a-4b78-94e1-55270b678fc8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, int(dim * 0.8))  # Adaptive population size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation scale\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with enhanced local search perturbation and adaptive population size.", "configspace": "", "generation": 10, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "76d3cf43-298c-4afa-8eae-ac0afc06da6f", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.diversity_threshold = 0.1  # Added for diversity\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                self.promote_diversity(i)  # Added diversity promotion\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def promote_diversity(self, idx):\n        if np.std(self.population[idx]) < self.diversity_threshold:\n            self.population[idx] = np.random.rand(self.dim)  # Reinitiate\n\n    def optimize_layers(self, func):\n        current_layers = 10\n        while current_layers <= self.dim:\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n            current_layers += 2  # Added progressive increase\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Adaptive HHDES with diversity promotion and progressive layer increase for enhanced exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "8972badd-9ac6-4b3a-a133-cdeaa49165a4", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20  # Changed line for dynamic population\n        self.pop_size = self.initial_pop_size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def adjust_population_size(self):\n        if self.evaluate_budget > self.budget // 2:\n            self.pop_size = max(10, self.initial_pop_size // 2)  # Reduced population size\n            self.population = self.population[:self.pop_size]  # Adjust population\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.adjust_population_size()  # Adjust population during optimization\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic population size adjustment based on convergence speed to maintain diversity and improve exploration.", "configspace": "", "generation": 11, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "530d4dad-8867-4745-baf6-4f7cd48024f5", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.restart_threshold = 0.1 * self.dim  # Adaptive restart strategy\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                if self.evaluate_budget > self.restart_threshold:\n                    self.restart_population()  # New restart mechanism\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def restart_population(self):  # New function to restart underperforming populations\n        self.population = np.random.rand(self.pop_size, self.dim)\n        self.evaluate_budget = 0\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive restart strategy and layer-wise differential evolution for improved exploration and balance in high-dimensional spaces.", "configspace": "", "generation": 11, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "6bc5153a-a41b-4c0f-8db1-f30cc2183d9b", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.pop_size = max(10, int(20 * (1 - self.evaluate_budget / self.budget)))  # Dynamic pop size adjustment\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Incorporate a dynamic population size adjustment based on current convergence trends to improve exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "d9a0388f-8295-4b07-b2ac-4ee1b68e6ee7", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3  # Improved adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved adaptive crossover rate formula to enhance exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "95415ef8-0131-46d8-84f3-a22f37824028", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  \n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.4  # Adjusted mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3  # Adjusted crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def intelligent_local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        layer_increment = 5  # Dynamic increment\n        for _ in range(self.budget // layer_increment):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.intelligent_local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced adaptive DE with layer-wise dynamic budget allocation and intelligent local search.", "configspace": "", "generation": 12, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "e4e4ba47-1c97-483a-bc2b-2dcbec43ede1", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        self.pop_size = max(5, int(self.budget / (10 * self.dim)))  # Dynamic population size\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Increased exploration\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic population size adaptation and improved local search exploration.", "configspace": "", "generation": 12, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "2ab92f40-7a1a-4ba4-97f4-5dff4cb8325e", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.enhanced_mutate(i)  # Changed to enhanced mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def enhanced_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c]) + F * (self.best_solution - self.population[a])  # Added diversity\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        std_dev = 0.1 * (1 - self.evaluate_budget / self.budget)  # Adaptive perturbation\n        perturbation = np.random.normal(0, std_dev, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with enhanced mutation diversity and adaptive local search perturbation.", "configspace": "", "generation": 12, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "8f64a022-fa48-49a3-b2a3-abe2ac2e40e8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            self.pop_size = max(10, int(20 - (self.evaluate_budget / self.budget) * 10))  # Dynamically adjust population size\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduce a dynamic adjustment of the population size based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "02e14db3-d131-4d05-9580-ca55d88130e2", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.4 + np.random.rand() * 0.4  # Adjusted adaptive mutation factor range\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, improved by adjusting the adaptive mutation factor range for better convergence.", "configspace": "", "generation": 12, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "8632a72b-3a79-49ff-9472-b99973a1ced0", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        idxs = np.argsort([self.evaluate(func, indv) for indv in self.population])\n        pbest_index = idxs[np.random.randint(0, int(self.pbest_fraction * self.pop_size))]\n        mutant = self.population[pbest_index] + F * (self.population[b] - self.population[c])  # Dynamic pbest selection\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced dynamic selection of `pbest` to enhance diversity during mutation in HHDES.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "04f9e13b-e7b3-4c37-8e48-0b291935cb4d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population, axis=0).mean()\n        F = 0.5 + np.random.rand() * 0.3 * diversity  # Adaptive mutation factor based on diversity\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Refined HHDES with adaptive scaling factor based on population diversity to enhance exploration and stability.", "configspace": "", "generation": 13, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "f2fcff83-57c2-427d-9ac9-c3f8cee57017", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20\n        self.pop_size = self.initial_pop_size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced noise\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            if self.evaluate_budget > self.budget // 2:  # Dynamic population size adjustment\n                self.pop_size = max(5, self.pop_size // 2)\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Refined HHDES by incorporating a dynamic population size adjustment and noise handling in local search for improved accuracy and robustness.", "configspace": "", "generation": 13, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "38202067-a019-4709-a729-2552b9a5553c", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.success_history = []  # Track success history for parameter tuning\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    self.success_history.append(trial_fitness)  # Log successful trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        F = self.tune_F(F)  # Tune mutation factor based on history\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def tune_F(self, F):\n        if len(self.success_history) > 10 and np.mean(self.success_history[-10:]) < self.best_fitness:\n            return F * 1.1  # Adjust F if recent successes are promising\n        return F\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Incorporate layer-wise adaptation and historical success-based parameter tuning to enhance solution convergence and global exploration.", "configspace": "", "generation": 13, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "f208f000-3757-4e72-94b4-0ef78ac7fa7f", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                # Change: Introduced an adaptive fitness threshold for replacement\n                threshold = self.best_fitness + (0.1 * abs(self.best_fitness))\n                if trial_fitness < min(self.evaluate(func, self.population[i]), threshold):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved solution selection by introducing an adaptive fitness threshold for replacement to enhance exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "0495a203-c5f0-416d-8d9d-481a1874efbe", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate) \n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.robust_crossover(self.population[i], donor)  \n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.4  # Adjusted adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def robust_crossover(self, target, donor):\n        CR = 0.7 + np.random.rand() * 0.3  # Modified crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        current_dim = self.dim // 2  # Start with half of the dimensions\n        increment = self.dim // 4\n        while current_dim <= self.dim:\n            self.population = np.random.rand(self.pop_size, current_dim)\n            self.best_solution = np.random.rand(current_dim)\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n            current_dim += increment\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Hybrid Adaptive DE with Layer-Wise Dimensional Increment and Robustness Consideration.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) (5,) ')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "e92e3eaa-e29d-4960-87bf-301ab3084741", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                if self.evaluate_budget >= self.budget // 2:  # Early stopping check\n                    break\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + np.random.rand() * 0.2  # Adjusted adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive strategy tuning and early stopping for improved convergence.", "configspace": "", "generation": 14, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "657602fe-0a75-4078-a321-12f945880253", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size for diversity\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  \n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n   \n    def refine_population(self, func):\n        new_pop = []\n        for candidate in self.population:\n            refined_candidate, _ = self.local_search(func, candidate)\n            new_pop.append(refined_candidate)\n        self.population = np.array(new_pop)\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.4 + np.random.rand() * 0.5  \n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.6 + np.random.rand() * 0.4  \n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape) \n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.refine_population(func)  # Additional refinement step\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Hybrid DE with adaptive local search and dynamic population refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "fd95b13c-2f57-425d-82f6-50b78fa533f0", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape) * np.random.rand(*solution.shape)  # Layer-wise random perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, incorporating layer-wise random perturbation in local search for improved exploration.", "configspace": "", "generation": 14, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "f8749e6a-7b00-4963-86ce-4f6a1680f284", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        layer_perturbation = np.random.normal(0, 0.05, self.dim)  # Layer-wise mutation\n        mutant += layer_perturbation\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive population sizing and layer-wise mutation, focusing on dynamic resource allocation and structural adaptability.", "configspace": "", "generation": 14, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "fc6a155a-d037-41b7-85b6-00f6d0e75f6a", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.dynamic_pop_adjust = True  # New attribute for dynamic population resizing\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            if self.dynamic_pop_adjust:  # Dynamic population resizing\n                self.adjust_population()\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation scale\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def adjust_population(self):\n        if self.evaluate_budget < self.budget / 2:\n            self.pop_size = min(self.pop_size * 2, 60)  # Increase population size early\n        else:\n            self.pop_size = max(self.pop_size // 2, 10)  # Decrease population size later\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES algorithm with adaptive local search and dynamic population resizing to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 35 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 35 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "42770593-f8e7-43b5-bda4-28242e96c84c", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            if self.evaluate_budget > self.budget // 2:  # Dynamic population resizing\n                self.pop_size = max(10, self.pop_size // 2)  # Adjust population size\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with adaptive reinitialization and dynamic population resizing based on budget utilization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 23 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 23 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "ef49cbd6-54db-4515-b443-2aa272f293f9", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.4 + np.random.rand() * 0.4  # Modified adaptive mutation factor range\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with modified adaptive mutation factor range for improved exploration.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 23 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 23 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "e8b1473f-4925-4810-a2dc-7833f92eb015", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        diversity = np.std(self.population, axis=0).mean()\n        perturbation_scale = 0.1 * (1 + diversity)  # Dynamic perturbation scale\n        perturbation = np.random.normal(0, perturbation_scale, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with improved local search by using a dynamic perturbation scale based on population diversity.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 28 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 28 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "cce8b232-3e4e-49ce-8d30-a26d9ebcae6c", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + (1 - self.evaluate_budget / self.budget) * 0.3  # Dynamic scaling of mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced adaptive mutation in HHDES by incorporating dynamic scaling of mutation factor based on budget utilization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 28 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 28 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "906192ba-3435-4434-8cb6-7b68fb7bd81e", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            if self.evaluate_budget % (self.budget // 10) == 0:  # Line 1 changed\n                self.pop_size = min(self.pop_size + 1, 50)  # Line 2 changed\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic population resizing and adaptive learning rate.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "c284a9b4-1757-4f55-b583-ec3a8bead19d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):  # Adjusted population size dynamically\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced a dynamic population size adjustment based on progress to improve exploration-exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "3c3ca59f-d10e-47fc-9a91-f54454480ee8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(5, int(20 * (budget / 1000)))  # Adaptive population size based on budget\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "HHDES with adaptive population size, adjusting dynamically for exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "2c19fb85-fac2-4e82-8f8a-4fe405c2467d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, min(50, dim))  # Dynamic population size scaling\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Enhanced local search\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "HHDES refined with dynamic population size scaling and enhanced local search step.", "configspace": "", "generation": 16, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "28850cb9-8e27-42b9-850a-45377f6c8bf8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            self.adaptive_population_control()  # Dynamic population size\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def adaptive_population_control(self):\n        # Scale population size based on remaining budget\n        self.pop_size = max(10, int(20 * (1 - self.evaluate_budget / self.budget)))\n        self.population = self.population[:self.pop_size]\n\n    def local_search(self, func, solution):\n        scale = 0.1 * (1 - self.evaluate_budget / self.budget)  # Dynamic perturbation scale\n        perturbation = np.random.normal(0, scale, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive control of population size and dynamic scaling of local search perturbations.", "configspace": "", "generation": 16, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "4bf1d415-2384-42eb-8e7f-f56a03611a65", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            self.pop_size = max(10, int(self.budget - self.evaluate_budget))  # Dynamically adjust population size\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES by dynamically adjusting population size based on remaining budget for efficient exploration.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 169 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 169 is out of bounds for axis 0 with size 20')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "e35d4604-9fbd-45e8-9e8d-78fb3d913fbf", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            # Elitism: Ensure the best solution is preserved\n            worst_idx = np.argmax([self.evaluate(func, ind) for ind in self.population])\n            self.population[worst_idx] = self.best_solution\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "The algorithm improves convergence by introducing elitism preservation to retain the top solution after each differential evolution iteration.", "configspace": "", "generation": 17, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "ff002d47-25c7-40d7-8e2b-98708e8613d3", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.layer_factor = max(1, dim // 10)\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        fitness = func(candidate)\n        noise_factor = np.random.normal(0, 0.01)\n        return fitness + noise_factor\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1 / self.layer_factor, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic layer adaptation and robustness integration for improved black-box optimization.", "configspace": "", "generation": 17, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "2e5fdb2e-87c7-455f-9201-ac13e60bed14", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + np.random.rand() * 0.3  # Adjusted mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Adjusted perturbation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive local search and mutation factor adjustment.", "configspace": "", "generation": 17, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "6dd18f0f-711c-4d06-8440-47edcee70921", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.pop_size = max(5, int(20 * (1 - self.evaluate_budget / self.budget)))  # Adaptive population size adjustment\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced adaptive population size adjustment based on convergence rate to improve exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "d0206380-f1bb-4820-ab89-ecf0aa8aba0d", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            self.pop_size = max(5, int(20 - (self.best_fitness * 10)))  # Dynamic population scaling based on best fitness\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhance adaptive strategy by introducing a dynamic population size scaling factor based on convergence rate.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: OverflowError('cannot convert float infinity to integer').", "error": "OverflowError('cannot convert float infinity to integer')", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {}, "mutation_prompt": null}
{"id": "0af7ad99-9621-4e59-be1d-50a849634d15", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.4 + np.random.rand() * 0.4  # Adaptive mutation factor (modified range)\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved adaptive mutation range to enhance exploration and convergence of solutions.", "configspace": "", "generation": 18, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "3335d9bc-d5e0-4abd-8ab8-ca4ee78d885b", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            self.maintain_diversity()  # Added line for diversity maintenance\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def maintain_diversity(self):  # Added method for maintaining diversity\n        if np.var(self.population) < 0.01:  # Diversity threshold\n            self.population += np.random.normal(0, 0.1, self.population.shape)\n            self.population = np.clip(self.population, 0, 1)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation, crossover, and added robustness through diversity maintenance for improved optimization.", "configspace": "", "generation": 18, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "4e1065b8-f591-4d74-9e46-d6088b529db2", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def modular_structure_detection(self):\n        # Simulate detection of modular structures\n        return np.random.choice([True, False], self.dim)\n\n    def local_search(self, func, solution):\n        mod_struct = self.modular_structure_detection()\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation * mod_struct  # Exploit modular structures\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES by integrating a modular structure detection and exploitation mechanism along with dynamic allocation of resources for local search and adaptive mutation strategies.", "configspace": "", "generation": 18, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "b08d56db-caa8-4614-b593-84c4fd6cc0de", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.dynamic_pop_size = True  # Enable dynamic population size\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        if self.dynamic_pop_size:  # Adjust population size with budget\n            self.pop_size = max(10, int(self.budget // (self.dim * 2)))\n            self.population = np.random.rand(self.pop_size, self.dim)\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Enhanced local search\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with dynamic population size and enhanced local search for better exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "4a141a3c-f72d-43ea-ac17-34944381d1d0", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.4 + np.random.rand() * 0.4  # More dynamic scaling factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES by enhancing the adaptive mutation strategy with a more dynamic scaling factor for better exploration.", "configspace": "", "generation": 19, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "a744c46d-816b-4446-963d-488571add7c3", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.pop_size = max(10, self.pop_size - 1)  # Dynamic population size\n            self.pbest_fraction = 0.2 + 0.1 * np.random.rand()  # Adaptive pbest_fraction\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduce a dynamic population size and adaptive pbest_fraction to enhance exploration and exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "ea71fc76-01c8-466d-9c05-1baafada884f", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.1  # Adjusted mutation factor to be more dynamic\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Targeted local search\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with annealing-inspired mutation factor and targeted local search for improved convergence.", "configspace": "", "generation": 19, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "bf37cc4c-0a37-4d56-9c23-7d61a00ca6aa", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.iteration = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n            self.iteration += 1\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        decay = 0.99 ** self.iteration  # Introduce decay factor\n        F = (0.5 + np.random.rand() * 0.3) * decay  # Adaptive mutation factor with decay\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduce a decay factor to gradually reduce the mutation factor, improving convergence over the iterations.", "configspace": "", "generation": 19, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "7d54344d-65ad-4e9c-81b7-a4e9581d8ed8", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)\n                trial = self.adaptive_crossover(self.population[i], donor)\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + (np.random.rand() * 0.3 * min(1, self.evaluate_budget / self.budget))  # Dynamic scaling\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Introduced dynamic scaling by adjusting the mutation factor and population size progressively to enhance convergence in later stages.", "configspace": "", "generation": 19, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "3f0c207e-812b-4fd4-b0d2-be6fa4191b06", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        while self.evaluate_budget < self.budget:\n            self.pop_size = max(5, int(20 * (1 - self.evaluate_budget / self.budget)))  # Dynamic population size\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, plus a fix for local_search initialization error, and improved convergence by dynamic population size adjustment based on remaining budget.", "configspace": "", "generation": 20, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "5e8e0a11-bb41-48b4-88ce-3ad60e361926", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced standard deviation\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Improved HHDES with enhanced local search using gradient-based perturbation.", "configspace": "", "generation": 20, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "848ce7c8-ed9e-4862-9dde-428dd3a060fa", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            # Probabilistic switch between differential evolution and local search\n            if np.random.rand() < 0.5: \n                self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with adaptive mutation and crossover, introducing a probabilistic strategy to switch between global and local search phases.", "configspace": "", "generation": 20, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "e3ec7a39-0182-4319-a4f2-552019f3786c", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < self.evaluate(func, self.population[i]):\n                    self.population[i] = trial\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.05, solution.shape)  # Reduced perturbation for finer tuning\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with a more robust local_search using smaller perturbation for better fine-tuning.", "configspace": "", "generation": 20, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
{"id": "9073fa7c-bdda-4122-b6ec-862cb1d975f5", "solution": "import numpy as np\n\nclass HHDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.9\n        self.F = 0.8\n        self.pbest_fraction = 0.2\n        self.population = np.random.rand(self.pop_size, dim)\n        self.best_solution = np.random.rand(dim)  # Initialization fix\n        self.best_fitness = np.inf\n        self.evaluate_budget = 0\n        self.layer_increase = 1\n\n    def evaluate(self, func, candidate):\n        self.evaluate_budget += 1\n        return func(candidate)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget):\n            if self.evaluate_budget >= self.budget:\n                break\n            fitnesses = [self.evaluate(func, ind) for ind in self.population]\n            best_local_idx = np.argmin(fitnesses)\n            if fitnesses[best_local_idx] < self.best_fitness:\n                self.best_fitness = fitnesses[best_local_idx]\n                self.best_solution = self.population[best_local_idx]\n            mean_fitness = np.mean(fitnesses)\n            fitness_diversity = np.std(fitnesses) / (mean_fitness + 1e-9)\n            if fitness_diversity < 0.1:\n                self.layer_increase = min(self.layer_increase + 1, self.dim)\n            else:\n                self.layer_increase = max(self.layer_increase - 1, 1)\n            for i in range(self.pop_size):\n                if self.evaluate_budget >= self.budget:\n                    break\n                donor = self.adaptive_mutate(i)  # Changed to adaptive mutation\n                trial = self.adaptive_crossover(self.population[i], donor)  # Adaptive crossover\n                trial_fitness = self.evaluate(func, trial)\n                if trial_fitness < fitnesses[i]:\n                    self.population[i] = trial\n\n    def adaptive_mutate(self, current_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(current_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0, 1)\n\n    def adaptive_crossover(self, target, donor):\n        CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, donor, target)\n\n    def local_search(self, func, solution):\n        perturbation = np.random.normal(0, 0.1, solution.shape)\n        candidate = solution + perturbation\n        candidate = np.clip(candidate, 0, 1)\n        candidate_fitness = self.evaluate(func, candidate)\n        if candidate_fitness < self.evaluate(func, solution):\n            return candidate, candidate_fitness\n        return solution, self.evaluate(func, solution)\n\n    def optimize_layers(self, func):\n        for _ in range(self.budget // self.dim):\n            if self.evaluate_budget >= self.budget:\n                break\n            self.differential_evolution(func)\n            self.best_solution, self.best_fitness = self.local_search(func, self.best_solution)\n\n    def __call__(self, func):\n        self.optimize_layers(func)\n        return self.best_solution", "name": "HHDES", "description": "Enhanced HHDES with dynamic layer adjustment and fitness diversity preservation for improved exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.660056797745749, "feedback": "The algorithm HHDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.660 with standard deviation 0.000. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b62dae09-80a1-442c-aaf7-a8735b8c6c1f", "metadata": {"aucs": [0.660056797745749, 0.660056797745749, 0.660056797745749], "final_y": [0.21891901516198964, 0.21891901516198964, 0.21891901516198964]}, "mutation_prompt": null}
