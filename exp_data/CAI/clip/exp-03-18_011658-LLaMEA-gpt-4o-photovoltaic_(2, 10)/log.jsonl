{"id": "0cdb3c2f-96b0-402e-9119-fc07a28f54d6", "solution": "import numpy as np\n\nclass Particle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass ParticleSwarmDifferential:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = []\n        self.bounds = None\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive (particle) weight\n        self.c2 = 1.5  # social (swarm) weight\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        num_particles = min(40, self.budget // 5)  # adaptively choosing swarm size\n        self.particles = [Particle(self.dim, self.bounds) for _ in range(num_particles)]\n        \n        for _ in range(self.budget):\n            for particle in self.particles:\n                fitness = func(particle.position)\n                if fitness < particle.best_value:\n                    particle.best_value = fitness\n                    particle.best_position = np.copy(particle.position)\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = np.copy(particle.position)\n\n                # Update velocity\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                particle.velocity = (self.w * particle.velocity +\n                                     self.c1 * r1 * (particle.best_position - particle.position) +\n                                     self.c2 * r2 * (self.global_best_position - particle.position))\n                # Perform differential mutation\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                F = np.random.uniform(0.5, 0.9)\n                mutant = a.position + F * (b.position - c.position)\n                mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n                trial = np.copy(particle.position)\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        trial[j] = mutant[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness:\n                    particle.position = trial\n                else:\n                    particle.position += particle.velocity\n\n        return self.global_best_position, self.global_best_value", "name": "Particle", "description": "The algorithm combines particle swarm dynamics with adaptive differential mutation to enhance exploration and exploitation capabilities in high-dimensional black box optimization tasks.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 194, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 288, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 148, in evaluatePhotonic\n    algorithm = globals()[algorithm_name](budget=budget, dim=dim)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Particle.__init__() got an unexpected keyword argument 'budget'\n.", "error": "TypeError(\"Particle.__init__() got an unexpected keyword argument 'budget'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 194, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 288, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 148, in evaluatePhotonic\n    algorithm = globals()[algorithm_name](budget=budget, dim=dim)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Particle.__init__() got an unexpected keyword argument 'budget'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5e0c5662-6e8d-4ef4-b52e-c3a78c165ac3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(budget / (dim * 10)))\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.diff_weight = 0.8  # differential weight for DE\n        self.cr = 0.9   # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = personal_best_scores.min()\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # PSO Update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = self.w * velocities + self.c1 * r1 * (personal_best - pop) + self.c2 * r2 * (global_best - pop)\n            pop = np.clip(pop + velocities, lb, ub)\n\n            # Evaluate and update personal bests\n            scores = np.array([func(ind) for ind in pop])\n            eval_count += self.population_size\n            better_mask = scores < personal_best_scores\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_scores[better_mask] = scores[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best = personal_best[min_idx]\n\n            # DE Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = pop[indices]\n                mutant = x1 + self.diff_weight * (x2 - x3)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, pop[i])\n                trial = np.clip(trial, lb, ub)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    pop[i] = trial\n                    scores[i] = trial_score\n\n        return global_best", "name": "HybridPSO_DE", "description": "A hybrid metaheuristic algorithm combining particle swarm optimization with adaptive differential evolution for efficient exploration and exploitation in high-dimensional search spaces.", "configspace": "", "generation": 0, "fitness": 0.8600835910864726, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.037. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8104655120499382, 0.872155493351243, 0.8976297678582367], "final_y": [0.14479057941038298, 0.12001420732134793, 0.1150248257827764]}, "mutation_prompt": null}
