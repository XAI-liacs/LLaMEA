{"id": "025116a3-4d76-4529-9dce-6e61f7658e03", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound)\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Parameter Control and Local Search for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 0, "fitness": 0.26657301669637384, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.5600726264230712, 0.5707216363825708, 0.5969207433609609, 0.6118775123858062, 0.6166989757138921, 0.5999819040222307, 0.6067436477014485, 0.6035508879134607, 0.6208235000190254, 0.3500492919831105, 0.32774651988534687, 0.34169375919730205, 0.31743867793895364, 0.3148673206949145, 0.3244833545523492, 0.33499222765653935, 0.321249373084176, 0.3161034267099634, 0.08880469298657134, 0.09334300269675655, 0.09438487706553478, 0.0932313426679342, 0.09181011011839058, 0.08537011162738783, 0.0851301827492913, 0.09568621484914597, 0.0909480421925829, 0.08390973887550823, 0.08218666881822012, 0.09680990213740204, 0.08624112747691592, 0.08243656628416651, 0.08858330993008878, 0.08460440816336778, 0.07854259519205897, 0.08688265935622075, 0.9802752460845796, 0.9900833642640725, 0.9660560606294184, 0.9274529329337128, 0.9608920062811868, 0.9654181360197007, 0.9386367788555876, 0.9822486033537455, 0.9567561544295679, 0.26803151514071477, 0.28211650601052274, 0.2545753716330261, 0.27320055652288033, 0.26843079540588344, 0.29889684447699516, 0.28336322648587253, 0.27906975911044574, 0.275741461457758, 0.48438141986647953, 0.4725334055024002, 0.393523432246925, 0.593393975643028, 0.5633776572371862, 0.6877408823149083, 0.5449801657376481, 0.5060940563406979, 0.4704126388945108, 0.19371093556594376, 0.1809667899708367, 0.18131440091481843, 0.21005738843544486, 0.18546681574284407, 0.18123266692385587, 0.2007444952893116, 0.18190879398085813, 0.195769019235839, 0.17907675234694798, 0.11110438659779798, 0.17911729366679396, 0.16060580197818586, 0.20013329251971312, 0.18155535366085562, 0.2026570645739818, 0.18151417862077468, 0.17370457852128274, 0.13336432190034408, 0.1328753972772302, 0.10774028099449029, 0.11855924006456353, 0.1644366186282501, 0.14530173597024532, 0.11874943401535787, 0.13519997001312645, 0.1382519617265351, 0.23941780562342874, 0.26429791396285474, 0.2416711607743931, 0.2827620027439467, 0.23798975005125922, 0.22770644464626932, 0.29571071264253235, 0.2523833370135048, 0.32223663947539416, 0.050655248173712586, 0.03309250882574666, 0.02049659253322711, 0.03511752248077593, 0.019079980806762764, 0.03665558132690894, 0.019717986503221097, 0.015196368013101313, 0.03243436872565475, 0.14860672230890637, 0.1360926722178487, 0.16740602125682558, 0.1528759511196477, 0.16698984049417254, 0.15968912216167408, 0.161408722241017, 0.14176310430908123, 0.14297577098307634, 0.45681626001220477, 0.45973912782119153, 0.4590571480865854, 0.4715786542932463, 0.4545914627166866, 0.4717282904003015, 0.47645102282336327, 0.45594174339693483, 0.4937700465864212, 0.08155168711086369, 0.09283423240263056, 0.08659303110894379, 0.09011629805770116, 0.09097885191844712, 0.08250096856365308, 0.08486329351195909, 0.07321073253648025, 0.08284981168916672, 0.15423549697782368, 0.14468839514078513, 0.14102540068606562, 0.1340878974772468, 0.17934484782586424, 0.13934580835636157, 0.2610876080352865, 0.13889825510645182, 0.13542279041858563, 0.2673889449479242, 0.2664039171354974, 0.2642546705779103, 0.2730005085331004, 0.25987312134792184, 0.25868141625288044, 0.27775832063462735, 0.2738012153060809, 0.287220077925743, 0.19670271245733562, 0.21097940574896235, 0.2062802892252582, 0.19272478650348523, 0.19503371777178635, 0.20790714458041015, 0.21339097009278551, 0.2109614296568778, 0.19916369960130154, 0.17465137093981686, 0.1864884624522083, 0.1833683433205625, 0.1750953681767673, 0.1794892794450057, 0.21206069090568858, 0.19682378526195976, 0.21378555555566114, 0.18291130264660727, 0.17101562212026544, 0.17215527385379015, 0.17714709242794036, 0.1682264446689543, 0.17471416448210675, 0.17631499121018335, 0.17438603310301348, 0.17469823974521026, 0.18001033039277003, 0.5804131351555851, 0.4194057790620448, 0.20274541239081734, 0.49885800640227684, 0.4819599583076538, 0.4953713750116536, 0.18079419012371922, 0.4498611875681472, 0.3259990332579372, 0.595536471302252, 0.19336184386260324, 0.19220225227630294, 0.24845835531373517, 0.40581463609372315, 0.19011916854382516, 0.6898762796128872, 0.6788186283247934, 0.202352828111382, 0.17706239575568816, 0.19754777730430062, 0.2024937866457419, 0.19432010135458877, 0.18504484389951303, 0.18310158573799196, 0.18789969284522035, 0.1991326132507033, 0.18301427674848147, 0.0697159535497276, 0.0734812894842819, 0.07584639871107834, 0.06343941934481323, 0.06669548801911585, 0.06465294609329353, 0.07110625572584217, 0.08442433065191346, 0.06851333626016953]}, "mutation_prompt": null}
{"id": "b269320d-a407-4aa5-a50a-583ce01f56a4", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, np.std(population, axis=0))\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, diversity):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.mean(diversity)\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce adaptive local search step size based on population diversity to improve convergence.", "configspace": "", "generation": 1, "fitness": 0.2626896465018495, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "025116a3-4d76-4529-9dce-6e61f7658e03", "metadata": {"aucs": [0.5979580297807929, 0.6402354428064756, 0.6048636520722519, 0.649895938973242, 0.6129297973807719, 0.6349817971620568, 0.6320089063572603, 0.5963386843350982, 0.6376748932058551, 0.3276759024556074, 0.3585679538886217, 0.33837876550811297, 0.33935984179631984, 0.33873547757810807, 0.3274731827057519, 0.33844806467500477, 0.32976475487153245, 0.33970997172711237, 0.08917068343908863, 0.08795863634681678, 0.09003716784257687, 0.08802904008752488, 0.10097825002186123, 0.08424859801753737, 0.0909630000142444, 0.09951675440562979, 0.08551763802913115, 0.07859009088280577, 0.08487760673669731, 0.09650381112584017, 0.09143881237846874, 0.10043522506886915, 0.08489196666310839, 0.0825740738126971, 0.09248033143469314, 0.0804615735779527, 0.9052971478518418, 0.9899986443550923, 0.968213747896146, 0.9705530678426136, 0.9569374253809004, 0.9069558660655888, 0.9581700487605836, 0.9825147143205545, 0.9611528392304267, 0.27251171852043565, 0.2868636303469724, 0.27662872372233493, 0.2884762460694391, 0.28004290348193006, 0.29692173131872257, 0.2868797315061473, 0.28175851158443266, 0.30042947500131667, 0.45946941306776945, 0.48019635009680595, 0.5772172210401507, 0.625777769174737, 0.5348827441209374, 0.4425542029302274, 0.486558247813223, 0.473084894789659, 0.4410233223897472, 0.1894618338824412, 0.2327866849559863, 0.1907222891252307, 0.2034186516193882, 0.16522408081286155, 0.19024965431837904, 0.22627083503961753, 0.17300698709364026, 0.1966425078676718, 0.23743449346083711, 0.2345688371400685, 0.23660450627023477, 0.19126975090071197, 0.1653868543271455, 0.22653088888367523, 0.2172371777195682, 0.1861268349486196, 0.1666486651733189, 0.11932548850992974, 0.1592744538653602, 0.12344000787184073, 0.12146469110059477, 0.1104069391066429, 0.12007290803827764, 0.14952423846038387, 0.125398280112065, 0.12090248275797422, 0.2638903060631601, 0.2833175768841302, 0.25365252913265857, 0.2354838486413957, 0.2085832341074264, 0.2665802285095742, 0.28516547401906456, 0.3182136453395781, 0.2543381375494945, 0.02927496916281247, 0.018026125715416286, 0.0327839346454899, 0.05007215398938658, 0.04464409135702352, 0.025547576947623774, 0.05089634912428587, 0.031090546468723, 0.018858798310854796, 0.16444567795561194, 0.15238038317215719, 0.1527986760523662, 0.16025149677055417, 0.16968160466100357, 0.1557518463411075, 0.16204820190642621, 0.15828061520674164, 0.14709469467638014, 0.473447823809217, 0.4974393462929011, 0.46883019264550385, 0.4717666955202332, 0.49197757025641, 0.4875062526627707, 0.5021354074685207, 0.46547656382592173, 0.49890372089227464, 0.1086650670538073, 0.08484224862914802, 0.09051168281653243, 0.09633653895190475, 0.09246918940594973, 0.08420090572101235, 0.07693168592354704, 0.10345094816578182, 0.08755540247096227, 0.13983550051294114, 0.1426283639824304, 0.15530933911149236, 0.15282225413088368, 0.16021832536841918, 0.13627930177550152, 0.19135584312966125, 0.12887274603651422, 0.14320410736943523, 0.2780982277633367, 0.2756954750646947, 0.26757290913674614, 0.24872200642333242, 0.24850494237653697, 0.268504500082821, 0.29040334967899006, 0.2872296559392252, 0.29338048385104876, 0.22123845900672334, 0.19645301541160543, 0.21535002632928657, 0.18007699769828145, 0.19835279928114646, 0.20134315953916926, 0.21561971814646674, 0.2263447630178832, 0.20884011593571783, 0.21319140166493622, 0.21301550398865587, 0.1919567526786209, 0.179545115052552, 0.17344742968337235, 0.18494954724812473, 0.17680503256228386, 0.18279333530319242, 0.16674377143328145, 0.17290511145164833, 0.1744588088668252, 0.1875285534728649, 0.18247777763502082, 0.18046966336597237, 0.1782325670246604, 0.1787796033448953, 0.17771089785398198, 0.1679058386690403, 0.14818574904456927, 0.3866839174307033, 0.5499399230945647, 0.3627728776712239, 0.35093989312890883, 0.4081890679558742, 0.19050177504026589, 0.17738200805493742, 0.34019863266922545, 0.4700269980229592, 0.3431362744462092, 0.19220040302698616, 0.3216527013196262, 0.3878286594214685, 0.19398899419066262, 0.21083495434291555, 0.20237572269652926, 0.20559294086714353, 0.18497425539696022, 0.17919501262580784, 0.17877022142687782, 0.1917203166876026, 0.19169567036674506, 0.2038265286196037, 0.18161951079554461, 0.18470118057869456, 0.17981951869720747, 0.06941190127065144, 0.07321090195432312, 0.07227546661924933, 0.07521296984136228, 0.06675259112131027, 0.07957191978618516, 0.06738637575622275, 0.08816081743852522, 0.07530825116205886]}, "mutation_prompt": null}
{"id": "802de285-c7b3-42d0-bc60-cd3892564883", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduced adaptive step size in local search to enhance fine-tuning near optima.", "configspace": "", "generation": 2, "fitness": 0.2689851477412817, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "025116a3-4d76-4529-9dce-6e61f7658e03", "metadata": {"aucs": [0.5758943263117146, 0.5505566339564656, 0.5736795504776789, 0.5835667218686931, 0.6219181843274695, 0.6267188446818808, 0.6293810817075095, 0.6259830308481182, 0.6197362725271527, 0.3242019315928314, 0.3530249341393804, 0.3105266133612272, 0.3331023709530446, 0.36628376760405823, 0.3577365306130543, 0.3640544076744454, 0.3258055589323544, 0.3228420537340999, 0.10544841517399328, 0.08338939018415281, 0.0964567348615386, 0.08765483077114367, 0.09037979489076065, 0.09238933014744377, 0.08585213303840478, 0.1067307514311222, 0.10213464522701865, 0.09654971896681053, 0.08090566085806916, 0.09424143310756483, 0.09314078150762195, 0.09720156898035259, 0.08005922851359082, 0.08833171146081586, 0.08345715330425196, 0.09201770573345802, 0.9721396950416133, 0.9785301059455156, 0.9700247776583891, 0.9510652129568564, 0.9760787069670539, 0.9403422588064844, 0.9333873200842511, 0.9650414210590316, 0.8975481404110893, 0.29071391799865376, 0.27008511918120626, 0.27062736955504585, 0.263627752089046, 0.2796717438078776, 0.25389909709928893, 0.2711102672444343, 0.29150553631693155, 0.27674742484999004, 0.5181236325691011, 0.561935111696293, 0.5396611993231972, 0.5914841253216867, 0.5361391364047818, 0.5441526113616355, 0.577609857723589, 0.5400398496895333, 0.5153278004385068, 0.21016976334196547, 0.2206811508029629, 0.1963538100944917, 0.19319704231506707, 0.15177871258842335, 0.2010239287549903, 0.20111135785891454, 0.17789798025879444, 0.20080671446967013, 0.28433015161161634, 0.27116903255681213, 0.2580781812196865, 0.19278112223933308, 0.1946804237510159, 0.20105367019845444, 0.17404982686127446, 0.21193992192415512, 0.14874320207767833, 0.11321965450932714, 0.13855756834129074, 0.1302273905032897, 0.17752599685873394, 0.1226232847307589, 0.11722663744645345, 0.15517101000704392, 0.1078821657290997, 0.1496676398191208, 0.24642871100283015, 0.28498374203568866, 0.24608274023965637, 0.265991975426623, 0.2683454047962929, 0.2809141215014834, 0.2542491856603125, 0.29398301378667835, 0.28592197783114326, 0.047228316716994456, 0.03524231273114786, 0.02322333900722029, 0.06282443255868042, 0.03934885500967411, 0.053488751423065306, 0.03387072878981712, 0.049562542492974204, 0.028073330277111896, 0.15864724970697153, 0.15265512986119556, 0.15675949875245132, 0.17578050828211667, 0.1621330733550449, 0.1445133116440337, 0.15954095381708577, 0.1662277282998209, 0.1678649938959832, 0.4677304311190924, 0.47091325919819604, 0.47163712245183276, 0.5012125990327606, 0.4847465490139785, 0.4830769921572391, 0.4689596652549466, 0.47149133657020226, 0.45139230285383847, 0.0853827351139429, 0.0785555688939974, 0.09314246806435345, 0.09261740718471356, 0.08996560652090413, 0.11243040995931042, 0.08880619057197914, 0.07246505817249926, 0.09545070713568182, 0.15824001236258334, 0.16477233713831396, 0.17066724912958886, 0.16716996765543157, 0.1549625684751742, 0.17423985714342693, 0.16597579627017567, 0.1940028274521971, 0.15225269308632106, 0.2737719341856878, 0.26741734189609434, 0.2734898677686699, 0.2714823827050382, 0.2617860054939193, 0.25749495312539616, 0.2886175830558261, 0.26546000681241333, 0.2872668346921531, 0.20722034281208312, 0.20059663785124415, 0.2046684734867965, 0.19331708797557579, 0.20705080370687745, 0.18543610589002524, 0.20261549744848717, 0.21596257165956445, 0.20675058998021112, 0.1818295402335468, 0.1777076963515366, 0.1847340801648728, 0.19540886011331682, 0.1684733006092698, 0.17846302546683435, 0.1907665285959831, 0.188970679111107, 0.18212645706718056, 0.17390445441063462, 0.17520177689475114, 0.1812330475017353, 0.1756415905340798, 0.17084759580453845, 0.18152217203173693, 0.1677210548913296, 0.1701642896755169, 0.18205218163711367, 0.17716645412237542, 0.18191420651963386, 0.5973820626843864, 0.6277113240239065, 0.3993658662025722, 0.37778952534475374, 0.46802675478449385, 0.15567956614630707, 0.3830837354976332, 0.19795170825362585, 0.4717336131832407, 0.4531492554078279, 0.2778479194346227, 0.33497818645252153, 0.4056548082058603, 0.210811150598459, 0.5092425764079498, 0.20172379203508806, 0.17942198298749967, 0.1861213878872885, 0.18014655283769387, 0.18747390782156903, 0.19320368078086947, 0.19137324002717215, 0.17924301776165108, 0.1903595246377996, 0.2131382201983396, 0.06906887580772603, 0.06840054227627557, 0.07333505628364889, 0.06867506112722821, 0.07297555782576437, 0.07039602287197899, 0.07626183709368428, 0.07196769974204109, 0.07477790437662823]}, "mutation_prompt": null}
{"id": "0607a0d2-a613-4745-bda2-5d00131c77b3", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Refined crossover strategy by adjusting the probability to enhance exploration.", "configspace": "", "generation": 3, "fitness": 0.27502560185050073, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "802de285-c7b3-42d0-bc60-cd3892564883", "metadata": {"aucs": [0.5932440513101718, 0.5683375901478935, 0.5912707137353257, 0.6018257761972513, 0.6114538091942539, 0.5810242161183621, 0.609351638314449, 0.5918610257205399, 0.5965662937052645, 0.3275052269629811, 0.3256116382325933, 0.354882321478014, 0.3137926559943266, 0.33371384301808116, 0.33501615377017335, 0.3420694329436972, 0.34820429026682775, 0.3382479642285159, 0.07925154464958428, 0.08663186334029083, 0.09150585887351681, 0.09096097979151052, 0.08670164490586085, 0.10162361023536814, 0.09596608087531988, 0.09540458690129183, 0.08440709658226975, 0.08542354070907054, 0.07596780940773573, 0.07606072300775701, 0.0934143707101015, 0.08100295147600778, 0.08221035324650106, 0.0943458543228981, 0.0771408891587475, 0.08804539873653738, 0.9589394752181876, 0.9222422687381278, 0.9628490823074581, 0.9263298433578719, 0.9877859401125411, 0.9005026950427417, 0.9188766092172186, 0.9132626544845497, 0.9090814742883938, 0.27759271982844136, 0.269773693339332, 0.24741816529478455, 0.28154523861564595, 0.2455931738308581, 0.2822394439590282, 0.30835243269023116, 0.288036757572937, 0.2894643490232669, 0.553340337283905, 0.5367261597426344, 0.5217593249535457, 0.6315352656733397, 0.5799395933861053, 0.6020089917435174, 0.568151933755109, 0.510341083591443, 0.528857442163039, 0.17494056257170765, 0.2174707518276302, 0.20001190769777744, 0.20370207547358032, 0.21196543280890978, 0.18308355847531954, 0.30192877242722016, 0.19890815404260143, 0.2170846103926921, 0.34682196412162125, 0.21214661916639477, 0.27991831213871443, 0.192487538292624, 0.16810295802926034, 0.24656217121683388, 0.19585678073067103, 0.1771276995224358, 0.2165660431905283, 0.2080199368117185, 0.16253873093845872, 0.1896827948186236, 0.22171313953610405, 0.18570213429089466, 0.19511047554210292, 0.20149330323179415, 0.16160267846892273, 0.20152932671988377, 0.3408873691938187, 0.31467913424833915, 0.3381760597866098, 0.3372253740809168, 0.3288619266068914, 0.2895558226002256, 0.3374996091048954, 0.3430615911504006, 0.3438013686788105, 0.030004940026659654, 0.05295325652732463, 0.03539261986931197, 0.08202748048157116, 0.02918525304817632, 0.07147123153877, 0.034239920920349, 0.04337013091475661, 0.06762008235713235, 0.18673774532749587, 0.16796813866639693, 0.16476718677310842, 0.20189012513546167, 0.17035709514854003, 0.19183628919576334, 0.18482463939657823, 0.20714012565340323, 0.17410029485365774, 0.475368469198723, 0.495513383723609, 0.4872950381467259, 0.5184081271826112, 0.4935489802297799, 0.4955179034811509, 0.500508018126144, 0.4773455893317078, 0.48970394530842953, 0.08006249118107711, 0.08527860832731882, 0.09166239855249592, 0.0883764411200284, 0.09143795569893642, 0.09463513313603034, 0.09833412161478206, 0.08666894441456063, 0.08977175123746783, 0.15725049401618596, 0.179198076505109, 0.22618771980821917, 0.15502780497640745, 0.18793796376862093, 0.17106242005436578, 0.1834239064563673, 0.18841422097401128, 0.15584367969305457, 0.27130013512855056, 0.2599821894511931, 0.27167269502142877, 0.2630582968888039, 0.24965425793982732, 0.24898325890991624, 0.26190364742822203, 0.27842193016598116, 0.2913176355394528, 0.20260033246811038, 0.20498577874552149, 0.19854421955146295, 0.20286635041591994, 0.2042023491386984, 0.2010245381368151, 0.2266346622288662, 0.22741238348460413, 0.21544745731486792, 0.1773403206234443, 0.16916251280379424, 0.1988474858593392, 0.1758800256395442, 0.1817275767416895, 0.19114190487641536, 0.17748096511690403, 0.18513628408827787, 0.20153836347658693, 0.19648529242590562, 0.177550399094362, 0.18116076578670826, 0.17912272310740518, 0.19045960028196474, 0.18498007102555925, 0.17708465369204152, 0.18144337415542577, 0.17600120405097186, 0.14776451697719062, 0.1998296437953272, 0.17074642221146163, 0.6099589516019419, 0.28664272346895114, 0.372202789690107, 0.4330121144625606, 0.2902304095237469, 0.30980750217447917, 0.1642880607781595, 0.534266902630061, 0.3248016876133909, 0.18996605766570307, 0.37757167317143536, 0.4532408243895235, 0.7627630763471309, 0.20508010369511143, 0.20844493840591438, 0.18743860861285233, 0.19530477105248534, 0.20578861798438874, 0.18501929051187394, 0.21013570206900622, 0.1786295938459993, 0.18850605886054295, 0.1923673610719998, 0.17611181468415693, 0.06719589052015218, 0.07285646088702469, 0.07076121530371782, 0.07110282215121333, 0.07711613435240194, 0.06210882094168502, 0.06722926428016651, 0.07629081873008436, 0.060305936923974346]}, "mutation_prompt": null}
{"id": "8a9ed45a-cc4d-4b28-96a1-0a2089f2f2c0", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            # Dynamic adjustment of local search probability\n            self.local_search_probability = min(0.3, self.local_search_probability + 0.01)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Improved exploration by dynamically adjusting local search probability.", "configspace": "", "generation": 4, "fitness": 0.25745994292331964, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0607a0d2-a613-4745-bda2-5d00131c77b3", "metadata": {"aucs": [0.49899451929407324, 0.5247836012093651, 0.4981831080695046, 0.53629755245987, 0.5456699409504369, 0.5547283946902135, 0.5257432616891953, 0.49769246946051604, 0.5356743906899093, 0.23598488527504247, 0.26592495797243887, 0.22875651824111232, 0.2099151375350613, 0.23948989880702465, 0.2827226851892346, 0.24060497666535297, 0.21878516789670688, 0.24444294603968275, 0.08440960720029866, 0.09592058946624837, 0.10298584931605348, 0.08779178151406031, 0.0995493721970877, 0.10584694314634158, 0.09045083837346357, 0.0999170935585274, 0.10354389402967468, 0.07311757888031156, 0.08165497885868522, 0.08277935767194267, 0.08331787689329229, 0.08401240635964347, 0.07249834268555644, 0.08229029993783443, 0.08853897617252149, 0.08962221014819172, 0.9099299460630325, 0.9701434664127861, 0.9683290985098485, 0.956632407320751, 0.9877859401125411, 0.9361950703661912, 0.9839196068644358, 0.8837645839061292, 0.8965387543125772, 0.2671359179849867, 0.24031156596239767, 0.23686609618124654, 0.2611215048919605, 0.25567736135537544, 0.2463043967174261, 0.2542098789064323, 0.2551021603293764, 0.26524049110072245, 0.5130821600550856, 0.432232062271828, 0.5037661812526113, 0.4861054090311898, 0.5115692621133339, 0.5555117465325422, 0.5386824339550238, 0.5307294723169487, 0.4434484252198265, 0.18145057251960384, 0.17917966957891984, 0.18919491068512184, 0.19131360214793702, 0.18474701661691584, 0.14727487783355753, 0.16547924531724767, 0.19565994460136216, 0.18643011756214323, 0.12326691413802326, 0.17829986033217904, 0.16588038346209721, 0.1555676609196115, 0.1547179740012401, 0.16430236653006447, 0.1516091629342009, 0.14936049876804114, 0.1733791555588967, 0.14275259214872893, 0.17000207953561763, 0.131775519230096, 0.17495391473397592, 0.1108486887212814, 0.16150845804366787, 0.12087973481937953, 0.1304700753623751, 0.15789516933455106, 0.27019726952015566, 0.2923802696424497, 0.27256054866323065, 0.27540433363585315, 0.25078642701570875, 0.25083484469518247, 0.24227792839763818, 0.2935999125752292, 0.25000154007332875, 0.04515999169191254, 0.00906880396513643, 0.029237599567317196, 0.04968646593079995, 0.043004655234541, 0.0179799831534474, 0.035184065174577284, 0.03345187937320604, 0.03171044807406875, 0.147924434118353, 0.14861852451209667, 0.15512872519713417, 0.1524774085429541, 0.15479479488749714, 0.1566614705467999, 0.14812215388213168, 0.15162231144596683, 0.15953987691873595, 0.4235769486350902, 0.4437065905113592, 0.45507866832956956, 0.44713884751313326, 0.4565108849149544, 0.4299264723614189, 0.42887038006202616, 0.44008852069733506, 0.45916410469744184, 0.09223808176340098, 0.08729753698354192, 0.09758342737691406, 0.08107741729192897, 0.09447093224196923, 0.08427278779081593, 0.09517286228886002, 0.10328766086221297, 0.08306951938776852, 0.17928982704708674, 0.18536142869843497, 0.1880667141284028, 0.18150090937991903, 0.2045060978609844, 0.1795615983227541, 0.18220061590668668, 0.17387001847796313, 0.20594664177880595, 0.2519311589025196, 0.26076754900357035, 0.25864068797277917, 0.26047238524556604, 0.24849120474566866, 0.2692113540947527, 0.2831361582454539, 0.2705576692092424, 0.27441758753321466, 0.2062137788947077, 0.20947668462027036, 0.2194452566398436, 0.20185240746380162, 0.2030798261697947, 0.17871592909291545, 0.20835670199877965, 0.2208874714228436, 0.2150030062224758, 0.17454258446641013, 0.17824946349771076, 0.17816891427327597, 0.17910965314901672, 0.1871916293714435, 0.17523964433121453, 0.1923760646335112, 0.17821234948380238, 0.17550897958105927, 0.18698204562503584, 0.18655421442036946, 0.17468934456575858, 0.18914704168188823, 0.18539212812323103, 0.18548996930667017, 0.1840619496666659, 0.1779332871473338, 0.17661309955783977, 0.7283546704058941, 0.18213732615315803, 0.5218379901178228, 0.3852341153111084, 0.39475612585104425, 0.49499917408230043, 0.1754672419311224, 0.5200612481194484, 0.37581891089382524, 0.38989819823576377, 0.4320688669238669, 0.43241742595439214, 0.38810189775894, 0.18703411825459837, 0.37378936072016233, 0.6609302702094958, 0.2019881712359326, 0.20624456325153107, 0.19010169288526513, 0.18901863703411426, 0.18474860425825423, 0.19454077126795588, 0.21256081363232848, 0.19498201975246032, 0.1945443705012111, 0.1998567970763654, 0.18637463877236182, 0.07063335793560965, 0.09067315161868661, 0.07074370359211934, 0.06542859945738766, 0.069959817247771, 0.06273907735527717, 0.06797001806424252, 0.07068037303320329, 0.06710223640742385]}, "mutation_prompt": null}
{"id": "5a2d5e39-e370-4e85-ab7c-49ed4865929c", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, budget_used / self.budget)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, scale_factor):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + scale_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Enhanced mutation strategy by incorporating a dynamic scaling factor for better exploration.", "configspace": "", "generation": 5, "fitness": 0.21934055233106414, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "0607a0d2-a613-4745-bda2-5d00131c77b3", "metadata": {"aucs": [0.7169636920530759, 0.6056232158581563, 0.708107215185438, 0.6780810091578933, 0.7261302034566813, 0.6774061323483109, 0.7212991625432582, 0.639208786242172, 0.6628007764542831, 0.09467376094640989, 0.05825562807809548, 0.06747900181082167, 0.018387014459165907, 0.09951853499528096, 0.1307992059782438, 0.0890964989332117, 0.059838002501249266, 0.11157754872702064, 0.09345488398285129, 0.05411323803539747, 0.10272056067719715, 0.09393911917214992, 0.06023380173629378, 0.17612418721937284, 0.08507824219181659, 0.12282799612668582, 0.1459911600952175, 0.06437588852153842, 0.06551110632632207, 0.034552710082234595, 0.1037826640032854, 0.08990051269481392, 0.09245371612768227, 0.107975978856799, 0.1072788233703823, 0.053273106819049953, 0.6502677738990776, 0.834666939400808, 0.724127447564597, 0.6342831512599076, 0.5672339670519109, 0.7704641302401685, 0.7709255955249874, 0.8606275758205165, 0.8179060522247622, 0.331100769168144, 0.2924554797891362, 0.2853530000377228, 0.3098749494400963, 0.29059009830770244, 0.32485922818186086, 0.3189070531724525, 0.3072926299801726, 0.3659844195731248, 0.21873135194178517, 0.2219026686635861, 0.20515703847931888, 0.20871353647019608, 0.2053740435692777, 0.18091989218096216, 0.14796625537857833, 0.2310057402831559, 0.21778151377897526, 0.11608889354704299, 0.12985253767339888, 0.15871659673142113, 0.043494443216889556, 0.034145208928495374, 0.008071809209256542, 0.2494426317908497, 0.09656566442650438, 0.14846221237824397, 0.07483898760343621, 0.046002472227727575, 0.24751642975384125, 0.14682132601234044, 0.04430088684211353, 0.160625689141926, 0.13191099533382789, 0.18148022899410787, 0.164314259273181, 0.03309999711812617, 0.026608140873429553, 0.03765592916176497, 0.04472335166868613, 0.05335117455223759, 0.01587765967313537, 0.04991341384017045, 0.03741094611095286, 0.0700289154516307, 0.06970561471088332, 0.05930184358230506, 0.0948844689245647, 0.10104471403665904, 0.03904517713646494, 0.06344946786903838, 0.12495511374312696, 0.08389726761219951, 0.09450924695899576, 0.06842662969425328, 0.03130375756723114, 0.03743952983575205, 0.09586103676477509, 0.1027488376491319, 0.09408710704418466, 0.18874555690626127, 0.0550038749160382, 0.14650282721112284, 0.08802194548852349, 0.10913711270543813, 0.16701051639115572, 0.1574222618279587, 0.07984277882692914, 0.1807343308768108, 0.19409854692281236, 0.09554374237561492, 0.14767952805126372, 0.48038214911213983, 0.4940843457042937, 0.5777429461923109, 0.46630307564726303, 0.5373569449980691, 0.40383982941122853, 0.5035906728630855, 0.5567166326479802, 0.46488981135684826, 0.1574369620606869, 0.11282725749059064, 0.07308382284770965, 0.07725387335946177, 0.02463810260446897, 0.15335040672887468, 0.06451227114852975, 0.08470672593154882, 0.07002330083356922, 0.17274354358071886, 0.221115111393281, 0.1994706451803907, 0.2488241317112897, 0.3150181337378001, 0.2044537707794818, 0.22173156368228897, 0.22013656500171874, 0.2039082576288056, 0.28742189439161425, 0.16067985438559262, 0.3061185468163885, 0.21640537510276747, 0.19128024457077175, 0.31507335863926667, 0.19799635741035282, 0.4243468403052574, 0.22186321409398857, 0.2222946921143203, 0.2830350902871802, 0.23134444618021544, 0.19449094660410338, 0.26847832313998266, 0.16660204198291195, 0.18970706808099835, 0.19577312542677305, 0.20800236051746868, 0.19820955820637098, 0.22059030466994822, 0.2253900213784109, 0.21026414290535644, 0.211425369503911, 0.18558155599221726, 0.21552022334728171, 0.17768795175280594, 0.20884214287367797, 0.1791008410497792, 0.17511492558936947, 0.1861523798263237, 0.2043343794309651, 0.18452760747226726, 0.17706299341010068, 0.17690517450603438, 0.16936955006922494, 0.17027767366944557, 0.6345596871444286, 0.1253063115258214, 0.19599788679083463, 0.1684404006586363, 0.19791484233429757, 0.716112975973273, 0.14101760049997425, 0.16633504320157133, 0.14123211241154987, 0.5263613236773939, 0.15547319564929918, 0.07347823903836748, 0.4653513634762516, 0.47109055790668686, 0.14905263182524264, 0.1531802707223866, 0.10174004852818475, 0.1620888055768086, 0.18469949699826949, 0.17862821514442617, 0.18789845889686496, 0.18588722290161075, 0.17924272233437877, 0.18836598563921825, 0.19542480617458147, 0.17698378459320796, 0.20135104719501362, 0.08931586642770728, 0.06539790211976537, 0.0675801868457534, 0.09468223101331918, 0.08572633481426528, 0.0868025778010133, 0.11690655482247803, 0.06926287293349742, 0.07622928626051784]}, "mutation_prompt": null}
{"id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Incorporate a self-adaptive mutation factor to enhance convergence and adaptability.", "configspace": "", "generation": 6, "fitness": 0.31659303334694, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "0607a0d2-a613-4745-bda2-5d00131c77b3", "metadata": {"aucs": [0.6635464007158411, 0.6293831701985166, 0.6849208998465177, 0.6781614331011415, 0.6639777707721564, 0.6517995359605278, 0.6610676321382318, 0.6301287239639839, 0.649323435788799, 0.39091747483993045, 0.37258624800622075, 0.4234624306517937, 0.40513457083403404, 0.3698412642142259, 0.3789789977095781, 0.44875231674313354, 0.39810925113823437, 0.3831052754959092, 0.0962851014959204, 0.10685470283470877, 0.09806190562932826, 0.09544732965917369, 0.08815656150343998, 0.09875828074236415, 0.10311873006294536, 0.09969502894645488, 0.10200248302988424, 0.08240848077470186, 0.08013909570690214, 0.08263679663486423, 0.09727516357203203, 0.09128723893973201, 0.08670889405322635, 0.08726921745556504, 0.08386885390372756, 0.10177692373835612, 0.934429814649841, 0.8398198089676021, 0.9052244775282956, 0.9875928482853346, 0.9606498552009355, 0.919093204976641, 0.915102882078107, 0.9186552668402754, 0.9253734902702923, 0.3107787886839146, 0.3212903914965898, 0.29624796396387787, 0.29995433335260524, 0.3041143434610124, 0.32144761882521644, 0.3172614966527605, 0.32895359973235394, 0.3456118487907327, 0.59148185742777, 0.6488059368846735, 0.6606497332115152, 0.6415674079961051, 0.6984937853824575, 0.6693691937289958, 0.6527227527633209, 0.6268806627931, 0.6426521753252322, 0.28277367583629665, 0.2615656118278058, 0.2803729683575885, 0.32162085785509875, 0.24933211775544373, 0.22667503805433087, 0.30620488672574686, 0.23994007191221867, 0.2421690448342999, 0.38239540529551597, 0.34096061717971315, 0.23503464330833435, 0.23681425769791564, 0.3164492151494428, 0.2662159506454258, 0.25641966070649436, 0.2196238897392262, 0.2602515516636068, 0.277091537743011, 0.26278111691383454, 0.2519810071932629, 0.23758223511484589, 0.23396866350826517, 0.24261614164758494, 0.25210764849433964, 0.27419374880154157, 0.2276071430786466, 0.3475795101206429, 0.4359172886367114, 0.400016154329384, 0.42291668963555284, 0.36706725202728363, 0.3814242842058194, 0.4488467064247781, 0.4078447643317583, 0.4263266219271693, 0.07981822711768038, 0.08275958074066547, 0.09460638945105437, 0.11812490892565308, 0.08465176919327366, 0.12051997033109185, 0.12153266797571616, 0.09255605560928903, 0.1015385339186039, 0.21925996648423052, 0.22025282507908028, 0.2126100590705451, 0.23214426687973533, 0.20876993782351416, 0.24797172802146705, 0.2193501886702387, 0.21798685105125892, 0.22337423426292802, 0.5608627858659654, 0.5394970632447178, 0.5594476555148571, 0.5676554703303669, 0.5308733050806854, 0.5658379767598027, 0.5692345609805685, 0.5706383408617778, 0.5506440210345941, 0.10747661150887888, 0.09372877313536743, 0.08681467902084128, 0.09023232028473416, 0.09330959524904481, 0.09080528400259591, 0.09930691068302733, 0.0962209295343257, 0.08309830242009375, 0.16642245416078327, 0.1923845232439073, 0.1660029070042114, 0.1751191395766749, 0.28490015308533834, 0.15899351557942787, 0.19441817222013225, 0.22935341433668988, 0.13543563478670184, 0.2938116888407897, 0.302034047318371, 0.30834945947212344, 0.28387951542667655, 0.31574055362324494, 0.30409200723103147, 0.3131570775507032, 0.32142402105082624, 0.2954269330694167, 0.24001668538958476, 0.2287576334918553, 0.2433478606327273, 0.2127127456479021, 0.2251514697124659, 0.21399330137816797, 0.233364839623594, 0.26303788149751905, 0.2342123367455391, 0.2128430015175461, 0.18800607711812456, 0.1923440173950266, 0.1926797518174993, 0.19919503068633426, 0.17979663021923575, 0.20216524054757024, 0.1907203973506123, 0.19281211371532236, 0.18460531680420467, 0.18208120226344315, 0.19330815546986901, 0.18860737446178844, 0.1765736576303516, 0.21542041514307175, 0.18329372469596306, 0.18157216475094906, 0.18041628331280446, 0.6344934650070768, 0.1547934495153186, 0.6852459871520369, 0.6086403453801743, 0.18026539967619504, 0.5590603941537711, 0.373471505663139, 0.4644873417383948, 0.519569438176133, 0.5490666327168466, 0.5911954584027719, 0.3402448564092053, 0.4930144881895445, 0.44493479841377936, 0.5939773313724641, 0.20734207178023467, 0.19944263406948548, 0.691572153661509, 0.18583956178727457, 0.1944343816325158, 0.20713417388499644, 0.18912640560395, 0.22998336054569357, 0.17367270686493097, 0.18312348536548995, 0.18517634602807698, 0.1882316067429598, 0.07519304787997827, 0.07199074496840474, 0.08181161975695117, 0.0703006357556143, 0.072879248011957, 0.07456101551493888, 0.0699480061062352, 0.06750417842507306, 0.07501251512092444]}, "mutation_prompt": null}
{"id": "978c2d89-b2b1-4aef-a29b-5737a77fda95", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        self.crossover_probability = 0.9 * (1 - budget_used / self.budget) + 0.1  # Dynamic crossover probability\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a dynamic crossover probability to improve exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'budget_used' is not defined\").", "error": "NameError(\"name 'budget_used' is not defined\")", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {}, "mutation_prompt": null}
{"id": "c7f923a8-19f2-4548-bcad-2fa7dc8277da", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            self.local_search_probability = 0.1 + 0.4 * (budget_used / self.budget)  # Dynamic local search probability\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a dynamic local search probability based on the iteration progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.2811049520394856, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.6258980995846477, 0.5921413861043182, 0.626901778401605, 0.6093429581850578, 0.6144943858812983, 0.6387506686132006, 0.6123074871656067, 0.5920394639191848, 0.6379710570255294, 0.33367245419030145, 0.3386237707111911, 0.31704823083054856, 0.3025871247083972, 0.3031960902055598, 0.3260893737200399, 0.33735270697322206, 0.33501546004519533, 0.30508968852052165, 0.10517072361408131, 0.09028173253803529, 0.10309623818075775, 0.08255712110085278, 0.1045821442295033, 0.10435535971343435, 0.09060285847767213, 0.09617785794913891, 0.10107310348957765, 0.09082679383366943, 0.09311309582116678, 0.09095446973574561, 0.10338524482898315, 0.08825083071949336, 0.1002294794018539, 0.08179794904620918, 0.08856714692727197, 0.09049375756072864, 0.8762063684378049, 0.8349632702485974, 0.9582741695072546, 0.9875928482853346, 0.9354412665422156, 0.8987524895548489, 0.9489563793546948, 0.9274845772673358, 0.9036459593710979, 0.2926118446411575, 0.2964357618362332, 0.2900085098681705, 0.2675703121957548, 0.2834345287385833, 0.27996707251516095, 0.30089332560722803, 0.257064208255982, 0.2853153027911757, 0.6166239996236818, 0.6078839946534813, 0.4797522077092291, 0.5545923871462201, 0.6212379251600805, 0.578435819480052, 0.5756329166419971, 0.62785252169717, 0.5869359376777455, 0.18182135351134388, 0.18806163534160203, 0.2266492651446712, 0.2262406237748772, 0.23952359425965686, 0.19468095522100914, 0.24209665803056224, 0.2137828395078467, 0.21677435952368762, 0.2965799702254782, 0.2308515623576819, 0.11841056660088778, 0.23274885713956117, 0.18046426235822288, 0.19661337451970717, 0.23479062986820376, 0.19057912156209744, 0.24188204360764176, 0.19463958472717402, 0.2314701465711615, 0.18223251480982572, 0.1880268224216507, 0.19619134454770637, 0.20933266447949928, 0.228615456950638, 0.1879893033046065, 0.17794106103342766, 0.3181492982824542, 0.3655188507268997, 0.32029464774808125, 0.3469050648289249, 0.3485139888488016, 0.31914460450250404, 0.3750961194339264, 0.37633714705602594, 0.36714103734215364, 0.05138830549325646, 0.05659780169933182, 0.05438587132376238, 0.09825562935287602, 0.07606958966965505, 0.08030621937107607, 0.06873272945049935, 0.039199273777886456, 0.05296854531427775, 0.19548623744225146, 0.20465711352949745, 0.18014135066499826, 0.1801524184833705, 0.18419157862344926, 0.2108686370068592, 0.17793737293799972, 0.18868009015241882, 0.19693298899683143, 0.4955475911694519, 0.509661051876516, 0.5032100308727823, 0.5150547588212694, 0.5238590803606236, 0.5403176485250438, 0.48220267981082365, 0.5101147018380743, 0.4765023381511383, 0.1168197954773279, 0.08385715584954101, 0.0931754779649353, 0.09997400984729088, 0.08874233240080143, 0.10644349635804451, 0.09450147634027939, 0.10471980486340848, 0.11140352757536454, 0.17236303514608298, 0.15664702920771068, 0.18514327111874695, 0.1600469532407527, 0.2009360814333242, 0.18049139596367403, 0.2064335453231716, 0.2205565900144908, 0.16795793914210932, 0.2776632352341284, 0.29077116894571897, 0.28013409708142323, 0.2674016826818034, 0.27730741962962524, 0.27360846027625074, 0.2957817811960215, 0.2874235400603842, 0.29200102018454044, 0.21761466303503252, 0.22574075030142127, 0.21482027767699885, 0.22782695215722892, 0.2126507297457988, 0.20310726695882653, 0.22315384829684393, 0.23676032502881006, 0.2328204733176953, 0.19187124331892869, 0.2019096069207128, 0.18584628628566435, 0.19292085300217088, 0.19539136134921686, 0.18644475715010078, 0.1895671863661943, 0.20229889119748845, 0.1965924492845107, 0.1862448257421142, 0.17432825437634403, 0.18460360474439563, 0.18277020416754086, 0.18300941358526546, 0.19107363725246862, 0.1742503222123225, 0.18198950784341372, 0.1802282276354037, 0.5953854553867823, 0.1908914877905593, 0.5948449986826936, 0.1841438912065555, 0.5044972349797452, 0.18053827475971207, 0.3300196124336705, 0.5970466793220801, 0.4617749002972429, 0.5369428228520057, 0.19520973251594975, 0.42367689617455784, 0.1783960029790702, 0.1854195295246358, 0.19095419658129664, 0.20463010244864377, 0.20126888325688064, 0.20680048265001227, 0.1820660185106765, 0.19884473534504155, 0.1986983099118378, 0.19589757485129333, 0.21675055433191592, 0.1797706718818437, 0.17933297003001447, 0.19971753256246683, 0.19702695140456672, 0.076945913348336, 0.08789283850054386, 0.07197795140811303, 0.07579978308734858, 0.08103530206812448, 0.06647295208472914, 0.06774786675858746, 0.06769954306049952, 0.07729278438288589]}, "mutation_prompt": null}
{"id": "9b572653-63eb-4723-a0aa-b0f7a73811f6", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        self.crossover_probability = 0.7 + 0.3 * np.random.rand()  # Adaptive crossover probability\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.05 * (self.upper_bound - self.lower_bound) * np.random.rand()  # More focused step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        direction /= np.linalg.norm(direction)  # Normalize direction for more controlled local search\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Enhance exploration by introducing adaptive crossover probability and improving local search bias.", "configspace": "", "generation": 9, "fitness": 0.2921062070344658, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.6570981295166849, 0.6594974802956879, 0.6584958390539816, 0.6955610435046029, 0.6716659424180682, 0.6643311184477136, 0.6462896492907293, 0.6818793509487715, 0.677183314837235, 0.4159591185054957, 0.43645541708495195, 0.4337949656895457, 0.3768610208739823, 0.4307763023268488, 0.4268252919382367, 0.44573249758959754, 0.4411382306680982, 0.4492615555407832, 0.09284733902854536, 0.12228819879134245, 0.10761038116874955, 0.1004219062504148, 0.09811074367164763, 0.12448161100107591, 0.10397097376919906, 0.10593429150184297, 0.10083905442700503, 0.09728247276457691, 0.09987842861027496, 0.09264172368055756, 0.09197493740872009, 0.10419610421618597, 0.09913780338943745, 0.09846781861423737, 0.09236270735961849, 0.1026571840574605, 0.9349827923071237, 0.9901800459177416, 0.9137748012883408, 0.9322854001694967, 0.9372583284884606, 0.9418610450610697, 0.94054688843279, 0.9264200817695989, 0.9498982489870408, 0.31084721527071557, 0.2973589978718568, 0.28969447948559235, 0.32908687105292433, 0.28957859675353914, 0.3096456120520694, 0.30402926655119933, 0.3062948216331626, 0.3027363589526355, 0.5039701620960225, 0.5490132610617267, 0.519459843475099, 0.5841787589498337, 0.5871590238458493, 0.5979451339670004, 0.5944120947569065, 0.5500600854037949, 0.6598955964908216, 0.19517484713155597, 0.20581421135213018, 0.22322757000443494, 0.19350672939146074, 0.222184300590607, 0.2763727698484555, 0.22069566832215182, 0.20554004543025006, 0.24442509688312464, 0.16283056485374747, 0.21073210417941857, 0.26051115153771054, 0.1934162374508096, 0.1985590673530636, 0.19805321041629065, 0.1947203362364811, 0.23362488743542043, 0.22916243756531562, 0.13366909611984978, 0.15751350884618698, 0.12363147765113558, 0.16131217318109758, 0.12193860595912998, 0.16243832592639262, 0.1417987375819183, 0.16879468780339157, 0.14597485098150542, 0.2515115839124932, 0.3016404173814612, 0.2633919651985177, 0.30417886048914855, 0.2712169753611442, 0.2411791234938362, 0.27969339317623454, 0.3013318659147105, 0.2774471349970672, 0.03807146756111146, 0.0361706943251594, 0.04157470250132267, 0.05989018569853266, 0.06772811522774536, 0.04781699549632468, 0.02443228762015992, 0.044185214141543305, 0.054675406154994, 0.14928408610018074, 0.172708373533506, 0.16602159901606628, 0.1675722658543195, 0.17186481701263379, 0.19358824820090015, 0.17615941223933584, 0.17622576841416426, 0.16992099439192443, 0.4960014483902737, 0.4935362225927785, 0.5041325118537019, 0.525976016504924, 0.5174628384077764, 0.5003850143714749, 0.4895206972095969, 0.49661878585247754, 0.4953697583297043, 0.08507707535829179, 0.0977623099331073, 0.09236965040325562, 0.09787708695692532, 0.09574818659970519, 0.10100483671763072, 0.08540928485277377, 0.0963890373066899, 0.08669525030727965, 0.23118966165817834, 0.19431920173150674, 0.2514800404357733, 0.1919222285864982, 0.18040322809550757, 0.13903432912991942, 0.15692532869021436, 0.2025325241980931, 0.14449277953982675, 0.29978239120917727, 0.28183497865576324, 0.2975554988578035, 0.26577344915912937, 0.29563355592911944, 0.27860071740392767, 0.30350530945237586, 0.3246433566454775, 0.3171852226501928, 0.2264515026457561, 0.2064165761620268, 0.2220915312571673, 0.21591962846204715, 0.21988320354537416, 0.2235493239953742, 0.23468469012518922, 0.22631618967191092, 0.22945608477110313, 0.17094633285714422, 0.20032926250520366, 0.1900230773836935, 0.20046415724959288, 0.2033064448230396, 0.18406141216820004, 0.19324977142296484, 0.17802595270038568, 0.18746733579696329, 0.19088312777865357, 0.1848703656436974, 0.19847635829105637, 0.1913945869809246, 0.17913997643525892, 0.1939614122708132, 0.18945521888474248, 0.17292555337962656, 0.18414440586712522, 0.6189244683836838, 0.16434363172527078, 0.6039467954424516, 0.4446061523342686, 0.49041785268453175, 0.46866791651702555, 0.4560394790154251, 0.1772020551633695, 0.3984439569114655, 0.4806007245963321, 0.5570537427193925, 0.5452642814838771, 0.2977632850553965, 0.28107009017305185, 0.4034137080352207, 0.20857998461347826, 0.6386815942653796, 0.6582155233033118, 0.18670094689261585, 0.18330212326920714, 0.20790111804533062, 0.18741647886436064, 0.18872733903369066, 0.17740317275943984, 0.19142577093000468, 0.19415697269918208, 0.18784109454346953, 0.07790053458940871, 0.07299909282129868, 0.07097753867670653, 0.08558818632546294, 0.07219567613767264, 0.06762123550067933, 0.08025325165797825, 0.0835473431118684, 0.08211589032953615]}, "mutation_prompt": null}
{"id": "57792b8f-3158-43ee-9bac-ad7143fdd902", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9  # Adjusted crossover probability\n        self.local_search_probability = 0.05  # Adjusted probability\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n            self.local_search_probability = 0.1 * (1 - budget_used / self.budget)  # Dynamic adjustment\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a dynamically adjusting local search probability and a refined crossover strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.2998919729706963, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.6754773944705414, 0.6556840690546976, 0.6386431136788833, 0.7113471497332922, 0.6920036835558931, 0.6995110488351309, 0.6997207661012197, 0.6801361306615381, 0.663997001233235, 0.4412238145937567, 0.4625265783171185, 0.42993539394050617, 0.44499101189295165, 0.43485362840326625, 0.4251818141315975, 0.4567327812891563, 0.4695016706726588, 0.4335367901024215, 0.10270868050919524, 0.11339423337472343, 0.09521193688375129, 0.09265582148645457, 0.09349000835591781, 0.10450314025834051, 0.1152868448470894, 0.10614753177185499, 0.10674205430320272, 0.10307936646387406, 0.09964561382767245, 0.0911153364791617, 0.089483854357858, 0.10060365359056489, 0.08705707867953827, 0.09818297088208017, 0.08122648303186797, 0.09594968860597164, 0.9186232687120619, 0.9209737389627054, 0.8326968790516274, 0.9097919438024266, 0.9470903871896367, 0.907597107983319, 0.9277294362471776, 0.9426216190696292, 0.8853346757446496, 0.30465462263903975, 0.2885013498563993, 0.3209676439949022, 0.302847544087541, 0.35682152116294696, 0.3247713312474627, 0.3319479661054008, 0.3431650815763281, 0.33963768149373375, 0.6446995303080194, 0.5723385750874843, 0.5561184136801272, 0.5597035879153349, 0.5502063288139509, 0.6832487779030678, 0.6801309253222015, 0.683895506322358, 0.6295214628929559, 0.22407262220274293, 0.2375228212207473, 0.24884527275959245, 0.2325779408066615, 0.284973340840888, 0.25070018110816095, 0.2514083479026613, 0.28067796075037554, 0.269905045209899, 0.1951743634343971, 0.23606762868812126, 0.19663808318260056, 0.1844663280071671, 0.20426515270706302, 0.2606145399830141, 0.23361232410574329, 0.25966639808638525, 0.201490000130227, 0.18178199821026608, 0.20677571403703432, 0.19355698530690002, 0.1934978869679489, 0.21703068115691615, 0.20439273125601365, 0.19749083439716297, 0.23861685909881936, 0.2054821590850795, 0.2951425612632681, 0.34403402325753063, 0.3556018818524399, 0.32461541047229847, 0.33131672491774644, 0.31937378874280375, 0.349703886450793, 0.36240697720753434, 0.3769987442465723, 0.07416121015778021, 0.05923477195184301, 0.039862989508520186, 0.09541650783535427, 0.08807800674574207, 0.06379430744292858, 0.07240698177018234, 0.05243750651992052, 0.07000319337037386, 0.1953227702166308, 0.18622183868151165, 0.1923613297458583, 0.1978329892136247, 0.21993510536426975, 0.20965682650818784, 0.18508634995867812, 0.18933749700793834, 0.19130500660446836, 0.5296784832817938, 0.5287053448073786, 0.5157008370250994, 0.5203429600223944, 0.5505768293194531, 0.5579355309878716, 0.5477400440457079, 0.5378886677364421, 0.5416744594912398, 0.09697063021330998, 0.08367917923545487, 0.09009991013278051, 0.10132345463214809, 0.09042294002510243, 0.10912782683512179, 0.08300100901993623, 0.10070512691502931, 0.08708821072379247, 0.21564290175630185, 0.25828926056733603, 0.2441341345061222, 0.21445843222690175, 0.16331779446791517, 0.17455125370322944, 0.15971155676213078, 0.18912709722032728, 0.17422841322033622, 0.29287803011644564, 0.27727229100420914, 0.2989079191049021, 0.2987743866053505, 0.2981998475979354, 0.2806663001810715, 0.320541383532819, 0.31284217604959885, 0.3139996228642751, 0.24020645994944811, 0.21442470971069794, 0.2329110708372274, 0.22870470564653034, 0.21598960253658583, 0.21670911342958477, 0.23933527025184098, 0.22740214319221297, 0.23292695544783937, 0.19161368800655676, 0.18889358642571075, 0.1934504382531359, 0.20510316215013613, 0.18832830690780422, 0.19229450454530528, 0.18323985650206898, 0.18875418500148222, 0.21354108662471072, 0.1875868170265147, 0.1731864293326626, 0.18005320730366436, 0.17112322324170715, 0.19350904125419577, 0.18206602501759483, 0.17578862853590582, 0.1805743991529427, 0.17595013296526618, 0.6077608144975273, 0.17295578494400854, 0.1896934417661541, 0.1662145950949987, 0.47394978711966884, 0.5120337473862331, 0.3099461885738438, 0.5366170604457046, 0.4463368740394732, 0.5379580767899406, 0.6527379148149375, 0.6132333944336446, 0.5546068288430653, 0.18612184557564115, 0.18034778075084756, 0.1997817494841635, 0.20106455088623532, 0.20634058470317518, 0.17791796581875874, 0.18583366857683892, 0.17758126163656196, 0.17097888520194415, 0.2010444937610173, 0.1791198815384405, 0.22299237032257713, 0.19822586786567664, 0.17969423551226027, 0.07805339878523032, 0.07777728050394184, 0.07270065797290959, 0.07093319505382278, 0.07206571199012346, 0.0745845589307157, 0.0790395456850238, 0.07211166112596823, 0.07436107284587834]}, "mutation_prompt": null}
{"id": "72d4d972-46fa-4e3b-a383-6de9a555c85c", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        self.crossover_probability = 0.5 + np.random.rand() * 0.5  # Adaptive crossover probability\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce an adaptive crossover probability for improved exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.2691514132922518, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.6971732117029695, 0.6798083379649058, 0.6577278307211956, 0.6778368358991973, 0.6812536394174762, 0.6928332033071982, 0.6624133522731668, 0.673735435100149, 0.6803941616831728, 0.4569730121633525, 0.4412369307370718, 0.4464955428038815, 0.4014783826710584, 0.4208876736480355, 0.4398046152564954, 0.45961330526310107, 0.4562447282768406, 0.4525661044485443, 0.11037547319116514, 0.11559992281372289, 0.12454819254267335, 0.11080224185605292, 0.11170951094483828, 0.11983773627418393, 0.10855255841864309, 0.10769348244396038, 0.11457163337357212, 0.11283092025064556, 0.10092504392858881, 0.10340962328609893, 0.12176540912788825, 0.0926802087257389, 0.09946801823841833, 0.10410873314084179, 0.10202266309091934, 0.1049651070933898, 0.9610567462411801, 0.942684015264563, 0.9454859367967611, 0.9498249572020042, 0.9410459188517893, 0.9464999297178865, 0.9322003513683021, 0.9508062258480341, 0.9483033250563435, 0.2958079823283899, 0.29343676373078365, 0.2957233597717841, 0.28968967598615725, 0.2704289482085388, 0.2947786808544266, 0.288947918616409, 0.2908152907700461, 0.2897111165554075, 0.4601250288948745, 0.5882299937425733, 0.5580890700101733, 0.532293231250432, 0.5535056355655885, 0.5079509740704953, 0.4314879478666346, 0.36970937813925697, 0.470559041202673, 0.18076877702008276, 0.17795444279557837, 0.16821662111105073, 0.18309848899235415, 0.1846472003236217, 0.2039312498422663, 0.2002514562993003, 0.17047944253912917, 0.2133299258410487, 0.15754053247813504, 0.13674297308454586, 0.16206775198774015, 0.1739598311161259, 0.17746821909214505, 0.15136951504732477, 0.17801835100671815, 0.14111651596295083, 0.19320523502647302, 0.06190106709672527, 0.08363221625536166, 0.0783433687758388, 0.09826234349229312, 0.09814479909282958, 0.0706984229208012, 0.052165549846791115, 0.10953268574704411, 0.058559930666775784, 0.22989773565438343, 0.1770632979478174, 0.21387704025269028, 0.15394475378012706, 0.17143229741260058, 0.18555336648629905, 0.19755345946635083, 0.2382354888523569, 0.25699341724661207, 0.012606819723301133, 0.01989968593984781, 0.01693255781647529, 0.03913519361658768, 0.05787807667650635, 0.02583186867425069, 0.02683329518547639, 0.03931191413816815, 0.01675148869303844, 0.1430694743746872, 0.14222927725633527, 0.13746064061203978, 0.14425390862469434, 0.141019707221689, 0.15051436276181507, 0.14909067100063256, 0.13343222836761726, 0.13464033705812473, 0.4805950871244863, 0.5033187007757483, 0.47433461784790043, 0.47842480821000744, 0.4709037347241991, 0.46796399779791675, 0.49507141687630773, 0.46819984948910076, 0.49002689467676064, 0.09621048206875327, 0.08695707302576516, 0.09578093683278566, 0.1060777299998179, 0.1073090420619599, 0.10848309097676279, 0.09307969460254883, 0.0994633258170261, 0.08718001206594639, 0.15586961864618787, 0.1492209609376055, 0.15250407903311625, 0.14536230135155725, 0.1620856561097731, 0.16097778075228142, 0.18009752776892618, 0.16326116786554778, 0.14006609267689796, 0.2798829508827194, 0.27761177464071485, 0.2678283355252574, 0.27296240196074795, 0.27628601912130857, 0.29703476318023836, 0.3105534624116528, 0.30066335660031995, 0.30123042241913, 0.2117053400014457, 0.20512306587439055, 0.21853458894598266, 0.196535391327751, 0.1888445814662414, 0.18730817408757616, 0.22221483619710447, 0.21354165648491386, 0.22415816846042258, 0.21045607990773718, 0.18007872922833246, 0.17731929436975535, 0.1899816211752925, 0.18886592569201177, 0.17744011088131173, 0.19745758054208573, 0.19254302241790966, 0.20004239438363602, 0.17978583179946794, 0.1866068606585023, 0.18921324588387278, 0.18889728054014399, 0.17713986628500167, 0.18761506608702772, 0.17668253655767752, 0.18022701279322295, 0.18311983084960692, 0.22217507141267523, 0.3445959096221507, 0.4761206537520202, 0.1824486612361288, 0.18051541738404053, 0.5259021247609748, 0.3840650525823225, 0.3128856615087323, 0.43678392244026554, 0.22468489481693477, 0.39371671939934594, 0.29098399963307775, 0.48278961566842005, 0.4868051142032759, 0.3702357051601288, 0.511432850721763, 0.2048152393453514, 0.48216552646701216, 0.1931071522938872, 0.17256411753606826, 0.17912559415302964, 0.1821889918233892, 0.21735654902018908, 0.18149346272507338, 0.1862769534190618, 0.18277001310980379, 0.17827840087887348, 0.07586723192793654, 0.06258820429538459, 0.06833983533095578, 0.07953510481931392, 0.07158694132584986, 0.06833824970211866, 0.08091704472344974, 0.06716356872721185, 0.077378951151719]}, "mutation_prompt": null}
{"id": "1ca32fef-3368-4618-b645-78e2707757c1", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Initial population size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = population_size\n\n        while budget_used < self.budget:\n            for i in range(population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            population_size = max(4, int(population_size * 0.95))  # Reduce population size dynamically\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(len(population)) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.1853377253676826, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.3719738750376449, 0.38030947498828394, 0.3804616917521958, 0.37015977938202904, 0.3709527041553341, 0.36914167679646415, 0.37084120741815785, 0.3743847271923897, 0.3626650616988132, 9.999999999998899e-05, 9.999999999998899e-05, 0.007931138563581075, 9.999999999998899e-05, 0.008079329295160975, 9.999999999998899e-05, 0.005150773989865964, 0.001239117580812299, 0.00041203905502296134, 0.08650344273026678, 0.0817152198011849, 0.09858841298619392, 0.0825252492575177, 0.08806103001171506, 0.07776929264571097, 0.07446042284060383, 0.07923395264112365, 0.10070255948928519, 0.0765554040584091, 0.06085139962978048, 0.06765897822254552, 0.06126484286956724, 0.09680836696729389, 0.08698146772022808, 0.06047816438123377, 0.07498334012565244, 0.07804892127508156, 0.9645434797031055, 0.9640793055297632, 0.9480693378507077, 0.9875928482853346, 0.9784678533023113, 0.9489425442490504, 0.9431049075566759, 0.961159278956787, 0.9483873622762239, 0.1896814340756311, 0.2064987977098527, 0.1957740538183319, 0.196620602676701, 0.18150733984226675, 0.1588209555180149, 0.201593800213835, 0.18596404394918065, 0.21997181721387316, 0.21411318496839038, 0.1953849293063038, 0.21322365376889174, 0.2694372917673362, 0.19912221470375402, 0.24434290382132418, 0.1706420120625628, 0.24560213391661478, 0.24699781943408694, 0.11969745845288271, 0.11093372992461792, 0.11985022669835177, 0.0994642796574422, 0.11861510115361074, 0.11189833268997551, 0.10997238196435488, 0.10610449975926062, 0.12862596748725386, 0.08687092139710006, 0.08402267809757835, 0.06655591286182971, 0.1232756564817501, 0.10740463348520402, 0.11092959546394066, 0.1210106044060758, 0.17632788316618608, 0.11612463742321721, 0.024454982208918064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07960400544443891, 0.07458105733833831, 0.12094363074385961, 0.10604157282852589, 0.08828995310765897, 0.0695325209240133, 0.11672022878497168, 0.0901669103748387, 0.09685637333311603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058277405944831884, 0.04900519391464364, 0.04586706746977054, 0.06071710642618877, 0.057005473377148896, 0.06976638788348888, 0.06058920083776409, 0.07735786905598507, 0.10626018260943382, 0.32733709268238553, 0.3498454656733426, 0.34355794508143, 0.33579507507999506, 0.3225526204896221, 0.3321742736676474, 0.35273749945942745, 0.3311355562460967, 0.3332715920805055, 0.09736459587728186, 0.0880039812390816, 0.07782317806403882, 0.11528368897313213, 0.09982207032012069, 0.09788323731496751, 0.08952807644668914, 0.0895158251413295, 0.09343826236602504, 0.1863469184677775, 0.22076274894842252, 0.1785568336649589, 0.2455162901271286, 0.17950038860586714, 0.1857143120401813, 0.17900261708036325, 0.16225610300793103, 0.17430502125999447, 0.2186449507712045, 0.22640901726271434, 0.25614356047300957, 0.22361749422736543, 0.24521672230039526, 0.22622672543658384, 0.23204830167099877, 0.22189326330932269, 0.23259144863194758, 0.13129470900985174, 0.14403955667828128, 0.1592771426575973, 0.18369624432220444, 0.15587839738740328, 0.1566504839639924, 0.16898735004089083, 0.15733523639143965, 0.1707597594387955, 0.19048554069631896, 0.17162060823689496, 0.17494098052318918, 0.1860859082232703, 0.1713693324400678, 0.1736412060073642, 0.2247839613948971, 0.20175160293363237, 0.17139264939355803, 0.20915973784380526, 0.17155009123552878, 0.17900305727031895, 0.19458894018620698, 0.1673128379076788, 0.17860124949304956, 0.17371857027738002, 0.19446344858543385, 0.18158655778968658, 0.19863170660994167, 0.3036462078546446, 0.38798433657193765, 0.44209781619971933, 0.1845031991146283, 0.18537098175033606, 0.19104642000467797, 0.32611771143429746, 0.1751822043473632, 0.2643507897858244, 0.24567075626065482, 0.24327813528360587, 0.1989112476697532, 0.26282844920522586, 0.16386377306415556, 0.20489765113176017, 0.37271290796587464, 0.20630709280204662, 0.1883438168760998, 0.18927039836866622, 0.185130130507554, 0.18449969537019195, 0.18268337853472572, 0.23403535073559822, 0.2058330136925538, 0.19254297911565488, 0.1883563229424844, 0.06623709068317785, 0.06687774145843428, 0.054505234756818566, 0.07708018984906373, 0.09264202939652766, 0.07790237141119538, 0.06381169019844912, 0.06903702072690954, 0.08260032970623776]}, "mutation_prompt": null}
{"id": "3f5bfd9e-d437-40f6-ae29-efc74b19af2b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adjusted step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Adjust local search step size for enhanced exploration.", "configspace": "", "generation": 13, "fitness": 0.3104334902897256, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.6417411722541437, 0.6688214977187814, 0.6516054949108359, 0.6331531125019951, 0.6819233909116826, 0.6646672892618419, 0.6447232387051745, 0.6486913672410449, 0.6485901890450088, 0.41438092620318834, 0.38542855318053293, 0.45692518760045364, 0.41917492557991376, 0.3872287982089069, 0.40690657707104694, 0.4309217657507911, 0.4025123106161984, 0.4036599388097287, 0.1012476636462245, 0.0990026646308173, 0.09202731163913891, 0.10254697582631611, 0.08839698516223471, 0.10520610738075753, 0.10066900027416015, 0.09712176575238829, 0.09602776359972864, 0.0850189880551876, 0.08360678856462855, 0.08445063895190474, 0.08730425210775483, 0.08404736974821803, 0.08518332206963153, 0.08070394637617917, 0.09254273627566512, 0.09303060329245472, 0.8566530358038325, 0.9153987479167507, 0.8313466521795588, 0.9875928482853346, 0.9361184599803638, 0.9134280015872152, 0.8810945246059774, 0.8821819410522014, 0.8762195043510962, 0.3262560491661468, 0.29512045849927915, 0.31784191236524717, 0.333467853037692, 0.3198849976847342, 0.32073786441785923, 0.31770777408570905, 0.3291087876674639, 0.3460112299954796, 0.6246378084159729, 0.6672704544767494, 0.5491608026259109, 0.6427821290975319, 0.7265461857289699, 0.6581969725732915, 0.6198776857033199, 0.6706614412037774, 0.6486777130176498, 0.2616414176531262, 0.2228848462516103, 0.30099298656298357, 0.24405891324764983, 0.3026682222491869, 0.24006287553307182, 0.25192659148424523, 0.2683623383200744, 0.3007849062934782, 0.10000506717069169, 0.39117278175625003, 0.18021302279168416, 0.25621300824599513, 0.3114291915005475, 0.23418412662253862, 0.28221764275732253, 0.3129682839317296, 0.22662721038926192, 0.25247460020829315, 0.26625814358027255, 0.3110560897982718, 0.26612877573857596, 0.21700560873484342, 0.2973266924610243, 0.2670048246893263, 0.2547456796775881, 0.2632819970110205, 0.4160851435241123, 0.4079823508615996, 0.43080851736317505, 0.37449214844963785, 0.38213823955595083, 0.37116029246833193, 0.3940814337096902, 0.41092907416279856, 0.4041057476763802, 0.09800173999787509, 0.062262504695482, 0.10058370372578651, 0.12463245204146134, 0.10899691357276153, 0.06544205184408114, 0.07778693524466651, 0.11386593623328112, 0.09190410373102409, 0.23048298801013012, 0.19935169408270348, 0.21929806502912297, 0.21562536028199197, 0.21141972866367398, 0.2147073032989708, 0.22282783493598413, 0.22240208154749164, 0.2110267528874219, 0.5624619268733551, 0.5681758996682996, 0.5518606815980972, 0.5825384013418515, 0.5499513775587804, 0.5703017196134537, 0.5377269419914684, 0.5429487644187564, 0.554874306447485, 0.09001201429499484, 0.10191996634450806, 0.09562911416894437, 0.0974682789107576, 0.09953499372894781, 0.09502298224065175, 0.09379759925082765, 0.08727542880630135, 0.07955123932391439, 0.1537203953966385, 0.17980585448456132, 0.4194811685505071, 0.15736786771907174, 0.15601958348912215, 0.20423365323754783, 0.18955044238170604, 0.15407597029972075, 0.151310287835541, 0.28868060554979, 0.3005023082438082, 0.3009859735263922, 0.27561770412608555, 0.3043252928702176, 0.3068716088674429, 0.2914810909383546, 0.31706436642198055, 0.30831279428834346, 0.22634826903193928, 0.2535504638236208, 0.22838669411376344, 0.22629812578388497, 0.21257411770581958, 0.22583665582271217, 0.2535446194940555, 0.2621833322127707, 0.25115004807698127, 0.2063716741455608, 0.1867156159322504, 0.19104647056021762, 0.1934264813669121, 0.18209590075324045, 0.19978722507005264, 0.1851674564553928, 0.1729865283817067, 0.2021116814718248, 0.1824233590224762, 0.19101317590172873, 0.18233718851871983, 0.17700749645690794, 0.18621209441592879, 0.18185665074277035, 0.19143893214850627, 0.17620174054474025, 0.1801095192814386, 0.14762115091047912, 0.15144054697738962, 0.6715702394906728, 0.6647759809047334, 0.6040342535559768, 0.537678806572957, 0.38149097147740596, 0.5006736299301701, 0.5753564592419036, 0.5076873605949013, 0.20016236215560712, 0.542146891145221, 0.33223854491698035, 0.2816038347872717, 0.5775531494351882, 0.20735310616474534, 0.2043491512395823, 0.21001229882194328, 0.17945312931595658, 0.1905369052482253, 0.18599131081564568, 0.21631954043073343, 0.21668913030609593, 0.1763074156814307, 0.19403637379527094, 0.1772491424506556, 0.1886885754047064, 0.07642886171013419, 0.06943008600548617, 0.07049796328440339, 0.07852051017371708, 0.08033910386314658, 0.07771468483802124, 0.08393296340691236, 0.07492791411782396, 0.08091203465905705]}, "mutation_prompt": null}
{"id": "b2c45036-db0a-4488-89ce-875cbb25d814", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Enhance the self-adaptive mutation strategy by adjusting the mutation factor range for better exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.36929343019734717, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "63c2e8f5-a646-4379-814d-0773bbed0e1d", "metadata": {"aucs": [0.7334040297316378, 0.7484757041979642, 0.7408398304863367, 0.7560931755131878, 0.7632979017262753, 0.7353379131812182, 0.7358161496973235, 0.7501484178863411, 0.7499934893903804, 0.5512719101785779, 0.48772924458982625, 0.5250652125379194, 0.5362569661125998, 0.5475294712479029, 0.5636282528929866, 0.5505718674983131, 0.5542401772049229, 0.5622575256510483, 0.10628957304228082, 0.1057015776370217, 0.11501388930510659, 0.1178944246707575, 0.09859617448531588, 0.09766137425535837, 0.10275867033308517, 0.09127996247798131, 0.09990333621917669, 0.08701008612472905, 0.09941005161727112, 0.09891679094713512, 0.08649431231780724, 0.10018109496401106, 0.0917243510658804, 0.09320971536104572, 0.08394233003485951, 0.08400086860951339, 0.8803175909225468, 0.8672245283635893, 0.9423811088118115, 0.9875455489323586, 0.8388757414465402, 0.8330235944739292, 0.9198144534415768, 0.9348751969529276, 0.9266990154814978, 0.3930502118724406, 0.43269502234350044, 0.41525284001742024, 0.4003184484368454, 0.4088901756195191, 0.397741931052751, 0.4242531831949915, 0.4339936036792771, 0.4090744321569114, 0.7671043868036831, 0.7907894273039464, 0.7056920061047793, 0.7850671967274141, 0.779477618989998, 0.7241731953213109, 0.659887603724723, 0.7703006132072088, 0.7286222079135544, 0.34022294506312023, 0.2599831330763358, 0.3579674273920743, 0.31841488370885884, 0.26905459212088956, 0.4282888915149923, 0.41925321978096586, 0.3898248094135671, 0.32671234344600864, 0.5432578154709886, 0.32382270245655964, 0.25441818065155597, 0.3994068417663691, 0.4248942447990641, 0.41207339973854085, 0.2729916027867034, 0.3938131277611654, 0.3566747103930088, 0.37201163273358195, 0.3925373321518545, 0.41589003808778846, 0.3340906276873773, 0.3978389646101047, 0.4164694579930237, 0.41402635280507905, 0.4451169725561359, 0.3791137811029929, 0.5410956174884877, 0.5207422900126394, 0.5671809426092478, 0.4910753415643615, 0.5522656259197916, 0.537164900830299, 0.503729195355183, 0.5751918742397512, 0.5491571836375219, 0.081124901856515, 0.15386149654248815, 0.10699214357855291, 0.24756432515164173, 0.14647610387351329, 0.2328178363846677, 0.156486394964383, 0.13733403645630027, 0.11897658256139898, 0.3442031613139209, 0.3144705286966365, 0.2709493493275352, 0.28936857705163155, 0.27400396348503575, 0.29968906190328615, 0.2918185382136096, 0.32096251523106367, 0.3137561183165001, 0.6684483034623734, 0.6588714958245863, 0.6776873956743048, 0.6742302887242475, 0.6583673922973132, 0.7002381148222433, 0.6880607217181691, 0.680956884275368, 0.6590608708826717, 0.10048563503724639, 0.09953902506807366, 0.09719026470247283, 0.08976992140503082, 0.09826275547599073, 0.09795074277824256, 0.10616753720394878, 0.103934632100939, 0.12153217467150823, 0.1669555489680461, 0.1778454563082601, 0.1987398572999578, 0.1843544793102505, 0.1475313330866218, 0.20451427457522242, 0.15298310766504386, 0.13822946169093575, 0.2648316829782281, 0.376810402537218, 0.3529494200345493, 0.3711195519375239, 0.38118883660677116, 0.3761702930061014, 0.3651442649820923, 0.3650598742851613, 0.36635471657354746, 0.3796658012760725, 0.28114298909304325, 0.2771875297787586, 0.31356647971860285, 0.2765704380902264, 0.30277851337154993, 0.286365578817671, 0.3121084497299609, 0.32480943772371895, 0.31584483502592, 0.18987321744704033, 0.19033126078476803, 0.19753543240063764, 0.18410905378902676, 0.20459441670237166, 0.17855367071168726, 0.22828228721176236, 0.20874005513564942, 0.24101340673413807, 0.18670051448225022, 0.18242144075969657, 0.2030370013655075, 0.18511604958140193, 0.18046192173335696, 0.19322615112634434, 0.17955969537940053, 0.20195643813566388, 0.18698885876615923, 0.6771548001036904, 0.16513070874996594, 0.19440560959251363, 0.18162915622957176, 0.6970564240088606, 0.7407750008411211, 0.7158914207497222, 0.4872901230434864, 0.6920926749251259, 0.7625643255807121, 0.7085161774848472, 0.5373586640753888, 0.20148300377168082, 0.2003498449746427, 0.7135779266803302, 0.20811870487119466, 0.20585120187256167, 0.2026587827780444, 0.19449512036175987, 0.17812200136391199, 0.18511054624587941, 0.17250258262397022, 0.20275673945919104, 0.18438051242417985, 0.19767354938921455, 0.20624040181826342, 0.17926638387577187, 0.0830165225961027, 0.07376653032197045, 0.07205251099097676, 0.08062054630652205, 0.08157422973017037, 0.08636320698439026, 0.08079787746609834, 0.06848294149742373, 0.0784611818702573]}, "mutation_prompt": null}
{"id": "2361bcad-7f2f-4b83-9fe4-652770168bab", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            avg_fitness = np.mean(fitness)\n            self.crossover_probability = 0.9 * (1 - (np.std(fitness) / avg_fitness))  # Adaptive crossover probability\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce an adaptive crossover probability linked to the average population fitness to improve convergence.", "configspace": "", "generation": 15, "fitness": 0.28473276502348266, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "b2c45036-db0a-4488-89ce-875cbb25d814", "metadata": {"aucs": [0.7079330511558403, 0.7509864017613392, 0.7429592553826964, 0.7380510526748709, 0.7454456933631393, 0.7461261567720945, 0.747059990537085, 0.7310870867966759, 0.7586686775313061, 0.45861374812025446, 0.44002001905921406, 0.45981928745762957, 0.4771084749567944, 0.48548673404004783, 0.4564191596545579, 0.49663429833980366, 0.4705446799447577, 0.4989468505626423, 0.10371845577987715, 0.11898883690841489, 0.09719644499564362, 0.1030514298132661, 0.10395872352193913, 0.11106819337970542, 0.11503844855263412, 0.12340411820330521, 0.10902992864926453, 0.08965183569391943, 0.083175810045785, 0.10954756392590426, 0.09929522666437673, 0.10628808197562334, 0.09704319090686109, 0.1447407950139239, 0.10859039951375693, 0.10727985012463814, 0.9400232089054062, 0.9466948143870784, 0.9467117321437969, 0.9695497033350906, 0.9253202801958877, 0.8515150992855922, 0.9571758771971753, 0.9581646365426756, 0.929656188917464, 0.30496665918431376, 0.2223342348645443, 0.3104961562291212, 0.299466468332072, 0.299050700712887, 0.3081162395103004, 0.3311580907779108, 0.3252620355298813, 0.34420305659147765, 0.6336131006724159, 0.6806612036100486, 0.6717271230294066, 0.6207232039990768, 0.6120475391624312, 0.6450740910018585, 0.303861762567181, 0.2025279064379315, 0.20326339139262295, 0.18540758231837384, 0.14078263042992079, 0.25442018041868586, 0.22430629450753314, 0.3161008322878762, 0.11859378820772948, 0.22297565181622025, 0.1925675190115389, 0.20063311974958586, 0.11024499571061586, 0.1283319262944218, 0.14232060265708402, 0.12120191908063571, 0.14144550042046578, 0.12228889711463709, 0.12585653014063047, 0.1174137666147339, 0.11370644130610563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08266391288044617, 0.05250061381220006, 0.09402171611009635, 0.09484977875200096, 0.046193856759369156, 0.06995930449375265, 0.08574510272243896, 0.1000343126942711, 0.09229288426135918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010823813943656946, 0.19565070764739334, 0.16893304389137886, 0.2103627758919363, 0.13621024023338468, 0.1913880901092706, 0.1817523686374749, 0.21613382819822735, 0.24960125323565685, 0.22476535533502473, 0.6031459011323469, 0.6102894650454388, 0.6239273796102911, 0.6061929000706205, 0.6137020724639436, 0.6156926654578885, 0.6117197561711671, 0.5792635904221712, 0.6699034637759802, 0.11475626666769334, 0.10052419171197058, 0.1029526126430359, 0.09283422541447528, 0.09720009253103057, 0.09358697032479868, 0.08826922738568332, 0.09108780739685551, 0.09233998559518097, 0.157492345208315, 0.135291789209675, 0.14984326433410555, 0.17695012090188378, 0.167260820654338, 0.1792246239269465, 0.20028637874010702, 0.13614754356959435, 0.16606438588623373, 0.3253123025163902, 0.3192736314774458, 0.35567303612697276, 0.3598482265043764, 0.32902265571421574, 0.3254775392160728, 0.3650116243894207, 0.3715917340421555, 0.3797603919361504, 0.1892972274842185, 0.20071387896632154, 0.21476997845924706, 0.23612011489924467, 0.25604289028299476, 0.2629351985622077, 0.2928687843485209, 0.29044235510138205, 0.275048149649601, 0.19961992079266588, 0.20747465539916043, 0.1970924259411082, 0.1945723248013076, 0.18230734940998716, 0.19490695932275537, 0.18869773268055146, 0.1880104904793085, 0.18342106000081593, 0.1897313165354403, 0.2001316049684, 0.2287402844497567, 0.17359492851617253, 0.18040229601786673, 0.19926615653402813, 0.1924051129445381, 0.2071789408951864, 0.1858231690204618, 0.17119379161616433, 0.5520702154237422, 0.7402464293192381, 0.3184152116443113, 0.22231956360409855, 0.2863466774492639, 0.5753427440730079, 0.526155559304041, 0.6331306997832378, 0.6974305596141803, 0.6740337529360463, 0.5265324280453618, 0.6074045337635265, 0.5537050707304628, 0.6709144037940674, 0.1980132775350849, 0.19727240467703455, 0.20215891361219107, 0.19468546146952048, 0.17523086915402786, 0.17784952010670219, 0.19013592631652054, 0.17423004525650831, 0.1870373681642683, 0.1756187016712334, 0.2063646892395008, 0.18487797489657076, 0.07875894623770419, 0.07813707065578968, 0.07691974125246348, 0.07935151960147324, 0.08252993782295848, 0.07205834533508426, 0.07738107672378991, 0.07340006120684739, 0.07596386440663916]}, "mutation_prompt": null}
{"id": "8ee4b5de-3dfb-483c-a99c-a476c4df2c4f", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability * np.random.rand() or j == j_rand:  # Stochastic component\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a stochastic component to the crossover probability for diversified exploration.", "configspace": "", "generation": 16, "fitness": 0.24309568144438223, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "b2c45036-db0a-4488-89ce-875cbb25d814", "metadata": {"aucs": [0.7477708352642101, 0.7197369463847068, 0.736593382690794, 0.7267227611570426, 0.7379613512333522, 0.7331419533773929, 0.7404333240339895, 0.7411470907915303, 0.7304566390061491, 0.5035155207767584, 0.5186053783542393, 0.5247850566893933, 0.490858636111723, 0.5207796375674634, 0.5406060781328692, 0.5261680135314672, 0.5008928278247231, 0.5118441187916494, 0.23511000581918462, 0.24203903312901198, 0.16074742253916197, 0.13749669700836153, 0.19084232304404625, 0.1372648051220956, 0.14946735250855459, 0.18586055562150727, 0.15682277027299873, 0.15965479228320456, 0.13489448287726047, 0.13255257355686623, 0.1628796267468191, 0.14101418878272287, 0.13759681419353653, 0.12389643665187178, 0.14237122848780293, 0.12241966022368489, 0.9452312086258111, 0.9520792412397913, 0.9403215929522539, 0.9383697146906071, 0.9533941634714621, 0.9424881627294461, 0.9525288612485123, 0.9533479869892734, 0.9529188763835257, 0.26315044707607094, 0.26178795116084086, 0.27207383302482624, 0.29182368156985516, 0.27711835076841485, 0.23644345637460484, 0.2629586624850654, 0.28243611511568567, 0.2651105042821681, 0.2499547407549323, 0.2294497151221242, 0.2497763578262301, 0.2519044694001469, 0.267406136836173, 0.27425200745095224, 0.25137089058057904, 0.23940103775241206, 0.2903761835497669, 0.1380350842178495, 0.13348318531132974, 0.16118684126220595, 0.1404463986526624, 0.1385060531602278, 0.15620090992651237, 0.14772915328259517, 0.1621140446756668, 0.150170897883926, 0.131171428577597, 0.13380763731887824, 0.16106108541746, 0.15440967029173225, 0.1566632976527531, 0.15446767854175436, 0.13451124704262696, 0.12443394823197629, 0.14143229446824357, 9.999999999998899e-05, 9.999999999998899e-05, 0.00037554118253735336, 0.010710987224301971, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007751590078812765, 9.999999999998899e-05, 0.0734379825681879, 0.10225731993825071, 0.09346315564106322, 0.09445951653337181, 0.070389276683125, 0.06892207751317014, 0.11231516688022458, 0.07595581337033619, 0.10731010478606418, 0.001125485935831616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009104523179854773, 0.08437112883546682, 0.09409150592683724, 0.09396602983656999, 0.12289637634865791, 0.0999938912186521, 0.09628896691433397, 0.10223120744732572, 0.10642919980853072, 0.09931378441206795, 0.43665184275814684, 0.4424449205488339, 0.45178536674044567, 0.44492522132473455, 0.45475770952943995, 0.44918857587875494, 0.47061271154985573, 0.4459244890583933, 0.4476588093201973, 0.09329104723711612, 0.09159226330572146, 0.08605796617010508, 0.09101787606046896, 0.0907373910591236, 0.11763807064525045, 0.09899383203140988, 0.09525833609228485, 0.09416549236879113, 0.1507417378162128, 0.15917184154606145, 0.16194086023056697, 0.17824517646441274, 0.1989884609664465, 0.1954799449801261, 0.1455891507803666, 0.15650903780836067, 0.17237086480652564, 0.2701719707969895, 0.2698262483377105, 0.26564681557296166, 0.2777939409918354, 0.24948519016389625, 0.26025233311215645, 0.29512735200171425, 0.31837840331495815, 0.29442859517825093, 0.18242490658188248, 0.1821941533614828, 0.19810758657403327, 0.17776700562135372, 0.17070827642301667, 0.19193173144779896, 0.2068868910924051, 0.20642359908797936, 0.18451999964668597, 0.18483046493707, 0.18245908550536438, 0.19966801393637856, 0.17220277228674308, 0.17465546373384622, 0.19632479286321136, 0.1893995100354332, 0.1867984179597435, 0.21555341234025527, 0.18513502024630957, 0.1995460108552155, 0.1958706236844442, 0.1997453659126326, 0.20258437890285064, 0.1965755935028698, 0.19350990681967128, 0.2139933383415663, 0.20525044195142883, 0.24176461222547574, 0.16260990109560403, 0.2044238192253235, 0.47578099760350445, 0.34197137153818746, 0.22013591321659842, 0.21103968431449316, 0.1910725709434109, 0.2746494428662629, 0.2003735143408435, 0.19531869529593804, 0.19170213004716818, 0.25586016529890654, 0.19930178262733966, 0.21186818526059237, 0.21109698407950162, 0.33782261019247106, 0.22461377138543626, 0.18260504076310968, 0.18258727823415577, 0.1893492829033877, 0.1721743607253966, 0.18454807721704014, 0.18569086127464152, 0.1948814484175051, 0.18089424303853896, 0.19530172596645612, 0.07790015569867448, 0.07290577510844287, 0.07291574248522559, 0.0738716050291589, 0.07612560424597559, 0.07574782354654452, 0.0654465479067683, 0.08179109756042457, 0.08086803294944511]}, "mutation_prompt": null}
{"id": "43f27a7e-5fae-495b-bc2a-097bc0cb7731", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                self.crossover_probability = 0.6 + 0.35 * (budget_used / self.budget)  # Dynamic crossover adjustment\n                \n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduced a dynamic adjustment to the crossover probability based on iteration progress.", "configspace": "", "generation": 17, "fitness": 0.2953072790814919, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "b2c45036-db0a-4488-89ce-875cbb25d814", "metadata": {"aucs": [0.7255045742819934, 0.7311783134075638, 0.7282030670047115, 0.7400311520969449, 0.7429790694583098, 0.7332860084198187, 0.7367832018027328, 0.7382214211626332, 0.7346603136809446, 0.5327939992419135, 0.5482029463964033, 0.5096682390017278, 0.5258331573856054, 0.5546899058641993, 0.5450156180150956, 0.5254890123143476, 0.5265805255877691, 0.5680296937030129, 0.11518354192293478, 0.1110066592160629, 0.12602584928563687, 0.1271036208906624, 0.11420523208356148, 0.11075963026345614, 0.11091071143245024, 0.11209714784152058, 0.12550045205010607, 0.10072744132662215, 0.11408291218691757, 0.11644184118150247, 0.09981306298839265, 0.11484567083358654, 0.1033546493319425, 0.11442018605598114, 0.11338086491925892, 0.10582711302428871, 0.9699526082991965, 0.9180130902682886, 0.9248864864246118, 0.9334793295945948, 0.9142701119792198, 0.9516938627929039, 0.9536563383050002, 0.9522802857437611, 0.932891311866632, 0.333069157870186, 0.318105304039202, 0.36549406027085674, 0.32872739554450314, 0.3478643395658919, 0.3723181691928661, 0.35033010874257975, 0.34495698746666026, 0.33585974623415327, 0.48062832926098376, 0.6019362578340257, 0.47313926281921515, 0.577921175105006, 0.5800141448737277, 0.5900574960081455, 0.599055228268214, 0.47820700418054285, 0.5329906688576616, 0.2164286820823763, 0.17471446060880313, 0.20450253491085535, 0.20921457555151357, 0.2050680259844514, 0.2256989226814341, 0.2210717776534551, 0.16605672011615202, 0.247016843612327, 0.1808840467792584, 0.2526685056817348, 0.2085094147473464, 0.24732355592427868, 0.27392004029197115, 0.2502680765013129, 0.19869140282887543, 0.20391315264248355, 0.18473830595233043, 0.122785024282003, 0.10304688887874092, 0.10328281476369194, 0.12638382357455025, 0.11610576182789156, 0.13118622495887844, 0.11615791957975452, 0.11129680301348632, 0.15526198440626104, 0.20582031223731878, 0.20938704219451576, 0.23640176823375336, 0.21536681899350218, 0.21895163789067873, 0.1915456113322761, 0.29378714310469844, 0.2417109782139586, 0.27807717666830734, 0.07674190464166752, 0.056076719575896106, 0.03731765873441795, 0.059181872351092846, 0.06018076674449491, 0.05935147413631714, 0.0677921691918274, 0.03795155344692047, 0.08387424586489556, 0.15798127421831565, 0.15835085171899277, 0.1726850757109476, 0.1845067522868883, 0.18920889411507613, 0.20727470721711838, 0.16985325938312856, 0.16815658954628432, 0.1887279841644265, 0.5178156833361843, 0.5200149400376267, 0.5620223294734148, 0.5612381703527831, 0.5149033045993751, 0.5359312760016375, 0.5523362936275524, 0.5223483172695087, 0.5405276215862245, 0.08587185903797867, 0.084105615276732, 0.09950661328208732, 0.09482197367643408, 0.09416430412337873, 0.08478683614936633, 0.11074819786737278, 0.08319237792149947, 0.09823996319325523, 0.15758734185236045, 0.15614981095890668, 0.17633902224154718, 0.16049865992503487, 0.16997380118605165, 0.16009223175305254, 0.1548471732439457, 0.15453618524260349, 0.1790382813617003, 0.31392617304269066, 0.29591691821170485, 0.3404572062743534, 0.28845292899895314, 0.34631643079151797, 0.3234134108576643, 0.3289302034236796, 0.3600139248086096, 0.3519430207793405, 0.2285520729067343, 0.20636316075994576, 0.2304395926747309, 0.2198357400718759, 0.22289012823104304, 0.24131012036741373, 0.25263345960836037, 0.24717121035280065, 0.2557887957150341, 0.20056058759654039, 0.1993798293339425, 0.20776946951902697, 0.1929201889323593, 0.19677616307975176, 0.2012941937107906, 0.18354345852787024, 0.19742822882604727, 0.1913375682838191, 0.18111792153182515, 0.1806645973980523, 0.20040466223623465, 0.19821213099826507, 0.20023799852355917, 0.2219283263195886, 0.18607589353550325, 0.19768503493567358, 0.1874105082651315, 0.3229609514766082, 0.5274639790058927, 0.4461547918086355, 0.38477422418450324, 0.22795543038606725, 0.240707843433556, 0.40750990762435835, 0.374700671295049, 0.454030233618241, 0.5475162406692069, 0.4309491585422571, 0.443838719530128, 0.31073768642471955, 0.19257328530823048, 0.4683159192402421, 0.19497933322177252, 0.42923813460732263, 0.18925110260947642, 0.1816017667073927, 0.18070910841026144, 0.1820798865402964, 0.17412735577018523, 0.18399306903072976, 0.18414554254457172, 0.18180972648591476, 0.20622064188309785, 0.19195527790883526, 0.07478270899123785, 0.07588399967745285, 0.0696270839628218, 0.08193483030557613, 0.07808864843537466, 0.07584717399878826, 0.07899103514233752, 0.08208716064610888, 0.07099660934378005]}, "mutation_prompt": null}
{"id": "259ffc5d-731c-4311-b32a-df08752cd00c", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        self.crossover_probability = 0.6 + np.random.rand() * 0.4  # Self-adaptive crossover probability\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a self-adaptive crossover probability to balance exploration and exploitation dynamically.", "configspace": "", "generation": 18, "fitness": 0.3159790677512305, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "b2c45036-db0a-4488-89ce-875cbb25d814", "metadata": {"aucs": [0.7357504887837467, 0.7377478063009342, 0.7669252375982767, 0.7281738187531523, 0.7290066749147478, 0.7229663677950504, 0.7513241211611024, 0.756983780933629, 0.7312838881101101, 0.5436214125687349, 0.5326937374796861, 0.5279620443533806, 0.541139200407069, 0.5245406647674035, 0.545374983643949, 0.549630461023501, 0.5288829097642234, 0.521183774336424, 0.11216892184834104, 0.11998570867785396, 0.12680629614933991, 0.10826042302256644, 0.12337069499763897, 0.11811159144041139, 0.11872286020045997, 0.13098371698857159, 0.12137582596406715, 0.10087630540360837, 0.11155174833930104, 0.10756255292116235, 0.1011182635839456, 0.10427018357891049, 0.11476195830381841, 0.09998838834797075, 0.10539781791850111, 0.11186129079679319, 0.9515328892182607, 0.9468493827391092, 0.9275188455964204, 0.9340549672104643, 0.9356733606076609, 0.9121626639008094, 0.9628609327109665, 0.9340192056663297, 0.9124505944631247, 0.3706020057945827, 0.3242856000487768, 0.3104461950810745, 0.3881535181159217, 0.36717249034301724, 0.3402425619778765, 0.39839296251330847, 0.37699322766937804, 0.378168422598368, 0.668155709718187, 0.6437202185481308, 0.6029384849455461, 0.6858259783640017, 0.672595206217802, 0.5813696663505632, 0.6414434428641342, 0.7106507362015235, 0.6399090907350811, 0.18597391392946183, 0.19286611045139945, 0.22469776731831148, 0.21717601749410198, 0.20164279399501894, 0.18584302342171555, 0.24219454008959151, 0.266287288231597, 0.23759737129419967, 0.21553417709658373, 0.12166179006724365, 0.1865843995940265, 0.1552200822616172, 0.20353406944012176, 0.28705357141797916, 0.17993481314965176, 0.18653029733903648, 0.2459463596683955, 0.21970243914790355, 0.16242468399652932, 0.13975693694812763, 0.1894513339966466, 0.18314685256705798, 0.1955486611197308, 0.1768370531600213, 0.16324040084080038, 0.18491762585166804, 0.31836243960763244, 0.2803517547711606, 0.33539489965167946, 0.3298497789452448, 0.2994763285180092, 0.31332787854577127, 0.3383372849253623, 0.3212052280210369, 0.286980684342399, 0.062328248480413406, 0.0683493182660403, 0.042007390837239145, 0.10446143138435238, 0.08296103860837556, 0.0879897472159471, 0.06671289820988224, 0.07400290032442058, 0.09196867138981812, 0.19472528088038898, 0.20729386245406023, 0.18215007439696862, 0.2093072680319712, 0.21800784266743933, 0.2123984610939088, 0.19113463782517315, 0.1974211738275511, 0.19376459148439318, 0.544219103938635, 0.5973173576948543, 0.5847153270097137, 0.550121654133539, 0.5522266763335224, 0.5742103294318092, 0.5776848322503065, 0.5491254496212619, 0.5504414117694778, 0.09227055615337088, 0.0941068982853498, 0.09417797957969087, 0.0940243712314861, 0.09544786789799342, 0.08763927179350317, 0.08823881589837634, 0.08396300509375254, 0.09307750217159205, 0.2031866721762603, 0.197739529029744, 0.16478907796467246, 0.16108513931126, 0.1662730184410457, 0.15861790105341844, 0.15477752084193708, 0.2321620062431089, 0.15858243210831513, 0.3412692645266957, 0.3186641498482673, 0.3391418634250596, 0.3247759335385013, 0.2993489986287925, 0.3237266246116034, 0.3662015698777005, 0.3752347539259082, 0.36640662584851713, 0.26049121326085034, 0.25234899847922787, 0.2314260461373493, 0.23420386662441783, 0.2627576313432447, 0.23759260870541277, 0.27820402376692777, 0.27014478510711126, 0.2685744604230429, 0.1798039728907681, 0.17178580149652467, 0.19126722155841502, 0.18064652099975065, 0.20932675690761515, 0.17365036153734925, 0.1851293115274496, 0.20175830704628572, 0.19572085187671295, 0.2127858253578745, 0.18784461140351294, 0.18954493577661502, 0.1923640000282757, 0.18959785670121698, 0.20084118660815498, 0.195052477300505, 0.20279185178377923, 0.19216770572035236, 0.6159345362595714, 0.17540714690169368, 0.33197111844538363, 0.6375171785498366, 0.5258860866501651, 0.5861052049319407, 0.6018397112899767, 0.44752697604382796, 0.35547717878507257, 0.49208583625054403, 0.20015081448206307, 0.4163312390094236, 0.5543752338272194, 0.3186025446081997, 0.5512602586409004, 0.20733635449181942, 0.2086723400716668, 0.6606710944813413, 0.193464322701681, 0.17620626825050845, 0.1976035842078847, 0.18317638782537637, 0.19217156013121584, 0.18157267439731173, 0.18379060586399543, 0.18946734740213933, 0.1724695841155408, 0.0727703900725879, 0.08384221780669465, 0.07408643449764163, 0.08134718686135767, 0.06786740965995419, 0.08133927139991082, 0.08573322750683876, 0.07486077329071761, 0.07761408252203161]}, "mutation_prompt": null}
{"id": "723e7eba-ca9b-452e-91c1-417a5b95b400", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.7  # Adjusted initial crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    self.crossover_probability *= 1.01  # Adaptive increase\n                else:\n                    self.crossover_probability *= 0.99  # Adaptive decrease\n\n                self.crossover_probability = np.clip(self.crossover_probability, 0.7, 0.95)  # Bound the adjustment\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Self-adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce adaptive crossover probability to balance exploration and exploitation more dynamically.", "configspace": "", "generation": 19, "fitness": 0.28327922558745905, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "b2c45036-db0a-4488-89ce-875cbb25d814", "metadata": {"aucs": [0.7111463513340022, 0.70807761237623, 0.7510519109004088, 0.739475520787076, 0.7311930172376908, 0.7508949283848226, 0.7488524395879974, 0.7327569000058054, 0.7219485516100741, 0.538199582178457, 0.5371665724243848, 0.5184104351441895, 0.5196986000927396, 0.5385807024829524, 0.5414776235251124, 0.5223389187818106, 0.5213556413216347, 0.5491924868383464, 0.12296138929514833, 0.13620985859367096, 0.12125484186105917, 0.12599511292785426, 0.11750322128364787, 0.11678626788150337, 0.11004816954983743, 0.13077928807739825, 0.1167083629711193, 0.1141237743555068, 0.10580032137207385, 0.11440104778902516, 0.10209754909184143, 0.10749501132593486, 0.1029376108455814, 0.10314900148883388, 0.11025746201373332, 0.11558155037639173, 0.9107567938744149, 0.9209908313468311, 0.9450154816050034, 0.9459653755676247, 0.9560168225892981, 0.9271694584578147, 0.9622098449766582, 0.9767368835133193, 0.9678665038281, 0.31613673212290594, 0.33723617467723066, 0.325234139545562, 0.353904516043531, 0.33388965205766463, 0.33322616295899965, 0.35116996323888794, 0.31665493603251627, 0.3379651133279591, 0.5180452857299901, 0.37030117415312436, 0.49604049084908264, 0.5545078743742986, 0.5294535436224079, 0.5842338797239957, 0.5602986709510595, 0.4977841629211148, 0.6071659232974322, 0.2167909498474888, 0.18193257692711406, 0.18631173396109524, 0.18200943403761216, 0.19403825905864291, 0.16490654317663722, 0.16197351990792053, 0.18847936612831762, 0.19239499129474402, 0.2125762440001474, 0.13329319556057817, 0.2006451109491878, 0.16415727240456124, 0.1960165154345499, 0.2375825672537898, 0.18487976538524398, 0.1674163507048786, 0.18239801299672076, 0.08149771585741639, 0.05124351783107872, 0.06836899892535186, 0.04095103956667756, 0.049510507862990605, 0.05435433077287399, 0.06615106644703506, 0.06683343610114456, 0.06249193787147611, 0.1884332387462737, 0.16574130220021088, 0.17070993548385194, 0.14869664375921876, 0.17592123371888702, 0.17088126230309808, 0.19316457128033326, 0.21401019706240243, 0.1971356999988082, 0.03143632481054115, 0.010728838975617716, 0.042564587798143316, 0.02758355711161309, 0.04401473488605623, 0.014558416902912374, 0.026908608783705268, 0.04329231009647627, 0.017743734754911977, 0.13499355015455117, 0.13693959690706414, 0.1579070278361816, 0.15815994073311723, 0.15519201972153873, 0.15069089202107044, 0.14194805897564688, 0.13791966660281518, 0.12776326454150344, 0.48997083526686636, 0.50475433914579, 0.5301351872191347, 0.5237179687089596, 0.5093492957150624, 0.5072528139438266, 0.524839731154451, 0.5045329075105434, 0.505613230791942, 0.09595802673944132, 0.10006076984112167, 0.10668215397284309, 0.11345608782798211, 0.0934664152011383, 0.10566132292137487, 0.08376456005645383, 0.09277505758640858, 0.08504173976170804, 0.16780385253659458, 0.17983554464087703, 0.14880361275521103, 0.1825820472580565, 0.19554162660005425, 0.15550709240429827, 0.15522762207573904, 0.1468844514595996, 0.1542629664573003, 0.3223296209266471, 0.31633265324850013, 0.31797738553019816, 0.3204762346847305, 0.3249509516043009, 0.30961394748415316, 0.3359392145697129, 0.3213588385726067, 0.3598045745993965, 0.23381161530670536, 0.21173822891939498, 0.24111844293296514, 0.2064252838197823, 0.23673980440245346, 0.23646796792310143, 0.24624336156263982, 0.27076715012920893, 0.22839105879308186, 0.18397057136672734, 0.19119331372369952, 0.19253250707385794, 0.20907539074954395, 0.2044494695157607, 0.19758328209507925, 0.19480418158602675, 0.18463856149642688, 0.1869004778897515, 0.1968143112502827, 0.19392225561957732, 0.24907976534722398, 0.18954785090478965, 0.18824671946100147, 0.1861221955596788, 0.18061204647708762, 0.19790342230585078, 0.21099357048145684, 0.5204946409247226, 0.4749107725688647, 0.44360031174649217, 0.5294229278472643, 0.47055640849442315, 0.42845488656432584, 0.3468656615485801, 0.27368293832835866, 0.17976342795386824, 0.3636508834899943, 0.39210686914373727, 0.19827964283454724, 0.19388646086309258, 0.2181950671003453, 0.21346342343450742, 0.20024028472304622, 0.5939673231116406, 0.5313070850822141, 0.174456116976188, 0.18291949588928047, 0.17764172965909875, 0.19247679693952835, 0.18051783412295208, 0.17626827402675338, 0.19723281564460748, 0.17620891357002022, 0.17794329448902302, 0.07067728757457248, 0.07516304943806096, 0.07242171452578405, 0.07617984664833488, 0.0738898996378945, 0.07363027415000234, 0.07674692493676394, 0.07327373737591403, 0.07933001412761553]}, "mutation_prompt": null}
{"id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6  # Self-adaptive mutation factor with altered range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Improve mutation strategy by altering the range for mutation factor to enhance diversity.", "configspace": "", "generation": 20, "fitness": 0.4165774812951358, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "b2c45036-db0a-4488-89ce-875cbb25d814", "metadata": {"aucs": [0.8075468797925962, 0.7715729813535681, 0.8120787699879062, 0.7984520815402331, 0.8136036232015049, 0.8043445480385656, 0.8138361320468941, 0.8083936659567925, 0.7861638053541757, 0.6604234582305837, 0.6461578159407462, 0.6295592193029285, 0.6390013828306831, 0.6415212853604326, 0.6407674907162305, 0.6354708105342142, 0.6418374615068609, 0.6610273035443706, 0.12998903943572326, 0.1143452749943723, 0.13013206183561943, 0.12124253508265848, 0.108082458006032, 0.11521823879186321, 0.10930661998146352, 0.11592554368789276, 0.11010860619338658, 0.10308072983220973, 0.10967667296265204, 0.11076660955202788, 0.11478765231838695, 0.10352817418255722, 0.10681398408217924, 0.09591596212109266, 0.1166236327039023, 0.10949172338502444, 0.9033109287981135, 0.9140533504699726, 0.8310935685205478, 0.9283304338243332, 0.8564350971662105, 0.8414154054585118, 0.9551256186356848, 0.8959178047425848, 0.9608652931858128, 0.4737597371140364, 0.42008253083538616, 0.5409741435392306, 0.3896427526842877, 0.4963714794235089, 0.4390457617237621, 0.4235066960477547, 0.4139482599013574, 0.5004473083312571, 0.8229019866774651, 0.7664605480674302, 0.7661927515856687, 0.7945467476363879, 0.831222507757206, 0.8264822578285244, 0.8362229828805093, 0.8176489517176573, 0.8029421125494377, 0.24598140138286317, 0.1549091051958107, 0.6024866950251917, 0.18536558223673383, 0.2703726310376755, 0.242706588499908, 0.30165805733318485, 0.2873705347502663, 0.5028549989471973, 0.11913834666195822, 0.5013956190324276, 0.29655400192353465, 0.3109767500246666, 0.29452888845810854, 0.14732635308750375, 0.5994046187093282, 0.17862555610134545, 0.20495711098410085, 0.5672300523928628, 0.5544067600087081, 0.5662451515685634, 0.5890820884397932, 0.5713407416963252, 0.5847435788128735, 0.5366490811192217, 0.6263554836090441, 0.566380519797303, 0.6755809862490149, 0.6821420110304005, 0.651475512535518, 0.6367494846247104, 0.6327513992846103, 0.6059065976983387, 0.6547456361296476, 0.6947309709294418, 0.6667057408848933, 0.09215453408028229, 0.26777358251039174, 0.2814084036320753, 0.3609393855324845, 0.40022695936466623, 0.4396930373080883, 0.23281096093554088, 0.2668099499321095, 0.15460103917999146, 0.43227509961414234, 0.41925610105262834, 0.4020429637885514, 0.4115436656014734, 0.4224227903107899, 0.44462277051200605, 0.3917290799083316, 0.40620588303500194, 0.4517151451580248, 0.7487526015956518, 0.7571178040504678, 0.7553451477508542, 0.7494380999387369, 0.7764765987893771, 0.7523963002855147, 0.7511142439166107, 0.7490756455355336, 0.755694540493959, 0.11478116567997965, 0.12660119035436235, 0.11481942043238946, 0.11573822059808647, 0.1258909498429206, 0.11260645980512451, 0.10766167185660669, 0.10554728107445899, 0.1123145438611125, 0.2046464130689083, 0.1519479796792561, 0.13842971079504462, 0.15926654100570103, 0.18099232092153028, 0.2147885348488089, 0.1530915116571666, 0.15821072003503323, 0.4557270117227177, 0.4545297667940563, 0.449113716194004, 0.45132450432142523, 0.44906826793978605, 0.4778792749719263, 0.46393193690808665, 0.4792160797438406, 0.4735006961520263, 0.4804664951922163, 0.4070741946272993, 0.39954040570493576, 0.3782173093685992, 0.3715061307533043, 0.3938430291240703, 0.36370310874716505, 0.4063705740029654, 0.41586764583664126, 0.3825461723849618, 0.189577038114205, 0.19402264496602106, 0.2162887052166218, 0.20461642910730982, 0.20088131801006448, 0.18924656212415336, 0.2028340629131501, 0.18994469488664067, 0.22290334858454186, 0.19240905611000403, 0.3582458931192034, 0.22023364235940135, 0.2290620891787889, 0.23216243886800791, 0.18476372645475048, 0.20178008848133622, 0.19969212926798163, 0.3210801810843069, 0.16639697263338804, 0.7295133103501457, 0.15284915499098184, 0.8305403879123189, 0.18395008890148845, 0.1907561111668501, 0.7560129837816398, 0.7495497154804057, 0.6886148991391814, 0.7195978744043157, 0.20955335193475277, 0.745376082429056, 0.20050316773324672, 0.7838062754686711, 0.73456209910896, 0.2091695335285152, 0.7718723042989866, 0.15322559875725894, 0.18825577848178177, 0.1867572944620055, 0.18132894351829099, 0.1745974291989416, 0.17989676987196512, 0.18571666144189392, 0.18967072408739716, 0.2028097444152419, 0.18489889569427242, 0.07616942603654386, 0.08591823718623404, 0.09040602968064249, 0.08610495809214203, 0.080908193652234, 0.09242931933305876, 0.07910564982329016, 0.0833396613099836, 0.086849105082901]}, "mutation_prompt": null}
{"id": "bdac7f1c-d4d0-454f-a1e3-90d01e36bd52", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = np.random.choice([0.2 + np.random.rand() * 0.6, 0.8])  # Probabilistic selection for mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce a probabilistic selection for the mutation factor to further enhance diversity.", "configspace": "", "generation": 21, "fitness": 0.36485940113187115, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.23.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7320684274915528, 0.7123267749324639, 0.7397745256734451, 0.7422234382381214, 0.7353318192059182, 0.7478331277791828, 0.7447826980376828, 0.7280944600687509, 0.7519427191990704, 0.5259529964965803, 0.49682003324754676, 0.5464905521423848, 0.5167476316020119, 0.5256331953856856, 0.5304312883282777, 0.5522681888039007, 0.5437760197344408, 0.519025011350807, 0.09758205165025724, 0.11794713732522177, 0.11037080053523873, 0.10847716695817944, 0.10720950524153527, 0.10749578111882074, 0.1239229961678775, 0.0988623421080842, 0.09657958530370692, 0.1037450942364565, 0.08887250877899677, 0.09651488761065397, 0.0873186025820305, 0.09416922365606917, 0.09148203569285618, 0.0830050785430807, 0.08376444688005213, 0.09901939186384456, 0.9017655901948575, 0.874447451710177, 0.9630028017296024, 0.9053142170172956, 0.8211115806329651, 0.9062404035279966, 0.8859114784375763, 0.8596820102983593, 0.9191593682441117, 0.41450063152948846, 0.38273321496688284, 0.3895514205756153, 0.43503928057506036, 0.43828461585693435, 0.3723234766679778, 0.39807863637648044, 0.35241974986718483, 0.45055716249580435, 0.7689331237370396, 0.7156688431543095, 0.7003182112302326, 0.7414486278130237, 0.7231187520379182, 0.7279719403297926, 0.7077785206007394, 0.7379371031669175, 0.7714093732488385, 0.45192685121856546, 0.31371197015429175, 0.2468287822638645, 0.27758786934071, 0.37902847245848614, 0.2600627011703067, 0.2985873488723937, 0.3936414190105638, 0.33626833719856464, 0.31150598977752586, 0.19230647578410964, 0.28600960186793767, 0.42915341458911493, 0.3444767419074597, 0.2392540390549528, 0.30379379960445085, 0.32587379051515086, 0.3793812402286314, 0.40676039624967575, 0.3809032826868546, 0.41762671739053303, 0.3773742697873562, 0.412487015415161, 0.3737093940044057, 0.42788105645247554, 0.4335025171853085, 0.3532543830410303, 0.518638619847132, 0.5260804775747133, 0.5328720478652178, 0.5357896399376738, 0.47006902590813693, 0.5129611391722299, 0.5386640400589578, 0.5456869438139016, 0.5357660214373424, 0.14208066796903007, 0.1311947296571132, 0.12169231830245175, 0.2703153523516111, 0.19519117287642607, 0.26932949771401826, 0.12807229211549587, 0.22466700837484266, 0.1362751008002122, 0.32932891993230773, 0.29793703025827967, 0.30734484954687646, 0.295133456519985, 0.30819948047296897, 0.3031937579599274, 0.2821939006906097, 0.3138671915250132, 0.29491940257418314, 0.6330723036542629, 0.6659794406363551, 0.6705994516438173, 0.6570734829577505, 0.6548255300125658, 0.6485038838925203, 0.6845336269846416, 0.6356287005190244, 0.6540841077601303, 0.10310722305941122, 0.09963036930019098, 0.10024433272251299, 0.08706855062417107, 0.08986711824685623, 0.11318253773577092, 0.08552816773421434, 0.09268606157969428, 0.08736838598271224, 0.19195017681080162, 0.15951260605504125, 0.18102940075294582, 0.18681936948131384, 0.17458334261844888, 0.1617451404351794, 0.27428034821173286, 0.18877927581267673, 0.15513636211534776, 0.36016606281592944, 0.3374618210816448, 0.36760469020182196, 0.34979529197762216, 0.36251412469756783, 0.35581296845933663, 0.3954772437053733, 0.3812569977897111, 0.3782749401513078, 0.2914860453170117, 0.2805170466577511, 0.28651310272784625, 0.2704056480359738, 0.29156145191195115, 0.27049463418389685, 0.32336165014553897, 0.2705326236879516, 0.29460001914262357, 0.18585609754110521, 0.18564674133275538, 0.19074755725263104, 0.19007600556652604, 0.18166787076297164, 0.19639898192439798, 0.18040811327236095, 0.20705867313978987, 0.21362030527646114, 0.19349567378565757, 0.20665499237561635, 0.1968851550427937, 0.240669975190963, 0.18416776342601493, 0.19527841929443968, 0.19185300588436183, 0.19060710560089944, 0.21139932493717895, 0.6219635384279761, 0.7356964587335677, 0.7533097543913212, 0.7443541807961287, 0.6415499146755903, 0.19324958778522672, 0.49507308219372426, 0.1800666150020126, 0.5496712034197695, 0.20370678120469488, 0.6471331080330409, 0.6124481855808546, 0.587965434896625, 0.5706945861179219, 0.5495390382169747, 0.20434962451913696, 0.20082859470167969, 0.1970741997008657, 0.1830796977203536, 0.17772463414027406, 0.1843834789297467, 0.18972852723827438, 0.17516426410979402, 0.2017514213991679, 0.19929867448541683, 0.17986615418973417, 0.1894724028147987, 0.08042269528092616, 0.0709935185496543, 0.07038625787278541, 0.08548590105529219, 0.08598223483251044, 0.08295715666457038, 0.08889233423498222, 0.08235610132350157, 0.07293278712689932]}, "mutation_prompt": null}
{"id": "d4a1d040-ee2d-4d0c-8498-7d97f20ae9bd", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Self-adaptive mutation factor with slightly increased range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Refine the mutation strategy by slightly increasing the adaptive range for the mutation factor to further enhance exploration.", "configspace": "", "generation": 22, "fitness": 0.41017932377289623, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.8146526362311206, 0.797536440200927, 0.8139928730509383, 0.7947883625855815, 0.8047236705618502, 0.8203012598409514, 0.8063569848380183, 0.8069407528141559, 0.7810972598559692, 0.6324935449419347, 0.6869093806196009, 0.6509524072349475, 0.6867500999666344, 0.6321951271248354, 0.665005770139518, 0.6436593106199439, 0.6522064250232749, 0.6387356135005198, 0.12926630878159118, 0.16136024071870247, 0.11694286766296913, 0.3365658850987261, 0.2123661437379265, 0.18815865306591828, 0.12800017700646127, 0.13744796025715955, 0.1766523247814472, 0.13134630790829382, 0.1103359745134821, 0.1175665862407308, 0.13039278564518464, 0.1087277971225018, 0.11569658152193574, 0.13110348591204746, 0.11773753779544227, 0.12418238957884364, 0.885849111397329, 0.885285692949749, 0.8347135726631462, 0.9602998267118237, 0.8527942503210317, 0.8812130986032042, 0.9099705451070078, 0.8765945618507025, 0.9613318974261684, 0.4764083521136159, 0.48512445248892155, 0.5018811063159012, 0.4590179298148884, 0.4717018221628325, 0.4479569556787769, 0.4749168272292379, 0.42948097228832594, 0.49232618566262676, 0.8174127970107316, 0.7882892343224073, 0.7893177601234902, 0.8050538791978399, 0.8228776954684793, 0.8080432213395581, 0.7767544382833743, 0.8077284969484115, 0.8356173186418118, 0.2406239088697697, 0.42286303863955976, 0.4312979989412927, 0.32040197511840685, 0.26228191804004264, 0.3020900628194465, 0.16954075953420766, 0.3446186848852162, 0.29851834735435645, 0.22344858337135032, 0.31140990593735196, 0.23187764292784518, 0.5086839241660922, 0.1283589511271881, 0.15769005964090643, 0.2268062689478333, 0.29477185209108026, 0.2826289949635916, 0.525122213702035, 0.45544657793654264, 0.37590524317944973, 0.5817241070665422, 0.4873991979822282, 0.26133742685149974, 0.5746023231536022, 0.5333583876477295, 0.5902010199182264, 0.6603372320881071, 0.6509286810136488, 0.5369752344609233, 0.627031685459849, 0.6554069555845892, 0.6704848851883585, 0.6893189530334722, 0.6655334154177168, 0.6976101749111918, 0.13581758429026503, 0.15296801333164367, 0.23661162609950914, 0.38964434612413557, 0.23832888313312328, 0.37156231246068017, 0.14984730101753407, 0.3082000737706274, 0.2619480909790486, 0.42812223384965353, 0.40090741213299674, 0.41941677716497217, 0.4228045629106658, 0.39679210994347547, 0.4336206512382752, 0.3532566299431469, 0.38481141343663017, 0.3291579342885056, 0.7511171816063168, 0.7595579552702793, 0.6865568659958325, 0.7652298939518555, 0.7621941414606743, 0.7652362737733859, 0.7353718366785605, 0.7664892725580944, 0.7222502975133985, 0.13518298109242222, 0.11640910196614529, 0.12729245767903774, 0.1363200668036343, 0.1168036986038904, 0.24500638393892038, 0.13399268330355496, 0.12927876077564793, 0.11895905045902144, 0.1744952862128012, 0.20040781057246582, 0.24564023852712802, 0.18080237998906823, 0.20420575586708323, 0.1936938437832305, 0.21949426298552022, 0.17170395207616462, 0.1772283068134457, 0.47440841573633097, 0.48431288331552524, 0.44410818769846894, 0.4810702441812441, 0.44506657330155297, 0.46580815572648904, 0.420016432322352, 0.4372996411201623, 0.4810134220283887, 0.3562540621498219, 0.4338097970860556, 0.39544121553997713, 0.3506681081229108, 0.403366563598447, 0.4027750038671548, 0.42600054018666855, 0.4294965696355424, 0.389847048557721, 0.22303177935256013, 0.1954876697619531, 0.19679490625097185, 0.20453742912485917, 0.20679093271320248, 0.20963886404754595, 0.2243590886200828, 0.2228525792963717, 0.20333160698934638, 0.22815491938356436, 0.20057142586661691, 0.20245360759566366, 0.1879633084543868, 0.5152952585530065, 0.318109036708603, 0.2261875230400474, 0.4048722011011022, 0.5087326554086253, 0.16974352007663396, 0.19653010449423713, 0.19679086251030764, 0.7850796014094291, 0.6205548353811252, 0.7558764981473836, 0.1847430590467709, 0.7918118487362176, 0.7493101957441097, 0.7287993154926549, 0.20428947111377194, 0.8325963235873497, 0.1646012258360694, 0.20112092087566424, 0.19957874513761054, 0.20877062036724736, 0.20601366810737587, 0.2026850444284406, 0.2010462973277497, 0.1741114839634863, 0.17675723095355877, 0.20683157174244848, 0.21510917826124787, 0.1824524292749342, 0.2077896553932881, 0.17212792473397198, 0.19857921934026657, 0.0765232029063776, 0.08162082785709646, 0.0800132131581055, 0.0782475248085015, 0.0913492373803545, 0.08118872264019339, 0.0979846058732664, 0.0875473506283363, 0.09814552480147831]}, "mutation_prompt": null}
{"id": "96aa099b-23f0-426c-9461-63dc1f85e27a", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.97  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6  # Self-adaptive mutation factor with altered range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Enhance selection pressure by slightly increasing the crossover probability.", "configspace": "", "generation": 23, "fitness": 0.4031116087802014, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7803696336723324, 0.8137527345383812, 0.7976456449872333, 0.8082690706267419, 0.8248106497134292, 0.8028669039475589, 0.812077719697354, 0.8019517023709397, 0.803859827420452, 0.6339334049155936, 0.6694987359449267, 0.6458572904822675, 0.6555736121405488, 0.6548828036996954, 0.6500667794929146, 0.5930222749026166, 0.6720152131026771, 0.6250461480908664, 0.10323963609643283, 0.12335010428302284, 0.10082863434273681, 0.10458411147794267, 0.11633870866149121, 0.09535056210745385, 0.11355490813270264, 0.11053416933790527, 0.12905297440938335, 0.12070611419882149, 0.10486008400545288, 0.12266486041955338, 0.10624779510849824, 0.09919297415457784, 0.10010131726561888, 0.10428309979226869, 0.09558908503592389, 0.1153728479664553, 0.7952558801713925, 0.8518918949656182, 0.9329946397522106, 0.9230181211180832, 0.8596658827331333, 0.8699804840693998, 0.6994212230676051, 0.8754788941104402, 0.8788084795400672, 0.4470220638594007, 0.45528523908163265, 0.5111523971635031, 0.45599338750764906, 0.4636710775315206, 0.44700929884240326, 0.4503440055471306, 0.4123439314639006, 0.535567878771469, 0.8322185081566335, 0.8472616521375113, 0.8146315667857913, 0.8021214134329396, 0.8372537646001804, 0.8453243496232882, 0.8511017240599389, 0.8534384301641669, 0.8271742989181432, 0.3853446689543384, 0.3860515714824432, 0.20158882063421746, 0.235550830243352, 0.24637954608191026, 0.5089218801661227, 0.1805606165838619, 0.16690670023534637, 0.26186413795350805, 0.2382136997977875, 0.3501287007120486, 0.28336327861052846, 0.2713465627575331, 0.20414136005334915, 0.13995892213451588, 0.17029555443262312, 0.5955794436211855, 0.18151637826525635, 0.6207294197712203, 0.5313001510704551, 0.6133238731993409, 0.6257056005098229, 0.617400190453202, 0.6096314846185031, 0.6163886491376718, 0.6084959899417877, 0.5785158093174118, 0.7086978222870246, 0.7141111478053411, 0.7172424219044706, 0.6711971963338463, 0.6871645256849761, 0.6946088041291345, 0.701500679852483, 0.6813329429282031, 0.6526153879625669, 0.15498292902842203, 0.13616472413803005, 0.1946097373717386, 0.09646441941406081, 0.4486412235175984, 0.3557471822484053, 0.26397055236695355, 0.1848637209028362, 0.16533513326968208, 0.4730270618044842, 0.4520752831984465, 0.4671649348611512, 0.4429563182080234, 0.4568187830980692, 0.45292365468995677, 0.4445046924817806, 0.4350813009108654, 0.43952607412473244, 0.741842268545171, 0.7601406477786762, 0.7719712123630544, 0.72810402620624, 0.7994566509924059, 0.7746322081866424, 0.7709155811625616, 0.759785557832452, 0.7520680694227845, 0.12917146771228527, 0.09794673358880424, 0.11091573959737033, 0.11723118279864919, 0.10961612406383359, 0.11140521433857098, 0.1439364526725505, 0.08783359811980296, 0.14087089075894488, 0.20692907593339072, 0.3131214576612724, 0.21018141959316572, 0.16815484640118827, 0.2833183955474675, 0.15879452301877006, 0.1764250852256739, 0.1678643033314634, 0.19163203598886724, 0.4634836198301271, 0.4656990246807128, 0.4402304529465354, 0.46832043516109756, 0.43306074658333626, 0.41029668813743003, 0.4449473124499037, 0.5344494870992009, 0.4752524909821839, 0.3993155228700349, 0.36629801142813867, 0.38001772357725827, 0.41719413506342906, 0.3881996544052132, 0.36893956018027096, 0.3797209670671764, 0.4357521243505348, 0.42796075722930405, 0.195508178389165, 0.1911812668985472, 0.20426396257507873, 0.1915741992679716, 0.20110616142034476, 0.20558095594168413, 0.20022953012157052, 0.18410229128666455, 0.2188241312705429, 0.20813060614195955, 0.1972736064788898, 0.21262015034605952, 0.22203388797059365, 0.21806301155074093, 0.18998348972394685, 0.1970551441838948, 0.4609641810490962, 0.21645734351400414, 0.14951237442758936, 0.1952183352622726, 0.15225874583644905, 0.7402217470656279, 0.17673721090026373, 0.761200840508617, 0.1840244689063325, 0.761454414569277, 0.7983066700592595, 0.20337182408677434, 0.20936886431118562, 0.6754708073237276, 0.16435037386943663, 0.20294056020010243, 0.19760602219934864, 0.20766069889434635, 0.12694790049520632, 0.20563335656947435, 0.18563016008744804, 0.20962028736520055, 0.1799256742104144, 0.17911525543258033, 0.1861541170585157, 0.192709547199575, 0.19608602407549436, 0.18571735460271577, 0.18794298480113036, 0.08706646624164494, 0.07759034734127856, 0.09231995456911157, 0.07853920441403095, 0.08203120298027555, 0.08462836313895805, 0.07725226662828699, 0.08477537689192138, 0.08504699400436933]}, "mutation_prompt": null}
{"id": "9db05348-301f-4f53-b301-adf8c3c2e122", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6  # Self-adaptive mutation factor with altered range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability * np.random.rand() or j == j_rand:  # Introduce variability\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce variability in crossover probability for enhanced exploration.", "configspace": "", "generation": 24, "fitness": 0.273680655166571, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7547670840377669, 0.7813086635512031, 0.7646537841673042, 0.7684012042261288, 0.7623326653637426, 0.7915806889599756, 0.781668795278078, 0.7744748039398155, 0.7716240700225457, 0.5913573386337396, 0.586728266400955, 0.6052329807120755, 0.5799436370981641, 0.6088532510396281, 0.6168972348247407, 0.6143477487656616, 0.6077331522531398, 0.6120005615010257, 0.18231100188746874, 0.2817165047339165, 0.23454909325369944, 0.2513398387629736, 0.1608232765634291, 0.18869732303620312, 0.3060948319954675, 0.20266673675734925, 0.27808930436889046, 0.18712810346609676, 0.12617543762323746, 0.15067918993428453, 0.2046017250686467, 0.1408330710481136, 0.1841902877996201, 0.20658865067124943, 0.17879082025856785, 0.17640353476648285, 0.9358006727409887, 0.9523179461142757, 0.9484004091639715, 0.9351571244826528, 0.9543062641466539, 0.9229799217195582, 0.9475204717366094, 0.9567618205279934, 0.9533482324334319, 0.316404092383169, 0.3278445805897663, 0.3128264177433123, 0.30004113432115087, 0.284788133251088, 0.2947007220905775, 0.32692285003147503, 0.30072703965865544, 0.3243336466427207, 0.3867589264129393, 0.34525698961347484, 0.4029225363837542, 0.432410871658539, 0.31939458948248045, 0.37721122363045156, 0.48851494735482437, 0.39852839147120855, 0.41690368977012193, 0.1626187003394467, 0.16261744697123703, 0.15147235667341852, 0.155810811665949, 0.16416663515679042, 0.1614447345294031, 0.1712112006614085, 0.15582251917253676, 0.1747627839592647, 0.13716942640154006, 0.15588658666874922, 0.15871058889193623, 0.15042384010630072, 0.1416934767907977, 0.15229873100561875, 0.14985433455189034, 0.14988584397157434, 0.17798472854895886, 9.999999999998899e-05, 0.001122501008851251, 0.00042581116797557605, 0.017659381867333068, 0.0028943512964735296, 0.012627330541768234, 0.0006111626664285774, 0.0001295770112830219, 0.005396769535741419, 0.11243073524622127, 0.11270584265005379, 0.10438943409831314, 0.08927837174089892, 0.04222010936960052, 0.08326960869057365, 0.11696913037436174, 0.11041516757412428, 0.09399589392466079, 0.00014627729430616299, 0.0005515449088896451, 0.01013811924723429, 9.999999999998899e-05, 0.007633815212253259, 0.003287012850358928, 0.017420620662392916, 0.017211107881351162, 0.004402038191966273, 0.11010631314477237, 0.11272519881853171, 0.11503167238107803, 0.12007477810268297, 0.12516912639352118, 0.1316938780766499, 0.11728182823566768, 0.10364326839958826, 0.10985339139396821, 0.45779863485164474, 0.4616939765367668, 0.5067966147226612, 0.4804398738363862, 0.47726107877994817, 0.4796168587298618, 0.48612742932053055, 0.4820963262897209, 0.4864384036321451, 0.09716474581970036, 0.11223474301617264, 0.09779239902397607, 0.10478189959175654, 0.09460249435977763, 0.098333777856485, 0.09260770902246218, 0.10806958554419166, 0.10472463410941313, 0.144324353662029, 0.16576084220238319, 0.17716477089801375, 0.14989251115121538, 0.1475203209918241, 0.17126939512198192, 0.16225193332494414, 0.15635497069903903, 0.16012688696330935, 0.30875004448148746, 0.30733841103371284, 0.32339390427904824, 0.2840799493974484, 0.3068180017346718, 0.2982966877198524, 0.34653427899770917, 0.36511062706329733, 0.3486506749711703, 0.19630800904829537, 0.21183569400611524, 0.20606978130861076, 0.18803007120218507, 0.1813169499782984, 0.2261043692300182, 0.23707254901099772, 0.24444533699965298, 0.2206193294976012, 0.1930888136479041, 0.1909885471293068, 0.18344051672711126, 0.2721537535458669, 0.21176700165304463, 0.23293154525707882, 0.19648433141651855, 0.2104887005773991, 0.19960818698387794, 0.19851393154791785, 0.2092308349359564, 0.22201763667780428, 0.28446329236147816, 0.23183205301643406, 0.2578489699875258, 0.22334205299668275, 0.2403006097653233, 0.19841530386939432, 0.28055242078791065, 0.2614988279496845, 0.42465590169458767, 0.5862600455794392, 0.3090978462528612, 0.5421288073167073, 0.24060543478862273, 0.23407497748342276, 0.34870394478659295, 0.2830636437847567, 0.2829751694387129, 0.26647709657013297, 0.29533197010292567, 0.18666605142920933, 0.21096032193340675, 0.23227684350275712, 0.24301473069189894, 0.29902886180577803, 0.17657870620798932, 0.20410847195321957, 0.18210393800393743, 0.20203697060424253, 0.18841646848381455, 0.18722188405258744, 0.17922770730380488, 0.1929618586870555, 0.19257404134170464, 0.07682506019078028, 0.09201389839768981, 0.07798241827676522, 0.07581155425984909, 0.07868172278430463, 0.0982071730099664, 0.07811157315589301, 0.0776332013009895, 0.0805998255962731]}, "mutation_prompt": null}
{"id": "b68fb06d-e968-4d97-b72a-fb6ea01edd57", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6  # Self-adaptive mutation factor with altered range\n        self.crossover_probability = 0.7 + 0.3 * np.random.rand()  # Dynamic adjustment of crossover probability\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Enhance diversity by introducing a dynamic adjustment of the crossover probability.", "configspace": "", "generation": 25, "fitness": 0.37483813401806493, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7867449171643636, 0.7778710354778822, 0.7947578426969564, 0.7903496068957553, 0.7907781699750456, 0.8126924045796775, 0.7925513955501147, 0.8111830825222408, 0.8078083623040442, 0.630704324944375, 0.6465776188545744, 0.6528493488723898, 0.6373878759651183, 0.6103883535658865, 0.6222800479077273, 0.6463677695927289, 0.644306588893319, 0.6411786296185293, 0.1290303960936544, 0.11678013323991254, 0.11766742845123268, 0.12622333310413503, 0.11740048195629083, 0.10896734003508013, 0.13019627343152695, 0.11365834327148316, 0.10878636642413364, 0.11538769300613605, 0.1154007090874416, 0.11268278045957991, 0.11195076133171, 0.1136124612966447, 0.13163801311688117, 0.11304682080829953, 0.1092930482244503, 0.11092824517793665, 0.925260750410857, 0.9609511100020321, 0.886770894885621, 0.9143081542246247, 0.9671038499171828, 0.897313364076468, 0.9559588148957412, 0.873232056836762, 0.9140274630552923, 0.4644646703114559, 0.47002771771182994, 0.47427041683944726, 0.4310535400776616, 0.47640023376348495, 0.46113948312027897, 0.4528593380334004, 0.5003126484671958, 0.4851517750794748, 0.7629845686500911, 0.6809366192386391, 0.7580396280895361, 0.7812537588306275, 0.8421051092115648, 0.8014397453513683, 0.7388558338034406, 0.7746459458991022, 0.790880134330959, 0.2064007199248432, 0.24571439510829673, 0.24458058175997932, 0.18769977449896003, 0.17660614366542138, 0.2794049179647614, 0.24352343541670296, 0.201043454694682, 0.18903208778853609, 0.16217915805991057, 0.16871922220162938, 0.1254926866908398, 0.19960300203369574, 0.21767066831439552, 0.23985343311172413, 0.21884046543718327, 0.1546231492902883, 0.17666007000567185, 0.37610503842469156, 0.3495926655904643, 0.33712092876839306, 0.38100825540048144, 0.321611016713346, 0.34780579414545787, 0.41767749604525684, 0.33794198411702137, 0.35025929883938267, 0.52768642353546, 0.5242359760504745, 0.5725510474794536, 0.4392508755939015, 0.530431121074308, 0.5082503390330273, 0.5203306015732725, 0.5618433201378439, 0.5633197809523773, 0.1790689092973835, 0.0858520692382736, 0.09550040607345911, 0.29623376952144376, 0.20072130593515736, 0.2504190375919023, 0.14454185039185885, 0.12957725724708946, 0.19635005266756023, 0.27316241251288664, 0.2984736147804007, 0.2810010801623979, 0.30298553228195224, 0.31469220524164765, 0.30334799317804473, 0.28623638149011055, 0.2745419272397496, 0.30439133649293604, 0.6936413548754525, 0.6976486844358014, 0.7111294949877938, 0.7042934443631765, 0.6695208436006462, 0.6715833051322464, 0.6925909829886281, 0.6711528477318426, 0.6927132668604072, 0.10431743569040441, 0.0904093076756981, 0.10000141104351967, 0.1070423309770473, 0.11771309898681026, 0.10664002337373535, 0.11103686676949676, 0.12154137400192289, 0.12389190601149835, 0.14548238664268598, 0.2559841842556628, 0.14905182802823513, 0.1559066625321659, 0.14790420259821735, 0.1489992072412495, 0.15338317995251272, 0.16042771915587817, 0.18391725771479928, 0.4033775903007346, 0.40703308309817077, 0.4781180030907046, 0.41640394758741806, 0.408343847892333, 0.40840882612130147, 0.4465270575758644, 0.4350648664319543, 0.44299724530701057, 0.32693946759778847, 0.31682340838053036, 0.3117072439978932, 0.3188501207155938, 0.31555145940933305, 0.33380686587102815, 0.3236802449807511, 0.3391056274253802, 0.36072930711026885, 0.2063809669760135, 0.1959955662802545, 0.19325271640220243, 0.19156927764004628, 0.20353098014945736, 0.22756579059295023, 0.19260561519365105, 0.18729534501607414, 0.18659843152604572, 0.18293538774858897, 0.20756749241273353, 0.20946960559622063, 0.2555192508708205, 0.21537606800906195, 0.21184988897308232, 0.2151400812692229, 0.2171575303355604, 0.25602551355068004, 0.4721295629836869, 0.684947193193747, 0.6760473515417365, 0.7255784237754968, 0.6823898363094607, 0.18000365181742584, 0.19545647174173986, 0.7027349072070241, 0.6895327002371399, 0.6939140998755235, 0.679244155190019, 0.20127655039670667, 0.5531115746486888, 0.5134474372064448, 0.1636773393190073, 0.21150133992757625, 0.7926565951737893, 0.2045328243977238, 0.19143942365208777, 0.1874075385678503, 0.19532194689698312, 0.19088328279503242, 0.20183336394247076, 0.1910144786662069, 0.1760713800522855, 0.1861234585338446, 0.18181342729865813, 0.09440202243246243, 0.07346618712636932, 0.07691313664306199, 0.08042911052290802, 0.07399292673036362, 0.08550206198440757, 0.08526734648145085, 0.07824051273015264, 0.09256289904043447]}, "mutation_prompt": null}
{"id": "5922afed-6f10-4ab6-9b73-f277363c5d82", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9  # Self-adaptive crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        self.crossover_probability = 0.85 + 0.1 * np.random.rand()  # Adaptive crossover probability\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.05 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Refined adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Integrate self-adaptive crossover probability and adaptive local search step size for better convergence.", "configspace": "", "generation": 26, "fitness": 0.39301036058722366, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.774887495996786, 0.7990459721899065, 0.7616338261320781, 0.781625005310931, 0.8006309661706046, 0.8204631911021922, 0.7873210419412281, 0.7998116125847496, 0.8071853311193554, 0.6323655024065482, 0.6619949035679134, 0.6679210369182669, 0.6649634543098709, 0.658692194698659, 0.6469134748229957, 0.6525476242329287, 0.6342246758059275, 0.655565371254281, 0.12316870404218971, 0.12208651593940667, 0.11567117446828412, 0.11454451165860868, 0.1058072084700965, 0.1180316763958199, 0.12436579452910557, 0.1647729887288193, 0.15485253404381838, 0.1133125862993285, 0.1252807829897682, 0.10415622040501982, 0.11891570341800528, 0.10918375254932622, 0.13330206036191017, 0.10220870349078637, 0.10450282570902636, 0.1335645263455446, 0.8856330241395801, 0.894019055622254, 0.875215884207552, 0.8529028369969631, 0.8894330563725432, 0.9504592558997668, 0.9020905583156527, 0.8751645314027249, 0.9100285433513259, 0.4496581906466359, 0.42440801584251575, 0.4762003788825352, 0.47789029793319715, 0.4444598458900598, 0.4158645881392159, 0.47819214857971837, 0.4744259026688725, 0.5473448795669429, 0.7964733175678814, 0.8105705723460576, 0.8087413717408375, 0.7919400486820287, 0.770383237037657, 0.8129648184184171, 0.7894530456116595, 0.7949542552355882, 0.7934740297846473, 0.21067654345022013, 0.20493948413186613, 0.16629559058104237, 0.23936779085329418, 0.1884225487767096, 0.18099095106098817, 0.21186513119985395, 0.18392646328169893, 0.24721965954760028, 0.15780695552467094, 0.20066581516160775, 0.3104459090466397, 0.4529949433810976, 0.19833755432996736, 0.2278914844656561, 0.2517263344650845, 0.33157865927839725, 0.2964821626819303, 0.4508137553007433, 0.46901076165350497, 0.4620755389779666, 0.39586865214389544, 0.43301449347999177, 0.47458083577304655, 0.4787848678353811, 0.49637875317716973, 0.48780903496338557, 0.5741297788391281, 0.5777519164278542, 0.5403508557048434, 0.548539683458867, 0.6046001027601593, 0.6230929878323922, 0.5959154984274899, 0.632926528006981, 0.596300504144009, 0.11302627668763254, 0.15677850632051704, 0.1298739220017382, 0.35815810037610196, 0.2861472005090494, 0.30321925793970383, 0.23682691819186608, 0.13565239521327455, 0.22219004636751483, 0.3007306044538778, 0.3595186966438574, 0.3567040627560537, 0.3416851809578899, 0.3469955213969176, 0.38629340574196225, 0.3386102381624363, 0.3312266398597917, 0.3597454831472229, 0.7069267777114023, 0.7301458871318642, 0.7108636136774393, 0.7226784371690185, 0.7206891864532655, 0.6989851752848142, 0.674216388400999, 0.7342262829734144, 0.7458495549145263, 0.11319904255208713, 0.11347059119271452, 0.09938959020508409, 0.1096221186382994, 0.09516561113921185, 0.10962264308699965, 0.09975797191820712, 0.11501675751704499, 0.10651396661079982, 0.14531360715370045, 0.32624081045504616, 0.22504958060196822, 0.17711787406150292, 0.15230659464127494, 0.14725478056726438, 0.14869443349494615, 0.18310913746153423, 0.16869827091112333, 0.41308430928298334, 0.4337795356243892, 0.4565549821806205, 0.4009963949119968, 0.44101392474231604, 0.4225028064662295, 0.46243663956732217, 0.46272163759050877, 0.4720386017744902, 0.31410862275408735, 0.355725523969483, 0.34172856722855527, 0.33936176666196294, 0.3660982762894356, 0.36218300123835, 0.368337953471082, 0.39672117623106995, 0.3577825317190917, 0.2122976523176655, 0.19994280232217532, 0.20214507934818582, 0.20966304513471412, 0.19348953295165194, 0.1947328850771337, 0.2026953385074387, 0.19687838335588725, 0.21564504275701124, 0.18958285025311805, 0.2059562292769408, 0.34550882872990885, 0.2175751947946647, 0.2012352258525979, 0.20094159696113334, 0.4413569469596761, 0.20742330426410482, 0.3367535034747171, 0.19541457640143867, 0.16330265829613722, 0.2023237432220253, 0.806166742927757, 0.6530163441412207, 0.8113590553041451, 0.7018414068341192, 0.1698858909259261, 0.8237942766546891, 0.699177941640849, 0.6856108803838608, 0.20213004829887282, 0.16347339681631934, 0.6639756294721973, 0.20008537651209002, 0.2112649400034745, 0.6580331093401677, 0.6365021020701097, 0.1851689334422334, 0.18507797700900286, 0.19494627456077374, 0.18206115225259578, 0.21429072194916066, 0.19003563963233094, 0.18104928389628583, 0.19058745795796195, 0.1742184571052301, 0.09470623472557149, 0.0826035248271686, 0.07601991438819455, 0.08318069359768454, 0.08755174056647497, 0.07996980255325048, 0.08253051455185667, 0.08576015242529444, 0.09716928404014158]}, "mutation_prompt": null}
{"id": "e136321b-0f4a-4ad8-aae1-07de50341973", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            iteration_ratio = budget_used / self.budget  # Calculate iteration progress\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, iteration_ratio)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, iteration_ratio):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        self.crossover_probability = 0.9 - 0.4 * iteration_ratio  # Dynamic adaptation of crossover probability\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Introduce dynamic adaptation of crossover probability based on iteration count to increase exploration in early stages.", "configspace": "", "generation": 27, "fitness": 0.3367411228881896, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7826595162702217, 0.7797369867890859, 0.7939980649142687, 0.7786927194211981, 0.8170041390828964, 0.8071939508863399, 0.8098244451350647, 0.8006968107446701, 0.773187709712464, 0.6130733249536935, 0.6351812512280044, 0.6273950272173349, 0.6201447152944661, 0.644554063463077, 0.6144171422632729, 0.6262152910491046, 0.6588960598041325, 0.6325616800888931, 0.12049998537186746, 0.18543462156816104, 0.13951324214213268, 0.11005988039694004, 0.13749617535214276, 0.12243788237667486, 0.12599195956374565, 0.13924856745535275, 0.1500800937895117, 0.10306577271140704, 0.11436093376317602, 0.11978653381651694, 0.1118268311867534, 0.11353930618980324, 0.1205277677180926, 0.11558757241347362, 0.1120233317499264, 0.11120643040737554, 0.8873756961124137, 0.9317459155929219, 0.901523234222264, 0.9053368482993754, 0.9227639716605203, 0.8630500855677743, 0.9374002405323915, 0.89685660271559, 0.9428781184640389, 0.4864338165975187, 0.4116543099443851, 0.4467308385319012, 0.42393655704525646, 0.418908909293252, 0.4210581108468149, 0.39537066290785905, 0.43538059624207714, 0.40548219037396194, 0.7497855970668399, 0.7036539747839405, 0.694108759398891, 0.737039160786121, 0.7390413440039649, 0.7146831565117282, 0.7020371798877454, 0.7591391411457858, 0.7471470766647186, 0.20164812691089906, 0.23325406630150314, 0.2856455634922098, 0.18217062929202577, 0.2230289565379623, 0.27877719352070585, 0.17516155910714148, 0.19095649125663827, 0.19105612053865173, 0.1234500067265768, 0.15479439670432837, 0.21269020795009141, 0.20985143886733626, 0.1733103546910859, 0.154305509712656, 0.2789378951657775, 0.1592136442319625, 0.22997239403940062, 0.19498104325795085, 0.17887402596825364, 0.17882937913083274, 0.1815364603579539, 0.159977303023624, 0.20230493394139726, 0.2004856155513749, 0.20657710304487797, 0.18998031859135345, 0.3202048583066597, 0.3685054594660008, 0.30149850845087256, 0.29502857597250154, 0.31949633406587397, 0.26308652032535274, 0.32806431413111947, 0.4195465210396294, 0.3842868857112893, 0.06892439510151216, 0.088724397545341, 0.13246490767006325, 0.1001036854247801, 0.09097664183487408, 0.09886060749858316, 0.09803454694163627, 0.10658833088039243, 0.1049159579186224, 0.21357703545204842, 0.20320427162868415, 0.18388437899305332, 0.21235782879266774, 0.2282385570049118, 0.2190608996463902, 0.174700479005227, 0.24214041984076773, 0.19782248812611114, 0.5849447565166601, 0.5848499284474015, 0.5988535015271604, 0.5693992717112961, 0.5914608523951714, 0.5808082313891166, 0.5891263324288761, 0.5897930484707492, 0.5904113973821692, 0.1019081695831181, 0.10339078824437709, 0.09903666611319772, 0.10196750545042088, 0.09760155633285905, 0.09728685248036184, 0.09595180429201211, 0.10631385999229148, 0.12660558611139372, 0.1603836496903821, 0.15663509779670326, 0.14527308857959664, 0.21264281358421844, 0.1664892585479738, 0.15888106309456196, 0.1657645842169999, 0.17874598829224397, 0.15144014214961787, 0.36751017736102176, 0.3766640663362325, 0.35719104859990847, 0.39201993578772376, 0.3690609209950535, 0.3968708103742269, 0.4142005534516152, 0.4452469249040659, 0.44536741466970176, 0.25423565119715197, 0.303325254894973, 0.2703465838858007, 0.2847816705851155, 0.30294617396297685, 0.25388831967449454, 0.2982261115713821, 0.3047608232178537, 0.31187568281921607, 0.20770579887507945, 0.20133226190369014, 0.1952277306347424, 0.20152856893730053, 0.20586498570035738, 0.1963332749372, 0.23478883344339951, 0.21876997170620238, 0.19535547503573292, 0.2006749592680228, 0.23197260693990474, 0.22783191974009898, 0.18666429645320448, 0.21346291876960766, 0.2132572374220022, 0.206483011821457, 0.34522822049622814, 0.37319202174801025, 0.6277238683462341, 0.17933402103943985, 0.16974706617490953, 0.6614772522894655, 0.7471123562610882, 0.18272360861029036, 0.6852645666644717, 0.8041439698137367, 0.689875703323831, 0.19983150350144596, 0.19856578968683514, 0.4478792886573939, 0.19502623751615966, 0.19921586979138983, 0.6005436545333712, 0.2090493520648048, 0.15094204401992029, 0.7346373554939258, 0.1824950489215711, 0.182806205143758, 0.19545551221528168, 0.19291035481551422, 0.17763741380116316, 0.19439867708887026, 0.18382577513755927, 0.17520242977816958, 0.1742698591720847, 0.08573299049446381, 0.07636538352457978, 0.07997388709631181, 0.08116676757459806, 0.0795286963504237, 0.07849420975333399, 0.08005529463814587, 0.08134537760700311, 0.07645671382488328]}, "mutation_prompt": null}
{"id": "739cbe3e-beb2-4afc-b1e7-14a294721e18", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6  # Self-adaptive mutation factor with altered range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamic crossover probability\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate", "name": "HybridDE", "description": "Use a self-adaptive mutation factor combined with a dynamic crossover probability for better exploration and exploitation.", "configspace": "", "generation": 28, "fitness": 0.40598226521693404, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7917905627821393, 0.7883146242645388, 0.8050220713537631, 0.7808917750903578, 0.7941599969306052, 0.7963735008847633, 0.8203498024159894, 0.799743026938676, 0.7979594542120018, 0.637629109884002, 0.657857917689024, 0.6540560174663683, 0.656830864993274, 0.6577591756044394, 0.6241216389729585, 0.604309671081416, 0.6686753099225192, 0.6409816186251887, 0.10574489615057958, 0.10577984293081533, 0.11858159032243132, 0.12299992930691528, 0.11096695078847985, 0.11150033476097665, 0.1250817481283597, 0.09829129634270706, 0.11006551818502686, 0.11348629044879655, 0.09237450643553768, 0.1087204180297594, 0.1116859271865156, 0.10999685432523276, 0.10859447170062775, 0.11703625872181933, 0.10563262340320767, 0.10605634302816636, 0.8880683177763429, 0.8990669372822222, 0.9209964841813806, 0.8694500412256924, 0.8537097147439872, 0.9060321071266215, 0.9142107515963811, 0.8933644518423278, 0.9515404408260468, 0.487394108067546, 0.4992394311231316, 0.47857364768336697, 0.4928253396150908, 0.43943785038479677, 0.47258202173292285, 0.47966064601727565, 0.5021693042984645, 0.4440156956005229, 0.8269970183853022, 0.829651467274546, 0.8170642663118883, 0.8385187918064971, 0.8212370421665927, 0.8469793085289541, 0.8380783667760878, 0.8018961894557788, 0.8493917007161107, 0.16470815948520356, 0.16523779661056104, 0.21538631489870408, 0.19903634549200377, 0.21547995141879217, 0.22807131781621715, 0.3268322237519513, 0.18494000189689697, 0.4405063481201551, 0.20226689776267726, 0.28758214084858724, 0.29028448342727764, 0.5799169366386463, 0.20535055704225946, 0.36834739155124485, 0.21088728326155393, 0.20970269789733553, 0.22064262590104777, 0.5566836422022772, 0.5638586063770945, 0.5380951834332172, 0.5795482268491938, 0.5281957535345667, 0.5141605286006573, 0.5596879680329873, 0.46070265125921916, 0.5597396537771736, 0.6667352114090335, 0.6898695021879561, 0.6749438187801533, 0.689254063023595, 0.6420484558506689, 0.6331931647974247, 0.663171297022665, 0.7065451535127182, 0.6598209759738483, 0.2517486375817529, 0.08388267692759421, 0.20144965606524845, 0.31718620755058136, 0.17836331595113986, 0.362919545844946, 0.2760338646137773, 0.20603393772986467, 0.10119892178112766, 0.4478427829827665, 0.3800468896374809, 0.4219930281711384, 0.43601418929613356, 0.42575965672215677, 0.41581917275393354, 0.4279074074651805, 0.42258766874656317, 0.4173807307876197, 0.7451336523893297, 0.7637730532448679, 0.7557133392226695, 0.7532469557263648, 0.7434973991985814, 0.7570084813373572, 0.753823284019811, 0.7576479005354597, 0.7604952598159453, 0.10987835426159054, 0.10124089884111132, 0.10011461838745495, 0.11234796923099766, 0.10568547849814003, 0.11871048909786808, 0.1116959630732488, 0.10888979275610478, 0.11228198936568135, 0.16479039307268273, 0.16740736656074895, 0.14903391454376302, 0.19984562488552315, 0.32184199607772157, 0.21215533726978797, 0.15942031872527673, 0.1557192679773487, 0.15858951879886685, 0.44749938774945963, 0.47517495820837075, 0.47933999615614653, 0.4601812952776668, 0.48270835685036917, 0.4581580522634553, 0.47565233155475795, 0.48527914618895795, 0.44787113861019956, 0.39023156174387896, 0.39590366335486893, 0.37202964131566063, 0.3439629417054775, 0.3418116402658665, 0.40083260195685333, 0.39153688355693916, 0.3846325853293555, 0.39754162729488984, 0.20045316529501056, 0.21803331189341602, 0.19523442280118009, 0.2093421719078007, 0.2103682430030781, 0.20885996348540192, 0.20010245307876062, 0.2052157147676752, 0.19021112183932865, 0.19485842098140038, 0.3976686096031631, 0.3078966745535583, 0.20444343193487757, 0.2203240526882453, 0.20912814355648057, 0.21073564572966486, 0.220279337189621, 0.2177774359989737, 0.7873044117269294, 0.15859565172548795, 0.20196823018910037, 0.832535150704396, 0.1918170306626864, 0.19537258277484237, 0.1867044833162127, 0.7167944762023373, 0.6782817108444172, 0.776532370647968, 0.20525862282189578, 0.7750485536214303, 0.16118289231742344, 0.20123417017790912, 0.7251307938942784, 0.2028106277899112, 0.7281388222270558, 0.20641610895066165, 0.19961440365824146, 0.18581751438312, 0.19072401500481273, 0.18452574114091636, 0.182285951121953, 0.19285802167098587, 0.17766220912055852, 0.18873163578524965, 0.1900564386694451, 0.08935208140392825, 0.08309935241661803, 0.07862557495716394, 0.0837206955360893, 0.08656373421073527, 0.08020260917485944, 0.08303626616166415, 0.07675722904255622, 0.09896537329035915]}, "mutation_prompt": null}
{"id": "b6cbb782-4f12-4ab0-b590-f0a15ead8c28", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce a dynamic adaptation of both mutation factor and crossover probability based on the convergence rate to improve diversity and exploration.", "configspace": "", "generation": 29, "fitness": 0.4213322954949106, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "c2952b72-ef15-4f77-bd6a-d486f3c66a31", "metadata": {"aucs": [0.7909717401634915, 0.789214132506242, 0.8223526827601897, 0.8041190279959174, 0.8231970617294784, 0.8188186730474215, 0.8026489084311526, 0.8026116433748007, 0.8131766660611612, 0.6613465491510802, 0.6241606726600325, 0.6124838792561706, 0.6408720390809407, 0.6305901070933588, 0.6590896663548371, 0.6516565630881629, 0.6384749268838241, 0.6662543226222781, 0.12096694558887955, 0.12087419523110132, 0.11803771132955299, 0.10664481563733752, 0.1456410935599466, 0.11453214623722419, 0.15668472809032152, 0.11985266599338196, 0.12087189020722666, 0.10121715312141166, 0.12493913610816798, 0.08877195701723473, 0.12031853177141949, 0.10042746072835984, 0.09833340780691402, 0.1107832343307582, 0.1024440849601187, 0.1157198523306805, 0.8810605324150513, 0.8478336065986803, 0.8384390954857921, 0.9398522576287106, 0.8557389912677027, 0.8788197457317394, 0.9081493943688568, 0.8841296537149038, 0.8815568937466848, 0.4838550333367162, 0.44159155145419937, 0.41843972769127025, 0.434269241584344, 0.45159702921099576, 0.44750623936759015, 0.4710139283089506, 0.5164138551596537, 0.5181004177752702, 0.8391660655319841, 0.8122871340109952, 0.8399363371128075, 0.8107794254673054, 0.8196076523406021, 0.7902850946922719, 0.8432749977347733, 0.8044218968766744, 0.7928730164902333, 0.1827621019078831, 0.23976560762442434, 0.28176835373489395, 0.19923760409554625, 0.21807856084803945, 0.5167960883948501, 0.6102074074723316, 0.2845345417150893, 0.22802727910346454, 0.16776193819057628, 0.32157227395600785, 0.17937584142444407, 0.5990030919191099, 0.34169059856415696, 0.2137933051508094, 0.2667304839082416, 0.23490183951687582, 0.16127056833514564, 0.5707000831621075, 0.5684795271845366, 0.5753457557166355, 0.5393123445571955, 0.5366374848716475, 0.580736425732054, 0.5705427994798029, 0.5389610187250812, 0.6121298526988991, 0.6630109402051543, 0.6490749775085054, 0.6472427082068792, 0.6351192661183964, 0.6788813961365273, 0.6634262228622327, 0.6806522219379809, 0.6695164479116461, 0.6638615212627663, 0.1444726025173504, 0.2780146076604606, 0.2008846746381423, 0.338842180318093, 0.17710031849920238, 0.40906290915154164, 0.1294449574480634, 0.30410797422064995, 0.2595908753840699, 0.43669215023548447, 0.39847113866524997, 0.3960884595490616, 0.39919986765557147, 0.40631558963415504, 0.41494348315266694, 0.4097545338478663, 0.46638451272608006, 0.45345674862931096, 0.7226838404157323, 0.765675494699565, 0.741593543655044, 0.7481145900190296, 0.7519364741795496, 0.6908956095325829, 0.7603551408701515, 0.7703153579073386, 0.7695444293793146, 0.10832747516046115, 0.09738140211981006, 0.10523723735615809, 0.1070739659787392, 0.12306432588352145, 0.11442281420450995, 0.13176475286814637, 0.12007893715757656, 0.10529185530904306, 0.1888924274165643, 0.16858926044585876, 0.14234643555080673, 0.18055612494641649, 0.15727924161881635, 0.20445679761671032, 0.33071215692436473, 0.15508819802528362, 0.16715697765740611, 0.4318023744601982, 0.43437762433361093, 0.48190987287489406, 0.43189543732766533, 0.4601043147180486, 0.4232196249615494, 0.4595796478209254, 0.4831263905632661, 0.48836325466661834, 0.354300695569432, 0.3980186967113385, 0.40859293743634895, 0.3610035662377349, 0.4046030022633379, 0.3990034476337929, 0.4055293479277111, 0.3657090257115315, 0.3886070470572335, 0.2169423748875483, 0.19496175619333578, 0.19349262835918546, 0.1995903248808043, 0.20233671888124072, 0.27665228257832963, 0.19376620837212177, 0.19692604902727595, 0.20372837588842174, 0.21466581614831315, 0.2193543397454658, 0.20930371327304353, 0.19745566826701078, 0.44496542954781815, 0.18882586344887198, 0.24027510839002386, 0.20167113771819767, 0.19471835355933242, 0.6965333559710767, 0.7568061922703244, 0.78931676895802, 0.7507656520722855, 0.7461100923817171, 0.5791599601625368, 0.18475415454429056, 0.7853355288402495, 0.7536601750700977, 0.7847909163588758, 0.7483845740680242, 0.7320656129508702, 0.2056643138084281, 0.2043826344257903, 0.728839000285022, 0.20681399808989342, 0.7120288577538063, 0.20498226929620011, 0.18910798595018685, 0.20093551998939363, 0.19096185902122775, 0.1978988582751452, 0.21070597258250634, 0.21637460017290555, 0.19994769606993867, 0.1920559601523344, 0.17875353498197144, 0.09066245546716345, 0.08040791409248393, 0.07912015004773731, 0.08040013816261449, 0.0915828003781719, 0.07661038708694612, 0.08236997273139801, 0.08234392239518007, 0.09509356620749809]}, "mutation_prompt": null}
{"id": "e86586f3-5f4c-4a41-ace7-32fbd0c4ed04", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n        self.best_solution = None  # Track the best solution\n        \n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n        self.best_solution = population[np.argmin(fitness)].copy()\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    if candidate_fitness < prev_best_fitness:\n                        prev_best_fitness = candidate_fitness\n                        self.best_solution = candidate.copy()  # Update the best solution\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return self.best_solution, fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = (0.05 + 0.05 * np.random.rand()) * (self.upper_bound - self.lower_bound)  # Adaptive step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Introduce historical elitism and adaptive local search step size to enhance convergence and diversity.", "configspace": "", "generation": 30, "fitness": 0.4065416807022159, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "b6cbb782-4f12-4ab0-b590-f0a15ead8c28", "metadata": {"aucs": [0.8027591705500505, 0.7832306232761153, 0.8116120358932106, 0.7937455962074524, 0.8101058100453866, 0.8015581022971647, 0.8184128720550228, 0.8123478344078932, 0.7822107623846324, 0.6774421009903939, 0.6127369842173892, 0.6644037885950466, 0.6299784187830089, 0.6413279847130472, 0.661828399118324, 0.6379576476304551, 0.6775841316257799, 0.6253128520546483, 0.11063093289737846, 0.13300592893497376, 0.09857868832806349, 0.1139820928185723, 0.11222858393822022, 0.10771866635572136, 0.09646263306979619, 0.10275827843957464, 0.11450077636833211, 0.10824168061102502, 0.10362375950150526, 0.11031972618978325, 0.09441832467098088, 0.10237798471576975, 0.10303061029047988, 0.09820455708661524, 0.11231509181547406, 0.12665838112376582, 0.8800089044499185, 0.8907645894545438, 0.8387298654244595, 0.9320387713613528, 0.8937164333569321, 0.9341504959996141, 0.917307269274924, 0.942339197808592, 0.9431275831807173, 0.4379278382946691, 0.45790581514913864, 0.47052651839265247, 0.49252638220861045, 0.4784163982293965, 0.46153358972571246, 0.5136650201981261, 0.4297408134969467, 0.49009168480288623, 0.8057577698225663, 0.8508787457557558, 0.8147747624163709, 0.8265878773143939, 0.7815745132486407, 0.802096484949925, 0.7979876869624319, 0.7603384322158817, 0.8375807728159412, 0.2870787747961081, 0.14817063452496237, 0.19959190695943374, 0.2674514765771444, 0.23408534441821138, 0.1400565958334048, 0.3826548833333663, 0.2224943716201695, 0.2559865093176583, 0.16297910721317788, 0.22100753552361652, 0.39338090775771084, 0.28405503428838386, 0.25782981923151516, 0.19446631083992882, 0.22332453072988467, 0.3499001711335479, 0.3537372566578292, 0.5579107816731537, 0.5737987898642747, 0.5338417274793261, 0.5570788561927342, 0.5396286803669312, 0.5533365586108985, 0.586682749216389, 0.5038451043766534, 0.5115246646346805, 0.6440979063987198, 0.6795082665366743, 0.6669218822931227, 0.6607263726391776, 0.6975754920548927, 0.6356529786573458, 0.6638881070369885, 0.6827695804513154, 0.6356347647541778, 0.15111719609347096, 0.22730990479981927, 0.2837841991631985, 0.1741803279672426, 0.36168481783035444, 0.2395716288162557, 0.21182151411436234, 0.18449626635265937, 0.25784672802139985, 0.4429885686868016, 0.4683788918971147, 0.40711615023678915, 0.4001254571846632, 0.409478753842883, 0.42859120081565316, 0.4128075189825662, 0.4184271518474535, 0.43712813015465724, 0.7532848782523222, 0.7671683214077829, 0.7663703193951329, 0.717699545511167, 0.7441520638478145, 0.7562939570014082, 0.7674915252894711, 0.6869684696668931, 0.7641951830423424, 0.11609173424780306, 0.10304610233625566, 0.11264423049086092, 0.11493878320759465, 0.09660319571316978, 0.09361161673469598, 0.11437692067612149, 0.1130474267304673, 0.10334202645187174, 0.1440314022996434, 0.13588449809360048, 0.18408130156835034, 0.19540564866306154, 0.1413914726408806, 0.1861719834234301, 0.13862760123080176, 0.19431867815716886, 0.15807190858184206, 0.4502483700647564, 0.4178765387328426, 0.46918151586916745, 0.422481821469438, 0.44249734046167644, 0.4472985088165716, 0.5028037470023429, 0.4714375240863735, 0.47374274968302277, 0.39744907039847577, 0.3717615414333052, 0.4104581016274065, 0.4026545662260125, 0.4150508207356841, 0.3330014603239294, 0.3922839414955036, 0.4218440975197294, 0.38458732186064204, 0.21228905387987385, 0.1983754768941718, 0.22139588254455767, 0.21408130863573194, 0.21926803515750215, 0.21068315330711962, 0.2007313069317468, 0.20164740006297244, 0.19963523591667576, 0.2212648081313221, 0.1915741828573153, 0.21645578587185077, 0.2044708938440607, 0.19394274327436067, 0.29685843404090284, 0.18907760231989146, 0.19353692228407304, 0.20918885257437336, 0.16747429908543376, 0.7353898018435636, 0.1927396369795491, 0.776774840163175, 0.1891841752118989, 0.7786252059082324, 0.7799142633194802, 0.7513248110111919, 0.7826276409634827, 0.7742056184142803, 0.7122805038514894, 0.6009174532317056, 0.16306218053427346, 0.5732194149237533, 0.20018696574101047, 0.208751123410172, 0.1266377846469552, 0.20664039760321773, 0.19383640431894023, 0.17977186200953765, 0.19101947456628376, 0.21042107171076962, 0.19650505938241591, 0.1833408010802594, 0.18184802637152497, 0.18071665064948705, 0.1733280632314116, 0.09512130272801333, 0.07948828307577183, 0.08091423446060075, 0.08753977677204061, 0.0799469489450001, 0.08399747260012813, 0.09039589579278873, 0.0802594311334851, 0.07891437589696926]}, "mutation_prompt": null}
{"id": "8a996618-0adc-4016-95f2-3f18703270d6", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce a small adjustment to dynamically reduce local search probability as the budget depletes to balance exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.4306268096817026, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "b6cbb782-4f12-4ab0-b590-f0a15ead8c28", "metadata": {"aucs": [0.8135956938187164, 0.8143387694415902, 0.8168241201973848, 0.7938079397897959, 0.8291474533141736, 0.8148791457263325, 0.8050894186734511, 0.8012153102153469, 0.8159169540678238, 0.6657189909497503, 0.6663145283940088, 0.6671449990923008, 0.6592363801927981, 0.671491589399867, 0.6770386593211928, 0.6559947213157983, 0.6196040373735827, 0.6451518466071179, 0.15418494517626424, 0.10555036230131487, 0.10848227634334817, 0.12117604009764216, 0.11366897516020513, 0.10473648705590854, 0.10805116627060529, 0.1147369422779333, 0.11495000359289065, 0.11884260775021571, 0.1099075569390181, 0.12527953372828493, 0.11185956832898769, 0.09519012123674708, 0.10615361414998425, 0.10182248297041674, 0.11281507758024545, 0.09224727382735631, 0.9015454359172456, 0.9227631217755471, 0.8911605003749427, 0.9104732913394574, 0.8290424882110163, 0.8322119714934941, 0.9164627164608611, 0.8977277769863725, 0.883731179025389, 0.4734910568095524, 0.4762975859853368, 0.5506298272325403, 0.5086764698649171, 0.5030303732267298, 0.535614784658122, 0.4698979599792561, 0.5588646651383453, 0.48372534595790617, 0.7831329439976389, 0.8431684972092436, 0.8052768956338664, 0.8329651813170913, 0.8356055812254843, 0.8046070685500811, 0.8179147126143331, 0.8202582649643783, 0.8125800717447078, 0.2216664893787207, 0.1632478289150715, 0.24756803079602785, 0.1822211059035157, 0.32764026216440933, 0.19817478857882875, 0.5791878729199779, 0.21230391956967065, 0.6692000611195491, 0.5779767642751846, 0.25142309436976007, 0.19520893139572482, 0.5803503637428087, 0.5427566912939741, 0.26219743956920505, 0.3760871286638543, 0.2291151813286486, 0.2298336096241267, 0.5878901739424406, 0.5865264429552794, 0.4785649280018226, 0.5833436075335161, 0.5782605857062495, 0.5143832934539674, 0.5784976082643443, 0.5462868327001489, 0.5288470514554156, 0.6910439427791613, 0.6747513517158481, 0.6549164962635152, 0.6214038483777271, 0.6264380493046817, 0.6266745821459454, 0.6907511109006301, 0.6939686764210747, 0.667455599905132, 0.27279194835643816, 0.1674677898337642, 0.2718287483283016, 0.5070082319349071, 0.1889344390215646, 0.19667821732255175, 0.2926222898875719, 0.23525616453265485, 0.29288042715832774, 0.4599328462958764, 0.445781566769618, 0.4256449679285461, 0.4334033313450283, 0.46450855420715487, 0.4424173892712391, 0.4444095892791642, 0.49277808539238876, 0.42946496731971684, 0.766032393067495, 0.7770124098023178, 0.7594062079667592, 0.7571444334134757, 0.7515643976595254, 0.7885851288830578, 0.7565684548274472, 0.7573471177597372, 0.7673418002110403, 0.11487610598245623, 0.09545376708700692, 0.09470466418839185, 0.12326956455007254, 0.09907279479030295, 0.15654402586381544, 0.0961166094543201, 0.12355174315005257, 0.12512381946014373, 0.40726243247625704, 0.1756799539846583, 0.17160406409934625, 0.13602701178832177, 0.18197261152185695, 0.3079577026689382, 0.17284449798904533, 0.16101054016626604, 0.13254382182164393, 0.4436112738029687, 0.46322078783398124, 0.4582878975345851, 0.4536115382804794, 0.480920143121632, 0.47447120811826304, 0.4810989743423498, 0.4784259237102316, 0.4834773868999328, 0.3904133916858118, 0.4211243906302705, 0.39085697281702136, 0.4065028704451399, 0.3810067369049316, 0.34451612433076007, 0.37986026508262893, 0.4109066472214039, 0.42948321213608986, 0.1909266615752313, 0.1957806020467674, 0.24099865135600418, 0.21000745488809924, 0.19326984334832453, 0.18177572348331406, 0.20484022774546662, 0.19917908764601644, 0.21357741202430958, 0.21218904723986076, 0.1979529253719341, 0.3208751847707154, 0.2128581853585717, 0.2931777232943771, 0.3952082855295461, 0.2736846955664375, 0.30327051162508756, 0.20095115456241652, 0.6520082533225886, 0.204547070451518, 0.7506472005164979, 0.7455083274943406, 0.18424101048019437, 0.2064161024775113, 0.7896507673564934, 0.8057808062273237, 0.800285814082944, 0.7294995995271203, 0.6905102092094801, 0.7450888931880236, 0.20086181049605234, 0.7152372527515322, 0.8166478709955144, 0.2017346267236052, 0.7303828796325321, 0.2106812129333019, 0.19757874199144043, 0.18579941961528934, 0.18016704987448962, 0.183763172896809, 0.2046276990977507, 0.18704220404894245, 0.1962412406515942, 0.18482503263513395, 0.1894531691069945, 0.07387067930225699, 0.09394652880287335, 0.08345072349167171, 0.08050785924177017, 0.08718696735791942, 0.09664746790739243, 0.07386375435381831, 0.08673300676833318, 0.08802460927896738]}, "mutation_prompt": null}
{"id": "efd883eb-4863-4431-ae17-02efe948af3f", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, budget_used)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, budget_used):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * (1 - budget_used / self.budget)\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce adaptive step size during local search based on the diminishing proportion of the remaining budget.", "configspace": "", "generation": 32, "fitness": 0.4195519860922702, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "8a996618-0adc-4016-95f2-3f18703270d6", "metadata": {"aucs": [0.8162797029837437, 0.8224733988370749, 0.7861477970315719, 0.8121931896718343, 0.8179400574581595, 0.7926510849279156, 0.8069656857523091, 0.8123358102692506, 0.8078808460717687, 0.668659233694606, 0.6630674010646724, 0.647718300478006, 0.6536007036109163, 0.6481763149120632, 0.6599130475784499, 0.6462873278890898, 0.6525842844537115, 0.6601040016788042, 0.12601678810904027, 0.10070588488974541, 0.11506956717748129, 0.13997013050367602, 0.10661720373533679, 0.1155543129168971, 0.11336583066826134, 0.1015146162916637, 0.12740939235297843, 0.1183273569105393, 0.09297849951062165, 0.1117891578454333, 0.10611414067935343, 0.10077365525350779, 0.10964033350056157, 0.11006595495316285, 0.12452202003306356, 0.11746122763105726, 0.9427944043966874, 0.836496539196434, 0.9232422917712116, 0.8924871784915733, 0.8302938069351373, 0.9103256186372124, 0.9278390023274989, 0.8941728704413409, 0.9069320323269351, 0.5050840309374856, 0.47247676920525616, 0.41412632517090964, 0.47372586398053296, 0.48428760438330454, 0.4589674751509586, 0.4683808513248833, 0.5439584144190264, 0.538928683055885, 0.8054914145787297, 0.8032256647854138, 0.8054558988763786, 0.8172771083295737, 0.8015094761023189, 0.802840200065894, 0.7826540950014074, 0.8102518505503775, 0.815768249466171, 0.3114581806772744, 0.2554003726491215, 0.3507365235961295, 0.22034552892505688, 0.19932897028845042, 0.2618383485479808, 0.18610967755125907, 0.2611132177584219, 0.23227984040274363, 0.6706482668457201, 0.12531034086000603, 0.17347700529632126, 0.5933176672315252, 0.5258218689590426, 0.4352634238335322, 0.22892227057270087, 0.16360765146295742, 0.21145207956989776, 0.5517225896536868, 0.5564996777700799, 0.5702312586223454, 0.5440671546309195, 0.5338561686666687, 0.5624957013386382, 0.5947201391520078, 0.5603006832811165, 0.5726026539412379, 0.662785145579753, 0.6743448942410128, 0.6840659233379798, 0.6223573872758646, 0.6754925526923277, 0.7157900596145637, 0.699800595507716, 0.6630532105906624, 0.6715616919902907, 0.21084946403815896, 0.2549739921109002, 0.12694258274837378, 0.44824750773322486, 0.17617612335646704, 0.19529778718185553, 0.15318724809260853, 0.22015441357482524, 0.16009952737012245, 0.42742913744409716, 0.45510720042356, 0.40840439055964184, 0.42194731272323105, 0.46666928007714203, 0.43699572823804644, 0.4617667754964072, 0.42059420103253664, 0.41119390282413737, 0.7615333851489064, 0.7521067741126914, 0.7718061073474488, 0.7291307353441034, 0.756009036820255, 0.7622697857022624, 0.7392192416739389, 0.770096225691391, 0.7522024534228906, 0.15305350768415316, 0.10370565608316029, 0.10859135614770699, 0.10677908991503715, 0.10877629866755856, 0.10572890692329817, 0.11256244364286627, 0.09485219356349839, 0.1139071242797538, 0.16254724027451317, 0.14929827945402163, 0.1736947136101864, 0.1706551972454754, 0.17415114851634084, 0.1314874140147786, 0.13718847404840473, 0.14355088775525526, 0.21477150681080281, 0.47261561971225685, 0.44193885615469675, 0.43415460689898766, 0.4730609876806269, 0.4515137856274005, 0.5003665180380042, 0.48086875048996824, 0.5047437945507258, 0.4950686040771556, 0.3855733427753171, 0.3978661599248374, 0.4460653235274713, 0.39597393723463126, 0.41710835204823626, 0.4126747252519304, 0.3982035763812223, 0.43734351822848705, 0.3664416034318313, 0.19591191872408853, 0.21500492586601616, 0.18963109159284308, 0.20473006224000412, 0.2041717144541101, 0.19597893650709408, 0.20198200630522, 0.22584224944691011, 0.19732733190559304, 0.3875123995231846, 0.19307619282430577, 0.20152234898656096, 0.4057883060427985, 0.18879373760259266, 0.20548834404710647, 0.1882738522446039, 0.19010630260474282, 0.26369587444618847, 0.18172751155792077, 0.1835682266296531, 0.8276458781182858, 0.7531522026340045, 0.7384331357797729, 0.6910869481304542, 0.8374878496816036, 0.6710701824823694, 0.8212709455109746, 0.8071063139000438, 0.7698108464091824, 0.5928397364473206, 0.20652870902614462, 0.19814582826880667, 0.20811414385128713, 0.20711511468965027, 0.7518516730010918, 0.20829080812109768, 0.1935528877915753, 0.17970106933826646, 0.2006098275027891, 0.20072273503095117, 0.193126557051161, 0.17948175643010222, 0.205994994854789, 0.18870379611115662, 0.18613945459661385, 0.07813788258811727, 0.0889942428092998, 0.08505634116687111, 0.08462389093189249, 0.08262904180179809, 0.08197567651577697, 0.07562328461176204, 0.09234656600104629, 0.08438481608305848]}, "mutation_prompt": null}
{"id": "f44c52e5-0d65-4202-9aef-bd5dbff3f1c5", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Changed line\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Increase the mutation factor range to enhance exploration while maintaining exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.34593137195398077, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "8a996618-0adc-4016-95f2-3f18703270d6", "metadata": {"aucs": [0.7221936661765436, 0.6982402844142201, 0.7200374842017618, 0.7318467158270613, 0.7525206635058378, 0.7374566034906369, 0.7344001931498885, 0.7102904260533389, 0.6975928682325498, 0.49186842357368143, 0.4565318201062637, 0.49771831071848727, 0.5197093032093214, 0.5026004343405068, 0.4928029324039924, 0.497524110037566, 0.4768335903083005, 0.5309433885059416, 0.10138211178541501, 0.09174248516329808, 0.09633174253549437, 0.10282097732274764, 0.1012947576761386, 0.09912208023150182, 0.10374114203137375, 0.09311560527154383, 0.09305703163934409, 0.09074657853433854, 0.09666658263896555, 0.07548769554102797, 0.09584761615061432, 0.11414760031516491, 0.08027100627340111, 0.09840058725819145, 0.09829983871106907, 0.08794115623235543, 0.92976402541861, 0.8667486655093333, 0.8245467824155296, 0.9715021814159145, 0.982699719115975, 0.8765974163909056, 0.9159511064359537, 0.9165873220900284, 0.910014262015904, 0.35755230496192625, 0.3566480215231814, 0.3546623271472449, 0.3836732815738916, 0.34958250127756707, 0.40446077545943915, 0.36346284030733, 0.3845283987183382, 0.39305722163389545, 0.7099643209898314, 0.7340690262078631, 0.6991592898016521, 0.7756787760384927, 0.7642310613248152, 0.7596163946426692, 0.6719116336163375, 0.7201423804244124, 0.65580357051034, 0.22032472580443618, 0.3563078471499569, 0.2575640525949814, 0.29223096151745265, 0.3619276311942601, 0.32966162894663065, 0.3186959558686797, 0.24373803697641216, 0.41489115571544344, 0.32112761643863785, 0.363340956856509, 0.31499187725394573, 0.34925853770704196, 0.3443392649883159, 0.27285859954942404, 0.37348822303913687, 0.2765738516392162, 0.2910000948176994, 0.3453702828573296, 0.3519777710014912, 0.3260331426434029, 0.38248055912711065, 0.3632160605490815, 0.3689956802121306, 0.34960174314803205, 0.35810343033268, 0.33914586029294713, 0.4363100536536022, 0.46253098985172714, 0.5081545119589721, 0.45009034751868104, 0.45246109005637214, 0.46685497462909575, 0.5104262890473212, 0.5217194351523478, 0.4634632761768015, 0.1201511942368958, 0.1278596160423232, 0.16127932807940792, 0.208025209868287, 0.1801894682261722, 0.19666910293177198, 0.18694327458713667, 0.1507922219355412, 0.15655626414943913, 0.28630411955008406, 0.2667192601900067, 0.25204180852420965, 0.2787600915656646, 0.25247840218974626, 0.2803924995269762, 0.2725814257427366, 0.27893788962900257, 0.2795710519929928, 0.61953544146777, 0.6548931408615835, 0.6480337686519099, 0.6448912982911021, 0.6289662215600464, 0.6402652207529183, 0.6240943449204654, 0.6412917788734782, 0.6083306281854346, 0.0967728074782146, 0.09746351943636089, 0.09677125495889705, 0.10159835705814146, 0.08589606376141001, 0.09776953043641845, 0.08981879268729664, 0.08895354677708167, 0.08857545283122958, 0.18151539865195943, 0.1649580866794087, 0.15973826916603862, 0.24714505129157127, 0.17391316794290235, 0.15157009069427096, 0.15110595565439322, 0.25536264505987505, 0.14446957137390437, 0.3312263777891692, 0.33406608805752136, 0.3188995495341783, 0.339550126214466, 0.32501746282076716, 0.3283871925610532, 0.3476631999883186, 0.3488460844051833, 0.34247502292871745, 0.2659747197167377, 0.26370363339123737, 0.24481445299095383, 0.24241273636700922, 0.2831642848018805, 0.25627256795329845, 0.30773575693641575, 0.2719374394077294, 0.29552224777925484, 0.20484555707421082, 0.18712425501327412, 0.19552581623753817, 0.2144217200811589, 0.19902753784804983, 0.18295547250086097, 0.1919021610211532, 0.20305221435289167, 0.18542897162142347, 0.19473626271883615, 0.18403649865459892, 0.17917711958982896, 0.18141867716253346, 0.19033898618765277, 0.18686884265857018, 0.19681603912450785, 0.19113576419497869, 0.17997088466680522, 0.6345828013285294, 0.759213656640991, 0.7118758468158206, 0.18097404086251223, 0.5550807689505108, 0.6216870619292025, 0.1798222944032044, 0.18761028136732316, 0.43852086894022535, 0.19677377837585885, 0.6967957400564326, 0.6844455023156867, 0.1899714341781058, 0.18982517260844156, 0.6520221392203129, 0.20804373797828013, 0.20430661834545838, 0.2002497079497243, 0.17959920555812592, 0.1836859317715056, 0.18623512946913134, 0.17361728146964583, 0.18597215792740218, 0.17407440926588968, 0.18322074694300305, 0.19770328088174915, 0.19433166133631008, 0.07601031435248073, 0.07047028867257665, 0.06823854687235165, 0.07477468362038231, 0.07806409539509496, 0.08169605167965022, 0.0789420641727393, 0.07424144669725197, 0.06869429808012262]}, "mutation_prompt": null}
{"id": "b7740a7e-4aa0-48b1-8e31-c6c9d66fcdd7", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand() * (1 - self.local_search_probability)\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Refine local search by adjusting step size dynamically to improve exploitation.", "configspace": "", "generation": 34, "fitness": 0.42292883933419045, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "8a996618-0adc-4016-95f2-3f18703270d6", "metadata": {"aucs": [0.8062612612268443, 0.797876626616663, 0.8235660167191332, 0.8014929966561739, 0.8184706787722903, 0.7908311008200604, 0.808386122056406, 0.8049088425147526, 0.8108549236876791, 0.6967543236451192, 0.6710142552289715, 0.6641573727313237, 0.671734088666387, 0.6839334631744675, 0.6580545355834442, 0.685857290396208, 0.6506076639307528, 0.6775403385649823, 0.11725201993957413, 0.14305669156309464, 0.10204229037231705, 0.12202387751848598, 0.11938877556278349, 0.11247742765997792, 0.10447057982643915, 0.1190839120318975, 0.12095790332598577, 0.10347463661017087, 0.11533776596461831, 0.10566479434393095, 0.10189623057525643, 0.0960780181657177, 0.11021820943991534, 0.10932029575228641, 0.09591113534545403, 0.10727786051643162, 0.8522566857575767, 0.9224512548462123, 0.8104594545376714, 0.9234432629225516, 0.8914230730675066, 0.8517921177583662, 0.8873720675374428, 0.8934185469106443, 0.8814974071729764, 0.5377488651110085, 0.5119411421384313, 0.48392321539504735, 0.529878475603077, 0.45502738587667213, 0.4807414991576633, 0.44704245448010094, 0.321734795135848, 0.5419349495650302, 0.8214344221213412, 0.8247826817410615, 0.8047246792624775, 0.8342735891991292, 0.8131142534749961, 0.824631348099261, 0.8416152763334258, 0.8143735984906921, 0.8183458176495406, 0.2175976526192126, 0.48994207641410203, 0.18596387458352914, 0.24660951218424354, 0.4177101915582824, 0.28825257764783907, 0.2700726514184083, 0.265796681944535, 0.33845141117401945, 0.1762359555051244, 0.22652610383022853, 0.24400315031554642, 0.2752504655112359, 0.22516970703191752, 0.2174927645393515, 0.32261305872508717, 0.3000648285156675, 0.45124372913616084, 0.5724922942140153, 0.5318884698063886, 0.5608434636682271, 0.5436891945476172, 0.6077440264612797, 0.5490785115542597, 0.6185948837797463, 0.5952306565686667, 0.5856583219090676, 0.6560597310189671, 0.6849422828874543, 0.6584109158484719, 0.6755456055773773, 0.6822197791917208, 0.6468935678948129, 0.6648004546833415, 0.6772272224109904, 0.7044089430173834, 0.0907832567145489, 0.21718054103844375, 0.15204462347374814, 0.4657273251179378, 0.4122420531982126, 0.465515245777932, 0.17811786688362152, 0.21804897267195156, 0.18490359117639033, 0.4419019035366182, 0.42258311039187446, 0.443748905200117, 0.4493614103826994, 0.4385146184500833, 0.4382035136642819, 0.4281164577735863, 0.40690812153808875, 0.45355955336770104, 0.7642019662378641, 0.7706113914133101, 0.7688556777364458, 0.7677392286968755, 0.7783092009426338, 0.7669295121676943, 0.7659041351914928, 0.7574509730966626, 0.7552118756452155, 0.11381796529026056, 0.11987156438046187, 0.11653486401000812, 0.11743945597370153, 0.08797916119517946, 0.118601823347943, 0.09671729636665805, 0.12845402987480248, 0.1982244482151686, 0.35311799384323017, 0.18049770603411652, 0.19292662136082916, 0.1928863268600829, 0.1832903714822347, 0.2524342592274409, 0.17773415067243514, 0.17990170557355523, 0.180221696575104, 0.453321997981295, 0.4592621831445808, 0.4477108602970463, 0.4686128279991256, 0.43993683700653496, 0.4527545628480014, 0.4958266182892188, 0.5078138747536032, 0.513858956698961, 0.3872815164926172, 0.36000028965074693, 0.37018007768539996, 0.33419693877733614, 0.4051090947531455, 0.4243171367324493, 0.44633882742295994, 0.38470313759824304, 0.37192605318220107, 0.18325102533969517, 0.21469891333000313, 0.18014811430527755, 0.199886468539075, 0.18819208073299631, 0.196636878448458, 0.2152194872000619, 0.20925812298869761, 0.1987989795180629, 0.36441597926113944, 0.20472387597553476, 0.25830381202415775, 0.41023023924456725, 0.19388357542370604, 0.21778223888974213, 0.21316500408754502, 0.18828043913367487, 0.21397753009302878, 0.1835072754473973, 0.7006066245667899, 0.7724214243351546, 0.7609606808525265, 0.1919924898421702, 0.20289092001931208, 0.7983653360278948, 0.7782945371556744, 0.7817034012229445, 0.7062706691548764, 0.8032819190392675, 0.16628392649888557, 0.2038350886291861, 0.20375415914689643, 0.7920150344338882, 0.565227852554138, 0.8117060662863407, 0.21070903158218124, 0.19075554207721246, 0.20170107345497568, 0.1876074992748027, 0.1796110688973862, 0.18755215171607387, 0.18561061344880492, 0.1880287031280954, 0.17509396992884008, 0.18995160357475172, 0.08902032138162053, 0.07638301151420857, 0.08353636575562595, 0.07934605347272883, 0.08967153314181464, 0.07395241818644649, 0.08050606137220073, 0.0836833830235677, 0.08511909587629995]}, "mutation_prompt": null}
{"id": "2197df71-59cf-455f-8774-b866b7f8e943", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = (0.1 + 0.9 * (1 - self.budget / self.budget)) * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce a gradual increase in local search step size as the budget depletes to enhance fine-tuning near convergence.", "configspace": "", "generation": 35, "fitness": 0.4306268096817026, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "8a996618-0adc-4016-95f2-3f18703270d6", "metadata": {"aucs": [0.8135956938187164, 0.8143387694415902, 0.8168241201973848, 0.7938079397897959, 0.8291474533141736, 0.8148791457263325, 0.8050894186734511, 0.8012153102153469, 0.8159169540678238, 0.6657189909497503, 0.6663145283940088, 0.6671449990923008, 0.6592363801927981, 0.671491589399867, 0.6770386593211928, 0.6559947213157983, 0.6196040373735827, 0.6451518466071179, 0.15418494517626424, 0.10555036230131487, 0.10848227634334817, 0.12117604009764216, 0.11366897516020513, 0.10473648705590854, 0.10805116627060529, 0.1147369422779333, 0.11495000359289065, 0.11884260775021571, 0.1099075569390181, 0.12527953372828493, 0.11185956832898769, 0.09519012123674708, 0.10615361414998425, 0.10182248297041674, 0.11281507758024545, 0.09224727382735631, 0.9015454359172456, 0.9227631217755471, 0.8911605003749427, 0.9104732913394574, 0.8290424882110163, 0.8322119714934941, 0.9164627164608611, 0.8977277769863725, 0.883731179025389, 0.4734910568095524, 0.4762975859853368, 0.5506298272325403, 0.5086764698649171, 0.5030303732267298, 0.535614784658122, 0.4698979599792561, 0.5588646651383453, 0.48372534595790617, 0.7831329439976389, 0.8431684972092436, 0.8052768956338664, 0.8329651813170913, 0.8356055812254843, 0.8046070685500811, 0.8179147126143331, 0.8202582649643783, 0.8125800717447078, 0.2216664893787207, 0.1632478289150715, 0.24756803079602785, 0.1822211059035157, 0.32764026216440933, 0.19817478857882875, 0.5791878729199779, 0.21230391956967065, 0.6692000611195491, 0.5779767642751846, 0.25142309436976007, 0.19520893139572482, 0.5803503637428087, 0.5427566912939741, 0.26219743956920505, 0.3760871286638543, 0.2291151813286486, 0.2298336096241267, 0.5878901739424406, 0.5865264429552794, 0.4785649280018226, 0.5833436075335161, 0.5782605857062495, 0.5143832934539674, 0.5784976082643443, 0.5462868327001489, 0.5288470514554156, 0.6910439427791613, 0.6747513517158481, 0.6549164962635152, 0.6214038483777271, 0.6264380493046817, 0.6266745821459454, 0.6907511109006301, 0.6939686764210747, 0.667455599905132, 0.27279194835643816, 0.1674677898337642, 0.2718287483283016, 0.5070082319349071, 0.1889344390215646, 0.19667821732255175, 0.2926222898875719, 0.23525616453265485, 0.29288042715832774, 0.4599328462958764, 0.445781566769618, 0.4256449679285461, 0.4334033313450283, 0.46450855420715487, 0.4424173892712391, 0.4444095892791642, 0.49277808539238876, 0.42946496731971684, 0.766032393067495, 0.7770124098023178, 0.7594062079667592, 0.7571444334134757, 0.7515643976595254, 0.7885851288830578, 0.7565684548274472, 0.7573471177597372, 0.7673418002110403, 0.11487610598245623, 0.09545376708700692, 0.09470466418839185, 0.12326956455007254, 0.09907279479030295, 0.15654402586381544, 0.0961166094543201, 0.12355174315005257, 0.12512381946014373, 0.40726243247625704, 0.1756799539846583, 0.17160406409934625, 0.13602701178832177, 0.18197261152185695, 0.3079577026689382, 0.17284449798904533, 0.16101054016626604, 0.13254382182164393, 0.4436112738029687, 0.46322078783398124, 0.4582878975345851, 0.4536115382804794, 0.480920143121632, 0.47447120811826304, 0.4810989743423498, 0.4784259237102316, 0.4834773868999328, 0.3904133916858118, 0.4211243906302705, 0.39085697281702136, 0.4065028704451399, 0.3810067369049316, 0.34451612433076007, 0.37986026508262893, 0.4109066472214039, 0.42948321213608986, 0.1909266615752313, 0.1957806020467674, 0.24099865135600418, 0.21000745488809924, 0.19326984334832453, 0.18177572348331406, 0.20484022774546662, 0.19917908764601644, 0.21357741202430958, 0.21218904723986076, 0.1979529253719341, 0.3208751847707154, 0.2128581853585717, 0.2931777232943771, 0.3952082855295461, 0.2736846955664375, 0.30327051162508756, 0.20095115456241652, 0.6520082533225886, 0.204547070451518, 0.7506472005164979, 0.7455083274943406, 0.18424101048019437, 0.2064161024775113, 0.7896507673564934, 0.8057808062273237, 0.800285814082944, 0.7294995995271203, 0.6905102092094801, 0.7450888931880236, 0.20086181049605234, 0.7152372527515322, 0.8166478709955144, 0.2017346267236052, 0.7303828796325321, 0.2106812129333019, 0.19757874199144043, 0.18579941961528934, 0.18016704987448962, 0.183763172896809, 0.2046276990977507, 0.18704220404894245, 0.1962412406515942, 0.18482503263513395, 0.1894531691069945, 0.07387067930225699, 0.09394652880287335, 0.08345072349167171, 0.08050785924177017, 0.08718696735791942, 0.09664746790739243, 0.07386375435381831, 0.08673300676833318, 0.08802460927896738]}, "mutation_prompt": null}
{"id": "fc96001b-d9b5-45d5-a2c4-cfc56b802d9d", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        diversity = np.std(population, axis=0).mean()\n        self.mutation_factor = 0.2 + (np.random.rand() * 0.6) * diversity\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Refine mutation factor adaptation by adding population diversity consideration to enhance exploration-exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.29016623426731686, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "8a996618-0adc-4016-95f2-3f18703270d6", "metadata": {"aucs": [0.5850466112360335, 0.6090149054354943, 0.5714705271711147, 0.6382886140834532, 0.47409077434967517, 0.6265184234063945, 0.48705096829612426, 0.5176326291636038, 0.5637437513962011, 0.3071375761218478, 0.29468484330985933, 0.26025995104599464, 0.4517969819882658, 0.21306320396829392, 0.2506508984793032, 0.39295982672905705, 0.21023987278742162, 0.23040296612931588, 0.1349294459338033, 0.11094689923502687, 0.1294250233663259, 0.10197931960933693, 0.11511666211334193, 0.10516801407378518, 0.13429505890148974, 0.1469283224585517, 0.14893595581395935, 0.09921717592091284, 0.09022676283202691, 0.125376229876765, 0.10883513213387763, 0.1265503621295746, 0.1104481713700487, 0.1024189173365525, 0.11101360433835239, 0.11419949522400874, 0.9550987839058144, 0.9146242423767269, 0.9572177623980774, 0.9899984088786065, 0.9750029186767374, 0.9084950840188373, 0.9639617951120624, 0.959463078542512, 0.9812392647057017, 0.26594318260082606, 0.2616452292148378, 0.2570816548564362, 0.24000523859048695, 0.21038858231128266, 0.2766085358304705, 0.24240985963491135, 0.2084639385824576, 0.18305862800811312, 0.8525243539173418, 0.35597697550872864, 0.32301033241462396, 0.259569131678809, 0.828423237272908, 0.8031883889866944, 0.2212259317925349, 0.7704620301746486, 0.8022886606581094, 0.43006085928606985, 0.1334081255467643, 0.13921577505709704, 0.286140375063733, 0.17573996921962554, 0.162668591309301, 0.1996664353328208, 0.13619033879858633, 0.147663501146178, 0.12085884132866831, 0.24634332673974202, 0.11662106846694165, 0.1417959252491866, 0.13112436544599204, 0.13281400392769227, 0.13514843328667447, 0.12923918404769863, 0.17589064123758524, 0.21974725457693767, 0.26109547958007007, 0.24726864738869658, 0.31075417060414134, 0.23175952972678238, 0.4067663630000632, 0.24041989996290902, 0.13007676918042055, 0.2581027988690643, 0.36166718433046696, 0.2875873176739916, 0.2580622418565083, 0.2875839479335802, 0.27300504809593973, 0.3351076870494115, 0.3125457521764383, 0.37988717658304627, 0.22600025673600843, 0.18545667368172392, 0.1450149125432184, 0.12098745868354366, 0.12614034790429218, 0.13206795063795274, 0.24196842383844108, 0.09670091582469997, 0.14612366982588265, 0.1181875749025818, 0.22671813264829965, 0.1892475069768329, 0.10208486250154947, 0.1982926122046238, 0.3251284948011135, 0.19141933858608884, 0.11619192477167561, 0.316041826166768, 0.16431640995368613, 0.48633805563902366, 0.4090105746440701, 0.6009281769516133, 0.41087320941988403, 0.4486518184023446, 0.4472038633697458, 0.40763117345130373, 0.4476151812468967, 0.4968267304299816, 0.1256461199238269, 0.09900009729446302, 0.11732400018623534, 0.1339662278636975, 0.0992276225505837, 0.10876686838460958, 0.11877346642347164, 0.13410911988417173, 0.11631059031032964, 0.20125689630289756, 0.26979781571533057, 0.1511222877669659, 0.21389106950521097, 0.20422574902154378, 0.21335832654879816, 0.1575701323918265, 0.2256479555764357, 0.2416215081100751, 0.3262091765257794, 0.3231090208334947, 0.3744656833185258, 0.3636267857194603, 0.3320876079140308, 0.42032020212355214, 0.39383109968931984, 0.38191293591541053, 0.33783686876316166, 0.3679955324742158, 0.34391835910694835, 0.28359457872439675, 0.2719812760432183, 0.2938927523360235, 0.41239305211486377, 0.3230970976837174, 0.321208499729, 0.33920178835202186, 0.18610111917539052, 0.1883645441061591, 0.19044541514746072, 0.17484682003704421, 0.18847583472596197, 0.20105917320118216, 0.18146724311198725, 0.19460058115027712, 0.1794109398985294, 0.2844885739018841, 0.19963365355126383, 0.2011547198644753, 0.22615556338750498, 0.33115553817307164, 0.2297217058955111, 0.22425236555515848, 0.2647135948497924, 0.29380827049791514, 0.17596089444414664, 0.5638575982412387, 0.16263480005594988, 0.3656842056615409, 0.1860055209175101, 0.590536446643127, 0.4139790337227066, 0.17409741167829418, 0.3560731621116129, 0.1955493193630523, 0.1632647006854301, 0.7309086243988173, 0.44440466470754614, 0.46848686010592466, 0.26718162886779007, 0.20557440147465167, 0.26929205876862705, 0.20963761206094655, 0.17599493471910121, 0.16858097892942858, 0.18364026529160515, 0.19151063648933853, 0.19636817710279386, 0.18473468904393509, 0.2175106146076723, 0.18154724244517206, 0.18554302002024303, 0.09307363803336044, 0.07232347555139462, 0.08882006508470752, 0.07479790024807664, 0.08520517057877863, 0.08695239711294289, 0.0750053714987553, 0.07529223590926326, 0.08108880356961179]}, "mutation_prompt": null}
{"id": "0f11e6ac-6265-4729-85f8-5fc9bca7cccf", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Adjust mutation factor range to improve diversity during search.", "configspace": "", "generation": 37, "fitness": 0.4313770069906629, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "8a996618-0adc-4016-95f2-3f18703270d6", "metadata": {"aucs": [0.8202799364399475, 0.7998509741280725, 0.815486235725086, 0.8068952744018346, 0.817144687741465, 0.8040987206136069, 0.8045142845607633, 0.7884630301336781, 0.7869867685560175, 0.6536300379351168, 0.6780055872788453, 0.6352700904698971, 0.6566359680912146, 0.6498652133237274, 0.6467562366441237, 0.6577416489934151, 0.6800565079386836, 0.6087511372575515, 0.358157386790676, 0.13075243479670318, 0.2100686021084609, 0.318259946020667, 0.15031537109490312, 0.13100202301415464, 0.13546425655769778, 0.2484304808657667, 0.11938467308874845, 0.12097697217913606, 0.11600329059431025, 0.11343702148484625, 0.11542464704210365, 0.1161565963156912, 0.1377659209473524, 0.11104680978648229, 0.1400073652579622, 0.13675805552651676, 0.8632844938312947, 0.9124035232166433, 0.8440794793078715, 0.9085405641924624, 0.866838500707485, 0.9502497910323774, 0.9098470806767526, 0.8777885017568545, 0.9482082687411901, 0.5000324389325752, 0.488080835272343, 0.47842156715075657, 0.47840137201041766, 0.49988842444719983, 0.4754276580619784, 0.4910508864046301, 0.5085124960619223, 0.4512683801235511, 0.8774199454519244, 0.813911760658639, 0.8073154518074982, 0.8139046928055356, 0.8174021909523854, 0.7942609877099991, 0.8202145230069285, 0.7997810986260869, 0.8417870371023809, 0.3045260009978692, 0.3505706090551596, 0.43413275726937395, 0.40861475382959733, 0.5021225337706411, 0.34548597551021065, 0.4066940162926237, 0.2803516017852751, 0.4581160314581817, 0.23244521595217849, 0.6337898105309834, 0.19572385759727273, 0.401737710821086, 0.3355200219171016, 0.12426619054688803, 0.43653772273419733, 0.33996936245746, 0.17578212104959434, 0.5789163204391718, 0.5878238759008012, 0.5591201753066499, 0.6143268893578185, 0.6057275990695878, 0.5828449848502409, 0.601724043217813, 0.6100563646390482, 0.6416307312876737, 0.6418161563363798, 0.602511588993552, 0.6715518160416107, 0.6733112740018498, 0.6589398513149596, 0.5993780416336998, 0.6330295145947242, 0.696297080862307, 0.6112205719134496, 0.15299795339115685, 0.13414716504478819, 0.2364658246363549, 0.22572658044879512, 0.44436473073066785, 0.42217771612905297, 0.3142081052874217, 0.12583442052184268, 0.1514975576759271, 0.4857415172072881, 0.4587153293029391, 0.4797009496543364, 0.44331132772135196, 0.4159124854561185, 0.4437009900549147, 0.44129781582845373, 0.46270983859170933, 0.44849424955390205, 0.7612378728510938, 0.7655702829237021, 0.7731895244205593, 0.7499387693480621, 0.7608385880577686, 0.7840697140932723, 0.7672011306316028, 0.7532344976004186, 0.7653675517901456, 0.12478496314058662, 0.2621823983017225, 0.10863413674113431, 0.13457947271229964, 0.1255212546736144, 0.12685869683276818, 0.10801596541293745, 0.13337224689528537, 0.1330072720466685, 0.16660976208464473, 0.16608765150094185, 0.21704327985932914, 0.5007898288444976, 0.15688713446853164, 0.18066172071140318, 0.18610348554423994, 0.1557506988540195, 0.16781758165470673, 0.4539266558439653, 0.4724953120344795, 0.4534958008669562, 0.47617698460941726, 0.4596372903149807, 0.4954333663380399, 0.4808848877747851, 0.47371832232510147, 0.5140689710965234, 0.37055601862473786, 0.36821401999456915, 0.31558370011533765, 0.4250895955289701, 0.38297225635250554, 0.45349880602104453, 0.4041858487753114, 0.3875369689169228, 0.4077893159511705, 0.2023477539563271, 0.21203987581160288, 0.19425579456242625, 0.19402885151706806, 0.19585370795684787, 0.199399971267484, 0.20587840757603437, 0.25094985735270037, 0.20555187174841505, 0.24302330760987112, 0.20277910878956296, 0.4311902457230802, 0.3068521614241412, 0.21348763624188283, 0.4111803919195105, 0.30356635982387903, 0.19974817416719648, 0.22250412416722187, 0.20462729626749754, 0.1858543043354307, 0.8230169919713922, 0.827588776183953, 0.701389627152748, 0.8140624965570362, 0.7003570204266494, 0.1765122536476179, 0.7857915941104432, 0.2053770086554857, 0.7900232616591963, 0.8105962047536222, 0.1998020319617001, 0.19189549896528613, 0.16430588707655003, 0.2007495398659831, 0.7893146324249003, 0.20968151266587942, 0.1750635501928287, 0.18614341651496247, 0.18800986551470555, 0.2098625802950742, 0.1832656838544272, 0.18744017378011357, 0.19348918966328688, 0.1949311675777441, 0.1924059874007289, 0.07848593161233619, 0.08446213341680253, 0.08224322213319868, 0.09167290931672156, 0.08412322474460887, 0.08909264795699567, 0.08540316805666914, 0.09168561948623433, 0.09166602035940308]}, "mutation_prompt": null}
{"id": "9c8ad2d4-c0a7-4f7d-b306-3cb25541f773", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.4 + 0.6 * np.random.rand()  # Adaptive mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce adaptive mutation factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.34593137195398077, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "0f11e6ac-6265-4729-85f8-5fc9bca7cccf", "metadata": {"aucs": [0.7221936661765436, 0.6982402844142201, 0.7200374842017618, 0.7318467158270613, 0.7525206635058378, 0.7374566034906369, 0.7344001931498885, 0.7102904260533389, 0.6975928682325498, 0.49186842357368143, 0.4565318201062637, 0.49771831071848727, 0.5197093032093214, 0.5026004343405068, 0.4928029324039924, 0.497524110037566, 0.4768335903083005, 0.5309433885059416, 0.10138211178541501, 0.09174248516329808, 0.09633174253549437, 0.10282097732274764, 0.1012947576761386, 0.09912208023150182, 0.10374114203137375, 0.09311560527154383, 0.09305703163934409, 0.09074657853433854, 0.09666658263896555, 0.07548769554102797, 0.09584761615061432, 0.11414760031516491, 0.08027100627340111, 0.09840058725819145, 0.09829983871106907, 0.08794115623235543, 0.92976402541861, 0.8667486655093333, 0.8245467824155296, 0.9715021814159145, 0.982699719115975, 0.8765974163909056, 0.9159511064359537, 0.9165873220900284, 0.910014262015904, 0.35755230496192625, 0.3566480215231814, 0.3546623271472449, 0.3836732815738916, 0.34958250127756707, 0.40446077545943915, 0.36346284030733, 0.3845283987183382, 0.39305722163389545, 0.7099643209898314, 0.7340690262078631, 0.6991592898016521, 0.7756787760384927, 0.7642310613248152, 0.7596163946426692, 0.6719116336163375, 0.7201423804244124, 0.65580357051034, 0.22032472580443618, 0.3563078471499569, 0.2575640525949814, 0.29223096151745265, 0.3619276311942601, 0.32966162894663065, 0.3186959558686797, 0.24373803697641216, 0.41489115571544344, 0.32112761643863785, 0.363340956856509, 0.31499187725394573, 0.34925853770704196, 0.3443392649883159, 0.27285859954942404, 0.37348822303913687, 0.2765738516392162, 0.2910000948176994, 0.3453702828573296, 0.3519777710014912, 0.3260331426434029, 0.38248055912711065, 0.3632160605490815, 0.3689956802121306, 0.34960174314803205, 0.35810343033268, 0.33914586029294713, 0.4363100536536022, 0.46253098985172714, 0.5081545119589721, 0.45009034751868104, 0.45246109005637214, 0.46685497462909575, 0.5104262890473212, 0.5217194351523478, 0.4634632761768015, 0.1201511942368958, 0.1278596160423232, 0.16127932807940792, 0.208025209868287, 0.1801894682261722, 0.19666910293177198, 0.18694327458713667, 0.1507922219355412, 0.15655626414943913, 0.28630411955008406, 0.2667192601900067, 0.25204180852420965, 0.2787600915656646, 0.25247840218974626, 0.2803924995269762, 0.2725814257427366, 0.27893788962900257, 0.2795710519929928, 0.61953544146777, 0.6548931408615835, 0.6480337686519099, 0.6448912982911021, 0.6289662215600464, 0.6402652207529183, 0.6240943449204654, 0.6412917788734782, 0.6083306281854346, 0.0967728074782146, 0.09746351943636089, 0.09677125495889705, 0.10159835705814146, 0.08589606376141001, 0.09776953043641845, 0.08981879268729664, 0.08895354677708167, 0.08857545283122958, 0.18151539865195943, 0.1649580866794087, 0.15973826916603862, 0.24714505129157127, 0.17391316794290235, 0.15157009069427096, 0.15110595565439322, 0.25536264505987505, 0.14446957137390437, 0.3312263777891692, 0.33406608805752136, 0.3188995495341783, 0.339550126214466, 0.32501746282076716, 0.3283871925610532, 0.3476631999883186, 0.3488460844051833, 0.34247502292871745, 0.2659747197167377, 0.26370363339123737, 0.24481445299095383, 0.24241273636700922, 0.2831642848018805, 0.25627256795329845, 0.30773575693641575, 0.2719374394077294, 0.29552224777925484, 0.20484555707421082, 0.18712425501327412, 0.19552581623753817, 0.2144217200811589, 0.19902753784804983, 0.18295547250086097, 0.1919021610211532, 0.20305221435289167, 0.18542897162142347, 0.19473626271883615, 0.18403649865459892, 0.17917711958982896, 0.18141867716253346, 0.19033898618765277, 0.18686884265857018, 0.19681603912450785, 0.19113576419497869, 0.17997088466680522, 0.6345828013285294, 0.759213656640991, 0.7118758468158206, 0.18097404086251223, 0.5550807689505108, 0.6216870619292025, 0.1798222944032044, 0.18761028136732316, 0.43852086894022535, 0.19677377837585885, 0.6967957400564326, 0.6844455023156867, 0.1899714341781058, 0.18982517260844156, 0.6520221392203129, 0.20804373797828013, 0.20430661834545838, 0.2002497079497243, 0.17959920555812592, 0.1836859317715056, 0.18623512946913134, 0.17361728146964583, 0.18597215792740218, 0.17407440926588968, 0.18322074694300305, 0.19770328088174915, 0.19433166133631008, 0.07601031435248073, 0.07047028867257665, 0.06823854687235165, 0.07477468362038231, 0.07806409539509496, 0.08169605167965022, 0.0789420641727393, 0.07424144669725197, 0.06869429808012262]}, "mutation_prompt": null}
{"id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce dynamic adjustment of the population size to improve exploration and exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.4387521548224066, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "0f11e6ac-6265-4729-85f8-5fc9bca7cccf", "metadata": {"aucs": [0.8151022435748793, 0.8034991048983169, 0.8201382026519154, 0.8130194617466889, 0.8304775974368135, 0.8160944524522008, 0.8064588676714559, 0.7963818598016055, 0.8220584365266815, 0.6636092898721418, 0.6926280023759248, 0.6704610564607814, 0.680777214322313, 0.684187432834649, 0.6793749558224311, 0.6888911512375773, 0.6637996132000905, 0.6583020318612021, 0.12680687489090214, 0.12451133354096433, 0.13004517128710336, 0.1366716953795245, 0.1251040294335093, 0.11162836670251508, 0.1562761507399011, 0.13119537961413497, 0.2158335870208805, 0.11006480220790549, 0.1340432905670037, 0.1371728419486703, 0.13712842133488812, 0.1213887926092242, 0.12330338357336745, 0.1317465119325547, 0.13306375268459647, 0.10172249324647453, 0.8785923560029124, 0.8401746627507677, 0.895625743143637, 0.8841955591157181, 0.8287716781578456, 0.9502497910323774, 0.8716582905750875, 0.8206543752311221, 0.9482082687411901, 0.5669408317171312, 0.5304067588286925, 0.46156293824820616, 0.5208225263920526, 0.5389303361527622, 0.4400887439697283, 0.4561505469210151, 0.5297504037196028, 0.4789170556337381, 0.8282382995679423, 0.8311955246525095, 0.81699151996263, 0.800275855124035, 0.8296924146092343, 0.8256123353385083, 0.8355050423879866, 0.8235006917251717, 0.855836102700263, 0.18935750911477867, 0.2636993189535165, 0.28235244193372133, 0.392458980289928, 0.2973067115612573, 0.18089196427276366, 0.6491982692628596, 0.23400744146600116, 0.2622892854778083, 0.2026107513023836, 0.5811956719358069, 0.16522310910177818, 0.24503152080413837, 0.18420843929298225, 0.6257696745233865, 0.5084072910110438, 0.4357807230285382, 0.3167698867799993, 0.6325739590915997, 0.633826110983693, 0.5761431593354673, 0.6107613297319507, 0.655953734616038, 0.5760277444971775, 0.6284995050505382, 0.6213099948377205, 0.6339672682331574, 0.6867995853819786, 0.5982791087774513, 0.6809840541075094, 0.7056766880291664, 0.6483045218553427, 0.644223240283911, 0.7215325898944467, 0.7314819970882123, 0.676776273939983, 0.1466910125320139, 0.07639085169028037, 0.2505279890265216, 0.48292246926617977, 0.4815806099771004, 0.16330403965965323, 0.15882871161563217, 0.34113547059181326, 0.24878657777410196, 0.464412898464054, 0.5034274469313136, 0.4201964109466706, 0.4690356228082724, 0.4006600552039812, 0.45434661974819146, 0.466959937768854, 0.5088917149739547, 0.4553802378254611, 0.7745501696752333, 0.7742221874896635, 0.8093373564634734, 0.7758918115082368, 0.7842048222117926, 0.7816482214031373, 0.7567655342689453, 0.771243936493528, 0.7590232336994429, 0.12292188308639451, 0.12433726325889616, 0.11961627765527938, 0.11049264616882415, 0.13863926546341554, 0.4625304610364147, 0.11888074890859568, 0.10702708594593258, 0.1590537730808994, 0.18633219422020397, 0.19037767440847198, 0.4318517321502642, 0.3365061450731942, 0.1534299636496722, 0.17952014673053596, 0.19918641748549604, 0.18748285519425334, 0.18778114046811512, 0.46981635135405153, 0.42503930870201734, 0.5258623607691513, 0.4670211201963108, 0.5037360811051619, 0.47913208079654224, 0.4794204187564167, 0.47496304561030134, 0.5300351082300665, 0.38303756427612545, 0.42354558847025914, 0.4102552786938374, 0.41237212251468824, 0.4253910849650092, 0.3929446473113204, 0.4404063121474866, 0.4226664499750026, 0.3962733122398955, 0.19945007208544074, 0.19046102727021885, 0.18718451232009392, 0.21358670934783008, 0.2071700987810997, 0.19681926793054172, 0.201599932361061, 0.20525223665875447, 0.21494354337893395, 0.23261347776250263, 0.2083375887993929, 0.35165907397847307, 0.1903360844906773, 0.21597119009413213, 0.5521762160305829, 0.20278280826349848, 0.22595496114476132, 0.2127228333707024, 0.2044105324932124, 0.18589481190920532, 0.8190424777382361, 0.8508622064837585, 0.651710899788204, 0.8108889344579135, 0.7696013232330992, 0.7625487646259269, 0.7568489056997466, 0.45124026074468215, 0.7950416095126175, 0.8395711239066544, 0.2010691731917955, 0.1981982876505377, 0.16429181567498852, 0.20165221602220185, 0.8159397675003429, 0.20976526088836367, 0.1904319732553903, 0.1888591138209772, 0.18491324078889004, 0.2072155347194321, 0.1806285103725015, 0.18367099601869075, 0.18939118360132456, 0.18437850773904874, 0.1825307277013566, 0.07693741069140725, 0.08356702850437381, 0.08302947023000362, 0.08352866346579324, 0.0848474534034791, 0.09337527178783545, 0.0919269015530112, 0.07745994477380425, 0.08672528179461036]}, "mutation_prompt": null}
{"id": "b896a4cb-5e98-4ce1-8fc1-3900e4c07dc5", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  \n            if budget_used % (self.budget // 10) == 0:  \n                self.population_size = max(4, int(self.population_size * 0.95))  \n            # Compute fitness diversity for adaptive mutation\n            fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness, fitness_diversity)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            # Implement elitism\n            elite_index = np.argmin(fitness)\n            current_best_fitness = fitness[elite_index]\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness, fitness_diversity):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        # Adapt mutation factor based on fitness diversity\n        self.mutation_factor = 0.1 + fitness_diversity * 0.7\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Introduce adaptive mutation factor based on fitness diversity and employ elitism to retain the best solutions.", "configspace": "", "generation": 40, "fitness": 0.20820696881060846, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.3848804003206605, 0.4115437579730772, 0.4206785579993412, 0.41460822088070004, 0.45609889165537043, 0.4775423900253152, 0.40068466591511465, 0.4028210860783008, 0.2952010675978497, 0.03813937094818354, 0.07111854089113256, 0.025551295162634435, 0.02011347143265707, 0.04499959977987078, 0.08207339716174888, 0.07061012541001799, 0.027478835480925445, 0.036193909400079605, 0.13062589908854383, 0.13380699402824214, 0.17967525091116043, 0.135987542024546, 0.14523267987581934, 0.13811227516306768, 0.1564857247334881, 0.309418136105613, 0.16899988231288066, 0.07016224004977356, 0.07254407745094904, 0.09636765617267284, 0.12660872513986288, 0.13712956287473665, 0.0875160227679902, 0.1473519483308635, 0.1043984197331882, 0.07973776516463027, 0.8348264757629874, 0.9394531897192198, 0.9193208839718048, 0.701203818274621, 0.8103535146442067, 0.7783211606926044, 0.8916313227019458, 0.7861521696544258, 0.6682877971289567, 0.22979721686258425, 0.3348832352982427, 0.2608682133004081, 0.4466714469656877, 0.24015750661874113, 0.1938632868244774, 0.1448738036071925, 0.11912874007001961, 0.2185003803870006, 0.3023972894040272, 0.24295967062362023, 0.16017302319882987, 0.30627475724980235, 0.2671740991187279, 0.318608999471102, 0.2374140427149103, 0.22916206348680956, 0.8554438333047489, 0.44191580530661567, 0.20556668754898078, 0.19157898430833975, 0.08346083152003725, 0.0965026890044115, 0.08305906313498002, 0.18533844203289762, 0.16137420870988117, 0.30924322531406423, 0.09675378834501003, 0.1724677996423537, 0.14981100706689654, 0.4616330794762662, 0.09811715693107981, 0.3163512445883939, 0.31975503927911453, 0.08964462400082707, 0.39853480714639256, 9.999999999998899e-05, 9.999999999998899e-05, 0.005310673016075684, 0.061309515147790594, 0.004175852166760863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06657983154722646, 0.04592639018996947, 0.03416665300533872, 0.02099767849928158, 0.07649455880211697, 0.077841598444649, 0.06238235150955329, 0.08763617573064453, 0.06606908696822034, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14656565767514562, 0.08784955333538003, 0.07656972471558532, 0.056310235176636025, 0.08087891599850772, 0.07576930043192354, 0.04786025628296031, 0.07322116387500954, 0.06399405687047477, 0.3313145527464467, 0.33627710146284795, 0.3394483843529472, 0.3986281945603314, 0.34195787845155523, 0.3315390084248696, 0.36144887755665167, 0.38537882988347005, 0.39475511977503897, 0.07870590823474721, 0.11246720320533554, 0.0894590827563797, 0.12886071522030818, 0.11483107841485163, 0.0909065354110189, 0.07196485867629077, 0.08701693429334723, 0.058892379011248, 0.22707498091299294, 0.1681222441915714, 0.20459886292896678, 0.35384379838270685, 0.26076251846861653, 0.21529518543408643, 0.22544626212866292, 0.21996219612953094, 0.23736168236383004, 0.26045426386816606, 0.23778583946878473, 0.2652687139440585, 0.23917829431739202, 0.27008225647551476, 0.275009216794424, 0.2225483303540876, 0.2588274487995066, 0.20651337972648032, 0.12028025820339139, 0.1621458929978411, 0.14016014368601226, 0.1994105808317952, 0.23593805734255735, 0.29114298527507154, 0.19362479759536544, 0.2639603666705429, 0.18753240251255976, 0.21901882275621598, 0.19736566881052608, 0.1850321724072278, 0.21471070628507494, 0.198960249003031, 0.22741067988470098, 0.24185757475493097, 0.21809629838643574, 0.2238071888194766, 0.1587014395083819, 0.1597728363237273, 0.16833828074949708, 0.21151300025774367, 0.19646850958024364, 0.23940324626201004, 0.18358159305844157, 0.22957969634198494, 0.19430315463816328, 0.17072734634693354, 0.18647447779329174, 0.16290124781827797, 0.2550666740772425, 0.3045854155817591, 0.3300448349783708, 0.1418606996438141, 0.17204124540031085, 0.4302187296926764, 0.47634242457885845, 0.3397775059612308, 0.45309509352395394, 0.1642996779343937, 0.16604598261618098, 0.15992995275180855, 0.19407953583071325, 0.20004188338283946, 0.12319842586019081, 0.17577075835371092, 0.19125282218016681, 0.19250382737169414, 0.18343864403315224, 0.20218068822730717, 0.17864038317959507, 0.19081046703475613, 0.19019834595615137, 0.18167130562247225, 0.09859125245051326, 0.08447468259896362, 0.10154318994325517, 0.10223491130691931, 0.09290025240681588, 0.13439909606093747, 0.09911276161929672, 0.07879419941049803, 0.08043376164784732]}, "mutation_prompt": null}
{"id": "c5a37f88-983f-4936-ada7-4bd0ccc52866", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.9  # Adjusted to 0.1 to 0.9 for broader exploration\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.05 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Reduced step size for finer search\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Enhance convergence by adjusting both mutation range and local search intensity dynamically based on progress.", "configspace": "", "generation": 41, "fitness": 0.43528096921241627, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.25.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8128776994965963, 0.7849348045100047, 0.7777938127593284, 0.787757412647378, 0.8115043584323209, 0.7982737285336203, 0.7846328889027372, 0.7787910614450768, 0.799931656837345, 0.6619325726979315, 0.6477245141157989, 0.654240616336514, 0.6383173865984095, 0.647985199970802, 0.6508567313760212, 0.6562715062157745, 0.6592148502181645, 0.6307971308552305, 0.12613605319288035, 0.21159641765137016, 0.1089681776897492, 0.1885421215751566, 0.22582683976543094, 0.12017701467847786, 0.19572962676308026, 0.11716801655805575, 0.15485798129232975, 0.12347830504351309, 0.11739453419604762, 0.14069642808940008, 0.12741166631420564, 0.13090374671825689, 0.130955114267846, 0.12464154169241282, 0.1188820759498812, 0.12292252954202121, 0.8605107437387274, 0.8357343173855796, 0.9018444298562349, 0.8949905955972088, 0.9182147921336169, 0.9044311403983455, 0.8977600772567526, 0.9073270853114157, 0.8788552806879407, 0.49861070875087865, 0.5141520625654303, 0.4272532577193935, 0.443105066124423, 0.5161814235833748, 0.5333452096133651, 0.5456154739471587, 0.42066558965347356, 0.4967944451074171, 0.8641997955857948, 0.8210447293117772, 0.7998041088008992, 0.81017645650867, 0.8346768331305681, 0.8185827043506205, 0.7755789779332691, 0.7653704697906549, 0.8276745293120559, 0.38514867806295405, 0.4041952056925512, 0.44116861953058395, 0.5153766260883951, 0.4912843338078252, 0.2211124652170482, 0.23990453161278724, 0.5116447153149659, 0.49446629545012255, 0.5881924994283372, 0.3104879884364904, 0.5560995589224478, 0.22946154212566294, 0.5307454140100298, 0.19893708165313684, 0.4498897460339275, 0.6326342736886084, 0.11854585230501069, 0.5441584805713995, 0.5409186766566692, 0.5368469122181754, 0.6049443913375745, 0.5575864018995377, 0.5610413634201326, 0.5537986604096038, 0.5745479738870075, 0.5625742928522928, 0.7085577929698287, 0.660475621561385, 0.6730677387867672, 0.6468764117423884, 0.6342409192112546, 0.6099539239063535, 0.6907071398491941, 0.6744723990209132, 0.6974284652517111, 0.2707359667491389, 0.13871128010463507, 0.11765261354929768, 0.46548498375773106, 0.4381622288505519, 0.22775556996973245, 0.28475820823807485, 0.26129964889988466, 0.1325605662730044, 0.40387916663545664, 0.43057903872951364, 0.412792889449756, 0.42099862990876014, 0.43067162504755596, 0.44130626764322345, 0.4153648029409538, 0.4221982936683224, 0.38787285000002103, 0.7540223843419094, 0.7527169594621498, 0.7819860617649019, 0.7588805314838307, 0.7388632670239003, 0.7229492999433927, 0.7542480099522721, 0.7352146588538564, 0.7605338585506749, 0.10941529970662722, 0.14262561958894426, 0.1482074357321448, 0.13734306329997603, 0.12765503961512858, 0.15913367125195632, 0.12030524731777004, 0.17346684674071788, 0.13237335003395745, 0.2180681940551813, 0.27266332466775833, 0.26596309689249187, 0.16124825422656397, 0.18543679612093433, 0.5441949195415545, 0.313354712753225, 0.18408856180471633, 0.26798180089404333, 0.46546648733688123, 0.4670035166109312, 0.5214854542597718, 0.4813909126851471, 0.4579343544360259, 0.4779146176484833, 0.4669221704577945, 0.5041161832787412, 0.4942956929385468, 0.38760295669984224, 0.37835091985761715, 0.3905220511354177, 0.3908256298569921, 0.4132639089738229, 0.4183277839688043, 0.4126998340723912, 0.437992609096184, 0.3765322521640603, 0.20410717224759467, 0.19903477596394814, 0.20436682011104546, 0.19616312539605474, 0.19603568265857296, 0.19539041349190678, 0.2228279009619043, 0.20691149520151764, 0.21493602641840093, 0.4653723851499174, 0.21246994379798556, 0.515396794758864, 0.1965775303330236, 0.48080256532077636, 0.22865652269847903, 0.22823368680706946, 0.4124714815945484, 0.19464580694548073, 0.2048689966968853, 0.21137621394723904, 0.18172367739032902, 0.7606203673130368, 0.7528973691049996, 0.7853657588024262, 0.7449372367885795, 0.7607899488325689, 0.7902585887909783, 0.7739278287787905, 0.6759077315394463, 0.7219955982559282, 0.20035709124932255, 0.20019876060784159, 0.16333473853841696, 0.20986304853122684, 0.20824352744160768, 0.21003309499425993, 0.18844529070610283, 0.19397259570739978, 0.17429190065063027, 0.1856882811694407, 0.3248082667531267, 0.19087510436898736, 0.20272155439686979, 0.18643765058173656, 0.20618837288770953, 0.08180347741307303, 0.08403187874601825, 0.08540019837557555, 0.07624465977054173, 0.07555854225336212, 0.08654721059805193, 0.07212925920439661, 0.0928507938322195, 0.07910295347476926]}, "mutation_prompt": null}
{"id": "a5dfb1df-947b-4620-9ca5-6b061b424037", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Changed from 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce adaptive mutation factor for improved convergence.", "configspace": "", "generation": 42, "fitness": 0.3233909029364377, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.652340289525997, 0.638150732611066, 0.6423351256586658, 0.6868752659577018, 0.7043905656741305, 0.6676857404985974, 0.6911670292777822, 0.6699286969113571, 0.6827049802315177, 0.48717721631002076, 0.46706842698451956, 0.47631347674975777, 0.4391929640040193, 0.42560158911578216, 0.45241637205422847, 0.46972944899336266, 0.47924299826430516, 0.4855145830654548, 0.0946828146736931, 0.08065535785922928, 0.08869091049261368, 0.10827483842280183, 0.08653388365910142, 0.09087927952962616, 0.09506101123207644, 0.09965053815342906, 0.10185356198795803, 0.10026846259190225, 0.10303493029849253, 0.09753078792143555, 0.09092156075782354, 0.09663420480164464, 0.09611395803299128, 0.08798000017495433, 0.08790388289651196, 0.09510658978268349, 0.8996134175952584, 0.9575418293468493, 0.9611684887802698, 0.9273564463453113, 0.9830025571055794, 0.937458509853465, 0.9562041149627575, 0.94469418578589, 0.8704373093731828, 0.3323905853424569, 0.3295006652462926, 0.33830807633575866, 0.34327698534575424, 0.31471530875797016, 0.3431352906243512, 0.34272016739763955, 0.36043370655645335, 0.3782219859920237, 0.6948347294657844, 0.7112558763133199, 0.6026489374881607, 0.714657643342171, 0.6746499330103455, 0.6990275723032108, 0.621575093633933, 0.6376810683749408, 0.6615057729714515, 0.26082788675757773, 0.2815307741956762, 0.28632511704865937, 0.26081215945543645, 0.2832905655516105, 0.29354276486610065, 0.30591497814229984, 0.26187831502967984, 0.27893271583591905, 0.4432691353009316, 0.32395859415924877, 0.28752252377149756, 0.3391600400639404, 0.3257553994108888, 0.27210347591108763, 0.35085109850145546, 0.2874032086609485, 0.2691292184356451, 0.35769713123513425, 0.3000507260675508, 0.317609070791284, 0.2866353582221557, 0.3094485765611833, 0.2963019057686911, 0.27995452045505764, 0.3090958794968047, 0.3181767905245477, 0.3969808298488495, 0.4688591907917269, 0.4639511462824888, 0.457430386318618, 0.4523193976061136, 0.43563841638454615, 0.44432106665601145, 0.4676459308583548, 0.4280813987519575, 0.03337160814177098, 0.11916959789407133, 0.10962923096615818, 0.1789119933726797, 0.18032571164442956, 0.1277040952940821, 0.10235806951618764, 0.06441534580603125, 0.1239800422012286, 0.2335625353489882, 0.25863728679660347, 0.25054397089689373, 0.26226104041272524, 0.25778918067569023, 0.2522040505965064, 0.22854292212031102, 0.24285809965530702, 0.258396301413752, 0.5656482145177588, 0.575855575472296, 0.6225831996245537, 0.6028918442971041, 0.5572440145242592, 0.5859667135468354, 0.6381541873855732, 0.5595109110922961, 0.6161691020161442, 0.08824549630836087, 0.09327426994050825, 0.0944922175471149, 0.08563142882576591, 0.09368435973899836, 0.09219459408385233, 0.08296158256299291, 0.08313690263962237, 0.08189677679987506, 0.13479955547754274, 0.22425179100308668, 0.39464780955878587, 0.1567075436803016, 0.17101530686449573, 0.246104692107315, 0.1964540642013961, 0.14072041848481331, 0.17084343824747028, 0.3117702883046086, 0.2963139501601648, 0.304206882097967, 0.3024697668554952, 0.29719464474978874, 0.30720386905008523, 0.325760208574135, 0.3157099120649731, 0.3164712919670485, 0.24194907389978126, 0.2165115514115079, 0.2830666531245557, 0.22746041413457496, 0.25314209442241165, 0.22631942886174317, 0.25472978531224544, 0.2536431229498224, 0.25978386027952904, 0.2017171490199109, 0.1731167367437373, 0.18080115185333456, 0.21282481754128135, 0.20427809373315453, 0.17869169425237574, 0.19430511602907152, 0.1842547888250996, 0.18855298428191225, 0.17430263020336934, 0.1828695403908569, 0.1799961932547547, 0.1820002255744988, 0.17854983907592192, 0.17913012344580803, 0.18468368019187242, 0.17665390767924216, 0.1863069098462189, 0.16667251713836218, 0.15122480395883664, 0.16571432231451488, 0.17845907540895856, 0.18343773250159678, 0.5056757663861934, 0.5643239406691368, 0.5970419810440177, 0.40262645380437845, 0.16519289831286166, 0.20129075772342098, 0.5675516158462406, 0.6162067116121301, 0.5483349617683346, 0.15977544698806545, 0.20284043817722264, 0.6922204391130884, 0.20622638784330494, 0.17645562479904842, 0.19414174482130753, 0.18012626539356902, 0.19724040799928633, 0.18357727833991, 0.17592908498453308, 0.18149774981414657, 0.19550059400931108, 0.18093655544787435, 0.06431480542427037, 0.07533246003417227, 0.07752388480831929, 0.0697675585447487, 0.0836679749303828, 0.08028670468134003, 0.07017139318973298, 0.08152033568459771, 0.07310486076044165]}, "mutation_prompt": null}
{"id": "f65a0d94-d61d-4c49-b31b-8a49285d06e0", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        shrinkage_factor = 0.9 + 0.1 * np.random.rand()  # New line for shrinkage factor\n        mutant = population[a] + shrinkage_factor * self.mutation_factor * (population[b] - population[c])  # Modified line\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.05 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Adjusted step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.85 + 0.15 * np.random.rand()  # Adjusted crossover probability", "name": "HybridDE", "description": "Introduce a shrinkage factor to the mutation strategy and improve the adaptive parameter tuning and local search.", "configspace": "", "generation": 43, "fitness": 0.4244202719660531, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8058610711223025, 0.8155065007812994, 0.8099823025340347, 0.8250232947827641, 0.8114934759153309, 0.8199080908911842, 0.8425109173331045, 0.8295714728671443, 0.83625573743313, 0.6877252468132671, 0.682949710407037, 0.6896203649434502, 0.7074899466586004, 0.677829596060866, 0.6903791801318465, 0.687699486625333, 0.6785031271882052, 0.6587115981927618, 0.15858768712173898, 0.13446050051241132, 0.1704884592812207, 0.156368786441896, 0.12872698209172395, 0.26228468289538276, 0.1598116870396552, 0.2421209824860192, 0.3952200297398386, 0.10112749872318527, 0.13584341571571967, 0.1394756766748092, 0.13093722344452963, 0.14872914755049804, 0.14517317720378864, 0.13544248095182598, 0.12724843359609606, 0.21938856883493807, 0.854746826194269, 0.9764072418910866, 0.8798832169642529, 0.8440501853314311, 0.9278773244730014, 0.8739857621232028, 0.806079330983794, 0.9351818281513387, 0.8510089958035628, 0.4946932796000264, 0.5576325905277923, 0.45972032253331596, 0.5481504022589649, 0.5538507128698318, 0.47174371029400886, 0.5577072711104517, 0.4760043785482603, 0.5414474078316078, 0.7872484487310661, 0.8340846284913436, 0.804553999831382, 0.8372907720888807, 0.821679915368977, 0.7995462916301591, 0.8548688790695106, 0.8194702231451937, 0.8200153868009951, 0.13780643553660388, 0.30075223040593657, 0.602574357512686, 0.6545365916671892, 0.21144018280081545, 0.25019917866771857, 0.1636236112963141, 0.20436115195991356, 0.23918604755252493, 0.1586987951838773, 0.14111870460618503, 0.5099187687291182, 0.24301999692250065, 0.18745552527354492, 0.6323913483300634, 0.18409479169426746, 0.1545536684059251, 0.19678470733141395, 0.5661749569473388, 0.5711129621148342, 0.5799536784359594, 0.583256763956484, 0.6444767819954971, 0.492345334877637, 0.600620442942339, 0.5447194350573299, 0.4966678380736047, 0.6560868971150242, 0.4836669010491391, 0.5275166933849471, 0.6030388512339888, 0.3213772525367887, 0.6659208737303863, 0.6286050052329124, 0.7054554945796314, 0.6990294434924141, 0.17178867224953032, 0.15146099642515642, 0.21478144018886924, 0.4078240841855597, 0.2199515058090531, 0.38237959187715187, 0.16445636198739388, 0.24616704680179968, 0.17403679454355192, 0.4031969264124947, 0.4372744501698318, 0.39428611923211554, 0.4005302167512127, 0.46304811920946365, 0.47648565491178974, 0.3988807430707403, 0.4886847489818239, 0.4410458635447857, 0.5204211245446898, 0.7844576254045295, 0.7797935595316295, 0.772101825689393, 0.7360169387630966, 0.7618163248485932, 0.7666739001788787, 0.7249961882401079, 0.7672621419331431, 0.14740518026662996, 0.1208145244750598, 0.14793330854524378, 0.16876768295371114, 0.11573654183115356, 0.12174568345751524, 0.1217233099556555, 0.1318324266187657, 0.13027309586329316, 0.24276947824588047, 0.16460145437196694, 0.3607602634426007, 0.1724070134238116, 0.23850720961066663, 0.2977066297268425, 0.243420438357555, 0.3298158136799857, 0.16722997495139003, 0.5135677810622159, 0.5206098113074391, 0.4738974121736359, 0.49602905914273565, 0.4546969756395923, 0.5046380225993933, 0.5168120573051835, 0.5356637955873639, 0.5221764576943982, 0.32775287273761633, 0.38439017767506, 0.4491634200267691, 0.3196085750738178, 0.358661108602196, 0.42357449140827086, 0.4306509862065473, 0.48719638592645975, 0.46409856884751444, 0.22396081775882748, 0.19317510774853497, 0.18909043132611636, 0.20717230768773276, 0.19358833630837657, 0.20765609644316874, 0.21165292032961924, 0.1925669634985766, 0.21473691940489548, 0.20135953877243495, 0.21232694238857253, 0.20754416401778908, 0.39725410772108416, 0.49116359626017725, 0.4996057836050303, 0.21082721819117112, 0.22059551196922322, 0.3273510347350307, 0.18586582871330048, 0.8031784783532663, 0.1872144293714404, 0.7165089311459716, 0.6926525475939942, 0.1946409816879603, 0.784685543216672, 0.16599909874592145, 0.8267564916816296, 0.8212671697604218, 0.15590759400813692, 0.8641105456885632, 0.28308489697583694, 0.2053666818866119, 0.16189165308285047, 0.20913092412962864, 0.7167562755605323, 0.20745025921882343, 0.18839718438393593, 0.19978433467234114, 0.1813668770957666, 0.19537945152321368, 0.18778748505597054, 0.1816745742819269, 0.18704072323733212, 0.18793981010581862, 0.20220975835705657, 0.0874408733224118, 0.08009221153249979, 0.08108334960753272, 0.07870453344676975, 0.0835578285990507, 0.08423760550916337, 0.082243763808718, 0.08303729023093054, 0.08232043236127884]}, "mutation_prompt": null}
{"id": "e77b99b2-4ea7-4294-b2c1-bd718cd9179e", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        fitness_range = np.ptp(fitness)  # Calculate the range of fitness\n        self.mutation_factor = 0.1 + (0.8 * fitness_range) / (np.std(fitness) + 1e-9)  # Adjust mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Enhance exploration by adjusting mutation factor dynamically based on fitness diversity.", "configspace": "", "generation": 44, "fitness": 0.11909083872846342, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.1370665938281993, 0.1117882623145835, 0.1355641136382737, 0.19229142789603426, 0.19538133501381294, 0.18109945483994538, 0.17694941645116746, 0.18815180961229772, 0.22094208537037519, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023558761389341654, 0.03186792007760619, 0.030303823611477654, 0.05301605891605088, 0.030722712474894442, 0.03503661937910052, 0.03722006082334994, 0.038128609323530016, 0.037731894976561264, 0.01935692638743891, 0.00794913605956249, 0.006684970776592691, 0.026392120340477443, 0.018504285107958984, 0.014343882353063053, 0.016110211423984944, 0.012708298828690956, 0.012204906055005793, 0.9915640538991698, 0.9724480099550603, 0.9925642517280261, 0.9945047668864766, 0.9951320419875883, 0.9678587903487723, 0.9943378274065986, 0.9847161596872613, 0.991843195263779, 0.08449588936405539, 0.05885905875911379, 0.060124497135254584, 0.028766430801002385, 0.05941152477879008, 0.08503961256251003, 0.05918932921101183, 0.07912137210582282, 0.08690528941217945, 0.11793362975811983, 0.13531690648105976, 0.11977680968867077, 0.13997032871277515, 0.09967580645818075, 0.10310841969811912, 0.12220604532335178, 0.18046866154556496, 0.17326881170987074, 0.023812108369407392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04462944071858732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01742190936594401, 0.040643819195039566, 0.08729172152148312, 0.057021612343677974, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015246210776144187, 9.999999999998899e-05, 0.008575293587190558, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03457687885689609, 0.03267133016806034, 0.04852341871736332, 0.05646934792070957, 0.057133379710566756, 0.03535730117702551, 0.05190729235378477, 0.05223832895436864, 0.04540670766161348, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008006556546517052, 0.0022825455380294235, 0.0011832220251176695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005271447238535232, 9.999999999998899e-05, 0.1449804555982106, 0.19179718113562716, 0.19666552136080295, 0.22272244887542747, 0.19856967444158058, 0.16635136949969453, 0.1950875727410839, 0.17108142500731738, 0.19844316778764437, 0.05524036423580114, 0.0496347067277948, 0.04524743784404961, 0.04022561020499138, 0.037000823155033835, 0.033962332823587515, 0.0274974852593306, 0.036103726397843094, 0.043418294738787, 0.14751644847890566, 0.14370116628711016, 0.14774294234036334, 0.1514090740235452, 0.22312944692116188, 0.16578311317171734, 0.1727059870196228, 0.17237229691558564, 0.12776633634736134, 0.1714100503561583, 0.13273933365584523, 0.1613932299901244, 0.15225308757678335, 0.13716841425059279, 0.14212119117999011, 0.16208326732214462, 0.1772024134919682, 0.16327738859456298, 0.09043548035362015, 0.09268329704755829, 0.11569472409007175, 0.12992495634000856, 0.11782183034854166, 0.10544706869454945, 0.10716710043279742, 0.14894579161215937, 0.12182900018443166, 0.14619491127136552, 0.12657297549845858, 0.15243447043327873, 0.13701071302633172, 0.15303552574891333, 0.13719576612777162, 0.1455650706458207, 0.11957258367295054, 0.13310774661741798, 0.06274586533236615, 0.06153887135597069, 0.09788490901846492, 0.01920494961820074, 9.999999999998899e-05, 9.999999999998899e-05, 0.07836621068707394, 0.002084341774832632, 0.0395233554744735, 0.2798452873896554, 0.163368915704314, 0.15476191769157233, 0.15748553874245208, 0.16494679140735935, 0.15098128116773368, 0.14763656785205626, 0.15798206620214528, 0.15065015923184255, 0.1441371757377452, 0.14878097188371975, 0.1422610199505132, 0.10038660273950373, 0.11019480072192223, 0.1573330972173006, 0.20468547870368436, 0.19481706499282136, 0.17505566103050874, 0.1814843210240319, 0.1613941671535979, 0.17441414395532373, 0.17838424289832733, 0.19802590445290935, 0.17618899296213586, 0.18451274183227429, 0.1516936731057209, 0.16272562845272298, 0.023683223081620075, 0.03457841810345286, 0.03216522021556989, 0.028874204266371994, 0.038241045803948714, 0.04396306276778472, 0.036371169540246995, 0.039541938706969426, 0.0454507673994301]}, "mutation_prompt": null}
{"id": "2ea0a295-4d54-495d-853e-d9a338fb1cc5", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            # Adjustment: Change local_search_probability based on fitness improvement\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                self.local_search_probability *= 0.98  \n            else:\n                self.local_search_probability *= 1.02\n            prev_best_fitness = current_best_fitness\n\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Refine the HybridDE by introducing a learning component that adjusts the local search probability based on recent fitness improvements.", "configspace": "", "generation": 45, "fitness": 0.3996129287457776, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8183309918868228, 0.8051760887356099, 0.8086726624974803, 0.8171380028739946, 0.8109589901161178, 0.8143048079974959, 0.8088014355496937, 0.8035147797693991, 0.8080697126089185, 0.6722440798544845, 0.709962013792304, 0.6718899596619994, 0.6615229450580816, 0.6601589493454407, 0.6357960580321704, 0.6503888232009938, 0.6679568976930184, 0.6655418540350333, 0.11828570136937211, 0.13649007471361851, 0.13049576383543826, 0.11413141828234785, 0.127145874115134, 0.10769311704964946, 0.1197949070138764, 0.11572301396197293, 0.12402683629628497, 0.09998095658117268, 0.1229266134082434, 0.11691799724545071, 0.1197765120176687, 0.10240190698014207, 0.11168877984691372, 0.09944229067609245, 0.09567498786523809, 0.11356584435604655, 0.8542739983949665, 0.895884885231879, 0.861272221447393, 0.9324353588034612, 0.9099502621586584, 0.8964198174865587, 0.9208861185438684, 0.8666446025242674, 0.8687862802642007, 0.5278599771063001, 0.52724108212861, 0.5403039761129295, 0.4827142941867687, 0.45131776500052667, 0.5364089737824436, 0.5346413349550404, 0.5020173708056352, 0.4462678044032914, 0.8295981703121711, 0.8156838165163554, 0.8250520467912517, 0.8141593305945576, 0.8031515956978026, 0.8327596590118657, 0.7622448590824366, 0.8124047768794143, 0.8340118995224498, 0.3468624467645752, 0.41272288852462624, 0.22293206414046218, 0.2835555607990039, 0.17282356323153603, 0.14289748628739762, 0.18021349684903964, 0.12670382598472352, 0.2223106413443986, 0.1536548733386971, 0.3909299880869621, 0.2850852313124702, 0.32922495773502736, 0.16327720382027655, 0.24658277262459982, 0.21080888161952782, 0.2150181317354336, 0.6012720949661187, 0.6048000037325706, 0.5732579632416718, 0.5096466919802982, 0.5840712113123643, 0.6324341288400126, 0.5410034955022651, 0.6339846960844583, 0.6114920221438502, 0.5727048429233499, 0.6576482264632671, 0.6384956615736205, 0.7005680346227117, 0.6272882438754185, 0.6698071802435601, 0.6718901442668355, 0.7067862894029028, 0.603549303415054, 0.6800451295198287, 0.10066281381003739, 0.08354531177069435, 0.11842533936364619, 0.4385783474553667, 0.4826676977858929, 0.13193551620149724, 0.21016933503448376, 0.1818911901008482, 0.2673600168236703, 0.40070078566042655, 0.37947153154816815, 0.34009007824611936, 0.45583662828733185, 0.4060290029849867, 0.36588819139399664, 0.40487574021098727, 0.4569014340395082, 0.34138226305926, 0.7732962550825824, 0.7785582954422955, 0.6437513084266024, 0.7708137900073495, 0.7666048311212763, 0.7292103776392215, 0.7613902095579511, 0.7095778647096889, 0.7553455072099782, 0.1259107539541623, 0.1260098966274099, 0.12706606595539105, 0.10574503763654886, 0.11462814121433362, 0.11228859508845113, 0.13217990101997512, 0.13795414205784962, 0.11503351558498431, 0.17987453601391734, 0.1924225113323884, 0.1498068650694666, 0.17593290682500662, 0.2112377004370043, 0.22895199457467474, 0.17750939759028972, 0.2010361730291429, 0.18140065662910287, 0.45193701599357017, 0.3990103512095198, 0.4211511329532691, 0.43326607339746526, 0.4161443537439451, 0.4572997328369335, 0.5056939667340572, 0.49996213296722536, 0.45255881529047803, 0.3889132911031521, 0.3489634108090498, 0.39541637681934283, 0.3524672778562833, 0.37446390380625194, 0.30657345406141734, 0.35719490669588505, 0.39388324453515233, 0.35922768547652406, 0.22149401728764162, 0.21204781780130644, 0.1973508986514586, 0.21064529049385294, 0.19918287784277833, 0.19871796152850185, 0.200652656196449, 0.21533941591700667, 0.2014050250757511, 0.19204370862866904, 0.22566836343802332, 0.23878160166667417, 0.3697204561555508, 0.23427630523273058, 0.2319986551294264, 0.20534385157694413, 0.4005393851796861, 0.1976574333107768, 0.20382213293238816, 0.20836980882747558, 0.15238309102290748, 0.8302528575689293, 0.73721712006267, 0.17565911726814998, 0.19579083014127285, 0.16735975916145684, 0.16268094276490175, 0.7824756649864301, 0.20060383563124384, 0.2044616651251958, 0.2009084186672, 0.19848008042206433, 0.1967566229775618, 0.6548054165676777, 0.7146228091735488, 0.20454818360783722, 0.18071499578888428, 0.18589100220530286, 0.18771203992708207, 0.1858432482749065, 0.18180700159393592, 0.18378203911618451, 0.18134780366176906, 0.1788497850213251, 0.1891208607624797, 0.08509018891615738, 0.09996566890064584, 0.0988751455570186, 0.07862166643134372, 0.08327043823185065, 0.0725198986193547, 0.08266391673786111, 0.0870699922842807, 0.08777395475419925]}, "mutation_prompt": null}
{"id": "8baa6894-131d-4f11-9762-7b4b975f4e6a", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + (prev_best_fitness / (np.max(fitness) + 1e-9)) * 0.5  # Adaptive mutation\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Introduce adaptive mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'prev_best_fitness' is not defined\").", "error": "NameError(\"name 'prev_best_fitness' is not defined\")", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {}, "mutation_prompt": null}
{"id": "ea71a772-85f0-4c05-b9b4-9c53dbd31252", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.98  # Slight increase in decrement\n            if budget_used % (self.budget // 5) == 0:  # Adjust dynamic population more frequently\n                self.population_size = max(4, int(self.population_size * 0.9))  # More aggressive adjustment\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.adaptive_mutation_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                elif np.random.rand() < 0.1:  # Introduce diversity-based selection\n                    diversity_index = np.random.randint(self.population_size)\n                    population[diversity_index] = candidate\n                    fitness[diversity_index] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def adaptive_mutation_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.9  # Increase mutation variability\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.85 + 0.15 * np.random.rand()  # Wider range for adaptation", "name": "HybridDE", "description": "Enhance exploration by introducing adaptive mutation and employing a diversity-based selection mechanism.", "configspace": "", "generation": 47, "fitness": 0.3543081972711489, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.76634452540592, 0.7696839364461925, 0.7834860337512146, 0.7778840558655179, 0.7797385333312737, 0.7787812343288795, 0.7718541944978374, 0.7850405942053518, 0.7854040813149181, 0.6018281326858024, 0.5931833191647871, 0.6149748850105825, 0.5702788131754322, 0.6347418446641654, 0.6176164560916189, 0.6343892930252715, 0.6129043139175621, 0.594536089233137, 0.13268436342426482, 0.10435937342826584, 0.09635198404011569, 0.10314470983615576, 0.12056142421001859, 0.09701512687263003, 0.10602762423703971, 0.10057319263437547, 0.11839117501402086, 0.08993994961251262, 0.09176421998138506, 0.10067243285063543, 0.10401358991906962, 0.09613174666201263, 0.09554905609235409, 0.08700228026663082, 0.10266048897398139, 0.10540982051881342, 0.9356974099249249, 0.9129279731259032, 0.8796861701059389, 0.9799961075631443, 0.9033811782004677, 0.9500573318407507, 0.8680227739011203, 0.9275302425538252, 0.8639982962471114, 0.42859469522083304, 0.4148403827954663, 0.45904429308825323, 0.4988507394865155, 0.4323148691921881, 0.44944242016402114, 0.46482691841587975, 0.4380093662930461, 0.46913891257392737, 0.7211306012851362, 0.7314778345761839, 0.6868348992749125, 0.7889403652712242, 0.753791536816074, 0.7606300739518874, 0.7391962763362558, 0.7223619152963339, 0.7709938048391484, 0.217122921232337, 0.23226050301072365, 0.2340671232238657, 0.24646564112456015, 0.304520467960266, 0.46277642394068863, 0.30259569024118727, 0.2537108468009506, 0.3163348144268652, 0.12332274146479394, 0.10557423233785435, 0.25224925223207717, 0.25277825630310147, 0.379737278012084, 0.33265655511693315, 0.22427242197611408, 0.19736204935127977, 0.25180043400068475, 0.4436854347197634, 0.30882712883822083, 0.32388564686540855, 0.31818217060924403, 0.4212102271989546, 0.27759304536419016, 0.46152937991727516, 0.44443202561207296, 0.4196710403588766, 0.5109058902777385, 0.3900992452811003, 0.5589473939665242, 0.4380003783316111, 0.3834726404523733, 0.42943692933683875, 0.5161305688245377, 0.47225842378613647, 0.5255296861788201, 0.0723686931673716, 0.1336157675854176, 0.12149822578745173, 0.15200419381404662, 0.20901331007070822, 0.26749925882835335, 0.14996144003331102, 0.160115424818147, 0.11524693717574774, 0.3167795145792165, 0.32165907635985336, 0.27789760335694835, 0.28241440563056475, 0.31254698069575115, 0.3600036571409442, 0.2876760364051355, 0.31786321249588123, 0.3016850440821671, 0.7003728066730679, 0.7210631749691128, 0.7013030165823797, 0.6092911849550321, 0.6898165236454641, 0.6930832615574184, 0.6745165371811271, 0.6897252429495047, 0.6973257648640729, 0.09286198180630745, 0.09294910127049238, 0.10327601554860244, 0.11547545722400554, 0.09464638260234637, 0.099597457411841, 0.09920044517873283, 0.10063359106494141, 0.09162762014371051, 0.15590616753567554, 0.13912939033968452, 0.13809957054453426, 0.23671580188912544, 0.16287670341821592, 0.15312771289770277, 0.1851708262915217, 0.17373117324907927, 0.1984053033998726, 0.3797360723600961, 0.3938847951283714, 0.37890708957450636, 0.4003048399046002, 0.4062068727113096, 0.4296330506878102, 0.3760496948058175, 0.4212648726856285, 0.4324109429335211, 0.3313059293309709, 0.3079918605418047, 0.3443516477753146, 0.29701150702505197, 0.31949657105296325, 0.32261104783524286, 0.3531185485080943, 0.35355716957882466, 0.3483087860082561, 0.19304473489068807, 0.18512154915573698, 0.18954898519072572, 0.22502576969249255, 0.1936324815761029, 0.19872534444862977, 0.22810535982694957, 0.20177924536715908, 0.18824062697037536, 0.24065687348620357, 0.20767264189134993, 0.18575142076175233, 0.1801436868042543, 0.22246918541577687, 0.18196712367799284, 0.2262028048699387, 0.19860408017473474, 0.3100751841855218, 0.5810064894238198, 0.1963033432771818, 0.14977531565976876, 0.28310183013224777, 0.1898782125352323, 0.18269712349028866, 0.7030297358428617, 0.16966936206812966, 0.16534436726181778, 0.7245169629233748, 0.16297381282373335, 0.1508031373474651, 0.19592846794466245, 0.6726958776837668, 0.20946903846221743, 0.2061294660671118, 0.20813134247591125, 0.20671896570968207, 0.18184844058101368, 0.18152744359982353, 0.20864203157504035, 0.18914250869299432, 0.1844769552519393, 0.1801158268163514, 0.2461946465003918, 0.17992625637751303, 0.18934717045026572, 0.08055444765191966, 0.07494670867563713, 0.07956545437303053, 0.08266830955354854, 0.08393650783606188, 0.07478791779257876, 0.07379687135411328, 0.07500265493589253, 0.07317702165935314]}, "mutation_prompt": null}
{"id": "661a1e49-b214-40e5-ad11-d5d8ef44adcc", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.15 + np.random.rand() * 0.8  # Changed from 0.1 to 0.15 for more lower bound\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Improve algorithm performance by introducing a small increase in the mutation factor's lower bound.", "configspace": "", "generation": 48, "fitness": 0.42472732673398994, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8045964955820589, 0.8072922416168562, 0.7890303885717748, 0.8117194485827076, 0.8137324708287716, 0.8024123400758951, 0.7828298612123831, 0.7952330790997166, 0.8014009834787588, 0.6439972794820996, 0.654097235311411, 0.628871648566852, 0.6335945754989833, 0.6328804922132251, 0.6556921329010563, 0.6655150681504176, 0.6452503914204213, 0.6274017882160489, 0.1199856750861531, 0.1068750931782555, 0.13691551552112668, 0.10496811303938125, 0.11547666379403965, 0.13179276894946923, 0.11762019935219992, 0.1413671963715859, 0.14628457503002135, 0.12014595414598483, 0.11276803634994725, 0.11361193225245136, 0.10208357682305791, 0.11180822243892707, 0.09198771631637415, 0.09704198695058253, 0.10623269905864585, 0.10044984269163082, 0.849899651527106, 0.8310435036431103, 0.8350675325396025, 0.930022191911239, 0.9321058908510355, 0.9065652580908189, 0.8754429674393568, 0.9234999248036457, 0.9197078834629845, 0.5120716419021945, 0.5332556373971593, 0.45529430509755486, 0.4553730791520003, 0.5438468898034585, 0.509720242372343, 0.505346726501547, 0.4401684997126748, 0.4465557375862561, 0.8387336472263062, 0.8052439671427427, 0.791343607798556, 0.8215321943864432, 0.8409355315874005, 0.8221729610624231, 0.8159956201533232, 0.8037993483781549, 0.7908161520965251, 0.41337344156401223, 0.4240352334409855, 0.3847446073910533, 0.24585110240587127, 0.35757336752410385, 0.5852600991873507, 0.5624862891193809, 0.19348424301277456, 0.5775219151322251, 0.4085814813794759, 0.22660880485446344, 0.49319682968556344, 0.27654735979244516, 0.1952705709996786, 0.17214810090271837, 0.299690905763064, 0.6141815955435173, 0.2074203967560726, 0.5020696980003894, 0.5950868198864819, 0.5506436680815017, 0.5249166017966532, 0.5427643403047411, 0.5565740529665062, 0.5844945239538675, 0.607734904929696, 0.5582218388726745, 0.6304323353991004, 0.5834145049206911, 0.6567812963739512, 0.6367822255321463, 0.6617335823635508, 0.65602031016548, 0.6600571459016901, 0.696524909042104, 0.6671187592156859, 0.26869733610533564, 0.31253200373115775, 0.13146600365957017, 0.4530573216898429, 0.3560206830363817, 0.45550262339001735, 0.23410421689599203, 0.17680951279303359, 0.14746469182472666, 0.4267121885132824, 0.4241222912139585, 0.3737473020614873, 0.4114586336185585, 0.4100227651458479, 0.42324202745705863, 0.4372207084762805, 0.4528176762017332, 0.4725854391886445, 0.7403157033754046, 0.748608345648178, 0.7691977271357634, 0.7577120130976497, 0.7631040108610722, 0.7660293860968954, 0.7296034240450469, 0.7495047639650614, 0.7575570274890755, 0.11011026184157546, 0.12321784842513339, 0.11773936437661325, 0.11251087550876104, 0.14295933398601535, 0.12288217990064221, 0.12406514548836944, 0.09989013800697144, 0.13177359065256755, 0.1961106068737044, 0.15909343705648427, 0.26262888219346403, 0.14974327167221146, 0.4542924544814084, 0.18983280474828623, 0.18556696671753703, 0.18041684497373023, 0.19799075606812833, 0.4504469199651513, 0.43950152073717286, 0.4844047603086131, 0.44182606110389766, 0.501493263115664, 0.44581053877435317, 0.46273600747066856, 0.5002160820942405, 0.48289003202509706, 0.3627538148926486, 0.3546684570911103, 0.393310008835691, 0.39134362338785433, 0.3497255590790763, 0.41193537262961677, 0.39690889250298755, 0.43017098696706835, 0.4239661855671568, 0.19368405763036423, 0.22677684191234293, 0.1938736154094921, 0.19111164580509565, 0.20416080023283334, 0.20858400359789453, 0.21573520192060014, 0.18624056380650333, 0.20554683982422806, 0.4892393798020366, 0.3483187336265532, 0.4906267409231405, 0.20717542719742343, 0.24978435633962914, 0.2757044597673072, 0.2768138685195881, 0.2122563149372647, 0.19862261512971557, 0.16907313912759359, 0.8013487986788538, 0.19393153698873178, 0.7465084239754639, 0.19261512809476733, 0.6904607158487599, 0.7485346016089307, 0.7900502491030656, 0.7878068349713123, 0.7642790247696649, 0.2068052374536583, 0.633396053411371, 0.19528270376380885, 0.1655491523535626, 0.19534710769995212, 0.20829633761438304, 0.7839354189745924, 0.20821967273492648, 0.18066124953791074, 0.18207147579084715, 0.18465581679830567, 0.19470622935248527, 0.19144781060842986, 0.17833907476399358, 0.1928191854520218, 0.20487983329965687, 0.18329276930539995, 0.06965098316691909, 0.08355248043200114, 0.08704383711550256, 0.08146601253561403, 0.08545055325292683, 0.08708143753728292, 0.07502285095088135, 0.08577620123506402, 0.08546834966755146]}, "mutation_prompt": null}
{"id": "967cd9ca-9397-4981-8d13-32be2bfdabcb", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            \n            if budget_used % (self.budget // 5) == 0:  # One line change for periodic reinitialization\n                worst_indices = np.argsort(fitness)[-int(self.population_size * 0.2):]  # Reinitialize worst\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                budget_used += len(worst_indices)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce periodic reinitialization of the worst-performing individuals to enhance exploration.", "configspace": "", "generation": 49, "fitness": 0.4387521548224066, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8151022435748793, 0.8034991048983169, 0.8201382026519154, 0.8130194617466889, 0.8304775974368135, 0.8160944524522008, 0.8064588676714559, 0.7963818598016055, 0.8220584365266815, 0.6636092898721418, 0.6926280023759248, 0.6704610564607814, 0.680777214322313, 0.684187432834649, 0.6793749558224311, 0.6888911512375773, 0.6637996132000905, 0.6583020318612021, 0.12680687489090214, 0.12451133354096433, 0.13004517128710336, 0.1366716953795245, 0.1251040294335093, 0.11162836670251508, 0.1562761507399011, 0.13119537961413497, 0.2158335870208805, 0.11006480220790549, 0.1340432905670037, 0.1371728419486703, 0.13712842133488812, 0.1213887926092242, 0.12330338357336745, 0.1317465119325547, 0.13306375268459647, 0.10172249324647453, 0.8785923560029124, 0.8401746627507677, 0.895625743143637, 0.8841955591157181, 0.8287716781578456, 0.9502497910323774, 0.8716582905750875, 0.8206543752311221, 0.9482082687411901, 0.5669408317171312, 0.5304067588286925, 0.46156293824820616, 0.5208225263920526, 0.5389303361527622, 0.4400887439697283, 0.4561505469210151, 0.5297504037196028, 0.4789170556337381, 0.8282382995679423, 0.8311955246525095, 0.81699151996263, 0.800275855124035, 0.8296924146092343, 0.8256123353385083, 0.8355050423879866, 0.8235006917251717, 0.855836102700263, 0.18935750911477867, 0.2636993189535165, 0.28235244193372133, 0.392458980289928, 0.2973067115612573, 0.18089196427276366, 0.6491982692628596, 0.23400744146600116, 0.2622892854778083, 0.2026107513023836, 0.5811956719358069, 0.16522310910177818, 0.24503152080413837, 0.18420843929298225, 0.6257696745233865, 0.5084072910110438, 0.4357807230285382, 0.3167698867799993, 0.6325739590915997, 0.633826110983693, 0.5761431593354673, 0.6107613297319507, 0.655953734616038, 0.5760277444971775, 0.6284995050505382, 0.6213099948377205, 0.6339672682331574, 0.6867995853819786, 0.5982791087774513, 0.6809840541075094, 0.7056766880291664, 0.6483045218553427, 0.644223240283911, 0.7215325898944467, 0.7314819970882123, 0.676776273939983, 0.1466910125320139, 0.07639085169028037, 0.2505279890265216, 0.48292246926617977, 0.4815806099771004, 0.16330403965965323, 0.15882871161563217, 0.34113547059181326, 0.24878657777410196, 0.464412898464054, 0.5034274469313136, 0.4201964109466706, 0.4690356228082724, 0.4006600552039812, 0.45434661974819146, 0.466959937768854, 0.5088917149739547, 0.4553802378254611, 0.7745501696752333, 0.7742221874896635, 0.8093373564634734, 0.7758918115082368, 0.7842048222117926, 0.7816482214031373, 0.7567655342689453, 0.771243936493528, 0.7590232336994429, 0.12292188308639451, 0.12433726325889616, 0.11961627765527938, 0.11049264616882415, 0.13863926546341554, 0.4625304610364147, 0.11888074890859568, 0.10702708594593258, 0.1590537730808994, 0.18633219422020397, 0.19037767440847198, 0.4318517321502642, 0.3365061450731942, 0.1534299636496722, 0.17952014673053596, 0.19918641748549604, 0.18748285519425334, 0.18778114046811512, 0.46981635135405153, 0.42503930870201734, 0.5258623607691513, 0.4670211201963108, 0.5037360811051619, 0.47913208079654224, 0.4794204187564167, 0.47496304561030134, 0.5300351082300665, 0.38303756427612545, 0.42354558847025914, 0.4102552786938374, 0.41237212251468824, 0.4253910849650092, 0.3929446473113204, 0.4404063121474866, 0.4226664499750026, 0.3962733122398955, 0.19945007208544074, 0.19046102727021885, 0.18718451232009392, 0.21358670934783008, 0.2071700987810997, 0.19681926793054172, 0.201599932361061, 0.20525223665875447, 0.21494354337893395, 0.23261347776250263, 0.2083375887993929, 0.35165907397847307, 0.1903360844906773, 0.21597119009413213, 0.5521762160305829, 0.20278280826349848, 0.22595496114476132, 0.2127228333707024, 0.2044105324932124, 0.18589481190920532, 0.8190424777382361, 0.8508622064837585, 0.651710899788204, 0.8108889344579135, 0.7696013232330992, 0.7625487646259269, 0.7568489056997466, 0.45124026074468215, 0.7950416095126175, 0.8395711239066544, 0.2010691731917955, 0.1981982876505377, 0.16429181567498852, 0.20165221602220185, 0.8159397675003429, 0.20976526088836367, 0.1904319732553903, 0.1888591138209772, 0.18491324078889004, 0.2072155347194321, 0.1806285103725015, 0.18367099601869075, 0.18939118360132456, 0.18437850773904874, 0.1825307277013566, 0.07693741069140725, 0.08356702850437381, 0.08302947023000362, 0.08352866346579324, 0.0848474534034791, 0.09337527178783545, 0.0919269015530112, 0.07745994477380425, 0.08672528179461036]}, "mutation_prompt": null}
{"id": "2e59b51c-1954-459d-9765-3db217c662be", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n        self.memory_factor = 0.5  # New line for memory factor\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n        memory = np.zeros(self.dim)  # New line for memory\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness, memory)  # Pass memory\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    memory += self.memory_factor * (candidate - population[i])  # Update memory\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness, memory):  # Added memory parameter\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c]) + memory  # Use memory\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Enhance exploration and convergence by integrating adaptive mutation strategies and memory-based parameter tuning.", "configspace": "", "generation": 50, "fitness": 0.4387521548224066, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8151022435748793, 0.8034991048983169, 0.8201382026519154, 0.8130194617466889, 0.8304775974368135, 0.8160944524522008, 0.8064588676714559, 0.7963818598016055, 0.8220584365266815, 0.6636092898721418, 0.6926280023759248, 0.6704610564607814, 0.680777214322313, 0.684187432834649, 0.6793749558224311, 0.6888911512375773, 0.6637996132000905, 0.6583020318612021, 0.12680687489090214, 0.12451133354096433, 0.13004517128710336, 0.1366716953795245, 0.1251040294335093, 0.11162836670251508, 0.1562761507399011, 0.13119537961413497, 0.2158335870208805, 0.11006480220790549, 0.1340432905670037, 0.1371728419486703, 0.13712842133488812, 0.1213887926092242, 0.12330338357336745, 0.1317465119325547, 0.13306375268459647, 0.10172249324647453, 0.8785923560029124, 0.8401746627507677, 0.895625743143637, 0.8841955591157181, 0.8287716781578456, 0.9502497910323774, 0.8716582905750875, 0.8206543752311221, 0.9482082687411901, 0.5669408317171312, 0.5304067588286925, 0.46156293824820616, 0.5208225263920526, 0.5389303361527622, 0.4400887439697283, 0.4561505469210151, 0.5297504037196028, 0.4789170556337381, 0.8282382995679423, 0.8311955246525095, 0.81699151996263, 0.800275855124035, 0.8296924146092343, 0.8256123353385083, 0.8355050423879866, 0.8235006917251717, 0.855836102700263, 0.18935750911477867, 0.2636993189535165, 0.28235244193372133, 0.392458980289928, 0.2973067115612573, 0.18089196427276366, 0.6491982692628596, 0.23400744146600116, 0.2622892854778083, 0.2026107513023836, 0.5811956719358069, 0.16522310910177818, 0.24503152080413837, 0.18420843929298225, 0.6257696745233865, 0.5084072910110438, 0.4357807230285382, 0.3167698867799993, 0.6325739590915997, 0.633826110983693, 0.5761431593354673, 0.6107613297319507, 0.655953734616038, 0.5760277444971775, 0.6284995050505382, 0.6213099948377205, 0.6339672682331574, 0.6867995853819786, 0.5982791087774513, 0.6809840541075094, 0.7056766880291664, 0.6483045218553427, 0.644223240283911, 0.7215325898944467, 0.7314819970882123, 0.676776273939983, 0.1466910125320139, 0.07639085169028037, 0.2505279890265216, 0.48292246926617977, 0.4815806099771004, 0.16330403965965323, 0.15882871161563217, 0.34113547059181326, 0.24878657777410196, 0.464412898464054, 0.5034274469313136, 0.4201964109466706, 0.4690356228082724, 0.4006600552039812, 0.45434661974819146, 0.466959937768854, 0.5088917149739547, 0.4553802378254611, 0.7745501696752333, 0.7742221874896635, 0.8093373564634734, 0.7758918115082368, 0.7842048222117926, 0.7816482214031373, 0.7567655342689453, 0.771243936493528, 0.7590232336994429, 0.12292188308639451, 0.12433726325889616, 0.11961627765527938, 0.11049264616882415, 0.13863926546341554, 0.4625304610364147, 0.11888074890859568, 0.10702708594593258, 0.1590537730808994, 0.18633219422020397, 0.19037767440847198, 0.4318517321502642, 0.3365061450731942, 0.1534299636496722, 0.17952014673053596, 0.19918641748549604, 0.18748285519425334, 0.18778114046811512, 0.46981635135405153, 0.42503930870201734, 0.5258623607691513, 0.4670211201963108, 0.5037360811051619, 0.47913208079654224, 0.4794204187564167, 0.47496304561030134, 0.5300351082300665, 0.38303756427612545, 0.42354558847025914, 0.4102552786938374, 0.41237212251468824, 0.4253910849650092, 0.3929446473113204, 0.4404063121474866, 0.4226664499750026, 0.3962733122398955, 0.19945007208544074, 0.19046102727021885, 0.18718451232009392, 0.21358670934783008, 0.2071700987810997, 0.19681926793054172, 0.201599932361061, 0.20525223665875447, 0.21494354337893395, 0.23261347776250263, 0.2083375887993929, 0.35165907397847307, 0.1903360844906773, 0.21597119009413213, 0.5521762160305829, 0.20278280826349848, 0.22595496114476132, 0.2127228333707024, 0.2044105324932124, 0.18589481190920532, 0.8190424777382361, 0.8508622064837585, 0.651710899788204, 0.8108889344579135, 0.7696013232330992, 0.7625487646259269, 0.7568489056997466, 0.45124026074468215, 0.7950416095126175, 0.8395711239066544, 0.2010691731917955, 0.1981982876505377, 0.16429181567498852, 0.20165221602220185, 0.8159397675003429, 0.20976526088836367, 0.1904319732553903, 0.1888591138209772, 0.18491324078889004, 0.2072155347194321, 0.1806285103725015, 0.18367099601869075, 0.18939118360132456, 0.18437850773904874, 0.1825307277013566, 0.07693741069140725, 0.08356702850437381, 0.08302947023000362, 0.08352866346579324, 0.0848474534034791, 0.09337527178783545, 0.0919269015530112, 0.07745994477380425, 0.08672528179461036]}, "mutation_prompt": null}
{"id": "c80882eb-5f90-488a-b46a-93c11ba20f46", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n        best_solution = population[np.argmin(fitness)]\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness, best_solution)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                best_solution = population[np.argmin(fitness)]\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness, best_solution):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        strategy = np.random.rand()\n        if strategy < 0.5:\n            mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        else:\n            mutant = best_solution + self.mutation_factor * (population[a] - population[b])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Introduce adaptive differential mutation strategies and elite preservation.", "configspace": "", "generation": 51, "fitness": 0.40363939567975726, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.7588782482796201, 0.7746674512269496, 0.7675075801172728, 0.7766830407428186, 0.7835063963196299, 0.8025221481681653, 0.7926806849482605, 0.803736084624148, 0.7691680607293764, 0.5802608815334291, 0.6022620357912525, 0.5823990560532126, 0.6069771516325791, 0.6128161242189879, 0.5983313956524172, 0.6155295106300456, 0.5853489791971092, 0.6153664694969194, 0.13464092390231763, 0.1271120753265439, 0.15325911765362799, 0.13105345835423288, 0.12517740306425662, 0.11744263582190562, 0.14307232563210381, 0.14402565908150755, 0.10957017910818723, 0.10122824819441012, 0.11369012223966435, 0.25916743999755765, 0.15198694329688556, 0.09681528857128319, 0.13485636807995305, 0.11411340797781921, 0.11499237468035395, 0.12724792559648834, 0.9881037413782344, 0.9795468494117859, 0.9809122746054368, 0.9831653133042367, 0.9813607250388322, 0.9766022180200621, 0.9760236089987815, 0.9935932729045428, 0.9923282364544757, 0.43698398064202837, 0.42014346774598366, 0.4240542897691696, 0.4865243325565273, 0.46581993241589303, 0.4470446091014436, 0.43324851471645787, 0.4468080954743414, 0.4530539561304947, 0.7554790029140839, 0.7662595543248488, 0.7818918837217068, 0.7472570838756603, 0.7990907645353198, 0.7761457318806663, 0.7777238101081146, 0.781022935136473, 0.7422175421975619, 0.4948526782601683, 0.5114310908644315, 0.5290693978266763, 0.4633421179024628, 0.530167007607332, 0.4647426564109858, 0.4779968510873157, 0.5049973613340806, 0.4843863889124511, 0.46783620176382645, 0.5374861207302772, 0.4931106900392964, 0.5224435982835046, 0.5131352857341407, 0.5291959629305977, 0.4763539656443391, 0.09718026159783277, 0.4904389898641601, 0.47523442145486305, 0.49510196215835134, 0.5194718437416064, 0.4241105348025147, 0.5158487320676188, 0.4881963730620673, 0.4816436971858382, 0.508240731727637, 0.4964221095056266, 0.5850515987424851, 0.6124061604559035, 0.5869776729652252, 0.565681891339507, 0.5959411517198898, 0.5756388784781834, 0.5911224702286946, 0.5841044308487038, 0.6551306778197903, 0.15634887989122637, 0.1488750013213327, 0.2137976114645378, 0.15952460034989546, 0.2964446409469115, 0.3462285659326808, 0.2456893236808112, 0.27958943030617145, 0.2588024729089442, 0.36649770511534674, 0.37469233965790816, 0.3289751554823199, 0.362525723842824, 0.36190087822340167, 0.36050153999156764, 0.3622965106311564, 0.3901458265557196, 0.3769454194671652, 0.7029348873029261, 0.713769465466233, 0.7018051475452275, 0.6746442898144462, 0.7025397237238737, 0.7029305033930378, 0.6862173777123255, 0.6939955609980527, 0.6659814449897447, 0.13429679241782433, 0.12172137946412875, 0.12311073496902658, 0.11440696040120091, 0.12061174947033704, 0.10508521013298033, 0.11675862462693154, 0.09921558552596543, 0.08600321401131128, 0.17197708437123516, 0.20846711755424285, 0.2513001102663138, 0.19512008466226838, 0.42355373570810595, 0.23556056955888083, 0.15865112070450837, 0.24626086333020025, 0.46340847529422313, 0.3732684681397537, 0.4079688318912196, 0.42035512653834384, 0.3599833487037972, 0.36441345398849423, 0.3608900429736067, 0.42629891901026307, 0.39650636488959645, 0.40000462318134267, 0.32033823185679, 0.3045520800035493, 0.3044844532836921, 0.3082154387995987, 0.30028938738843114, 0.309299096701358, 0.3006009260014303, 0.36136861649806606, 0.3537139951839069, 0.19671278692544758, 0.1872389411898876, 0.18003551689067832, 0.1897999816058078, 0.19298214952944082, 0.20311719618771795, 0.21746624458401298, 0.1995379139428486, 0.18867282486913828, 0.22860626182111599, 0.44053723122806243, 0.20299040560856385, 0.223831697279825, 0.2259170631663926, 0.5369870651147528, 0.5101710566799827, 0.22020307291303598, 0.192898193336548, 0.1645951608205498, 0.19117639861912517, 0.15400649324200144, 0.17706786781945538, 0.1967172963519489, 0.1883579318759092, 0.18039227251255707, 0.7836676832208176, 0.20629488378424365, 0.7858125262692837, 0.20567170925480993, 0.8317194259883609, 0.19863598848933917, 0.20197878962955196, 0.16455204903987142, 0.21183381607286034, 0.8031841658611316, 0.2068161360383245, 0.1771386543877681, 0.17946679528141907, 0.20847787350957792, 0.2045964861276729, 0.23893393800216878, 0.18196226003569704, 0.18500732701461886, 0.19328271352515947, 0.1862775186509883, 0.08623570527859536, 0.08001454356948401, 0.07606470743878946, 0.07328154215362936, 0.06526933881044295, 0.07633096127502226, 0.08441175945648993, 0.08310221559007147, 0.06841719633502708]}, "mutation_prompt": null}
{"id": "f02cc9ea-2bc7-4d0b-98cf-8ea9d1ca4739", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Changed from 0.1 to 0.3 to refine adaptation\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Refine mutation factor adaptation to enhance diversity and convergence.", "configspace": "", "generation": 52, "fitness": 0.3747447385908067, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.7594518737634619, 0.755814738216342, 0.7273905220580987, 0.7718121524678525, 0.7397057483726799, 0.7826057233476562, 0.7869709601597644, 0.7371581315376889, 0.7487093315247517, 0.6021762372848802, 0.5941373911044983, 0.5709079992561968, 0.5662022669447799, 0.5246956640730776, 0.5848370943419801, 0.5924929474608873, 0.5890964440367072, 0.5649070507583487, 0.10605257876859264, 0.10313012244023301, 0.10649984452993144, 0.11113602223075214, 0.09768808625140013, 0.11568472324729029, 0.10328499188773455, 0.10436324634219929, 0.1064951556889937, 0.09045735457679605, 0.09999736352458077, 0.09362698596680652, 0.10340250304900767, 0.09737154516150714, 0.11242204324120009, 0.10038343499275326, 0.10076685457554335, 0.09701912047705596, 0.8541531819709769, 0.8334938319530236, 0.935632816456591, 0.9688161517075192, 0.9823766227222305, 0.8978447540856648, 0.9045633351619748, 0.8637951488039721, 0.9175663333927047, 0.44020777936141986, 0.4465827416037108, 0.4430183707669949, 0.4510352660835414, 0.471960636622487, 0.40109815590763276, 0.48956502050124173, 0.4371375474795117, 0.46970640542421405, 0.7525088297871969, 0.762971493203446, 0.7732802917955893, 0.7071571212891195, 0.7699757314032818, 0.8171693340214904, 0.785218168849473, 0.7668124318105355, 0.7196350097211692, 0.36634643215413987, 0.36082044583063677, 0.3812394773734673, 0.2846677924295137, 0.39803006999479795, 0.4202997554122484, 0.3930538779133419, 0.3959907743835006, 0.2932770023045418, 0.44756705310178346, 0.2177964507616328, 0.5375620225779336, 0.4924231928044328, 0.3389457082910522, 0.3263122318678062, 0.3964755130934676, 0.23713141700317164, 0.29448957230534645, 0.4585097273012336, 0.4815453063919233, 0.4373950654150367, 0.44893082513755667, 0.4840891315110335, 0.43131374059305183, 0.4298724124993569, 0.42938059572770515, 0.47088584349006546, 0.5228040881880499, 0.4928140067229315, 0.577073293877495, 0.5705800289500271, 0.5578706325614646, 0.5604090617655713, 0.5917360683153169, 0.6262318489070211, 0.6273354680497407, 0.15794315623539734, 0.13341753604835316, 0.11256658784238749, 0.29565567865341436, 0.2817827816252647, 0.3210363621967579, 0.249987121483914, 0.14560044871379374, 0.20627999453726598, 0.33250234419416547, 0.3343876651359168, 0.3170447330775398, 0.34030163037667804, 0.3150469787463184, 0.33015830542835367, 0.3149425853201716, 0.3569499184110675, 0.3655274618390545, 0.6613876036085434, 0.7128491488183806, 0.6961008448853123, 0.6824247766958486, 0.6941026207654188, 0.6836553807119173, 0.700196067974639, 0.67187821652353, 0.6666434222387252, 0.11161044803500897, 0.09482778874025444, 0.11784741694827694, 0.09605724431155527, 0.09617600495418777, 0.09249866512829008, 0.09872626581340316, 0.09873058290214554, 0.0936846310584093, 0.15232619096679156, 0.17465083278060278, 0.20245448009289857, 0.1897719089843658, 0.1715839225891559, 0.1672002250154777, 0.16484750507787138, 0.17431188368041073, 0.15212487482084036, 0.38814720792282253, 0.402730571658231, 0.3698974614381898, 0.4121912505466002, 0.3933238175577237, 0.3599601244469375, 0.403831588019811, 0.388299953667246, 0.359201271875646, 0.3384793586818703, 0.30136423883722285, 0.2859040782370784, 0.29067794629163746, 0.3163107587441385, 0.3526486202382475, 0.3290955272687426, 0.3429871410333706, 0.3272201283188422, 0.21690734144718182, 0.19615702924537382, 0.20713160620221338, 0.19573231969538674, 0.18787372321205165, 0.20265411590719018, 0.18237540665089902, 0.19204721466551833, 0.21182602370026082, 0.19105639703850819, 0.19556106920553862, 0.198728184624117, 0.18283671151687997, 0.1763840170877462, 0.19379613954861785, 0.18547199982098805, 0.1871777241452779, 0.18548521931942386, 0.16660140223926667, 0.1751605417902916, 0.19240980084190829, 0.7633351446739256, 0.1936136330161119, 0.1763980774306685, 0.178365124002952, 0.5932038560192509, 0.19769429423536033, 0.7217769724793646, 0.619607513841778, 0.6558904747566443, 0.19324483649488944, 0.18885742243834314, 0.2006813853729713, 0.20685178381931113, 0.8133665025997348, 0.20596865120964813, 0.18530193652940585, 0.17979565795957275, 0.18857795473175698, 0.17946605093076395, 0.2161845215611483, 0.19694694599886475, 0.20348152159661081, 0.20066868550944705, 0.17516140355540122, 0.06889501026303446, 0.08181890031399741, 0.08803761294000012, 0.07997979186490811, 0.07672875406482749, 0.07651280184380904, 0.07707880044350279, 0.07512674734482039, 0.07745678853820226]}, "mutation_prompt": null}
{"id": "bd522185-cb0a-46ea-b35b-ed97dba3d034", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, prev_best_fitness)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        d = np.argmin(fitness[indices])  # New line for more diverse mutation\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c] + population[d] - population[index])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best_fitness):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand() * (1 + 0.1 * (best_fitness - func(target)))\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Introduce adaptive step size in local search and diversify mutation selection for improved exploration.", "configspace": "", "generation": 53, "fitness": 0.36705253878901917, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.7139179401404856, 0.7451479536796729, 0.6913300893809241, 0.7372352052515673, 0.7719790515851688, 0.7443168717440685, 0.7097906664855682, 0.7312522799435347, 0.7519451495747127, 0.5472929182082165, 0.5388060608833011, 0.5196462585112467, 0.47857149720879055, 0.5296860279601863, 0.5216959594183883, 0.5235735321388244, 0.4964993973043743, 0.5508430283977175, 0.09533842800972381, 0.09020897099617009, 0.09689732808763163, 0.08599426842528757, 0.09162757188524151, 0.09648948835273552, 0.10362537089087276, 0.10652305774902615, 0.10400232384090946, 0.09719846380011021, 0.09220232650128235, 0.10130675665974809, 0.0825273768315985, 0.10597135021119097, 0.09197747326142358, 0.09090770464849551, 0.0830399581876683, 0.09008680320023721, 0.9876756870676944, 0.977535607856721, 0.9730407565889962, 0.9822653541703632, 0.9866731691361804, 0.9902522112492009, 0.9874765450109259, 0.992658886279337, 0.8952441580342752, 0.33801640216060946, 0.34772745668498517, 0.36362330804496223, 0.35355826325754014, 0.38815593663522485, 0.38923093434992717, 0.38832618776176564, 0.3454145481401558, 0.37465034155210364, 0.722552986054165, 0.7041041578197481, 0.7398759498226666, 0.7440369556645817, 0.7705580798814917, 0.7628045410051183, 0.7378232687597179, 0.7706382682790496, 0.7076735886358971, 0.3807487162016838, 0.35319130988495906, 0.31732145887761276, 0.31060161388088203, 0.37311637278356113, 0.33447377233916864, 0.38957998222071744, 0.31822279748566196, 0.44143644371578683, 0.2704201886615287, 0.24474258313280817, 0.409426583364898, 0.17091329054740567, 0.39239727596887164, 0.4006692847409148, 0.44673847679054723, 0.10089138424893684, 0.40866236435628234, 0.40584567039058117, 0.4611258665040777, 0.37340667560779683, 0.4456140225432691, 0.43157597910631673, 0.3606786821587723, 0.3963536243125081, 0.4044179868980621, 0.4512391116515342, 0.5498842743997976, 0.5627853886012393, 0.5403472010354142, 0.5300036119264725, 0.5189902870080589, 0.5248691883627737, 0.48649031963347844, 0.5679106958134968, 0.560281363519517, 0.1575258782812169, 0.07869660524110333, 0.13127607309872968, 0.26823838517911724, 0.224713177762481, 0.1544589565127812, 0.11490913919214696, 0.10595612789850206, 0.16556635852124257, 0.3262752784946015, 0.27945954618653357, 0.28970078525882303, 0.3114096874848157, 0.27320856905964164, 0.31080173206268413, 0.26895866297476345, 0.2899055278759536, 0.2844566495255545, 0.6996101231006888, 0.6656476955789984, 0.6756736224073396, 0.6482545229993271, 0.6343444673340907, 0.6171080597683982, 0.6527285536634339, 0.6512119583817408, 0.6496465465399544, 0.09060044719630533, 0.10371113498838369, 0.09036844629212815, 0.09357123065696193, 0.092599601282225, 0.11193540383496126, 0.09339065320891382, 0.09568029135931522, 0.10478520982653006, 0.13146778724480213, 0.1976097378104663, 0.18214757682021787, 0.19941275523014934, 0.14516576602661158, 0.15873768369121044, 0.1531252565796014, 0.15847675067675804, 0.17768144131293206, 0.35428826338674546, 0.3628260286648447, 0.3753760083205899, 0.3483282755555752, 0.3620221131465602, 0.3592197648418223, 0.40749232249504674, 0.3956572512123736, 0.37115584003718316, 0.27909887850084825, 0.2882992022092108, 0.2870522321636476, 0.285071940340082, 0.30160124415456435, 0.28917340043498985, 0.3195969369661752, 0.2917206251903459, 0.3085372966325405, 0.19511882200802577, 0.20101212122850642, 0.18921197904605902, 0.22816620504340568, 0.20106368793659157, 0.20795595480041484, 0.20147900432309485, 0.20562094606213877, 0.18358682787213287, 0.19928158086479975, 0.18073540782046071, 0.1764974964648931, 0.18189624016311645, 0.17748192080481873, 0.17679974278954103, 0.18551663029204946, 0.1914448478709081, 0.20422289274795713, 0.5767099743779339, 0.6474915969495392, 0.7698471450828864, 0.5895210820125019, 0.34037232784126814, 0.5408766886833857, 0.5373056536254829, 0.6312179555295938, 0.5199483698904362, 0.5123450154320408, 0.19325494051718994, 0.18970860669903788, 0.4935378102337923, 0.1957212599972219, 0.7378331182220834, 0.211441827173663, 0.5466022736470472, 0.5835756870552187, 0.1913272998996518, 0.18398146193027776, 0.18600465360093765, 0.18965206378632915, 0.18181906170894635, 0.1712124529161736, 0.17566655866527803, 0.18007309387443715, 0.1871908939830843, 0.0824727635493906, 0.0727809170022119, 0.07929285954920418, 0.07429351406073004, 0.077821283577028, 0.06856738896353509, 0.07669375408239487, 0.06909644454455643, 0.06784847501356417]}, "mutation_prompt": null}
{"id": "548c8753-81d3-45be-9c9b-6b7cf20f72c8", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n        no_improvement_counter = 0  # New variable to count no improvement\n\n        while budget_used < self.budget:\n            if budget_used % (self.budget // 10) == 0:  # Adjust population size more frequently\n                self.population_size = max(4, int(self.population_size * (0.9 if no_improvement_counter > 5 else 0.95)))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    no_improvement_counter = 0  # Reset counter on improvement\n                else:\n                    no_improvement_counter += 1  # Increment counter when there's no improvement\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Introduce adaptive population reduction and dynamic local search intensity based on fitness improvements.", "configspace": "", "generation": 54, "fitness": 0.4271258577172661, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8076907851118292, 0.7856896082756752, 0.8234210816074896, 0.8059782097986178, 0.8193694094144053, 0.821886776896255, 0.8057514025041945, 0.7883067330573819, 0.830069097309089, 0.6622594075635481, 0.6585297321644612, 0.6642555812773148, 0.633041433938953, 0.6749762441108637, 0.6263231583951867, 0.6860312046520125, 0.6544344129749622, 0.6305163092718288, 0.12930383578893712, 0.19146483818647198, 0.31800775918940016, 0.13026763369883687, 0.2384770517763729, 0.19407753939703232, 0.11240081581677608, 0.20709451657278155, 0.12269220055734276, 0.13329438709910846, 0.1156035675642677, 0.20386089527607332, 0.12169851239292706, 0.1244559029159118, 0.13124441690545863, 0.16266340449956296, 0.14215910807124432, 0.12705316964844893, 0.9121574203684784, 0.8964656436839578, 0.8996763854557954, 0.9234745275830837, 0.9073200863089238, 0.85299909233363, 0.9617717097302517, 0.8603419959795506, 0.90598620186317, 0.4821988094070505, 0.4913281587217877, 0.4583176342168537, 0.5052166774379229, 0.5192727448845118, 0.533857745823116, 0.49922828941433506, 0.46032686321096594, 0.5848629856652117, 0.8137793568351815, 0.2249380582675209, 0.8042434651244735, 0.7932350832528035, 0.8512986483274927, 0.7657849461790489, 0.8103857033511147, 0.8155647975678375, 0.827655402302931, 0.5770156623241516, 0.21059050512380006, 0.21858867856772435, 0.18642575464645972, 0.1841462320340832, 0.29625327975858895, 0.20265427715782602, 0.21433107430941778, 0.21092684274776197, 0.20724229444641395, 0.12449496435750784, 0.21489310436272058, 0.682306519547428, 0.2367533290918683, 0.27626931590318515, 0.2981633869274455, 0.3854785490305548, 0.17428398460693584, 0.596300906282345, 0.4146679620875653, 0.5207897601990454, 0.5897105699046143, 0.5783982802473113, 0.5253005076749594, 0.5200816251880729, 0.5893249317324123, 0.537354031994537, 0.6405294702729769, 0.5302601163296138, 0.6675202877112414, 0.6910930645399207, 0.6876006681315544, 0.6445345371928625, 0.681781420496927, 0.68990642727211, 0.6690042977387998, 0.26535652976638335, 0.08740521411889879, 0.10317416271393287, 0.42641615759299933, 0.40100735420979705, 0.3711239733390902, 0.22756271074293655, 0.30727382382572443, 0.15568665883000488, 0.46006727135683745, 0.40096116209073285, 0.4480284773286056, 0.41286716056613937, 0.44537565623007314, 0.42391200955999875, 0.3839897047396845, 0.40419844600618193, 0.4518195499783849, 0.7746376218947796, 0.763338091584572, 0.7785940070141832, 0.7957978328989412, 0.8001767837529917, 0.7348830749689279, 0.7732374200024827, 0.7171133445312062, 0.7905992911077395, 0.12456336348652763, 0.12070969043075364, 0.12090425267072258, 0.12438417591520756, 0.11316422881767807, 0.12307411881773733, 0.12532154604808388, 0.10160507072149927, 0.10085060373109578, 0.19767016783834856, 0.2675177684828417, 0.24994144987141143, 0.2544208951597937, 0.4168869208709104, 0.2337319750383482, 0.2320883630602184, 0.2719844594297297, 0.16140334361812514, 0.47231709246575526, 0.4626253202878935, 0.4673619198034026, 0.4765728573391872, 0.4889753808435322, 0.5021157684664324, 0.4676130142780638, 0.4833781067758959, 0.49122238120579287, 0.3865593599962015, 0.33716462585372275, 0.4203223614833733, 0.41507184252769314, 0.39171988923158674, 0.3802885019245167, 0.398707715372732, 0.4317036341320962, 0.3635003977004765, 0.20116065220267154, 0.1913528488428553, 0.1953457881025894, 0.19919356051187176, 0.19264663283601602, 0.2114960990064546, 0.19073465188349836, 0.19065724368062642, 0.19163954319921084, 0.467984205082123, 0.5195486148064212, 0.20690908636869965, 0.3370260407764808, 0.2406233038087926, 0.21009055607071814, 0.2585591853597311, 0.22952344794176904, 0.21239191269548252, 0.1813555407537406, 0.8414873577772916, 0.8237877096292804, 0.74376176752178, 0.200961172027886, 0.7355679845255204, 0.18421608268221012, 0.8149278226142974, 0.19259153992147526, 0.7159648695689611, 0.7403245587571774, 0.8358257002471214, 0.19963148400830044, 0.6592397743365286, 0.16468875718009168, 0.20864901602238484, 0.8714040102382631, 0.7903794490039477, 0.18551933300621393, 0.19861229790064072, 0.2011685249978158, 0.17611734499101006, 0.22800782249829832, 0.19209735053930566, 0.17674692124760316, 0.1924890337264351, 0.20880512798299755, 0.09019716255716559, 0.08152795522365364, 0.0819423094408609, 0.07849435006070449, 0.08871199871072599, 0.07762373511129883, 0.08127026396766923, 0.08384234405657243, 0.08130216954984282]}, "mutation_prompt": null}
{"id": "e9f63bb3-56e8-4acf-9f58-671f27e423d6", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n        self.phase_switch = int(budget * 0.6)  # New parameter for phase-based control\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            if budget_used < self.phase_switch:\n                self.adjust_diversity(population, fitness)  # New line for diversity control\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability and budget_used > self.phase_switch:  # Condition adjusted\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + 0.5 * np.random.rand()  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.05 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Reduced step size for more refined search\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.85 + 0.15 * np.random.rand()  # Adjust range of crossover probability\n\n    def adjust_diversity(self, population, fitness):\n        std_dev = np.std(population, axis=0)\n        excessive_diversity_indices = std_dev > 1.5\n        population[:, excessive_diversity_indices] *= 0.9  # Slightly constrain widely spread dimensions", "name": "HybridDE", "description": "Implement multi-phase diversity control and adaptive mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.3175680868009612, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.7146078794678159, 0.7221683809543753, 0.7155330824940979, 0.6957681008480319, 0.7214039800005391, 0.7069255968764482, 0.7300219390250988, 0.7175253410542239, 0.6999852643640034, 0.5059713351082773, 0.5551066333997228, 0.4998030873881406, 0.4889356525724319, 0.5158852908084024, 0.5148550958797067, 0.5126718517431612, 0.48954456547237546, 0.5289214037598698, 0.09283097743352609, 0.10547234797126437, 0.09431893103214983, 0.09965799005192444, 0.11649889753937792, 0.09051367969573454, 0.1270064797404904, 0.10562524349065772, 0.10751088563881528, 0.08870940661890714, 0.08064223657078184, 0.08867651163351298, 0.09066909744108476, 0.09663727711540882, 0.09649914911528779, 0.1105717111630371, 0.09481912304481122, 0.09915364072473953, 0.7864147306078796, 0.8910240402293568, 0.8798784251406023, 0.8274991184837434, 0.9328980427864725, 0.8395105469056435, 0.9458121929796335, 0.884879475990467, 0.8901771868755664, 0.3481630518885882, 0.3779872801093058, 0.36408154056209374, 0.38888771785293097, 0.3710849959334853, 0.34399569099977667, 0.3924979947586533, 0.3536302574577811, 0.3519378718754397, 0.6818769613789253, 0.5267608924007567, 0.6744101754534514, 0.703376927828943, 0.6737389607207764, 0.632985342864518, 0.6983930025068501, 0.6201920347416678, 0.6729199870838061, 0.3018894731109144, 0.33486413655137626, 0.28736167031541326, 0.3061182584610642, 0.35241015193070846, 0.27281318362685647, 0.30293959090916966, 0.3011942826935411, 0.3116961490418251, 0.3364433558345129, 0.3284503986182945, 0.26156226347464784, 0.3067546033378916, 0.32917467842223846, 0.32377224467416377, 0.3226316071422529, 0.36208833927233064, 0.29459097345101326, 0.05693256223792664, 0.1533979266347758, 0.15217874623361438, 0.181406057014179, 0.15620686167126874, 0.07155836633896828, 0.1638805878641757, 0.19143898922355806, 0.24887686914455975, 0.12500271727727996, 0.1551298121014093, 0.12132726732592514, 0.11903540347760577, 0.15424089224022552, 0.06280184504855901, 0.13525769602368487, 0.09146915467709515, 0.1794374572405828, 0.12340975638892815, 0.09810226721935378, 0.09460893311056318, 0.07645205517767228, 0.182191623918054, 0.09448761208756329, 0.07614632873959215, 0.06692927088485956, 0.09458629395688534, 0.2151264390975941, 0.25943553967247757, 0.22526732562964946, 0.2489271308172839, 0.23953026261744303, 0.24726096305308698, 0.2364478636615246, 0.22314396842377693, 0.19331408628541102, 0.6198166499296472, 0.6307883332877346, 0.6085437227311327, 0.5715374945239082, 0.6199015779046921, 0.6140418560479888, 0.592544061194131, 0.6206840784257441, 0.6120009671943485, 0.09223036798745865, 0.09333977298496976, 0.09249727470838842, 0.08965803823193141, 0.09825748867072348, 0.13018965503842028, 0.10000838982321525, 0.09800614189491474, 0.08148728767658775, 0.16921988491521534, 0.15366768375354145, 0.143973676495881, 0.1524255979428557, 0.14668072834854173, 0.16399231009871196, 0.17992265724913614, 0.15511161879086155, 0.15543796670864574, 0.32571390717055815, 0.31339248944494447, 0.32367754992734177, 0.32527327214329116, 0.33835726872730476, 0.34311839177125414, 0.33487645031307434, 0.3362096920603146, 0.31912239080575744, 0.26135663221797445, 0.2691249567060816, 0.24185630816119874, 0.2727606440546596, 0.2839620172414349, 0.26290158627773696, 0.2401887936324687, 0.23810185784734506, 0.22820017807729365, 0.20147023594225177, 0.20497928126278153, 0.19919368174826357, 0.18192772243292277, 0.1935005453244376, 0.17968131170391077, 0.20701156011925415, 0.20292009618913742, 0.20045567632539874, 0.18293246763265314, 0.19069355849869873, 0.18119302476049814, 0.18662848084720562, 0.1922082570561413, 0.18469596809220235, 0.1843216948021582, 0.19552692758151657, 0.20170441108683002, 0.7309460791264624, 0.18057245770152808, 0.18496341988404474, 0.7520239543702645, 0.7406941065048431, 0.7037844829085411, 0.7696493829126385, 0.7123863063058595, 0.6406284645061464, 0.7624173126208519, 0.20276605584773866, 0.7028738306931972, 0.4485763706146334, 0.16451999696563457, 0.16653247279084626, 0.20787430218412128, 0.19805744846104723, 0.4043029204287534, 0.18738764593512458, 0.18543028625713487, 0.19054149461569048, 0.1891863053450341, 0.1775356295259486, 0.2105529028900498, 0.1803244500551051, 0.1881544738172921, 0.18209919817106412, 0.06994602585257614, 0.07466143356169652, 0.07493884964082786, 0.07688313873882746, 0.08116895824329273, 0.07992494546143625, 0.07050576128945507, 0.07667016108086278, 0.0818563461127525]}, "mutation_prompt": null}
{"id": "0cb0d706-adb3-46ec-873c-36e6d973688b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c]) + np.random.normal(0, 0.1, self.dim)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Enhance mutation diversity by using a Gaussian perturbation in the mutate_and_crossover method.", "configspace": "", "generation": 56, "fitness": 0.23549718705669118, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.4511959126347783, 0.44939450104861023, 0.4329474947904285, 0.4318848826749542, 0.4394299459116905, 0.4358482946902482, 0.42290796412663667, 0.4279468053173717, 0.42278526462911814, 0.07528559663540113, 0.040613376631187914, 0.05177868389863849, 0.06098281569618391, 0.03355224409199087, 0.0631806080956765, 0.06341900919185173, 0.056919358802788755, 0.09358272483644647, 0.10580943221728722, 0.10082447392022964, 0.10774852127734524, 0.10450777522714927, 0.10424247489796523, 0.10527164732150962, 0.11722208584350724, 0.11140989654199585, 0.10298909149801161, 0.10244663038895419, 0.09759725946325692, 0.09127318568205323, 0.1077522968371013, 0.09193912635889578, 0.10925457032667452, 0.09904566387471259, 0.10245970059652554, 0.09371106026709208, 0.9059006671644183, 0.9163940779556328, 0.896115347211633, 0.9646559896208701, 0.9787791692808993, 0.8525841487812995, 0.9162917727767337, 0.9425232057453574, 0.9005295335717971, 0.30567141713689727, 0.2657496854277833, 0.30136201773358073, 0.2661844727098601, 0.2921232006171841, 0.2691290953136405, 0.291544192695413, 0.27640921881429825, 0.2973065652166458, 0.5347221191523254, 0.4499844768294754, 0.69173280523697, 0.3546479073765638, 0.48768747935109746, 0.6404754602623588, 0.36450005717138423, 0.33019127667467074, 0.3526765848046216, 0.16815937346218546, 0.16201594069912517, 0.16684229316710608, 0.1641101067952575, 0.17393840742632782, 0.16564812514759775, 0.1613777254178833, 0.16645019116883142, 0.1683864088738728, 0.16799511082985286, 0.1673488602080091, 0.17934643072978707, 0.1620975118687129, 0.15516596188117615, 0.1513673766761996, 0.16984395325360424, 0.17151865508692732, 0.18685306735368823, 0.041807065951052214, 0.03710094704263811, 0.03209978024625748, 0.028676903546390742, 0.06566336128685812, 0.0416395073210688, 0.055105854796430376, 0.04840519785444064, 0.04742175810044669, 0.10678292051744209, 0.12215996997218481, 0.13725225630167537, 0.07160585218054671, 0.10963947948918595, 0.16279934463497936, 0.112333511290587, 0.10139447043549277, 0.10459534521400271, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10878896256872117, 0.12419595631524483, 0.10684152812782699, 0.10484882387742855, 0.10778675831576878, 0.1164367293896823, 0.10464251533569435, 0.13242898320368035, 0.11316201228984413, 0.4251778007536542, 0.3973281462898992, 0.4145697758343422, 0.405239375874617, 0.4352285680566077, 0.41294321223318753, 0.3916710578716516, 0.40512179763850176, 0.41812975231068705, 0.09935963005521065, 0.09821959742111686, 0.11577969130451637, 0.11279581770898073, 0.10371171036289384, 0.1097627461222821, 0.10643151555860608, 0.09710317012253267, 0.11089956392591704, 0.14862349860973123, 0.20508978163327007, 0.16216786637157987, 0.2666233176913414, 0.1905463598513637, 0.13761457180763426, 0.17962328716939757, 0.18072414344157428, 0.18427692080068314, 0.28631361209499784, 0.2860659887543511, 0.29226842884656035, 0.2899618808911575, 0.29076785088945045, 0.2946501354751324, 0.287926401618806, 0.30455982099404866, 0.29621459701765795, 0.24126498181066813, 0.2292207416696953, 0.24019110477826855, 0.23208022815465656, 0.22721600381249596, 0.22914784994649562, 0.22835365230370774, 0.23187561474417573, 0.22876294831201716, 0.2005536400544271, 0.19556865156552816, 0.18852238059302628, 0.2027193247123863, 0.19446867663114087, 0.1956276608660369, 0.18575520093192222, 0.18891926481296972, 0.1892466967577544, 0.1814737643445138, 0.1855654977312351, 0.1937136235211756, 0.19696484612009701, 0.19872042943282442, 0.25755691302803485, 0.19508896514214735, 0.20178941645640402, 0.2267734321884749, 0.6476098514900972, 0.5718571432934333, 0.5424532651079219, 0.5760707587893956, 0.572797800111888, 0.5385783335763081, 0.15985202600906578, 0.5254528647051953, 0.1460569273187401, 0.16626147334163066, 0.2031251858952552, 0.3932997897249214, 0.6688408153862939, 0.2044897869555311, 0.20076044831983952, 0.5126687426031379, 0.20382146358779618, 0.1507481722592129, 0.19414477758448412, 0.17915617698111674, 0.18279757543777664, 0.18939831513104022, 0.19122416584714497, 0.19145589011683806, 0.18445984511570768, 0.19648844186104808, 0.18910427222789483, 0.08607320732184232, 0.08111956036894064, 0.0830908183035326, 0.08440961106290701, 0.08734452293408435, 0.09010792225390318, 0.08362521217136787, 0.08417025606554474, 0.08383046462883648]}, "mutation_prompt": null}
{"id": "cb4aeabb-048e-4c31-a504-a82061e8be11", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters(0.01 * (prev_best_fitness - current_best_fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Increased range for mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self, improvement_factor):\n        self.crossover_probability = min(1.0, 0.9 + improvement_factor + 0.1 * np.random.rand())  # Use fitness improvement to adapt", "name": "HybridDE", "description": "Improve exploration by increasing mutation diversity and refining parameter adaptation based on fitness improvement.", "configspace": "", "generation": 57, "fitness": 0.43354880175595256, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8002761553919289, 0.8147024655991519, 0.7809618143606528, 0.799667792464086, 0.829995271685387, 0.8046654521971104, 0.8209661330495617, 0.7989490227584766, 0.8072421054774871, 0.6485058445912191, 0.6552825969336484, 0.6471120206294602, 0.6628826871873805, 0.6513311975737142, 0.6184101543384467, 0.6511721326966984, 0.6172031569784981, 0.6476771897050295, 0.10155183182509953, 0.12662894644158074, 0.11974823065088169, 0.15290427629105363, 0.11443970682561244, 0.10146445179390451, 0.10518155824869646, 0.11421705655454406, 0.12331396711038867, 0.08911650479207578, 0.10057576655531941, 0.1368379395805196, 0.1163275841467295, 0.08792892638980576, 0.10471209202479936, 0.09513782582592045, 0.12253757119288422, 0.10455590161582318, 0.8829190202303487, 0.808282458345335, 0.8951800840401631, 0.9519909586311776, 0.8423554551921104, 0.897451140811494, 0.8341802001914412, 0.9243911024909034, 0.9596262233506866, 0.4330717124460659, 0.544019661166195, 0.4658927542666377, 0.48228456313614354, 0.480756928548273, 0.48814382767307785, 0.48524794407821614, 0.5361389353208709, 0.5336542908429343, 0.7931356914726359, 0.7905693902127371, 0.7555596513837622, 0.8316636539101185, 0.8202312513808167, 0.7980247839372565, 0.7968773184699358, 0.821524774065211, 0.7851419195008169, 0.23386292565532008, 0.1687158124949687, 0.34447365761549675, 0.6213191318878073, 0.3127451643151494, 0.5046957237431888, 0.5368121454826804, 0.3809925425487066, 0.3732846926253973, 0.4098791585664713, 0.2106387138828668, 0.24836118344590297, 0.5748567085097473, 0.39834674302159234, 0.38321762209872967, 0.20033182305409591, 0.370012471128797, 0.2341721075585721, 0.547395883066581, 0.6286001147063878, 0.5702817489049578, 0.5491488364083732, 0.5892284305480456, 0.5729407665019979, 0.5576355231824668, 0.5495564215471459, 0.5391046032284177, 0.6803095142603002, 0.661043015907278, 0.6632437004819793, 0.6578234500799218, 0.6591594510586638, 0.6562960705058881, 0.6448578046672515, 0.6575771670559158, 0.6870730462521678, 0.09574142471824254, 0.1991920120385161, 0.09226742053468806, 0.42955554471495583, 0.43166287118192537, 0.38195629982007895, 0.1773703244667666, 0.2214388536699886, 0.24933226197699154, 0.43573278889232603, 0.4042199696173011, 0.4143428060716423, 0.4352326036104104, 0.41978246322529156, 0.4171277888383078, 0.432255591652587, 0.39419897000692083, 0.3931592651861061, 0.7154160002134871, 0.7563214866059731, 0.7585318683139209, 0.7530166996034875, 0.7315367697198008, 0.7672337654123699, 0.7565727126175011, 0.7488610441140815, 0.751999938740803, 0.11296681401111086, 0.11551662219437309, 0.09839832251158043, 0.10932295324855601, 0.09626994198427474, 0.11211396990767375, 0.10571028011496308, 0.09089752022210618, 0.09848352241326297, 0.24355280008129865, 0.18833493049561556, 0.1724422544068035, 0.21216691139659916, 0.3552508814553247, 0.14191090761304292, 0.4079846423498047, 0.14163500075252233, 0.13825793827058241, 0.4766124486539125, 0.49116393583840723, 0.4728815116704562, 0.4460658697723594, 0.44604398363208997, 0.42684552501276707, 0.48298903599243603, 0.4597414035383076, 0.43884970178300187, 0.3551918334540827, 0.3711220993794043, 0.35623755201619267, 0.42459652839795725, 0.38072506066515954, 0.34553945657021756, 0.4099911410209446, 0.40746612560799844, 0.39862524256745224, 0.18426757069141309, 0.21668380532073617, 0.19779691641053643, 0.20482474425243902, 0.20481674742963651, 0.19738485032064734, 0.18371270798253259, 0.21258893337936513, 0.1994964098527644, 0.2916147405855102, 0.5284997358790707, 0.2222566931063351, 0.30080417275699545, 0.5650772455822566, 0.3113845142767462, 0.25435173201979255, 0.4966451468036345, 0.27589241165945144, 0.16748084807402852, 0.8129522605387478, 0.778817584998372, 0.7526079389119902, 0.19473681397567777, 0.6888471157563941, 0.653513265558493, 0.8063646932116155, 0.7252524230774551, 0.6505812087479531, 0.20252603871573482, 0.7165688742508989, 0.6980658358773107, 0.7409482111735606, 0.7609990745520124, 0.20918263660974468, 0.8319224432417147, 0.2111755655281945, 0.1771110298921249, 0.1890420664565423, 0.20030090215495533, 0.18753311164141628, 0.18550880829891347, 0.19356514712978612, 0.17955445809544346, 0.182745197674701, 0.1814472713967792, 0.09376690584897351, 0.07960718629687724, 0.07758687673316433, 0.07719169112763613, 0.0811816615791866, 0.077274426637153, 0.0786009935445332, 0.08005805837133684, 0.087366358151175]}, "mutation_prompt": null}
{"id": "67965565-7253-4472-811b-30e431c345db", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        diversity = np.std(population, axis=0)  # Calculate diversity\n        self.mutation_factor = 0.5 + 0.5 * (1 - np.mean(diversity) / (self.upper_bound - self.lower_bound))  # Adapt mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Implement adaptive mutation factor based on population convergence.", "configspace": "", "generation": 58, "fitness": 0.23361049537556242, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.4455044086294111, 0.4534602864746725, 0.4113159895700921, 0.4953035007930645, 0.4806014378415503, 0.4630338027680787, 0.4641846525263881, 0.467951976247338, 0.49265674536813, 0.23317023005597903, 0.22488598037054175, 0.23993736603026916, 0.22632259411652034, 0.20750603672608126, 0.24557893633283412, 0.24992117910720768, 0.23379160112952924, 0.2569946692826657, 0.08910289320202958, 0.0898234535780652, 0.09155122105688973, 0.08444597924796726, 0.08060426615640193, 0.10982774390445593, 0.09793146131642694, 0.08684063847838774, 0.09294491554947382, 0.07812356254608765, 0.08024595736445694, 0.0818720267835864, 0.0776337694748872, 0.07667833758199505, 0.0808696122772542, 0.08394054869811896, 0.08273782822557663, 0.08099615676777916, 0.9563651350256573, 0.887675260816287, 0.912257149563691, 0.9127911129454771, 0.9740397641980159, 0.8894860100599107, 0.9489954438361603, 0.9050325541326913, 0.9034128249848887, 0.21449743517471265, 0.203057190844407, 0.21169918935402343, 0.22165188513808765, 0.2405699829921929, 0.2174983824076211, 0.22836842949507186, 0.23240868395383651, 0.23335502389861884, 0.33228355069158877, 0.34921575356156276, 0.4118329257173372, 0.4316837220397326, 0.46898698216492785, 0.4160278093021348, 0.3022996155292108, 0.3624644510481486, 0.43461029396956063, 0.15400761169108523, 0.1513221391598123, 0.14359543878217973, 0.1572009651917866, 0.12214728084615034, 0.1438213772593383, 0.11731206235615477, 0.1243203393202259, 0.13328424265003613, 0.22923161147937354, 0.16197770984444781, 0.2018306060826217, 0.12371160703220174, 0.12063503383771257, 0.129753855633851, 0.15903540177241227, 0.12517028918529083, 0.14636477568362338, 0.1418269584951105, 0.10486840772913442, 0.11811113498390313, 0.14065210113184334, 0.10393533329068905, 0.12095284688022478, 0.11396741053722204, 0.12680523435241087, 0.1365175185834132, 0.2809281002360001, 0.2706975910258499, 0.24485880126537907, 0.25185414809733153, 0.23596510743774501, 0.21899706584496215, 0.27398871245975054, 0.24299279469594393, 0.262736057009321, 0.005353011052583345, 0.008903265188005882, 0.012375124723180475, 0.011120845210717767, 0.021189335695442457, 0.013422514387990803, 0.007019924294507818, 0.006764977560464458, 0.029062827840554584, 0.11389486072366073, 0.11615506633397221, 0.1271828099709732, 0.10965615985037769, 0.14138561158229623, 0.12830204622323582, 0.12644479520172225, 0.10655012154159083, 0.12421848165575156, 0.3931814723688507, 0.3975056501403196, 0.39795043287768217, 0.37838811297321207, 0.4025823030982857, 0.4280094538888901, 0.4190998526870471, 0.3809189568392837, 0.38562382611082435, 0.0805814310498223, 0.08115928433548292, 0.09788360831537335, 0.07128441515419981, 0.093937535493129, 0.08762761461673252, 0.08511479189184934, 0.08531451102933185, 0.10219287595081239, 0.18322055635739154, 0.15138204886208073, 0.24362683200204682, 0.2137179463233344, 0.2534534739850014, 0.23182541919998545, 0.252684204579149, 0.14401538429639005, 0.16871746928313747, 0.2328307287785255, 0.2683039655960592, 0.22674458292977429, 0.22657869852749812, 0.23830326540409807, 0.21151033550425358, 0.25176159875461523, 0.24762141897982892, 0.2408108159162754, 0.16645970155079304, 0.19474718824410542, 0.1747083966884735, 0.19143609501096703, 0.19666699734945225, 0.16709902324532067, 0.20245479245538534, 0.17887571654746282, 0.19475781432635197, 0.179107501225524, 0.1828035082873518, 0.18011214714514334, 0.17431217437924462, 0.17700971418336742, 0.16606727446401237, 0.1744624172845528, 0.17020360816066915, 0.1689822564510075, 0.17531396462882753, 0.18232839704603165, 0.19316270695310533, 0.18393325854607911, 0.18209277874741336, 0.1719736687711556, 0.17213684641621008, 0.1807614490238746, 0.1691527171229794, 0.4737503346102584, 0.6418935087977582, 0.17541111427538503, 0.15262085094714184, 0.549566503061786, 0.4486329631364231, 0.1758698358972015, 0.31538277512814095, 0.18312350310390046, 0.1972741801203649, 0.41022045500249515, 0.45722052302032457, 0.18344012092593498, 0.29876214270279955, 0.33644951054877814, 0.21070966539808766, 0.6152975519380688, 0.20776343382311124, 0.18266101694156733, 0.20102005937633838, 0.1931650130188718, 0.18322171385298192, 0.175227858428887, 0.18389061767479353, 0.24476035561385512, 0.1876974651205061, 0.17248047589518611, 0.06127850827532477, 0.06996327628141408, 0.07456776573417667, 0.06194762536645193, 0.07401628600334809, 0.06719949100745704, 0.06895570065049905, 0.063309137103843, 0.06929089465526872]}, "mutation_prompt": null}
{"id": "8d4782f2-7325-4bb2-a633-fffdb7dc1c3e", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Changed from 0.1 to 0.3 for more exploration\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce stochastic parameter adjustment to prevent premature convergence and enhance exploration.", "configspace": "", "generation": 59, "fitness": 0.41487411503859983, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8076828446083335, 0.8022500122526967, 0.7955691162747383, 0.8067336321746909, 0.8045023518438389, 0.79778103388134, 0.8026256798097898, 0.7867430320106606, 0.7944104690330984, 0.6338574292515614, 0.6716130758047594, 0.6565127021522864, 0.6297890206703775, 0.6477060129229932, 0.6705815059683577, 0.6614778187459271, 0.6190419197883152, 0.6411891364201284, 0.09417807551019286, 0.1092457520217206, 0.12271712603542151, 0.12800881101103223, 0.10573917406191635, 0.10009914510234375, 0.10058087694735118, 0.11582766120946397, 0.1166551422598443, 0.09854072553747395, 0.1044545629418977, 0.10567683753358192, 0.1038424489677171, 0.09738474196859404, 0.0973939107242282, 0.09310553587710602, 0.10600941513602558, 0.1036525499076919, 0.9412500014530969, 0.88159004013638, 0.8815177193102217, 0.9481569885585154, 0.9822507951528109, 0.8679518562739785, 0.8930047403196095, 0.9291747590849403, 0.9590230607338446, 0.48921451635207136, 0.49438431261324667, 0.4747667277055503, 0.46742475282887463, 0.496027203184644, 0.5030552510472261, 0.5171675790819763, 0.5232827742722213, 0.514988608133066, 0.815754527817983, 0.7890992975204119, 0.7680013837023986, 0.7739979738348488, 0.8216969119062794, 0.8054257539435634, 0.8063857133374912, 0.8166485536117422, 0.7797740576539651, 0.3522382626145376, 0.27232731659194576, 0.4580756325541795, 0.37866917156289037, 0.35213248081075754, 0.11819049993201025, 0.5428814347641134, 0.3147269155116449, 0.29056611836886526, 0.56648512559984, 0.5307236688819401, 0.25251274752391095, 0.22295566014604917, 0.56247830085312, 0.30274371814666123, 0.2622939608225826, 0.21625587904039711, 0.31581692707920384, 0.4873727084187699, 0.5347309232675417, 0.5151959812548392, 0.6107901035276129, 0.6009142335023514, 0.54315798520677, 0.587860180751584, 0.5935798599827051, 0.5249501362339186, 0.6780069074196741, 0.7001888619267941, 0.6893650230742068, 0.6422785669223314, 0.6824232573477411, 0.6530042724502871, 0.6703990362207629, 0.6959689225608519, 0.6339885150490078, 0.24598933587063343, 0.13358803145587594, 0.19502805645296473, 0.4056022402024825, 0.21437121517781021, 0.4464228831723285, 0.32040637362106916, 0.15073158179874513, 0.1579404196939851, 0.39465068703456496, 0.43279854696867104, 0.3840714328703667, 0.3902276351152766, 0.4248263665862061, 0.43927421063862526, 0.3839529050607444, 0.4458032880835394, 0.34000263946087184, 0.7342253911687368, 0.7682846312114634, 0.7597564554260592, 0.7364888221637654, 0.7627454478219449, 0.7537481331964068, 0.7579310342475021, 0.7491265455291753, 0.7478680289609257, 0.09488803218174757, 0.09542022017517371, 0.09978595152780145, 0.09410896962955972, 0.09794115630450284, 0.09694316460277097, 0.10063888860539205, 0.10896970472795187, 0.1042558332718252, 0.25187449828050945, 0.1548357481201127, 0.16113267184370583, 0.17103325739382547, 0.1655124147044298, 0.15667691268536932, 0.2507457870842552, 0.18363640393189518, 0.2386811539227338, 0.40709132494536815, 0.40824323105641425, 0.4720601347066796, 0.43834517470124224, 0.4470468104228873, 0.4415939283661712, 0.43449441864208915, 0.4515674696501837, 0.4558180198514712, 0.3401598952499302, 0.36967379007253764, 0.3560179641440918, 0.3439118934555372, 0.35698090373328784, 0.3904928824636922, 0.3818437088899904, 0.4064719854149762, 0.32908052787238473, 0.1953751751887276, 0.21257941611714437, 0.1869794072901867, 0.21109737495385417, 0.19071703982577348, 0.1963318493446652, 0.20240301193011578, 0.17909296584974577, 0.19826516226722346, 0.20584038100875757, 0.19101608103245227, 0.25404297172883206, 0.1978601486152194, 0.19312150682420215, 0.2370870992601154, 0.23365154792707865, 0.19119729871758995, 0.2213935151084916, 0.18785056922523968, 0.7460886109412209, 0.8212784438838845, 0.752164373752271, 0.19386842846017238, 0.7514366881353949, 0.16299192533755846, 0.7397539956037709, 0.7295953977565484, 0.7665918885049875, 0.20424923572636888, 0.5920352479946902, 0.6111608158428878, 0.15985841619322783, 0.1641322635544955, 0.2041982170175758, 0.7712629248005336, 0.20918085281832977, 0.18476735930854127, 0.18701109986875908, 0.18040033869595007, 0.18095416767290506, 0.1781817553769457, 0.19253055730496083, 0.18997015908055104, 0.177104971285307, 0.19161213936396093, 0.0826158000250774, 0.0791537495381972, 0.07503044093683697, 0.07967599344796439, 0.07756611787006373, 0.07981058309482758, 0.07547783564940747, 0.08249996309715879, 0.08841395469672497]}, "mutation_prompt": null}
{"id": "b52d8bc5-1574-404d-a6df-96113a4f9136", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        diversity = np.std(population) / (self.upper_bound - self.lower_bound)  # Added line for dynamic mutation\n        self.mutation_factor = 0.1 + diversity * 0.7  # Changed to use diversity for mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Fine-tune mutation factor dynamically based on population diversity to enhance convergence.", "configspace": "", "generation": 60, "fitness": 0.264966733870202, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.4446748065300026, 0.5376630905073123, 0.49956638146950205, 0.7569578849010946, 0.7894940618770379, 0.8276860639369968, 0.5076480082170891, 0.6251123306031021, 0.4528384119587887, 9.999999999998899e-05, 0.10544940139339654, 0.07822968055374235, 9.999999999998899e-05, 0.14019986829483566, 9.999999999998899e-05, 9.999999999998899e-05, 0.14463614444535122, 0.3131221441124795, 0.16155717179223772, 0.15297421182205584, 0.18749778486539148, 0.15992414747205785, 0.14672780129333007, 0.1499724277694282, 0.14984339730720675, 0.15350679881980034, 0.13586792919884683, 0.1206317341630242, 0.13226185347946573, 0.14353623170856322, 0.1475532478846726, 0.1020531728803149, 0.14297562155515675, 0.1382697335358618, 0.1497142924783038, 0.11678007584825822, 0.8376565337091109, 0.8510554420737519, 0.860494147401057, 0.9476338576191199, 0.9083009730312258, 0.7210408242929411, 0.8530671150304465, 0.9025814626099237, 0.9037262992246956, 0.19884371087645358, 0.2690983885150964, 0.2333575675455578, 0.23904620436168622, 0.22342954284582228, 0.21609992725700344, 0.30083618259235634, 0.22795572316544144, 0.30046501764613176, 0.32635052217789695, 0.8953362323985572, 0.21233590594938279, 0.8709232100094069, 0.26069892688668483, 0.27460458804196886, 0.16824904219313597, 0.17564586600777488, 0.36722666190784725, 0.12483738420846346, 0.16252648729156882, 0.11446680972340018, 0.1919343185139778, 0.1453181044473617, 0.11331200969183175, 0.1411529456565539, 0.2320550026562157, 0.12623961717464283, 0.12096601128066431, 0.1294960595943201, 0.16969200264077822, 0.12133981119611903, 0.25309906862979914, 0.13739424944836376, 0.13580517791316904, 0.19645610914948142, 0.17522987371802423, 0.08912298782723849, 0.09768189418941997, 0.15318258711485921, 0.11820839255106197, 0.06374982579012134, 0.09492686619675383, 0.08701464675946247, 0.07466283736758084, 0.07615570782011294, 0.2387331400495345, 0.19707926968578127, 0.12904655295972256, 0.14050084833466903, 0.16945879960806998, 0.14127964220329126, 0.08633599901939526, 0.15161492597639858, 0.22071288857531823, 0.17718164272340653, 0.04992111862016013, 0.360467167304217, 0.12719776066037958, 0.09647970929764815, 0.3081416802481254, 0.07186548099130674, 0.10615540837735027, 0.16543744665592874, 0.10770148426342419, 0.11007172141168942, 0.3257555654124431, 0.16222952615760222, 0.1695647749123682, 0.22282201530279955, 0.09449026097204383, 0.14988613490865688, 0.1231718501194422, 0.4005882555595168, 0.4432574457355327, 0.4939792471663077, 0.4791869530809375, 0.4690568852867024, 0.4265490889499277, 0.47156341221392417, 0.39215786455954893, 0.423319737008385, 0.12091954485264045, 0.13115179186958426, 0.08761896534013869, 0.14351136368175177, 0.13126169437132595, 0.12223620983954475, 0.11144900305740502, 0.1368693539756991, 0.13967933711193292, 0.19851381500060228, 0.20216547592603762, 0.2811262099457462, 0.18537596970667425, 0.31906267305033476, 0.290018013438488, 0.19611151152121042, 0.1936981998000752, 0.2581653362692885, 0.3156974070984019, 0.4326333464293385, 0.4047763403862229, 0.4866484205774434, 0.3185686959400037, 0.39787292883832237, 0.5519441546064606, 0.5047520183854832, 0.4714999530388312, 0.25035701615258754, 0.2891167235823343, 0.36831514753657724, 0.2789731904961894, 0.2859974543639051, 0.33939912132150674, 0.3037255957036754, 0.3606116218322579, 0.21121093192054918, 0.24652117645143612, 0.24972823422975465, 0.20962999517467074, 0.23610289839341503, 0.20261008624626753, 0.27245142218913343, 0.26452507104026846, 0.21640858832136078, 0.23129451264168077, 0.19279422193993423, 0.19245983379155884, 0.16874516549283924, 0.2066487165260139, 0.19977918449858112, 0.196863889867138, 0.22111634168477445, 0.2098605572377893, 0.3829224152642169, 0.861984813187098, 0.15520785847617158, 0.16273447636469696, 0.7355772869363951, 0.1920351855432888, 0.8436317824217284, 0.3982795270704711, 0.16649693201901505, 0.1752355616790926, 0.39939732395054506, 0.20745423464459367, 0.3568314740616749, 0.2049372664244864, 0.2054980641306361, 0.8054546778595872, 0.21939987473520162, 0.16784085060140386, 0.15224423181341973, 0.17487281546491962, 0.19307175499962181, 0.1809904594172489, 0.18907402719962985, 0.1771795691282192, 0.1828577553527938, 0.19066766320963946, 0.18380595363373498, 0.17527914129627442, 0.09981425732343474, 0.09970124235182842, 0.10206228443211762, 0.10065798738484644, 0.08364383282686194, 0.10668911487699007, 0.08733965964949131, 0.08288149824089719, 0.08011294838768213]}, "mutation_prompt": null}
{"id": "70b91933-c38b-4385-83ed-73c09f0ac7bd", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    self.mutation_factor *= 0.99  # Dynamically adjust mutation factor\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce a dynamic mutation factor adjustment based on fitness improvement to enhance convergence speed.", "configspace": "", "generation": 61, "fitness": 0.4387521548224066, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8151022435748793, 0.8034991048983169, 0.8201382026519154, 0.8130194617466889, 0.8304775974368135, 0.8160944524522008, 0.8064588676714559, 0.7963818598016055, 0.8220584365266815, 0.6636092898721418, 0.6926280023759248, 0.6704610564607814, 0.680777214322313, 0.684187432834649, 0.6793749558224311, 0.6888911512375773, 0.6637996132000905, 0.6583020318612021, 0.12680687489090214, 0.12451133354096433, 0.13004517128710336, 0.1366716953795245, 0.1251040294335093, 0.11162836670251508, 0.1562761507399011, 0.13119537961413497, 0.2158335870208805, 0.11006480220790549, 0.1340432905670037, 0.1371728419486703, 0.13712842133488812, 0.1213887926092242, 0.12330338357336745, 0.1317465119325547, 0.13306375268459647, 0.10172249324647453, 0.8785923560029124, 0.8401746627507677, 0.895625743143637, 0.8841955591157181, 0.8287716781578456, 0.9502497910323774, 0.8716582905750875, 0.8206543752311221, 0.9482082687411901, 0.5669408317171312, 0.5304067588286925, 0.46156293824820616, 0.5208225263920526, 0.5389303361527622, 0.4400887439697283, 0.4561505469210151, 0.5297504037196028, 0.4789170556337381, 0.8282382995679423, 0.8311955246525095, 0.81699151996263, 0.800275855124035, 0.8296924146092343, 0.8256123353385083, 0.8355050423879866, 0.8235006917251717, 0.855836102700263, 0.18935750911477867, 0.2636993189535165, 0.28235244193372133, 0.392458980289928, 0.2973067115612573, 0.18089196427276366, 0.6491982692628596, 0.23400744146600116, 0.2622892854778083, 0.2026107513023836, 0.5811956719358069, 0.16522310910177818, 0.24503152080413837, 0.18420843929298225, 0.6257696745233865, 0.5084072910110438, 0.4357807230285382, 0.3167698867799993, 0.6325739590915997, 0.633826110983693, 0.5761431593354673, 0.6107613297319507, 0.655953734616038, 0.5760277444971775, 0.6284995050505382, 0.6213099948377205, 0.6339672682331574, 0.6867995853819786, 0.5982791087774513, 0.6809840541075094, 0.7056766880291664, 0.6483045218553427, 0.644223240283911, 0.7215325898944467, 0.7314819970882123, 0.676776273939983, 0.1466910125320139, 0.07639085169028037, 0.2505279890265216, 0.48292246926617977, 0.4815806099771004, 0.16330403965965323, 0.15882871161563217, 0.34113547059181326, 0.24878657777410196, 0.464412898464054, 0.5034274469313136, 0.4201964109466706, 0.4690356228082724, 0.4006600552039812, 0.45434661974819146, 0.466959937768854, 0.5088917149739547, 0.4553802378254611, 0.7745501696752333, 0.7742221874896635, 0.8093373564634734, 0.7758918115082368, 0.7842048222117926, 0.7816482214031373, 0.7567655342689453, 0.771243936493528, 0.7590232336994429, 0.12292188308639451, 0.12433726325889616, 0.11961627765527938, 0.11049264616882415, 0.13863926546341554, 0.4625304610364147, 0.11888074890859568, 0.10702708594593258, 0.1590537730808994, 0.18633219422020397, 0.19037767440847198, 0.4318517321502642, 0.3365061450731942, 0.1534299636496722, 0.17952014673053596, 0.19918641748549604, 0.18748285519425334, 0.18778114046811512, 0.46981635135405153, 0.42503930870201734, 0.5258623607691513, 0.4670211201963108, 0.5037360811051619, 0.47913208079654224, 0.4794204187564167, 0.47496304561030134, 0.5300351082300665, 0.38303756427612545, 0.42354558847025914, 0.4102552786938374, 0.41237212251468824, 0.4253910849650092, 0.3929446473113204, 0.4404063121474866, 0.4226664499750026, 0.3962733122398955, 0.19945007208544074, 0.19046102727021885, 0.18718451232009392, 0.21358670934783008, 0.2071700987810997, 0.19681926793054172, 0.201599932361061, 0.20525223665875447, 0.21494354337893395, 0.23261347776250263, 0.2083375887993929, 0.35165907397847307, 0.1903360844906773, 0.21597119009413213, 0.5521762160305829, 0.20278280826349848, 0.22595496114476132, 0.2127228333707024, 0.2044105324932124, 0.18589481190920532, 0.8190424777382361, 0.8508622064837585, 0.651710899788204, 0.8108889344579135, 0.7696013232330992, 0.7625487646259269, 0.7568489056997466, 0.45124026074468215, 0.7950416095126175, 0.8395711239066544, 0.2010691731917955, 0.1981982876505377, 0.16429181567498852, 0.20165221602220185, 0.8159397675003429, 0.20976526088836367, 0.1904319732553903, 0.1888591138209772, 0.18491324078889004, 0.2072155347194321, 0.1806285103725015, 0.18367099601869075, 0.18939118360132456, 0.18437850773904874, 0.1825307277013566, 0.07693741069140725, 0.08356702850437381, 0.08302947023000362, 0.08352866346579324, 0.0848474534034791, 0.09337527178783545, 0.0919269015530112, 0.07745994477380425, 0.08672528179461036]}, "mutation_prompt": null}
{"id": "f7389619-f87c-4f58-8716-8e57126c8d7a", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.98  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.9))  # Adjust population size\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            for i in range(self.population_size):\n                self.mutation_factor = 0.5 + 0.5 * diversity  # Scale mutation factor with diversity\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()", "name": "HybridDE", "description": "Improve diversity and convergence by adaptive mutation scaling based on population diversity.", "configspace": "", "generation": 62, "fitness": 0.17483239725478258, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.21.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.3214598037691059, 0.33728358153969107, 0.4571952788620235, 0.7366338690270209, 0.6771671419395577, 0.6988844091616209, 0.56088250631344, 0.6263044511211874, 0.6461792697211648, 0.026357247941463546, 0.026077018523813056, 0.06082534688075936, 0.04934428273699942, 0.025754313892111136, 0.014331250338521895, 0.002746743330447332, 0.009411078829072217, 0.07711460330245079, 0.07293594049851548, 0.06576684444116532, 0.0847315677916225, 0.06441551641904719, 0.06805915361246784, 0.07359976115949707, 0.09981430253411927, 0.065265706409809, 0.07312424462548894, 0.041806098540559056, 0.04980761830212599, 0.05824562081115403, 0.04911563484827597, 0.039637439732329915, 0.03880284666894662, 0.059835512506432154, 0.04822828253429401, 0.07561597867785275, 0.9594652930943655, 0.970785604051788, 0.9925515498850299, 0.994475062908963, 0.9951320419875883, 0.9793815845450204, 0.9943301724576088, 0.9820610426230256, 0.9863220394876893, 0.19518502756268696, 0.198982281515657, 0.199610498094014, 0.15692553850034996, 0.1431846673561138, 0.14917514552469402, 0.18295630066405522, 0.17850217994812123, 0.18999413198538317, 0.16776387133953607, 0.17629099500591405, 0.13859373017822596, 0.19664686639617335, 0.1746816607996925, 0.15621892312600283, 0.1804616914938466, 0.16250285546764898, 0.21725733382418533, 0.044622323630798544, 0.0456293361380693, 0.035335488580233165, 0.1003305078199046, 0.1135500229575851, 0.06426179078992533, 0.10496093566358033, 0.12584510576735597, 0.08807004059918777, 0.20300856621208918, 0.11565708699234678, 0.17113327588164484, 0.04981498474920387, 0.04540410096656888, 0.025793554902170723, 0.06950347191553574, 0.03465671277869187, 0.029384441011400697, 0.0001641303070355482, 9.999999999998899e-05, 9.999999999998899e-05, 0.007169601451064267, 9.999999999998899e-05, 0.020620330277926424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04535158720958732, 0.058342338040051844, 0.049786249119266324, 0.09045265831131566, 0.10640423632178386, 0.06499413427015244, 0.15349373203998862, 0.05573235126206888, 0.0667418019971745, 9.999999999998899e-05, 0.0048826736721355735, 0.0025176965763071824, 0.0140332666765971, 9.999999999998899e-05, 0.016570102723785785, 0.03093415921350884, 0.032235973758749425, 0.02902081996015038, 0.14294881457363806, 0.09047251337900686, 0.09255336703030093, 0.15894740498035098, 0.10274395551677351, 0.08909771026353897, 0.20748023135895943, 0.19970950188010272, 0.2139239231083503, 0.2942826442885482, 0.32236959735157567, 0.30800238727209384, 0.29547414126523386, 0.28290134963541524, 0.29945008906012327, 0.33335822450358, 0.367607473642243, 0.3272686756068175, 0.08438796698117512, 0.0929601656723178, 0.08094989867527147, 0.06133465066453825, 0.06196473246169698, 0.056198777200438754, 0.055483401480341255, 0.05814126038342471, 0.06240390977973276, 0.15036876235820384, 0.14681977536698687, 0.14512471161834806, 0.16117257397389895, 0.22510079995872756, 0.15588118153623998, 0.22057821096048114, 0.18804002390079144, 0.15017392030173538, 0.1666845058016968, 0.16555462643285423, 0.1815767152018788, 0.1676119178148201, 0.15125391189928739, 0.1615209742315986, 0.19111945644808825, 0.19061090330245478, 0.18542806407353352, 0.1059444166888317, 0.11557033165445174, 0.11710656386186347, 0.13942567726334287, 0.16904258863191013, 0.13094440540027918, 0.11817117379114461, 0.11326169969106681, 0.10878059221350245, 0.147563732535692, 0.14834267041481786, 0.15624106522717907, 0.1583860807873554, 0.1570812237955459, 0.16431639460250513, 0.1493413417808448, 0.17649624261762287, 0.1356036824246909, 0.15353781835746216, 0.14020107155499006, 0.11351818206112962, 0.16379858953213988, 0.1421921767295211, 0.1330096234769289, 0.10780763716613051, 0.11933947783894894, 0.14392015885717413, 0.16487941948245244, 0.2892498836659688, 0.15910750890322511, 0.16882716860791225, 0.17176105796987762, 0.16369444025312152, 0.1670958401417565, 0.16738110502944126, 0.15540078652695666, 0.15190722710575733, 0.20920209212099994, 0.18490324621800114, 0.22935747529002204, 0.11488520897780852, 0.14775783431332945, 0.20121615493506184, 0.1999980327907871, 0.1982685163937522, 0.18267114445907884, 0.17928755935068852, 0.20099426339943594, 0.15520009575674232, 0.16532219110867064, 0.20829425073786345, 0.2053628965094827, 0.18518982491189595, 0.20451943954496288, 0.04609087319603333, 0.04607928077886103, 0.0418903025981574, 0.051611867816896306, 0.046158014252575374, 0.05178905166706549, 0.0484023290963802, 0.05597710000868861, 0.048673953246559765]}, "mutation_prompt": null}
{"id": "6beaf630-887b-43dd-a153-ccf911f1dd63", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        # Change: Adaptive mutation factor based on convergence progress\n        self.mutation_factor = 0.1 + (0.8 * (1 - (np.min(fitness) / np.max(fitness)))) \n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability", "name": "HybridDE", "description": "Introduce an adaptive mutation strategy based on the convergence progress for enhanced exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.25206026283251415, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.4732626082891629, 0.5445604505861332, 0.39907962580933076, 0.44456945531001735, 0.37879939487850856, 0.44130165440989544, 0.42886475590554207, 0.38820995922309864, 0.41742029777761813, 0.2481554549405921, 0.2550090460995551, 0.23899682494656405, 0.28610599932087266, 0.25076521836799026, 0.2658914379149723, 0.28471739876216706, 0.2783819285090513, 0.27934225801290224, 0.08208777496233177, 0.10817268860293339, 0.08380969798400784, 0.12136863698118538, 0.11283685942291999, 0.12382638667169688, 0.5319543842648642, 0.14360255048850346, 0.12622010917957105, 0.01155739235865405, 0.08825952815257809, 0.03023176146273543, 0.13304905546293322, 0.15317480816493023, 0.09907672051242733, 0.1250109051426025, 0.11542133546545263, 0.12127515113114717, 0.9351888013774072, 0.9632349440471867, 0.9346888036503211, 0.7053830850385041, 0.7270821164635616, 0.16795813949547678, 0.9036414457855618, 0.9081791057212705, 0.9212403795320542, 0.480949281166132, 0.5120447381253683, 0.44627510496394274, 0.3999460327791313, 0.332005005905315, 0.4548842367015975, 0.11257602231061103, 0.25005363536055125, 0.1637897818430758, 0.34818083795306687, 0.23431507959361952, 0.3567380198208322, 0.8164952111419564, 0.3653093841450107, 0.8579238810164105, 0.618836271599686, 0.5115168191544854, 0.5031375897365373, 0.16938523656533488, 0.1996289105089203, 0.2783240993992324, 0.09158383362248645, 0.05263345027306365, 0.10434126005611566, 0.22244087577616178, 0.21106807638466218, 0.20281627812529923, 0.09566871716649805, 0.20941573237593902, 0.08215578101379473, 0.15814597170963984, 0.18993208646557536, 0.12065235816801323, 0.19400211609772255, 0.17312142998287983, 0.16335543525171892, 0.13665495518517456, 0.1413754469224483, 0.1324647773673736, 0.14635722362141135, 0.1251937230404666, 0.12655923262369628, 0.12187454315732471, 0.14344504101290367, 0.1453788731009461, 0.28330048286745646, 0.32899303068275176, 0.2760189545139289, 0.24837119397476737, 0.20823307447258654, 0.2763978021411886, 0.2964608445982809, 0.30723060219082277, 0.2794551726913731, 0.02520646135715565, 0.031792707010911414, 0.018675477134397656, 0.022796937144730745, 0.04255268422317093, 0.03983172197074947, 0.03710025408187034, 0.03461583107257671, 0.02570883910012467, 0.22061222935566716, 0.2081139852925724, 0.23124114734878454, 0.10975830098617534, 0.11654344137892292, 0.12947260788646797, 0.011546336560531612, 0.017480127662175104, 0.012926171801115549, 0.37036290356371515, 0.3580255844493542, 0.373749214272484, 0.3451781446415396, 0.3502011987904542, 0.3278307045438459, 0.36913418770147255, 0.3902120046843017, 0.3924215155721493, 0.07190108288874308, 0.08751101221375901, 0.13630259919191945, 0.1363195427752082, 0.12096274598254753, 0.10793564348016893, 0.07213117165103144, 0.05897472172930518, 0.07284919204192952, 0.1916059219879236, 0.16591776255188362, 0.20723671722017223, 0.2592814128117822, 0.2868852501446121, 0.17757340518849474, 0.2293068407994967, 0.2300777061405772, 0.14977487250031374, 0.19974000273484638, 0.1642581390984429, 0.1613932299901244, 0.30802190097556414, 0.3347974841115874, 0.4348341849594455, 0.29698476979228194, 0.24690320427446755, 0.24338375091772146, 0.1386878780435722, 0.12239334745175778, 0.14194897953668884, 0.3474575778949094, 0.36207044580615055, 0.3998294142069658, 0.2263964158299996, 0.2008635287748286, 0.17075301508312146, 0.20178835361646774, 0.17546438445031998, 0.25546011158269877, 0.25973707568902493, 0.20587926081598162, 0.21293074774667042, 0.24412860059944963, 0.21411569443985246, 0.20630022711988227, 0.15190544904677294, 0.1657674588765483, 0.17233435705526934, 0.37254586223576447, 0.20541688783571466, 0.21705101246562253, 0.16234298507912737, 0.1760571727070741, 0.16874131496940004, 0.7788311378332577, 0.7698227262972315, 0.16561956662017197, 0.5857845282431954, 0.4424464695514523, 0.44834864889342074, 0.14177018017960885, 0.16608069045382323, 0.1695160178016687, 0.376914193654736, 0.15534815305809113, 0.3411409304626345, 0.6066126863627848, 0.2073357010121708, 0.16438511490270213, 0.19281302382966392, 0.20374959382097224, 0.1953209896844046, 0.19850063200084822, 0.16852569606442325, 0.18658416567343783, 0.18762384625139694, 0.22435398681388896, 0.17672733322004774, 0.2271821806548181, 0.1904965729254523, 0.19786409977291441, 0.08679066716817485, 0.08487961072921135, 0.08018891375726, 0.07938668550749628, 0.0845343929848481, 0.08559358443817255, 0.08240837866348161, 0.07348220440889308, 0.08535102841281328]}, "mutation_prompt": null}
{"id": "93688e51-0853-406a-a27a-076e097b4cc1", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.85 + 0.15 * np.random.rand()  # Slightly increased range for adaptation", "name": "HybridDE", "description": "Slightly adjust the crossover probability adaptation to increase exploration potential.", "configspace": "", "generation": 64, "fitness": 0.428558662105803, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8373701317226654, 0.8132475333970844, 0.7968356341780221, 0.817456849351164, 0.8327462287973357, 0.8158744638124489, 0.79400541670288, 0.8202727107420357, 0.8125532812567275, 0.6673199278021643, 0.6704948377052036, 0.6648021985158543, 0.6786122389489251, 0.6998835671451347, 0.6513836395633326, 0.669463537768554, 0.6878065528696864, 0.6340637277090698, 0.2800988100176691, 0.13219137213347054, 0.18160980987371023, 0.29856565517427414, 0.1188018342120688, 0.3058568465886504, 0.11247526627692861, 0.1374888994367024, 0.1246737862257119, 0.11328868726489782, 0.12428190389476079, 0.13316486099162117, 0.13247861573388053, 0.14705440703857986, 0.14952118576904283, 0.1220024285957948, 0.12141303338500986, 0.11817369865486849, 0.9102007283881732, 0.8680881870546254, 0.9179923069606765, 0.9075634471684858, 0.8155437037917325, 0.9052042409025813, 0.9083986617629557, 0.9583811692192532, 0.9509662321854917, 0.5188066328969587, 0.5540467180840917, 0.505939370273044, 0.5001788526182889, 0.5102136413092428, 0.4487571469074435, 0.6024735178315149, 0.5096669499533621, 0.5542648978448129, 0.8409086209426412, 0.7993455402506124, 0.8027868995475149, 0.8257590195968002, 0.7962673397261082, 0.7879456061036252, 0.7918142352782154, 0.782323265731161, 0.8131465630982919, 0.23066889343628683, 0.16015015710465208, 0.17335298343418093, 0.21736703934914303, 0.6355245301657635, 0.17724295577965898, 0.28404797998516707, 0.15725560597224209, 0.2339294086795085, 0.1962054051628903, 0.17020182856261667, 0.1930830914404046, 0.5259407085201488, 0.18820387134204652, 0.2968098652814126, 0.24589909147926503, 0.1834907511726842, 0.3267854847963655, 0.5882423396905101, 0.601597392726393, 0.5672519432747289, 0.6011182577563453, 0.574921249498092, 0.5494540842887097, 0.5093099316125678, 0.5535550215302991, 0.5630218230198805, 0.5949020007642976, 0.6381881020963123, 0.6535118065569913, 0.6271929026707075, 0.657196971776089, 0.6523511238989392, 0.6747667385968106, 0.6484081816681879, 0.6481407643391494, 0.2488298637499312, 0.08575819946656593, 0.15776539702368342, 0.41441140871691096, 0.45643880372335044, 0.2943855764597988, 0.19155936630342718, 0.20076694581494403, 0.2624692210341064, 0.4510661018088252, 0.3842880941485699, 0.4558221392574404, 0.4121808934240241, 0.4617202767700076, 0.43344698182825514, 0.3246033220964195, 0.39168466404444346, 0.47492392387144466, 0.7351512789481769, 0.7481504204272282, 0.8030091992790858, 0.7466388368138581, 0.7461910894497935, 0.7584449825590268, 0.7788572854282498, 0.7562384381346354, 0.7482794027847749, 0.1086432881919891, 0.14863220378267994, 0.10982278840877735, 0.11514562157244634, 0.10639221790456999, 0.11838308981996015, 0.3689814594668941, 0.11029769332595862, 0.11147694150605636, 0.14348434451540504, 0.27487852211144215, 0.17795810614389307, 0.2232411900594038, 0.16388206071738387, 0.5884991665070021, 0.3658156733052532, 0.20992952364600603, 0.24867374274544185, 0.46255376041384055, 0.49226855980593753, 0.4926856993953769, 0.5044284236784545, 0.47940929960360457, 0.4758056296118621, 0.509013447271016, 0.4835539301359063, 0.5316306989356431, 0.3401312692976438, 0.3638371591911693, 0.41632743902447367, 0.4013043428401696, 0.4169040221310232, 0.4253760114419154, 0.4071905798068093, 0.4149700037541929, 0.4010712309249982, 0.2155089842189254, 0.20526640848370603, 0.2007507066797628, 0.1969352940250928, 0.1938188397705587, 0.21729950243196616, 0.22149076042095683, 0.21617919803489016, 0.1904868273975171, 0.2184770942605685, 0.2263356066339215, 0.40668332254595274, 0.20130541056771067, 0.20916731208459027, 0.21081897674937478, 0.21655418596543585, 0.35116146302737206, 0.20357387342343325, 0.7354800415259881, 0.18689958563577025, 0.7730428910233338, 0.833447280710309, 0.7188456530149971, 0.6844842283935642, 0.19974463102477125, 0.7750235186691149, 0.7291402309769313, 0.6999150889811059, 0.20367939360446152, 0.8308922023284236, 0.16391229730233026, 0.6259366785369598, 0.16098407493148315, 0.20626740883227757, 0.8347829027619773, 0.2081181972212799, 0.19467416228595313, 0.20316385643526358, 0.19353306987668417, 0.17354832665418563, 0.2062380096005696, 0.17029698845040253, 0.17531335848889318, 0.17709498392143308, 0.1858674921395861, 0.07871687491580126, 0.08801172411445846, 0.09676454197858497, 0.0818951563775574, 0.0882624225891181, 0.09067810623452754, 0.08420059957093073, 0.08430238029388692, 0.084410272254138]}, "mutation_prompt": null}
{"id": "fb75a0d0-33ae-47f6-94fd-2eb0e9bc367b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()  # Dynamically adapt crossover probability\n        self.local_search_probability *= 0.98  # Decrease local search probability more significantly", "name": "HybridDE", "description": "Introduce dynamic adjustment of local search probability to improve balance between exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.43248514366356183, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.813104388486984, 0.8156998557775441, 0.8206564792828621, 0.7914922922626121, 0.8294900743970213, 0.837725331409207, 0.8349498653008393, 0.8134764196484133, 0.8021633715810194, 0.6812259079811653, 0.6805676854598612, 0.6749194023000888, 0.6710274009660444, 0.6869744489831408, 0.6808929049766688, 0.672124114796228, 0.6581511018215335, 0.6901797363127246, 0.14801707963807242, 0.19146779712270645, 0.13618264748236653, 0.18526973452510187, 0.1689673036144308, 0.2576536979178198, 0.16629034430260348, 0.2640146019256576, 0.11053479974063107, 0.10521732900809022, 0.1534783308138551, 0.12483484980114734, 0.1180063648225127, 0.12310792276187366, 0.1167862517965208, 0.13310844586571935, 0.11598762215841019, 0.09795259598909178, 0.9137755225310848, 0.8579252474971111, 0.8956426446521416, 0.8693440430150462, 0.8119827573866787, 0.8616687412840065, 0.9195932227225551, 0.8978414913033387, 0.9482082687411901, 0.5292299244143079, 0.5179798598153507, 0.4451674500730116, 0.5032892238013951, 0.37322445478491795, 0.5117055102729322, 0.4858770866474531, 0.5647450583022322, 0.5894759459887841, 0.8057878222677223, 0.803790815600494, 0.7966864864386074, 0.8233488616324885, 0.8393820196098146, 0.8006035642693238, 0.8019947300275294, 0.8440720812372562, 0.833542081596697, 0.5652020529903159, 0.20842553948967535, 0.45290168241314777, 0.4562775164913382, 0.2691465116918391, 0.3238231651707941, 0.1895435258497623, 0.24096891487248062, 0.17949476179906998, 0.16643842521571406, 0.2716896587769544, 0.24320587005066285, 0.5791137984067402, 0.18668102427738353, 0.18471957427210806, 0.2614063081676009, 0.22122301950400336, 0.22486166980581956, 0.5719306467895968, 0.6257411812768809, 0.575596780096002, 0.5797461410470932, 0.6228707063982527, 0.5509197889707904, 0.611953626404119, 0.6429288698835083, 0.6401145396528434, 0.6722290287838313, 0.6676689216967772, 0.6823986821674228, 0.6770071336618674, 0.6640139976242423, 0.6835376915247194, 0.7113727492725315, 0.7015935576186572, 0.6705728411969811, 0.2091093596218252, 0.1552821317193861, 0.177830301120118, 0.4862520718669662, 0.12076699042663841, 0.22623124185076937, 0.16771752773957138, 0.1517618902960094, 0.14134054300276444, 0.4560774929809309, 0.38092010000174836, 0.4946314869423549, 0.454583893386599, 0.47834942632396604, 0.45219948834660917, 0.4609174855823601, 0.4832690473687734, 0.37478495269999934, 0.742022896256161, 0.7953543658889682, 0.7732828627893699, 0.7604486115182437, 0.7818964767169816, 0.776059720729114, 0.7907538178810513, 0.6732625113878477, 0.7679670593328753, 0.134635342236905, 0.13710286347122747, 0.12504027119058714, 0.11728768919733723, 0.14309974335156805, 0.1321615984194896, 0.11484942599768344, 0.11384438007720454, 0.11362831606257318, 0.2841763473462877, 0.17934793782675984, 0.25353917993116737, 0.18471132414594005, 0.4689895511624209, 0.3039523167953335, 0.21184749387351431, 0.27979588600324956, 0.17264817408197342, 0.4310958619754942, 0.4805913116213294, 0.4903189705030032, 0.4569729763502235, 0.47203062914788985, 0.4925071863095799, 0.5404369428090485, 0.47902629519290985, 0.5335412463759654, 0.4036313307743007, 0.3804361803337203, 0.43769306511528416, 0.3770680797680266, 0.44076841880493334, 0.413093943113372, 0.4288978764449628, 0.48508753404243166, 0.512128935705747, 0.18952629372771368, 0.21214339276698635, 0.17937701195027034, 0.18889467739856747, 0.20346894341379895, 0.22868106832654433, 0.2071444632735745, 0.1995785157013361, 0.2216960986129859, 0.19306854299124343, 0.19467829989950547, 0.21331297221498158, 0.42660762598741264, 0.20016725760808962, 0.5697917270536288, 0.204694159044443, 0.21224387348521057, 0.4648857080645835, 0.201823837728191, 0.18586430037576307, 0.8394054092531722, 0.8540328922546635, 0.1920622266645161, 0.8399195749547572, 0.7723731677400676, 0.7859767441303038, 0.7790595682379424, 0.5765867052158813, 0.6990529569852881, 0.694125861558015, 0.16560977660330645, 0.16264397714410372, 0.19992030969233177, 0.20264247779057665, 0.8191877785243726, 0.20916960247517125, 0.19097553547305612, 0.19380517266515962, 0.19832704586335714, 0.1826238340904197, 0.17182914475060884, 0.18494830946066299, 0.17652846523131194, 0.18868121717500252, 0.2018445510076763, 0.08290444480650216, 0.07985941742808789, 0.09356682313086562, 0.07938907609578605, 0.08536049193256079, 0.08194416684662775, 0.08347383703193867, 0.09374668013495979, 0.1036033197624574]}, "mutation_prompt": null}
{"id": "3ff86b07-c9bc-418e-8baf-c1dc49621422", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:  # New line for dynamic population adjustment\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8  # Changed from 0.2 to 0.1 for more range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        self.crossover_probability = 0.7 + 0.3 * (1 - diversity / (self.upper_bound - self.lower_bound))  # Adapted crossover prob", "name": "HybridDE", "description": "Introduce adaptive crossover probability based on population diversity to enhance exploration.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridDE' object has no attribute 'population'\").", "error": "AttributeError(\"'HybridDE' object has no attribute 'population'\")", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {}, "mutation_prompt": null}
{"id": "6049fb5a-3991-4aca-a5c0-c2a0967c09c1", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.98  # Added line to adapt the mutation factor", "name": "HybridDE", "description": "Enhance parameter adaptation and introduce elitism to improve convergence stability.", "configspace": "", "generation": 67, "fitness": 0.4475732413581273, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "b98d76d7-2431-423c-bef6-9e4f4923098e", "metadata": {"aucs": [0.8404899898460326, 0.817962737698113, 0.8547924283247508, 0.8492794445146368, 0.8436133184780507, 0.8423219415071972, 0.8452518370528626, 0.8328226278433714, 0.8276425872471761, 0.7232777380523869, 0.6876226543231583, 0.6841686858335099, 0.7237122084110538, 0.7255106801318167, 0.7434823157726319, 0.689572585411913, 0.7205167786861526, 0.6927827152710231, 0.14959709285329537, 0.1494146856515608, 0.11457187394695101, 0.6000123867842826, 0.15911472636924795, 0.12923749871812373, 0.15099543517704683, 0.1630628382702315, 0.16974451893418496, 0.1589606750690118, 0.12591517963335486, 0.13658494543960698, 0.13157430876524412, 0.11422145942315531, 0.14135547454402897, 0.1304326041102577, 0.13020258918666405, 0.14542433780636888, 0.8738524977770745, 0.9165465657256424, 0.900912155130988, 0.9250292171289497, 0.8384829475366997, 0.9056372102995737, 0.8486810513367686, 0.928446232097126, 0.9614442470757285, 0.5544772785763643, 0.5886473775648368, 0.5907215613633586, 0.6604620463292707, 0.5768470105550845, 0.6364775484710254, 0.5711375537947769, 0.5925972530213164, 0.609434900449522, 0.8850040861211421, 0.8371661571940776, 0.8135105753992373, 0.8518438673682496, 0.8428265664431058, 0.8345630987772352, 0.8567466681827314, 0.7814139071397808, 0.8113422884663831, 0.6873072200767061, 0.6225552469377755, 0.2167363795342584, 0.26972688527649946, 0.3946215853911452, 0.16122593824452924, 0.3666092114443342, 0.5049476587900982, 0.22831890886994466, 0.244547112198794, 0.47119254353231466, 0.12956473313475658, 0.18637739132772912, 0.24516478969140976, 0.34751173594550167, 0.3556953050255143, 0.49873119598514015, 0.24044704539811956, 0.6618412964125279, 0.6607883023792774, 0.47550399701332613, 0.69992537214396, 0.1178101368693466, 0.6938601117338039, 0.653333891078026, 0.6834377656839985, 0.704695358505257, 0.6752444506443783, 0.1999565782436291, 0.7491593318086515, 0.7683939866365412, 0.756371020728801, 0.7295059581621446, 0.6700298237931721, 0.7503791164027839, 0.7042087866446536, 0.16598872667396303, 0.13451103295706557, 0.32376792664568876, 0.10886614604915212, 0.4045309845171483, 0.5280219866988968, 0.1464262693277798, 0.2501967625161554, 0.3364742389084455, 0.5149986284448157, 0.5233320094546373, 0.48141261295066773, 0.5166196903822549, 0.5574996007278429, 0.4607128056441998, 0.4955608123643205, 0.5296893985546764, 0.3473409294471693, 0.7349744953355414, 0.8101872987859542, 0.8297034366268369, 0.7986885560360685, 0.7893325478905521, 0.8099381299933014, 0.8121168255731921, 0.6709323424296416, 0.7990715990119531, 0.15098376748640274, 0.08644718806634732, 0.1280042519229282, 0.13423885080437126, 0.14503693184570932, 0.14818665056949598, 0.1345293936440809, 0.132794489140881, 0.16481326492733772, 0.7162953870659454, 0.2219496464220556, 0.2320049783778897, 0.7307033338321278, 0.7003626686631708, 0.644000543514099, 0.1918399570010242, 0.2554037647853502, 0.20064188023968865, 0.4692879592424276, 0.5391708714291312, 0.3317878315110663, 0.5175813745526328, 0.35632483487093625, 0.5353965143263621, 0.5906673760352676, 0.5952457658915717, 0.6049628693800324, 0.47025827011059285, 0.46198521479328936, 0.2982218886923248, 0.4849642975237549, 0.4726444066342368, 0.3488863134914716, 0.4661226826056366, 0.5267627495238469, 0.5071488287256376, 0.20849728525987143, 0.20882778643930755, 0.22419348511196613, 0.19011216677520382, 0.18787603189443447, 0.19115264483287164, 0.18895725877915504, 0.20931917963050473, 0.19679655531559637, 0.19775310977658278, 0.2039731131212431, 0.17803166927400305, 0.24076530002639351, 0.20624414588872308, 0.2428949000536712, 0.20374471782699166, 0.1849873587025288, 0.19791180897637028, 0.2065863278443434, 0.18657561750116813, 0.8159576439526586, 0.8435958590011808, 0.1975675751808058, 0.1737627197301277, 0.16293370851873512, 0.17576374673617834, 0.8386901399793898, 0.8754327490505204, 0.20639014404867018, 0.15463555278562602, 0.16657122701621352, 0.20677516213014724, 0.728638049939506, 0.2039500502182473, 0.8630527617747544, 0.15375753277297521, 0.1889028962369288, 0.2039261835007954, 0.18978599641838845, 0.19956803164131354, 0.2047569147018401, 0.20399963340373373, 0.17126494292306615, 0.24476347874402005, 0.30158348915957267, 0.1287342190821732, 0.07988392289149082, 0.1087737145566916, 0.09047576528505175, 0.08453976007850306, 0.09221533933849846, 0.1289165039866753, 0.09396728295795054, 0.09531023488172874]}, "mutation_prompt": null}
{"id": "f795440b-b932-4e7d-ba76-4ba8419f2af7", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            success_count = 0  # Added line for tracking successful mutations\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    success_count += 1  # Count successful mutation\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters(success_count / self.population_size)  # Pass success rate to adapt_parameters\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.1 + np.random.rand() * 0.8\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self, success_rate):  # Modified to include success_rate parameter\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        if success_rate > 0.2:  # Adjust mutation factor based on success rate\n            self.mutation_factor *= 1.02\n        else:\n            self.mutation_factor *= 0.98", "name": "HybridDE", "description": "Improve adaptation by dynamically adjusting mutation factor based on success rate.", "configspace": "", "generation": 68, "fitness": 0.4475732413581273, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "6049fb5a-3991-4aca-a5c0-c2a0967c09c1", "metadata": {"aucs": [0.8404899898460326, 0.817962737698113, 0.8547924283247508, 0.8492794445146368, 0.8436133184780507, 0.8423219415071972, 0.8452518370528626, 0.8328226278433714, 0.8276425872471761, 0.7232777380523869, 0.6876226543231583, 0.6841686858335099, 0.7237122084110538, 0.7255106801318167, 0.7434823157726319, 0.689572585411913, 0.7205167786861526, 0.6927827152710231, 0.14959709285329537, 0.1494146856515608, 0.11457187394695101, 0.6000123867842826, 0.15911472636924795, 0.12923749871812373, 0.15099543517704683, 0.1630628382702315, 0.16974451893418496, 0.1589606750690118, 0.12591517963335486, 0.13658494543960698, 0.13157430876524412, 0.11422145942315531, 0.14135547454402897, 0.1304326041102577, 0.13020258918666405, 0.14542433780636888, 0.8738524977770745, 0.9165465657256424, 0.900912155130988, 0.9250292171289497, 0.8384829475366997, 0.9056372102995737, 0.8486810513367686, 0.928446232097126, 0.9614442470757285, 0.5544772785763643, 0.5886473775648368, 0.5907215613633586, 0.6604620463292707, 0.5768470105550845, 0.6364775484710254, 0.5711375537947769, 0.5925972530213164, 0.609434900449522, 0.8850040861211421, 0.8371661571940776, 0.8135105753992373, 0.8518438673682496, 0.8428265664431058, 0.8345630987772352, 0.8567466681827314, 0.7814139071397808, 0.8113422884663831, 0.6873072200767061, 0.6225552469377755, 0.2167363795342584, 0.26972688527649946, 0.3946215853911452, 0.16122593824452924, 0.3666092114443342, 0.5049476587900982, 0.22831890886994466, 0.244547112198794, 0.47119254353231466, 0.12956473313475658, 0.18637739132772912, 0.24516478969140976, 0.34751173594550167, 0.3556953050255143, 0.49873119598514015, 0.24044704539811956, 0.6618412964125279, 0.6607883023792774, 0.47550399701332613, 0.69992537214396, 0.1178101368693466, 0.6938601117338039, 0.653333891078026, 0.6834377656839985, 0.704695358505257, 0.6752444506443783, 0.1999565782436291, 0.7491593318086515, 0.7683939866365412, 0.756371020728801, 0.7295059581621446, 0.6700298237931721, 0.7503791164027839, 0.7042087866446536, 0.16598872667396303, 0.13451103295706557, 0.32376792664568876, 0.10886614604915212, 0.4045309845171483, 0.5280219866988968, 0.1464262693277798, 0.2501967625161554, 0.3364742389084455, 0.5149986284448157, 0.5233320094546373, 0.48141261295066773, 0.5166196903822549, 0.5574996007278429, 0.4607128056441998, 0.4955608123643205, 0.5296893985546764, 0.3473409294471693, 0.7349744953355414, 0.8101872987859542, 0.8297034366268369, 0.7986885560360685, 0.7893325478905521, 0.8099381299933014, 0.8121168255731921, 0.6709323424296416, 0.7990715990119531, 0.15098376748640274, 0.08644718806634732, 0.1280042519229282, 0.13423885080437126, 0.14503693184570932, 0.14818665056949598, 0.1345293936440809, 0.132794489140881, 0.16481326492733772, 0.7162953870659454, 0.2219496464220556, 0.2320049783778897, 0.7307033338321278, 0.7003626686631708, 0.644000543514099, 0.1918399570010242, 0.2554037647853502, 0.20064188023968865, 0.4692879592424276, 0.5391708714291312, 0.3317878315110663, 0.5175813745526328, 0.35632483487093625, 0.5353965143263621, 0.5906673760352676, 0.5952457658915717, 0.6049628693800324, 0.47025827011059285, 0.46198521479328936, 0.2982218886923248, 0.4849642975237549, 0.4726444066342368, 0.3488863134914716, 0.4661226826056366, 0.5267627495238469, 0.5071488287256376, 0.20849728525987143, 0.20882778643930755, 0.22419348511196613, 0.19011216677520382, 0.18787603189443447, 0.19115264483287164, 0.18895725877915504, 0.20931917963050473, 0.19679655531559637, 0.19775310977658278, 0.2039731131212431, 0.17803166927400305, 0.24076530002639351, 0.20624414588872308, 0.2428949000536712, 0.20374471782699166, 0.1849873587025288, 0.19791180897637028, 0.2065863278443434, 0.18657561750116813, 0.8159576439526586, 0.8435958590011808, 0.1975675751808058, 0.1737627197301277, 0.16293370851873512, 0.17576374673617834, 0.8386901399793898, 0.8754327490505204, 0.20639014404867018, 0.15463555278562602, 0.16657122701621352, 0.20677516213014724, 0.728638049939506, 0.2039500502182473, 0.8630527617747544, 0.15375753277297521, 0.1889028962369288, 0.2039261835007954, 0.18978599641838845, 0.19956803164131354, 0.2047569147018401, 0.20399963340373373, 0.17126494292306615, 0.24476347874402005, 0.30158348915957267, 0.1287342190821732, 0.07988392289149082, 0.1087737145566916, 0.09047576528505175, 0.08453976007850306, 0.09221533933849846, 0.1289165039866753, 0.09396728295795054, 0.09531023488172874]}, "mutation_prompt": null}
{"id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Improve exploration by enhancing local search and refining parameter adaptation.", "configspace": "", "generation": 69, "fitness": 0.4670814651440223, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "6049fb5a-3991-4aca-a5c0-c2a0967c09c1", "metadata": {"aucs": [0.8295569832706273, 0.7933531803752237, 0.8196848734018306, 0.8238317939462176, 0.82837512379319, 0.8325393486213061, 0.8320521370947525, 0.8287655467633539, 0.805431706731377, 0.7137169543961581, 0.682225091869862, 0.7024987435998535, 0.7170531168469549, 0.6849804172716962, 0.7122741482101564, 0.665852941208829, 0.6808006072938961, 0.7153853594717582, 0.13634942252436122, 0.12034936735114565, 0.16701091538920587, 0.14629988400927108, 0.1620808580859341, 0.11499796432402765, 0.1426719331367896, 0.1407495691283619, 0.15968165084300578, 0.44215252731337773, 0.10952824233716651, 0.12001114129140222, 0.1293684944516892, 0.11137039250452163, 0.1276371715670861, 0.15910308430893105, 0.09584732603313861, 0.16101866524269226, 0.9703167635373494, 0.8753895685561045, 0.8959483090796165, 0.9380354502488474, 0.86196832033715, 0.9308031795621045, 0.9411583206878581, 0.9528649623713521, 0.9437541165228769, 0.5945673269763838, 0.6119858713626349, 0.5313469599408298, 0.5986569482834612, 0.5786384580836368, 0.5557550355275593, 0.6370061205532563, 0.6001988659219503, 0.556332455520524, 0.8545533564083584, 0.8292941364225799, 0.8374577084846657, 0.850397807351813, 0.8438218725476332, 0.8431059195024365, 0.8634203871680503, 0.8457695619722834, 0.8258165751687003, 0.5953664526433666, 0.3557805088146775, 0.4651205244895822, 0.4237874028177273, 0.58786813636121, 0.4013445305348856, 0.4900097094721624, 0.27892718118015647, 0.3527506381339086, 0.5623934303068823, 0.5075877717232922, 0.21049012732091987, 0.6907869250784933, 0.30233185358000325, 0.4199343586823304, 0.3166576063436828, 0.40710538961299025, 0.436932697892757, 0.6064870068968391, 0.646589953244802, 0.5135210940366708, 0.6508744245010891, 0.6120451391322133, 0.6246612197711007, 0.6510806731269992, 0.630430918000948, 0.6459489955685673, 0.7421449125291686, 0.7144548876130528, 0.7341853685441885, 0.7175084414122729, 0.6757005584305393, 0.6716081852227556, 0.6807157644158457, 0.7291877681717555, 0.7182644318062228, 0.3115055140216142, 0.1855468536459055, 0.3344106682089951, 0.5037602131740148, 0.48209310545165607, 0.21093639257210117, 0.16410631037522727, 0.09746384696224053, 0.3493996678000554, 0.47303073509111604, 0.5182920061480065, 0.48383651784470616, 0.515828043547524, 0.464584240053848, 0.5049809932113354, 0.5228005635151518, 0.4904952767508627, 0.443494133505521, 0.7319474483752677, 0.7795973977621056, 0.7816125534910687, 0.7983696701903358, 0.8035150793969821, 0.7939678086206917, 0.7938342206036807, 0.7742830021667307, 0.7558382033128584, 0.14186926939233402, 0.14199349771224223, 0.1711478420016187, 0.09773275823313632, 0.13466461054351397, 0.13678691775869756, 0.10806086684963845, 0.13242488288398524, 0.13295075836212, 0.24655290350974834, 0.15627835507517285, 0.21979221252035508, 0.6390061155158979, 0.1978150785422219, 0.15752650563851256, 0.2580169546646549, 0.645404093217204, 0.1936068949566231, 0.4776063005766781, 0.5320893238538303, 0.5803640281044352, 0.5062449094825432, 0.5979482022239688, 0.5509107786322849, 0.48367631989833126, 0.5140096996939618, 0.5743877217709377, 0.42693391959912697, 0.43374553250574877, 0.3531372644297569, 0.47377773843790727, 0.464615106938132, 0.46754274469525203, 0.44600789368849925, 0.47099101601578264, 0.4176583830934196, 0.19286557104070312, 0.18593338154487948, 0.18671947795890786, 0.19686224901629013, 0.17735570091917308, 0.20123671049230074, 0.19111930414185974, 0.23681540332958162, 0.2394708822674162, 0.24228456089069572, 0.21582308154526086, 0.18736485989190532, 0.21338470108581242, 0.20333952610011496, 0.20518189404585863, 0.19179782983596794, 0.1994637390478049, 0.19748846252450114, 0.17044206855275446, 0.2057253758455846, 0.15232463850121347, 0.8108880078706957, 0.8502363165917826, 0.8133817081193682, 0.8401622732784987, 0.7969934226142428, 0.19206931282844275, 0.8466997706655859, 0.20540216804623856, 0.7984010892922005, 0.8361532442528071, 0.7695140224620602, 0.8358247566506339, 0.20835692527077188, 0.7969794429836599, 0.20796631448563363, 0.220652766855029, 0.1851920260041413, 0.34999230233950773, 0.18147816581224696, 0.1757758756190425, 0.17955783941603387, 0.17378409580748944, 0.30084992105386466, 0.1757822680108897, 0.0755427601115305, 0.08794760190107886, 0.10018941509412893, 0.10138650468979415, 0.09414679052668329, 0.0715122723378867, 0.1447955052797606, 0.07537586880663871, 0.08724240111075965]}, "mutation_prompt": null}
{"id": "25cbb92b-2472-49cf-8221-023f4a7b9388", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.98  # Decrease more over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.6  # Narrower mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.96  # Slightly increased decay rate", "name": "HybridDE", "description": "Enhance adaptive mechanisms by dynamically adjusting local search probability and mutation factor decay for improved convergence.", "configspace": "", "generation": 70, "fitness": 0.461084208932506, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.8585601428072698, 0.8206913625025342, 0.8331354830536662, 0.842110325956238, 0.8387625522271448, 0.8252202552508442, 0.8422909317865384, 0.8378802331727379, 0.8291411580480468, 0.7352901897502713, 0.7408628098287255, 0.6885835350991757, 0.7249483011600146, 0.6517024092788997, 0.7192684593104383, 0.7178861944069613, 0.72769464821705, 0.680533482395705, 0.13741989155891532, 0.15858886321150734, 0.1744474579724712, 0.12981341159812654, 0.16408619192220053, 0.14022680784376407, 0.14551730860609247, 0.1601961441000871, 0.13874280620840995, 0.11049852207171129, 0.5662090296981934, 0.13483768141042218, 0.12527471281137592, 0.13318949214388753, 0.16444699017764564, 0.13957099790852479, 0.13243919087105405, 0.14267722721133724, 0.969144639332941, 0.8268042718978418, 0.8943489915411988, 0.9553774426968105, 0.854311295546347, 0.8984549736848558, 0.9371506076809185, 0.9347499792448999, 0.9378280394567845, 0.5942630294472442, 0.5593024363050488, 0.5662614995130211, 0.4992900774273007, 0.6342528161975549, 0.6048797480932684, 0.6471011328587516, 0.6599644511532505, 0.5502576990210026, 0.880355665581304, 0.8392167891425689, 0.848649226629756, 0.7651610954734104, 0.853284368704883, 0.7997395013535442, 0.8578478407162032, 0.8692229213280763, 0.801946095151099, 0.6643612581598319, 0.17960857197255886, 0.2753780869275795, 0.6323996881106569, 0.4202359857222443, 0.35132228638330676, 0.5006616663853697, 0.17634652887569668, 0.412184264069692, 0.16333134761225343, 0.2700415864062765, 0.2038197928111548, 0.1825923257879093, 0.2644534656975006, 0.30294343512220356, 0.7577322072075791, 0.7138628631443205, 0.54265525007768, 0.6437056506797649, 0.6960138174409419, 0.6233419493168881, 0.6814171194982461, 0.6628617708162801, 0.6676562070416387, 0.5733357931777558, 0.6798966460725875, 0.6543685483373991, 0.7057696598308286, 0.7051803261275821, 0.729950519546864, 0.7116685003962129, 0.6847044578477417, 0.7239535728780508, 0.752495741075398, 0.7377548896769003, 0.721754177913394, 0.37720597306623793, 0.06610219479270585, 0.3101330205988668, 0.22259400870215496, 0.5764440697983813, 0.22069478573145496, 0.2453578290280921, 0.15808289916594043, 0.10108501668896386, 0.5250166826846066, 0.5952421566365543, 0.5779770061787959, 0.530539854276888, 0.5608574086279248, 0.5341495930326405, 0.3931677368710407, 0.49403567613834076, 0.5269224147452296, 0.8069102786503466, 0.794909788024197, 0.8193621881049924, 0.7823542054689538, 0.7942091417552325, 0.7950703588661197, 0.7950833811868825, 0.8170585527550575, 0.8113253848570172, 0.11499384841116733, 0.12513569029864868, 0.17050932296065424, 0.5632284335156469, 0.13239572386612797, 0.13124520518353455, 0.08728131853788168, 0.16938014972217674, 0.1530056785184073, 0.2662572159584409, 0.5988958750125363, 0.2077934450979747, 0.24256860775361322, 0.6316582770735506, 0.14181570086010453, 0.2383090641112824, 0.17600674391840765, 0.18712558997822804, 0.5564800972492105, 0.5622224627698429, 0.5457116580985264, 0.5431364337977045, 0.604193596860259, 0.5727771398913376, 0.6121246113972536, 0.5411592896218519, 0.6189587424878336, 0.5333410874628035, 0.45749222170498915, 0.4679551098923723, 0.29361351843409367, 0.4673267250124745, 0.40840524740369544, 0.555247488361077, 0.4770280658887309, 0.5105351687136244, 0.19598273155667123, 0.1963684873050211, 0.17188172871795193, 0.202388207105467, 0.18349523605304707, 0.22073835836045974, 0.2085262023325749, 0.19194580199784672, 0.16367406344109936, 0.6677423323490588, 0.21680395791769191, 0.19668507563051485, 0.20245946428191652, 0.18916773893794891, 0.17454085056096702, 0.2046510265103918, 0.18605707354774936, 0.23424785917500635, 0.18046788882574416, 0.2075044017839045, 0.20746171578011607, 0.8661290393606771, 0.19723707295676263, 0.7928462244935224, 0.1650177835278508, 0.8742185416072658, 0.7860152039676455, 0.8777789231251636, 0.2113975208428336, 0.733771201587207, 0.2048744765626367, 0.20632566466563296, 0.16611646530708768, 0.20855249368853745, 0.8056400708168212, 0.210168504821998, 0.19390423932962975, 0.19346530521118233, 0.1772408566879642, 0.17635600628888348, 0.19289561210393835, 0.17845474303910525, 0.16697285858585542, 0.23255234323467178, 0.17479058554694216, 0.0723714365800674, 0.08451941045178446, 0.08887254823982216, 0.07425509649489592, 0.08478552231699288, 0.09707711860178447, 0.09291528795170323, 0.09918953799285246, 0.08581327409459139]}, "mutation_prompt": null}
{"id": "48bbaf7d-ecc1-43ce-aaa9-067562745a1a", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.98  # Slight decrease over iterations (changed from 0.99)\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Incorporate dynamic local search probability adjustment for improved local exploitation.", "configspace": "", "generation": 71, "fitness": 0.46642453227763425, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.8420293774480189, 0.8113177257149305, 0.83557820590608, 0.8312079060631639, 0.8247243975855914, 0.8274881404649945, 0.8357402168277732, 0.8403078051904731, 0.832627182431626, 0.6832189411605654, 0.6483043019221817, 0.6871778573389488, 0.708336969431706, 0.6704764735194598, 0.6987669255006883, 0.6764690931179533, 0.6858476671660171, 0.7072225639087826, 0.43115962092699134, 0.162115617349047, 0.14032344407897834, 0.16761237181544475, 0.14424836340629477, 0.13999059825238436, 0.13796556857790276, 0.6657055800587703, 0.16662338920621622, 0.1411734566656282, 0.1576625310438391, 0.10922333785800897, 0.1179809946378011, 0.1383272467361345, 0.1266813663043529, 0.11127358524592912, 0.1117880308605127, 0.12320175341084161, 0.9060274557536594, 0.9215251184818752, 0.9106731732249432, 0.9685752661304989, 0.9094526129388644, 0.8993981482707766, 0.920882292051381, 0.9349159622145764, 0.9345518231207539, 0.5552682577517869, 0.598966606036079, 0.5795670982477521, 0.5488131997188909, 0.5623515085761379, 0.582019524058133, 0.6044758168812399, 0.6054456192305255, 0.5941503265968889, 0.8670865556702888, 0.8261726720561058, 0.8430447200101769, 0.8369356485213105, 0.80415938357031, 0.860639456456036, 0.8298753936494898, 0.8446803721909385, 0.8171021184432141, 0.4205068858886124, 0.44626243218537964, 0.2195683663323552, 0.4687491273483867, 0.4070539357428363, 0.5170134364362491, 0.5704168505020139, 0.4903433423357628, 0.2908235741293652, 0.489229492637015, 0.12158112579247649, 0.6629417425382429, 0.4982337355882188, 0.4565036919564446, 0.5970593742807845, 0.42191941951348366, 0.6610519855654624, 0.31114396826713386, 0.5922858606096908, 0.635822048957035, 0.5966629448193397, 0.653099525050222, 0.6161065793416869, 0.6194465964374855, 0.6258071363435597, 0.6686174430871117, 0.6410449922902569, 0.7289673877811635, 0.7291599965221782, 0.7587283684255206, 0.7196918279583878, 0.674788651322938, 0.7096746761496308, 0.7256356459121438, 0.7315611823340025, 0.7132970542883721, 0.17581498534213136, 0.317926485461562, 0.2538374684610535, 0.5030788478296598, 0.5515391216873138, 0.47418828551897874, 0.32592992716189395, 0.21711125414109744, 0.2154625653367107, 0.5006397994394636, 0.5381367332186799, 0.5071727906769679, 0.48303389914707273, 0.5085923303124746, 0.4779110528899675, 0.5374005419979624, 0.5067249156850662, 0.5185619946450357, 0.7851087642582266, 0.7642925643487708, 0.786014013514098, 0.7919890640783858, 0.7947308699763527, 0.7902202917141955, 0.7658561435696711, 0.7672895209961642, 0.7547323413326068, 0.1346238149633846, 0.13557178078120158, 0.1050989173599568, 0.1645941660156619, 0.10414840725017405, 0.17282143451341003, 0.14226542752425753, 0.11794320972572969, 0.13885765105895642, 0.2796373194738945, 0.15492364212626175, 0.1706444705776603, 0.6977383408141227, 0.19665533588706308, 0.23332758955071276, 0.19074825518730554, 0.27224497114091295, 0.16694308342303554, 0.5118045081312556, 0.4864034762395427, 0.5218983944808109, 0.5531359437966412, 0.5303887002023724, 0.5028890816979045, 0.6053573515477493, 0.5165809647990143, 0.5463451173745635, 0.4600158153695164, 0.4312147251329911, 0.5270978548569917, 0.4571300920774324, 0.4295039553765164, 0.41160980027774574, 0.49072257161838384, 0.43537494480572436, 0.4715116165874641, 0.23994292804825823, 0.19766679557907518, 0.1878177020693047, 0.19451121790718473, 0.1981176071256332, 0.17796471866400165, 0.17323612557234536, 0.19008138143778675, 0.20794444566190728, 0.5605096553337137, 0.203078282779941, 0.1931163942270112, 0.19473882127475817, 0.5983262625283048, 0.6753666103259115, 0.2128793928247159, 0.2101687568558943, 0.22783652352788886, 0.1700729304494918, 0.18335120221063173, 0.20625596469720087, 0.8230677457452905, 0.8363999341699013, 0.8090276291845679, 0.16097939196435296, 0.7944445505350854, 0.17312242859389904, 0.8513340548387359, 0.20498770369868868, 0.20266949523179933, 0.2044044694315318, 0.1658459064303559, 0.8277347444400579, 0.20784092566102164, 0.8651304892506083, 0.2070338634590223, 0.17339165576652815, 0.18610741031474054, 0.175909675214448, 0.1763084692451372, 0.5030466782689831, 0.20097281581422577, 0.16562745707254656, 0.23618021904008146, 0.15956727804798898, 0.08190224332245433, 0.09890288833147587, 0.07685448616666002, 0.06611074236600356, 0.09030522708493915, 0.083356144700521, 0.08894136608634651, 0.08355157333884056, 0.08513114390569188]}, "mutation_prompt": null}
{"id": "7e1d3789-7610-442d-921a-d1ddd0287cc4", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.8  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance exploration by slightly increasing the mutation factor range for greater diversity.", "configspace": "", "generation": 72, "fitness": 0.45385274414242643, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.7884082315536647, 0.8004143841005436, 0.8038008814637866, 0.8239941139999372, 0.8144711454111206, 0.8172353795118608, 0.8030672436087577, 0.8170877271080461, 0.8081187884773147, 0.6606308222478936, 0.6496376612781407, 0.6739217617131048, 0.6585857994185478, 0.6792119623299269, 0.6503519875219173, 0.6536690087701753, 0.6850235942753424, 0.6628545409322968, 0.1163850542792979, 0.16251964149330556, 0.10738823787010132, 0.17166263452991992, 0.13595127574018384, 0.14449245695729873, 0.14119853479216804, 0.12834828230536421, 0.11521789364049784, 0.10399504357100942, 0.43284756508962363, 0.13698011669708954, 0.17223046829890754, 0.12421506365377022, 0.12446344931521158, 0.10545399133922218, 0.09902865875633615, 0.125174299740075, 0.9002935911549013, 0.9100817044067834, 0.9561191107576619, 0.9544251904916654, 0.9152247302446607, 0.8984624663188168, 0.9160832411194667, 0.9356758342823449, 0.9492052717232607, 0.5707786072115204, 0.6146428149079717, 0.5696632112719502, 0.5957153305962124, 0.572552910056138, 0.6124174476985851, 0.5935128578267825, 0.5473859651881088, 0.5523571465356403, 0.8477079577819139, 0.7912758357321459, 0.767736195272499, 0.8389199163936757, 0.8453952577778339, 0.8502139547678081, 0.8445741529841106, 0.7595605666229363, 0.8634075737579816, 0.5280092818782682, 0.3028317872850528, 0.2532453757924671, 0.597612893846169, 0.4606543411975088, 0.5232337547304476, 0.550845444146228, 0.12663635962599384, 0.44011321932250613, 0.4634564357847545, 0.20973734298292224, 0.19910438507616668, 0.5522094867117869, 0.6231046030761551, 0.3479210605389397, 0.5716558029349609, 0.6446131356146882, 0.2251421477057658, 0.5905073077798968, 0.6029123571411082, 0.5993480851499784, 0.5776683520232413, 0.5941359871822156, 0.5931293972441553, 0.589778378383333, 0.6265428295848247, 0.6161639425321392, 0.6774476352080556, 0.68643044692746, 0.7164901196250746, 0.7343613239563606, 0.7188347335420067, 0.6714917270306662, 0.6750456115900851, 0.7148382783577616, 0.6552913307585239, 0.3124768415683884, 0.23261278763796323, 0.249656264065938, 0.44126194663640717, 0.2402501768288946, 0.5540968263425528, 0.2822095166705235, 0.2882710119306712, 0.2541473770738718, 0.4795926557019903, 0.46882736657823876, 0.45605177219994775, 0.4804823986773302, 0.4627978305773587, 0.4746181314318666, 0.46291897842784924, 0.48175245776523723, 0.44524750467995533, 0.7636803641110582, 0.740734658543901, 0.7739731409419487, 0.7581704527811437, 0.7637764998616207, 0.7578238030350853, 0.7591903843898217, 0.7698298571619043, 0.7892431375778018, 0.10030997429517174, 0.1162943931183883, 0.1341676673829495, 0.14157411429459243, 0.14334150868301043, 0.16473869596727964, 0.12830806342861723, 0.10319141225179596, 0.5821519009979661, 0.5984447149765266, 0.21432394525792364, 0.22621968482739307, 0.17510158248544483, 0.7008258930246423, 0.2023232621339639, 0.60793109679868, 0.18398637081686264, 0.26427107035327413, 0.4876873401757148, 0.5225936757529936, 0.5139819349818733, 0.5237577172254285, 0.5130112951730719, 0.48445240625734076, 0.5160540756693917, 0.5205944289265669, 0.47135715281149393, 0.41344543699309444, 0.4131744923944345, 0.4659315788946534, 0.4241856796944756, 0.4746628725919302, 0.4136760374931876, 0.4536095564777377, 0.4126263070411512, 0.44978927663771506, 0.24060161767442978, 0.17337643032621985, 0.1979222036502003, 0.19727395333275588, 0.17421201213686965, 0.2125620338302825, 0.23091576258454194, 0.28284248651715693, 0.19868846867226497, 0.6119944699380264, 0.19244964820811628, 0.21484579505049906, 0.21725505426535985, 0.23375994400976297, 0.6059819086749851, 0.6015401003002083, 0.24077085476047144, 0.23485569779098858, 0.1796496756644529, 0.19848879037437583, 0.15233818971230262, 0.8348802227803317, 0.1994178878088695, 0.8169062598603627, 0.19486868894773524, 0.16761418099198833, 0.20405268068613225, 0.8281782263057771, 0.20742530104145573, 0.15236007057799938, 0.20247671074493245, 0.7891753851723649, 0.20308642729758453, 0.7876770351422391, 0.7491511748249492, 0.2099209713875434, 0.17805158981567415, 0.17188028215545414, 0.17567648805813219, 0.18419554355178147, 0.33511989492751926, 0.16965341386712884, 0.18311774659090152, 0.20266482332181546, 0.18965442037297886, 0.11072799587585691, 0.10339767579986259, 0.07808042964296147, 0.0658045904085548, 0.07669252678828542, 0.08570410656741356, 0.0900023230216822, 0.0745269119822437, 0.07996364454251048]}, "mutation_prompt": null}
{"id": "8391de9d-a10d-461c-9e2d-e09d2171c55a", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, budget_used)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, budget_used):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand() * (1 + 0.0001 * budget_used)  # Increase step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance local search adaptability by increasing step size over iterations.", "configspace": "", "generation": 73, "fitness": 0.4625615705956023, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.831092792532446, 0.805903193369764, 0.820949814875183, 0.813827923507648, 0.821796782454113, 0.8220068517124903, 0.8208134510345337, 0.8404177964918143, 0.8197839349683379, 0.6723372776983685, 0.7006139421566646, 0.6789427478717192, 0.6931332211752121, 0.6931167652576329, 0.6943287947031369, 0.675360682905826, 0.6882179302471025, 0.7145248678463, 0.49039828411781505, 0.12125005850523629, 0.14491137035584778, 0.1593411731888602, 0.1265648948411059, 0.14049498832744578, 0.14860417327656983, 0.1314436633743773, 0.504668756728742, 0.10238933807943229, 0.12808304425106143, 0.1480061508188827, 0.14983023982761512, 0.12770365047964738, 0.1352131105044022, 0.12260401573562563, 0.1433931058290716, 0.10722935009834345, 0.9703165771422748, 0.8617727319916872, 0.8978188097391983, 0.9378595898534325, 0.8798373119319999, 0.9038006726820286, 0.9412719768391352, 0.9545335672455179, 0.943802853301897, 0.5814218084767206, 0.590391609810798, 0.5829031222921284, 0.5894983960242963, 0.5961485671995446, 0.5855069538360378, 0.5930252823260798, 0.5623295210020708, 0.5797739312223591, 0.8392871884300279, 0.8061719399480717, 0.8288359975671624, 0.87140585788102, 0.8619655865643594, 0.8491013885373049, 0.8209557686087479, 0.8339995942753929, 0.8174207349484777, 0.41503696611357943, 0.3895768758228212, 0.5630850530270479, 0.3303871575036065, 0.5733774985845874, 0.34618563194646235, 0.5053518184494235, 0.2211125448667014, 0.5451146632753778, 0.48593574019185304, 0.4100946718467262, 0.20015947034231507, 0.33209618263407326, 0.5694033522703823, 0.22276833040262933, 0.42447738037841787, 0.6164592894390798, 0.1239673912056829, 0.646729509217882, 0.6278748275996284, 0.5948848942660541, 0.5358362239093225, 0.6091119809423728, 0.5535030562367279, 0.6721267494674028, 0.6383471226993771, 0.6074763490815895, 0.7442110161348567, 0.6893876679051159, 0.732122643385934, 0.6961032557988333, 0.7325853767223763, 0.6886925580022243, 0.7028576115592301, 0.7504050411224087, 0.7124146648442677, 0.08853503182054079, 0.1909109291366241, 0.16545469315367756, 0.5333106176338871, 0.30523271665863305, 0.1832278996922907, 0.3189834089325062, 0.3116751063340176, 0.26171529615673783, 0.5172929500759303, 0.5267883779147369, 0.5117319739665487, 0.46449143979253127, 0.4971513733279842, 0.49907195313447006, 0.48256987959379394, 0.47782933778294145, 0.5131061067336025, 0.7798908886078973, 0.7938382177718615, 0.7671889618074406, 0.6851960981978455, 0.792800749680644, 0.7618709869335595, 0.7917804152348717, 0.781490100074382, 0.7373084794107327, 0.12126504429697538, 0.12080747032168715, 0.09652492462765894, 0.163719684921933, 0.087777792664258, 0.1650826198666837, 0.13350087573556335, 0.1429836594781183, 0.13479445275384427, 0.5938498851484451, 0.2115235263430142, 0.15052009772570296, 0.25019617472654043, 0.26557733410786155, 0.27953265318188025, 0.6191565222330488, 0.6818722601140399, 0.2596568413226482, 0.5401741710255611, 0.49437364949569595, 0.5675108673244059, 0.5477527106655993, 0.5473815534451616, 0.5205703200901699, 0.5206542384330176, 0.5186092314229303, 0.5769977257954881, 0.43307290823403155, 0.4379705022506216, 0.433613400785134, 0.4795277741647427, 0.46728204965888576, 0.4653160844571864, 0.45526912635772676, 0.44413202567384646, 0.45750761767631176, 0.19741370944906755, 0.19733565451354984, 0.20338913082178245, 0.1983135505886352, 0.2354607306725386, 0.17360087205010333, 0.20735481086166108, 0.2343982404042505, 0.19420001595838032, 0.2224534378064168, 0.21641782977397928, 0.2157931442715315, 0.21480079283974474, 0.17609978581557095, 0.19689734614032572, 0.2317639688897999, 0.2146082096357157, 0.21058023322256691, 0.17080296879957935, 0.18400316572897324, 0.15220443798801275, 0.8002853209969367, 0.844796669851816, 0.8123733667331205, 0.840503815242649, 0.8121990544104329, 0.17319908623140423, 0.8624611015468016, 0.20636651254642624, 0.20737907724307902, 0.8118378733403538, 0.7867518461930691, 0.8120790107241556, 0.20852770367628515, 0.7627097346516232, 0.20792565640668248, 0.1711438734189492, 0.2259025609929194, 0.16693237347743684, 0.17546737764075637, 0.1839723410566969, 0.16513952564933165, 0.16959210740533182, 0.20851624597684648, 0.17486569802951213, 0.06324271416814009, 0.10008457511496216, 0.09343629742181181, 0.07520626020614196, 0.07660217465661467, 0.07794268327815501, 0.07993921984016883, 0.07356768473802622, 0.0782398574416473]}, "mutation_prompt": null}
{"id": "d58227d4-4756-4029-b178-af8b86b6db10", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand() * (np.random.rand() > 0.5)\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Improve parameter adaptation precision for better convergence.", "configspace": "", "generation": 74, "fitness": 0.46328628693297996, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.8105432185474299, 0.7939424603777232, 0.806082974095806, 0.8220084260646855, 0.8156805209061697, 0.8133514839380757, 0.8301071703933418, 0.8257959875695061, 0.7923066589840866, 0.6671365674993942, 0.6855945771773899, 0.6822658284401129, 0.6902876314867656, 0.7022248014309926, 0.6920378614813355, 0.6849254491904293, 0.6942902081269796, 0.6759215652266748, 0.14374980487178257, 0.14892552976363094, 0.4755210228180241, 0.16215347360185695, 0.6221312119450793, 0.13175085712945023, 0.13568652157230132, 0.13930258954565122, 0.15942672580337802, 0.1283987469896961, 0.1606652783648671, 0.1410287489751092, 0.16117431408532445, 0.15172656558740782, 0.13052581005349717, 0.13640872684572458, 0.10321224824708064, 0.12919756944522776, 0.9563991944281304, 0.9094290751440763, 0.8645593465363891, 0.9647297128928997, 0.9495207998768211, 0.8949567807240786, 0.9181045649257777, 0.9154897272374825, 0.9802891947155942, 0.5484704063536199, 0.549050219573386, 0.6563437385895563, 0.551998185821112, 0.5526851814314814, 0.5818002521135244, 0.5848220976661662, 0.577108189910611, 0.5328760459822546, 0.8555514283892083, 0.8428220348770588, 0.8238490922358812, 0.8208650482226367, 0.8314447400013394, 0.803432482517309, 0.8153512361895531, 0.8119702404857048, 0.8261345124082726, 0.3241729706249791, 0.5347281657471171, 0.2712133239675494, 0.5263185720766463, 0.4759603528484785, 0.21133419733135939, 0.5050027467195655, 0.642224378773079, 0.5068819834420102, 0.2886909075700532, 0.28014520027833434, 0.4085739508185997, 0.4608173172604021, 0.1264300333652787, 0.278133333736317, 0.3969092473414141, 0.23755538432774403, 0.6442954686678956, 0.5747373193178719, 0.628103744264169, 0.6154046148668955, 0.6109471347974955, 0.5561966933846232, 0.6195827814723438, 0.5738086634514716, 0.49153866922277023, 0.6014403587171021, 0.6703213632399809, 0.6562080548879481, 0.6453418682916352, 0.6455752054789208, 0.7090931736545782, 0.7037975304929045, 0.6843170379860191, 0.7361137577173104, 0.6801386947615118, 0.24191687391996575, 0.1957261803979241, 0.15720201601720074, 0.4393511977927814, 0.41044945015881673, 0.16654617305412378, 0.1121264926391512, 0.17903946691096517, 0.29620387421224736, 0.4467713311263225, 0.4710416923665772, 0.45316809593200924, 0.4450842439128988, 0.4775384652122283, 0.47465028603433534, 0.4799160803026503, 0.46940734599854284, 0.471312635734657, 0.7516383765749952, 0.7651185053378862, 0.7646162248035244, 0.7638861737718575, 0.7893272998101479, 0.781903804971136, 0.7883032937808983, 0.7654846319693511, 0.7592850115041611, 0.13370726076805073, 0.14156375199285232, 0.11843349638500422, 0.10009255997051991, 0.16363926430567077, 0.11355419874152262, 0.1252728755192637, 0.16261219475736255, 0.11572351631932065, 0.23482432115802632, 0.30475613676239777, 0.2179608941319986, 0.21722816490662267, 0.6089888562217538, 0.2229420361912975, 0.1806382431390533, 0.2587504259109472, 0.23220383412997658, 0.4897526203327359, 0.5218460696595746, 0.4875308680330227, 0.48057169910525377, 0.5233670264425025, 0.4861175776915706, 0.5772853455256418, 0.5183276076771621, 0.5588474587379364, 0.3778066838255164, 0.4244059618612287, 0.49422096952933003, 0.4746183760999395, 0.3263194657303322, 0.4109056314118784, 0.37673010902360826, 0.4700195357740671, 0.4671565779729907, 0.18707646375125841, 0.22552677241725183, 0.18398992050432494, 0.19668564564523028, 0.2060550497953998, 0.1930316932218541, 0.20502464741338167, 0.24591395277513495, 0.17707000884885948, 0.20222236733985965, 0.21658267306149026, 0.6209800453031205, 0.660577644481455, 0.23961738340333882, 0.6315328531123503, 0.23650745066813117, 0.23417631479553924, 0.2190984177031131, 0.16885962049888636, 0.1988495516708224, 0.15201770090018185, 0.8373588102424923, 0.8219354424814869, 0.8396856026701842, 0.7637060241233595, 0.7424518741504988, 0.7931317998607551, 0.8379046483131585, 0.8166622448090998, 0.206997964083528, 0.7862236451249883, 0.7972084359206573, 0.8492426568649035, 0.21055023789337035, 0.7152339965279206, 0.15323243746958437, 0.18045725720482564, 0.20639720109749815, 0.18637873278885742, 0.1844807768164527, 0.1921859857934829, 0.18923786487901684, 0.19400547465551787, 0.19500905489374665, 0.22139393429828447, 0.0692445629111682, 0.08704844587538152, 0.08139110242786807, 0.08890672178647308, 0.08892724828508558, 0.08206602747515901, 0.15080235284179377, 0.09567189248094787, 0.0799776364375735]}, "mutation_prompt": null}
{"id": "26a9e782-95ed-416c-8f63-b66a471536b9", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability = 0.1 + 0.8 * (1 - budget_used / self.budget)  # Dynamic adjustment\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Improved elitism by replacing the worst individual\n            best_index = np.argmin(fitness)\n            worst_index = np.argmax(fitness)\n            population[worst_index] = population[best_index]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce dynamic local search probability and refine elitism to improve convergence.", "configspace": "", "generation": 75, "fitness": 0.292289890302, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.6366236146953987, 0.5980666206376379, 0.5679323057839231, 0.5973157083485093, 0.6242997135029202, 0.6336572879910041, 0.5790871308197819, 0.624137400903735, 0.6062238833913942, 0.24209708127477036, 0.29827403240642403, 0.2862728597637969, 0.2972186804298703, 0.2834871084214343, 0.294436769949994, 0.3170003428994801, 0.29507075878567557, 0.30652936184995827, 0.09979148093927181, 0.10796987186475526, 0.11680357721586099, 0.09518200482311145, 0.08834801523889124, 0.10423461870675022, 0.10504027524481807, 0.09475072963378806, 0.10566808828883201, 0.08924550203928905, 0.08252829859336419, 0.09447034979700397, 0.08996669958701387, 0.08117098616480778, 0.09573943179219335, 0.08094416418070782, 0.08608622918898834, 0.06933026450162993, 0.8768804108276687, 0.8719348864176223, 0.8769212591378367, 0.8864348066295756, 0.9396084803404741, 0.9021733682697862, 0.8662123260940723, 0.9092875351943048, 0.8686313204734369, 0.3449862389535402, 0.3185885367497244, 0.2912466477622202, 0.30661624999221393, 0.27179604834297066, 0.3174038722994095, 0.30264902391533777, 0.27536382252280533, 0.28685928772893643, 0.5781848778364067, 0.5645821404746767, 0.5327272312688972, 0.6091285687550142, 0.5863301784398229, 0.5855789113897774, 0.5998867957258402, 0.5838947938797492, 0.5902399638886375, 0.15638102737686732, 0.17074635918061576, 0.17477752829548265, 0.16679941144372756, 0.17409654221941961, 0.17170224173858584, 0.17140234832919032, 0.16141898920813014, 0.17683931204619308, 0.15160316841539478, 0.20481925328991768, 0.1785099438480836, 0.18932985829219817, 0.18526367460890458, 0.1583778470135443, 0.16838446247600292, 0.260193068573208, 0.2306705038986694, 0.17397052336836683, 0.219270266056953, 0.24270549760098004, 0.20036336328852145, 0.21154751227558277, 0.17436599280437237, 0.20937607508226286, 0.1890697115057398, 0.23105828766036496, 0.357845727091212, 0.300967357866335, 0.3577892608898908, 0.2922868615726941, 0.33599701895695244, 0.3860904755631659, 0.4091502273354569, 0.36570397271203614, 0.3609609895830558, 0.04398548086477949, 0.03651322310708205, 0.0851372915974209, 0.1067871234384995, 0.12285243251293232, 0.12338295357700224, 0.12848347541283733, 0.08131936902955061, 0.14514350544736931, 0.19188070596839546, 0.183725795269727, 0.20466837811655558, 0.17547849777512725, 0.18321706335472, 0.19827404231549428, 0.19077376890330866, 0.18424441462253738, 0.20230329274664638, 0.49923871512549745, 0.5553623298641069, 0.5005330250867185, 0.5624118622887158, 0.5768624998789569, 0.5015217548654014, 0.5476819577994807, 0.5044857525033852, 0.5205180792438654, 0.09130454795758813, 0.0996005647989503, 0.0897201876715451, 0.08896687822034022, 0.08354699107678154, 0.09633206232648095, 0.09460070477287263, 0.09708595578693224, 0.09841261350886255, 0.19225697230260463, 0.22547960867217776, 0.19918631089346972, 0.2910772468823245, 0.1744431614395231, 0.19278403710769365, 0.23925667131567452, 0.1732416542079258, 0.25605806473006376, 0.2965115978835088, 0.283357254559214, 0.32159068512875366, 0.305401745425396, 0.30783056138536, 0.29430825865440746, 0.32037328900183204, 0.31182006201746804, 0.31707999920660646, 0.25142758650808383, 0.22124433116778475, 0.25305925600422796, 0.2426131992875551, 0.2331801370378167, 0.26354624228976653, 0.26499015212226207, 0.2611348242208199, 0.2365737532526495, 0.1837393281230889, 0.19102815869640155, 0.20315377537490897, 0.2226587126342916, 0.2109724934401821, 0.210910246688638, 0.21778207787092163, 0.18654536700911373, 0.1861804181649337, 0.18348209294128437, 0.1769850097679988, 0.17703689756086827, 0.19134106209905477, 0.19296204653776994, 0.1924116003286087, 0.18783081773949273, 0.17658535894387073, 0.18604022206514825, 0.19178806656019354, 0.6438271613082509, 0.5115669826513354, 0.6756857432898605, 0.1926754220262945, 0.5936256909195696, 0.4970519628236323, 0.16836444725410327, 0.6580799647498098, 0.6846130706711083, 0.20679611734882009, 0.6630843056071118, 0.20167456087667657, 0.6633087452361721, 0.16558526038471877, 0.6527282206525731, 0.16103043000417727, 0.5660633245442712, 0.18580877863666712, 0.18573052315047, 0.19593321951867082, 0.19162063951481145, 0.17866748344127115, 0.20269893196742517, 0.21100940744698005, 0.18407268829501788, 0.19828544604350962, 0.06802754282330192, 0.08326185424631605, 0.08803739730742532, 0.07566914703916283, 0.07665139510959162, 0.07173076212654139, 0.08225254999298559, 0.08927444172130106, 0.07552147997823155]}, "mutation_prompt": null}
{"id": "6adc5ec0-b5ae-44d2-be10-114961400518", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.2 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.975  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance diversity by introducing a slight variation in the mutation factor adaptation.", "configspace": "", "generation": 76, "fitness": 0.4670814651440223, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.8295569832706273, 0.7933531803752237, 0.8196848734018306, 0.8238317939462176, 0.82837512379319, 0.8325393486213061, 0.8320521370947525, 0.8287655467633539, 0.805431706731377, 0.7137169543961581, 0.682225091869862, 0.7024987435998535, 0.7170531168469549, 0.6849804172716962, 0.7122741482101564, 0.665852941208829, 0.6808006072938961, 0.7153853594717582, 0.13634942252436122, 0.12034936735114565, 0.16701091538920587, 0.14629988400927108, 0.1620808580859341, 0.11499796432402765, 0.1426719331367896, 0.1407495691283619, 0.15968165084300578, 0.44215252731337773, 0.10952824233716651, 0.12001114129140222, 0.1293684944516892, 0.11137039250452163, 0.1276371715670861, 0.15910308430893105, 0.09584732603313861, 0.16101866524269226, 0.9703167635373494, 0.8753895685561045, 0.8959483090796165, 0.9380354502488474, 0.86196832033715, 0.9308031795621045, 0.9411583206878581, 0.9528649623713521, 0.9437541165228769, 0.5945673269763838, 0.6119858713626349, 0.5313469599408298, 0.5986569482834612, 0.5786384580836368, 0.5557550355275593, 0.6370061205532563, 0.6001988659219503, 0.556332455520524, 0.8545533564083584, 0.8292941364225799, 0.8374577084846657, 0.850397807351813, 0.8438218725476332, 0.8431059195024365, 0.8634203871680503, 0.8457695619722834, 0.8258165751687003, 0.5953664526433666, 0.3557805088146775, 0.4651205244895822, 0.4237874028177273, 0.58786813636121, 0.4013445305348856, 0.4900097094721624, 0.27892718118015647, 0.3527506381339086, 0.5623934303068823, 0.5075877717232922, 0.21049012732091987, 0.6907869250784933, 0.30233185358000325, 0.4199343586823304, 0.3166576063436828, 0.40710538961299025, 0.436932697892757, 0.6064870068968391, 0.646589953244802, 0.5135210940366708, 0.6508744245010891, 0.6120451391322133, 0.6246612197711007, 0.6510806731269992, 0.630430918000948, 0.6459489955685673, 0.7421449125291686, 0.7144548876130528, 0.7341853685441885, 0.7175084414122729, 0.6757005584305393, 0.6716081852227556, 0.6807157644158457, 0.7291877681717555, 0.7182644318062228, 0.3115055140216142, 0.1855468536459055, 0.3344106682089951, 0.5037602131740148, 0.48209310545165607, 0.21093639257210117, 0.16410631037522727, 0.09746384696224053, 0.3493996678000554, 0.47303073509111604, 0.5182920061480065, 0.48383651784470616, 0.515828043547524, 0.464584240053848, 0.5049809932113354, 0.5228005635151518, 0.4904952767508627, 0.443494133505521, 0.7319474483752677, 0.7795973977621056, 0.7816125534910687, 0.7983696701903358, 0.8035150793969821, 0.7939678086206917, 0.7938342206036807, 0.7742830021667307, 0.7558382033128584, 0.14186926939233402, 0.14199349771224223, 0.1711478420016187, 0.09773275823313632, 0.13466461054351397, 0.13678691775869756, 0.10806086684963845, 0.13242488288398524, 0.13295075836212, 0.24655290350974834, 0.15627835507517285, 0.21979221252035508, 0.6390061155158979, 0.1978150785422219, 0.15752650563851256, 0.2580169546646549, 0.645404093217204, 0.1936068949566231, 0.4776063005766781, 0.5320893238538303, 0.5803640281044352, 0.5062449094825432, 0.5979482022239688, 0.5509107786322849, 0.48367631989833126, 0.5140096996939618, 0.5743877217709377, 0.42693391959912697, 0.43374553250574877, 0.3531372644297569, 0.47377773843790727, 0.464615106938132, 0.46754274469525203, 0.44600789368849925, 0.47099101601578264, 0.4176583830934196, 0.19286557104070312, 0.18593338154487948, 0.18671947795890786, 0.19686224901629013, 0.17735570091917308, 0.20123671049230074, 0.19111930414185974, 0.23681540332958162, 0.2394708822674162, 0.24228456089069572, 0.21582308154526086, 0.18736485989190532, 0.21338470108581242, 0.20333952610011496, 0.20518189404585863, 0.19179782983596794, 0.1994637390478049, 0.19748846252450114, 0.17044206855275446, 0.2057253758455846, 0.15232463850121347, 0.8108880078706957, 0.8502363165917826, 0.8133817081193682, 0.8401622732784987, 0.7969934226142428, 0.19206931282844275, 0.8466997706655859, 0.20540216804623856, 0.7984010892922005, 0.8361532442528071, 0.7695140224620602, 0.8358247566506339, 0.20835692527077188, 0.7969794429836599, 0.20796631448563363, 0.220652766855029, 0.1851920260041413, 0.34999230233950773, 0.18147816581224696, 0.1757758756190425, 0.17955783941603387, 0.17378409580748944, 0.30084992105386466, 0.1757822680108897, 0.0755427601115305, 0.08794760190107886, 0.10018941509412893, 0.10138650468979415, 0.09414679052668329, 0.0715122723378867, 0.1447955052797606, 0.07537586880663871, 0.08724240111075965]}, "mutation_prompt": null}
{"id": "807397c6-7be2-4b34-98bd-90a8edf4704e", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.4 + np.random.rand() * 0.5  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = self.stochastic_boundary_handling(mutant)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate\n\n    def stochastic_boundary_handling(self, vector):\n        for i in range(self.dim):\n            if vector[i] < self.lower_bound or vector[i] > self.upper_bound:\n                vector[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return vector", "name": "HybridDE", "description": "Enhance global exploration by adjusting mutation and introducing stochastic boundary handling.", "configspace": "", "generation": 77, "fitness": 0.4409099164984322, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.24.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.7739077610522959, 0.7802331097127975, 0.7672499540067186, 0.8049693857768185, 0.7589150462685702, 0.777981933305341, 0.7785166461754798, 0.7755192446111011, 0.7849582372684014, 0.6287711522700046, 0.6165835405816759, 0.6284469487068582, 0.6299608031415127, 0.6216477267823034, 0.6312285100687163, 0.6440149426917864, 0.618197210644025, 0.6110973118349603, 0.1469687256948422, 0.45600800842152345, 0.16501958715850595, 0.1581000646136479, 0.13847387951112178, 0.11381829512407038, 0.15331363236003703, 0.15701718723530034, 0.10277775991029081, 0.11963889170161457, 0.13306064499285408, 0.1541731125752518, 0.14001664757706878, 0.1309599162883991, 0.10425808807048476, 0.11212987632450588, 0.13248751144722715, 0.14225341794216018, 0.45489516494924553, 0.7893198758603949, 0.7221179942398889, 0.7479327859648258, 0.8120565698411361, 0.7641975036749893, 0.7401824774906776, 0.7138340524691027, 0.7525349292667333, 0.5225679133563714, 0.49790863750934855, 0.5062200240302333, 0.4714906182244094, 0.5743753757760208, 0.5641818535201857, 0.5256210854008095, 0.5369874771447782, 0.5426371631654945, 0.8224365664635234, 0.7808360959658177, 0.7672819116042691, 0.8184964766153935, 0.7923093228506841, 0.77214381572529, 0.8233828445821764, 0.8255746654151087, 0.7871467367694508, 0.4743808290119067, 0.4296212189881722, 0.5154541415963619, 0.4308652266393218, 0.5741233485869274, 0.442015819169859, 0.4892231414435907, 0.48980785465085497, 0.5325255725073765, 0.34170468965953793, 0.5012179585033524, 0.5675461554832404, 0.5161377647702974, 0.5261451021945003, 0.46797400328824823, 0.4881919406145112, 0.3614043654002387, 0.41423641298915215, 0.5238469599182591, 0.5062926644428247, 0.49804596762924214, 0.5408882298312462, 0.5445176244261658, 0.4869993801474173, 0.5536183489321439, 0.5659156200598905, 0.49233264200177795, 0.6502530736065566, 0.6045315219592856, 0.6469230052226096, 0.633529741864193, 0.6360038634049311, 0.5985790402268114, 0.6264380101176622, 0.6363726111502407, 0.630468236347283, 0.3161531813501799, 0.2338160580250631, 0.1985096938180071, 0.20201175029860774, 0.329381433092634, 0.30472807384196277, 0.20417113392596797, 0.2064969568007683, 0.3037394725615087, 0.38278160214940293, 0.3627344087292621, 0.39515609681274233, 0.37699566557415076, 0.38098984811552417, 0.41579955965300064, 0.4173188112434546, 0.4325810975358366, 0.3868691989136407, 0.7188149562355004, 0.7110665533213205, 0.7462022633837, 0.7184050188209854, 0.7436272912102742, 0.7184748942263541, 0.7239150349462029, 0.748699783747641, 0.7299665756726359, 0.11862700713869034, 0.10033997355475166, 0.13633373566013562, 0.11841201742732554, 0.09710558240446976, 0.10223837618788545, 0.12567041067906826, 0.11694332440719668, 0.13243469966499977, 0.18966400456457855, 0.2305288905113837, 0.5793095976289038, 0.13623743770729657, 0.15499291017726013, 0.18468225774693214, 0.2243562581405486, 0.2618932187541273, 0.5521201993060767, 0.4448279731990329, 0.44667442970424864, 0.4421566752317978, 0.4431822116470522, 0.4746986090716422, 0.43951361644256326, 0.4413135923398871, 0.4510967321091546, 0.43100237061513813, 0.37421056460615465, 0.36873391039734404, 0.3602091437531798, 0.35399118513617367, 0.36619126239200983, 0.3851057496292105, 0.37912926741052067, 0.3567417157419668, 0.3716117411405695, 0.19725616506869803, 0.2047197110163741, 0.185540720083179, 0.21077349865873274, 0.2040466809975381, 0.20139590809730357, 0.18863157396963337, 0.2636173076224384, 0.20109872543375118, 0.6285090791570178, 0.18413736289696025, 0.5236177211607689, 0.2113061781291089, 0.19919516485504996, 0.5820158943975402, 0.6319503800469688, 0.5841417790745309, 0.186265141563711, 0.18199735789373261, 0.7999299505027557, 0.8188186516147433, 0.8167025193376894, 0.8291976999388084, 0.7690914370732076, 0.19112842246025785, 0.7924039837525125, 0.7939901470362899, 0.7985034394284953, 0.7621255055557409, 0.7467541696791213, 0.20751021979691298, 0.1666039895347451, 0.16477825847378735, 0.7574379817254606, 0.8055909434536415, 0.7408430852015386, 0.19992748313751552, 0.15915510654371645, 0.18799544319563577, 0.17579906214334717, 0.17448896497395217, 0.2103155695222778, 0.1788592562501533, 0.20181728421628475, 0.17711559313647618, 0.07100531917607711, 0.09404018738135678, 0.0867274408267531, 0.07500803038508452, 0.0854014193630035, 0.0906996026636554, 0.094110850514738, 0.07013112516902953, 0.11115366762732959]}, "mutation_prompt": null}
{"id": "c9a8cd57-4504-4ee3-b21d-35abc3c4587b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance convergence by refining the mutation factor scaling.", "configspace": "", "generation": 78, "fitness": 0.3898551438996307, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.741632471378979, 0.6948292961822278, 0.7240181424967623, 0.720167630390904, 0.7300609801054987, 0.7478785946656776, 0.7136715408972507, 0.7323235338859595, 0.7227029566020134, 0.5886839377227328, 0.5729318735210885, 0.5401030506073933, 0.552803587791051, 0.5426141140953569, 0.5149830425885539, 0.49135539657142335, 0.5288262515980806, 0.5341291407475618, 0.15603562055885356, 0.27347206059136875, 0.1057532379228664, 0.1577708353527778, 0.1438054676600492, 0.12875522549562135, 0.1395905165255743, 0.13681082663977362, 0.30174645515193166, 0.12679851700032085, 0.10685090418657217, 0.15037510883433225, 0.13119809969858998, 0.09780922421696703, 0.10538326066224868, 0.11865937819603956, 0.1305551756333745, 0.1225438359332156, 0.9739317815724691, 0.9508421621448494, 0.9319511239678826, 0.9785554932874363, 0.89892708900474, 0.9509477824621828, 0.9106337614324596, 0.9662720654212889, 0.9578121945897841, 0.45548202877320887, 0.4455217354987543, 0.3995839691835441, 0.43650413025591184, 0.39559537994345007, 0.4517619892246624, 0.4285501535495142, 0.4197307379074575, 0.48383791428807255, 0.8063755296598477, 0.7391153646340296, 0.7683183670013196, 0.7404354866680584, 0.7454323799894175, 0.7633593443856823, 0.7525901122072249, 0.7524184974020786, 0.7405211769584652, 0.4523665189261409, 0.3622965602719509, 0.36260952370984345, 0.3508933581389748, 0.4212053750049195, 0.40581553478525, 0.4959016376913765, 0.4270464366754695, 0.44143084347562656, 0.20910094544449698, 0.12546679762080293, 0.3556480368987234, 0.4010608480771979, 0.4372192275210153, 0.3531497798930111, 0.34492761556009677, 0.45131016121709167, 0.41331380919565, 0.4336548736239344, 0.44473159842037846, 0.39492328925494957, 0.3644134857052571, 0.4249490792693915, 0.3913079294162015, 0.376614146440853, 0.4362866744230316, 0.4601117450958446, 0.5671869542402148, 0.5770522201053315, 0.5382759009931722, 0.5870483103163434, 0.5513612655494959, 0.5199679670275636, 0.5797038356059312, 0.5482289981507485, 0.5716594425018591, 0.20625543960215986, 0.0927536783444366, 0.21356409545309318, 0.20425895965550478, 0.25279301060550496, 0.23352055169658092, 0.24604714748118595, 0.14774168082928996, 0.10455820072358002, 0.3006843800686604, 0.3195664981595132, 0.3046099872329546, 0.3036502094550677, 0.31283760349775847, 0.31690895659208085, 0.2916918935761873, 0.321169638559625, 0.3153220089121229, 0.6698075671805365, 0.641795359431004, 0.6851733604027516, 0.6699258125728258, 0.6722147278504977, 0.6818336221174632, 0.6800698647944474, 0.6255155807051089, 0.6491604074404684, 0.09911178351383909, 0.11834313557369314, 0.10157625748566024, 0.12462968153009368, 0.1394064314550706, 0.13697694977067043, 0.13726422811343986, 0.10999084660641201, 0.10934041122564997, 0.1499369237824496, 0.2480563558042509, 0.5641926667518791, 0.28662646578867457, 0.2189591922698817, 0.17790225897981404, 0.2254954645149131, 0.18241109663808153, 0.15725537613525975, 0.3562519676273741, 0.3550804031751422, 0.37266296345605265, 0.39000985527487675, 0.3504613867675408, 0.33283296038915144, 0.4036632240231204, 0.40001696452359625, 0.37795414157678964, 0.31183403208013416, 0.35835668585462677, 0.2836321710778281, 0.3145210093290127, 0.3343268928791756, 0.32074396753630385, 0.33780294458635796, 0.3511703602234919, 0.3204654757248553, 0.16957906715897353, 0.1884634185005266, 0.2156589908213673, 0.17995735159515858, 0.16827501046634297, 0.17108066439010527, 0.18878190040081422, 0.18875620245027147, 0.16377127607760378, 0.2097995804100704, 0.19658539635829397, 0.5682365001789936, 0.2005317192190348, 0.18611819440390376, 0.4734213767190254, 0.22954106400599383, 0.18676329608969022, 0.21251564181087668, 0.16634298133482428, 0.15162148242913465, 0.8008549732403414, 0.18480408560542705, 0.19369048733474314, 0.19067095506120457, 0.757990700127492, 0.7414501600468746, 0.7718075060420104, 0.772547763714873, 0.20308353935674772, 0.7192748646444503, 0.7932951885377917, 0.192013109410605, 0.6913341076698208, 0.21049631074240704, 0.20577927458993073, 0.798435248345255, 0.20079159815680692, 0.2464581249431097, 0.17760493103049357, 0.1699612680937005, 0.1963033052790173, 0.2621020123100367, 0.202419219485386, 0.23812933135908199, 0.21487187082612902, 0.08940417908552167, 0.08993480349660798, 0.0696378245438336, 0.08864489629099914, 0.08560813736263395, 0.10407523470803315, 0.08141795747081648, 0.08473229517304393, 0.08971375865750908]}, "mutation_prompt": null}
{"id": "27270c43-8513-46f3-b2ea-d9ad8d91c8e7", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n        self.diversity_threshold = 0.01  # New diversity threshold\n        self.diversity_factor = 0.1  # New factor to control diversity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n            \n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.multi_strategy_mutation(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            self.adjust_population_diversity(population, fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def multi_strategy_mutation(self, population, index, fitness):\n        strategy_choice = np.random.rand()\n        if strategy_choice < 0.5:\n            return self.mutate_and_crossover(population, index, fitness)\n        else:\n            indices = [i for i in range(self.population_size) if i != index]\n            a, b, c, d = np.random.choice(indices, size=4, replace=False)\n            self.mutation_factor = 0.2 + np.random.rand() * 0.7\n            mutant = population[a] + self.mutation_factor * (population[b] - population[c] + population[d] - population[a])\n            mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n            trial = np.copy(population[index])\n            j_rand = np.random.randint(self.dim)\n            for j in range(self.dim):\n                if np.random.rand() < self.crossover_probability or j == j_rand:\n                    trial[j] = mutant[j]\n            return trial\n\n    def adjust_population_diversity(self, population, fitness):\n        diversity = np.std(population, axis=0).mean()\n        if diversity < self.diversity_threshold:\n            for i in range(self.population_size):\n                if np.random.rand() < self.diversity_factor:\n                    population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97", "name": "HybridDE", "description": "Enhance HybridDE with adaptive population control and multi-strategy mutation to improve convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridDE' object has no attribute 'mutate_and_crossover'\").", "error": "AttributeError(\"'HybridDE' object has no attribute 'mutate_and_crossover'\")", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {}, "mutation_prompt": null}
{"id": "877f08a0-ae63-405b-9f5b-2103530aa90b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n        \n        while budget_used < self.budget:\n            self.local_search_probability *= 0.98  # Adjust search probability\n            if budget_used % (self.budget // 8) == 0:\n                self.population_size = max(4, int(self.population_size * 0.9))  # Dynamic resizing\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.randint(self.population_size)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        dynamic_factor = np.tanh((self.budget - self.population_size) / self.budget)  # Adaptive mutation\n        mutant = population[a] + dynamic_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Reduced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.85 + 0.15 * np.random.rand()  # Adjust crossover\n        self.mutation_factor *= 0.95  # Adjusted mutation adaptation", "name": "HybridDE", "description": "Enhance the balance between exploration and exploitation using dynamic population resizing and adaptive mutation strategies.", "configspace": "", "generation": 80, "fitness": 0.37645146391176604, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.706524423310753, 0.7109291316709994, 0.6936381283643861, 0.7189050455498924, 0.7638044620681581, 0.7475004707865089, 0.7576463383520572, 0.7471222202077219, 0.7123559681986779, 0.49981158700427264, 0.5088244585480961, 0.5376173312041732, 0.506595583547149, 0.5246311946132025, 0.507289142235426, 0.5371569681496056, 0.5142171770076407, 0.5334626284639475, 0.15068340263149615, 0.1381196556602725, 0.15368043793093644, 0.14106806603147415, 0.14861451015139304, 0.116825255669196, 0.1288351897482486, 0.14067094941579872, 0.15536038152546694, 0.14566770159966524, 0.1279190368987605, 0.11710038742545315, 0.14169004268858332, 0.11399306620701433, 0.09436295848078335, 0.12914036233290827, 0.14309865650221598, 0.1225043525887839, 0.959370499485538, 0.9118902950719888, 0.9737211261112917, 0.8969626895011686, 0.9781471386340173, 0.9433754556379719, 0.9663166299783632, 0.9664180288044376, 0.9598859399800825, 0.39871582049881915, 0.43262817935211584, 0.4272111655469816, 0.4474706232023705, 0.403468203709585, 0.4279029723608825, 0.445998738107522, 0.42656495608563294, 0.38173998730613157, 0.7151895710517793, 0.739297991208381, 0.6383248664111623, 0.7297594937557015, 0.7348488932157944, 0.7049564777967046, 0.7041196006235433, 0.7772218392964266, 0.748988757709045, 0.3994869917172592, 0.36368731272137267, 0.3591270332995812, 0.3449389903634257, 0.4515459601478238, 0.3562582553094954, 0.44447815385630374, 0.34667400802281423, 0.4060900582047797, 0.2654069059032501, 0.3708929619292646, 0.43455115398118704, 0.37769455320794654, 0.3841392647605658, 0.38198550859418423, 0.32742707052955, 0.3740794554479231, 0.35775760949013435, 0.3602628894774196, 0.35549503518618897, 0.3016564096680274, 0.36273223037925595, 0.34256275458216623, 0.3949995943877834, 0.3260712353852706, 0.34160409548509896, 0.3732761552928908, 0.4648394416245657, 0.48467618993067807, 0.5465955233238483, 0.5044681616872992, 0.5079129609068735, 0.4412709979566719, 0.5489626082333806, 0.5102744805961577, 0.42535344038258827, 0.06799090384170103, 0.12246720328620764, 0.19511010214263347, 0.18912083950446879, 0.18713640992532254, 0.2652166602588353, 0.18115685152936067, 0.13429952912112297, 0.1522461958363116, 0.2590056062799646, 0.2986177254507755, 0.28412919663787484, 0.24675934200212757, 0.2816192678106828, 0.25595578493174553, 0.2733869864257077, 0.2993864179418787, 0.2568529952668609, 0.6422268774540962, 0.6357154643975805, 0.6291235283495973, 0.6679934772758975, 0.6474097031694328, 0.6474284247908396, 0.64127133525393, 0.6522457431748737, 0.6692661775539634, 0.13479490626744117, 0.10373111630639142, 0.1061549682950943, 0.08194468856897563, 0.1218438854627355, 0.07996678857517758, 0.1194219948594184, 0.13838613068177796, 0.1065171923411301, 0.2313552470210477, 0.14001365163933754, 0.19580599402231935, 0.43623418055865504, 0.14069516846941788, 0.21821880647628245, 0.26525766628943803, 0.18887066811828324, 0.19432902520005846, 0.3558265267032328, 0.34914038726886143, 0.4015950648953517, 0.3608876166329512, 0.3714705976660444, 0.36431742088986263, 0.389349547021013, 0.41832979116700875, 0.3767749595893254, 0.3097039821695109, 0.3010527655175489, 0.31433095423518354, 0.293687402069462, 0.3098194732109085, 0.2956138298200378, 0.33609580043083165, 0.3415160758774286, 0.31129354594546643, 0.18530400347278975, 0.21414340281743183, 0.17456083197644479, 0.1916251845750251, 0.16499724461193432, 0.1655546875790036, 0.19596886402489855, 0.1767096930488833, 0.21873553909361876, 0.18313890992641702, 0.18089760282501488, 0.20133407603996734, 0.20637862602606372, 0.1917302382929843, 0.20393686809825162, 0.18474307250778743, 0.2059405886909722, 0.20988668329384152, 0.814536115581549, 0.15035153171508342, 0.8003843343306367, 0.689721061444523, 0.7778076359277406, 0.7286019232225458, 0.7559934872617662, 0.1845085697310015, 0.7112044229788612, 0.76434970072513, 0.20439973773970543, 0.12293417066703316, 0.19906010206160552, 0.739098126063187, 0.7664602193518737, 0.21159564853475665, 0.7576374313270325, 0.20763406040583676, 0.17689565554497055, 0.19173608115055718, 0.18806201828724634, 0.17631655493654963, 0.1808723502063132, 0.184592976869133, 0.37579694307199596, 0.17814018729129166, 0.18285183096493607, 0.06084660661846897, 0.07030075271563785, 0.08570223331071736, 0.0627212645136559, 0.06841907312742967, 0.0907041317155739, 0.06376998256070032, 0.06740517676936886, 0.061933354251337724]}, "mutation_prompt": null}
{"id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance the exploration-exploitation balance by dynamically adjusting mutation factors and improving elitism.", "configspace": "", "generation": 81, "fitness": 0.4764235618475581, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.27.", "error": "", "parent_id": "73e6c536-d0a4-4a5b-89f8-e94cb88471c6", "metadata": {"aucs": [0.8316267823304446, 0.8172924993458099, 0.8023113794019013, 0.8166273623821311, 0.8329821906423176, 0.84740065091231, 0.8390965349431122, 0.8161128602222785, 0.8227961903624075, 0.6953339028998864, 0.7075798142243466, 0.6971515675150257, 0.6919548836201543, 0.6898250672983712, 0.6833270377878844, 0.7034526428198036, 0.6835134642348417, 0.7099995530568368, 0.15173001578569112, 0.17085515293945575, 0.145824254285166, 0.14796165778364134, 0.13647103263854965, 0.1512865784541393, 0.11375920199205325, 0.12254115720414505, 0.5617149921039616, 0.14691628555361824, 0.1408008227607439, 0.16578656853076412, 0.1330233016325334, 0.10465083808597753, 0.5057023598365672, 0.14626220180346372, 0.12827514358508285, 0.10040018025129305, 0.8922444443663, 0.9058364780279881, 0.928143059847374, 0.9465896470439239, 0.9685501671323848, 0.9469624837922418, 0.9178906756621209, 0.9861471072206803, 0.9106762373397564, 0.6200336578802476, 0.677573277096514, 0.6333857393668327, 0.6497057202814427, 0.5929958280795181, 0.6250745930649335, 0.6359503139724362, 0.621387930288088, 0.5889373236943691, 0.8325300051045686, 0.8079037507201655, 0.8537553704451242, 0.8427008421630323, 0.8694365659936177, 0.8425141929977404, 0.8315141224012846, 0.8302751655421554, 0.8189517054513107, 0.48253513632316913, 0.5492491604980001, 0.679999641041698, 0.6135830969033338, 0.13100200245741256, 0.12023793342136546, 0.3669080603589703, 0.574654517953719, 0.6852945844407394, 0.12819479022074032, 0.563007382049661, 0.47098936322570273, 0.46830982429882795, 0.5528464271658534, 0.5275615187597578, 0.43357962800795213, 0.4316273665293472, 0.45212055816545715, 0.5954284633938882, 0.6239630086182129, 0.6655457095311728, 0.6310536734656483, 0.62646176117597, 0.6037760600710516, 0.6587106628820147, 0.6482780072520705, 0.6758324321309765, 0.6828987682588497, 0.6176749970367663, 0.7178262436211669, 0.7137149305390974, 0.6883813188663364, 0.7016165413805002, 0.7109437332825519, 0.7195980063540328, 0.6855460961074544, 0.06794454777524439, 0.20339787352550487, 0.29835003938661186, 0.5688091948914609, 0.5720023801187446, 0.47732220403321024, 0.33538828342351346, 0.3624506878696425, 0.19796052508721085, 0.5405283248153145, 0.503990012452051, 0.5159619743977764, 0.5090025912299759, 0.5575974130813517, 0.5289802167135811, 0.45143648108541923, 0.5263695979265353, 0.48021685997883556, 0.7522233670070194, 0.8027888208160998, 0.785444743146158, 0.7851891761575239, 0.7907864900064975, 0.7748911500853101, 0.7922999219484705, 0.7608204999597981, 0.7836388348286215, 0.12630775569066122, 0.13983720061194693, 0.15758530822048578, 0.10167469069917023, 0.1512722943040421, 0.14761995420726848, 0.09159991980636295, 0.10789462407665051, 0.17298239272920723, 0.34193416102103324, 0.7442535000376597, 0.22920008642808132, 0.19590199783133144, 0.201544458588108, 0.2920683171365085, 0.6851996580144676, 0.33319433697368517, 0.11864607291104257, 0.5666281175583976, 0.5701344543476716, 0.49459417696654595, 0.525617122523476, 0.568164911353706, 0.5408090958334351, 0.5426948815455508, 0.5228534743838331, 0.610340881725547, 0.41933846718538403, 0.45176851345238733, 0.433939930868001, 0.45421100286944616, 0.5432922814846068, 0.45248483869229617, 0.4711507693565311, 0.5040655048161483, 0.33594200435477906, 0.19279168494757182, 0.1788899654694689, 0.2596865667292324, 0.19948839378356864, 0.21898504296183552, 0.2023041509443787, 0.15895888333611752, 0.19454114900486474, 0.18545313722530532, 0.20017240305908035, 0.20713089709756027, 0.21412062275152255, 0.24213261271385222, 0.23443031415967064, 0.18278667602191745, 0.19258494780469393, 0.21251476361107524, 0.19939580402342838, 0.8732669034083131, 0.1940600583937362, 0.17595843901838293, 0.8656118247839707, 0.8722865962627464, 0.8394770926267094, 0.82290336547192, 0.16577227535873407, 0.17018918349411816, 0.8367104706044177, 0.8630082247088178, 0.8329636608089923, 0.7877866089641057, 0.20562172506974508, 0.1637931532905662, 0.20632503359054788, 0.8592340678665749, 0.20836594118913176, 0.17064941691286806, 0.2417330145163602, 0.16598481129597675, 0.18403626131784834, 0.18365001019977734, 0.1704741349180413, 0.18144045753545657, 0.19393748235940278, 0.1868536727905965, 0.09398771839352593, 0.08106218915795527, 0.07691496181065083, 0.0825455232187714, 0.07616563353923789, 0.09941385944006653, 0.1078561393159222, 0.10795642654420956, 0.07162169490392478]}, "mutation_prompt": null}
{"id": "7116e49d-f8cf-4e8e-9626-b57f7adaa311", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.25 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance local search by increasing the local step size for improved fine-tuning.", "configspace": "", "generation": 82, "fitness": 0.47027124790294156, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8345862120435504, 0.828086396702156, 0.8101899198396403, 0.8093327319232991, 0.8273929459704266, 0.8369688577599665, 0.814970766988851, 0.8328059158960782, 0.8139541679570703, 0.6931630092521078, 0.6767684822213175, 0.6909302384587068, 0.6891430663339732, 0.7096755789851583, 0.6211387268285659, 0.6778168536483409, 0.6869920654854993, 0.7162221443681946, 0.10418161245046886, 0.16483443040024126, 0.1673597326348507, 0.13519129707907374, 0.12255003090327465, 0.5834412179820645, 0.11425706465351704, 0.1525341522082575, 0.16414149718391013, 0.08384777006584776, 0.1426621058763914, 0.0833100903971441, 0.1424467790520575, 0.08275081374351756, 0.1214878908976551, 0.10197341510104685, 0.11943086199861996, 0.13844278559781542, 0.9013714830462048, 0.9372839056262852, 0.9646037572894192, 0.9341555870868374, 0.9686386933663, 0.952609556789646, 0.9203762578060548, 0.9861477751104445, 0.9126293230450998, 0.6323626956059261, 0.63195830931425, 0.6462568919989236, 0.5722715745532001, 0.6080096724769253, 0.59389347915715, 0.6121373089956297, 0.6088167724914326, 0.6015844220275905, 0.8399271745583698, 0.22208610122579553, 0.8218183601299767, 0.8571322288113438, 0.8672146673526961, 0.8429813911038619, 0.8744515434873126, 0.8083526117654785, 0.8626352717963737, 0.5068535987809264, 0.44639897377086224, 0.4969468053534184, 0.5000757784644669, 0.6134355607547272, 0.44871926975288, 0.4181009372085377, 0.45305086343838674, 0.5540748269233878, 0.43994054177821706, 0.5584831622965045, 0.25367098592517245, 0.4994420325330857, 0.40389929540002845, 0.5731911351486512, 0.4859231764865992, 0.6199286739161465, 0.5579153961941334, 0.6449748031955893, 0.6223443101648594, 0.6452797360223348, 0.6585170035329363, 0.611264011911508, 0.6169438163129148, 0.6314838839025221, 0.6502016921030196, 0.6291577663198662, 0.6974051062035183, 0.738926507753247, 0.7351151587639266, 0.6636212036230592, 0.6847937954272472, 0.7262710846289848, 0.7231514251087562, 0.7383255291267585, 0.7045924368788942, 0.21554875427004383, 0.08544772213105134, 0.11491116132481438, 0.2722061825110076, 0.19054093522136706, 0.5017314883920523, 0.2911065335898191, 0.32262009165968475, 0.3637967136845045, 0.5189224040164173, 0.5281289309974301, 0.5338534547594433, 0.4979678435903232, 0.5360264800550445, 0.5096738367257205, 0.47149259411840705, 0.49048158409259424, 0.5393316626494227, 0.7799098678579992, 0.7753480146182935, 0.7853695760220492, 0.7758563133218037, 0.7851040557986044, 0.7828115422097293, 0.7770395525999796, 0.7701492454307066, 0.751387710803415, 0.139594584064746, 0.11021753667351952, 0.11028122581962307, 0.11316270914025861, 0.1536911325430408, 0.1450645594119092, 0.09782324574730228, 0.11400061245883353, 0.10770498786268035, 0.34211739894962456, 0.1561035322726777, 0.1755994960895788, 0.17586565070889026, 0.5254682258318212, 0.2246088216993467, 0.12363785867794708, 0.23960009076969435, 0.1631925661409488, 0.5492626875204802, 0.5668678522848041, 0.5757133967100221, 0.4993828200670384, 0.5593416169818173, 0.48132830261997195, 0.5384966988295656, 0.5335755552948671, 0.4542980892015679, 0.4021154540276629, 0.4313094054504101, 0.3716130595335798, 0.4408873330424339, 0.3040978447389928, 0.42883290167044275, 0.3106748976731708, 0.4703160873174881, 0.4490107040208824, 0.16820510561216984, 0.23341360564811864, 0.18577178285846463, 0.1599618322838141, 0.19557821177889956, 0.1792404125088104, 0.17048450296610185, 0.1983377784341699, 0.1979459644175663, 0.19181538770233197, 0.20427425315766645, 0.20948468180954238, 0.1922195082768121, 0.18019574727698673, 0.1866557806374346, 0.20437034986471447, 0.1814968606941888, 0.20412934471822108, 0.8540731434749419, 0.8340022879888067, 0.17640432389067628, 0.8691229183439798, 0.8909806040160044, 0.8677684510316936, 0.8182979846456511, 0.8533080952064875, 0.7890719470920551, 0.8453178013250586, 0.8556638471257998, 0.813885977020492, 0.16489402915240048, 0.20138790679331875, 0.8291715142735606, 0.20797691351960013, 0.8459996567026298, 0.2069660665455786, 0.17485017070485342, 0.17215703072235633, 0.2050991488633751, 0.18199347899125828, 0.20127971577927106, 0.19749032654751641, 0.2528896011950973, 0.16949170143148273, 0.17288097112770828, 0.07042559913306035, 0.08462772453859946, 0.08598886005408257, 0.07574843187210789, 0.07372386707947065, 0.07045344812339738, 0.07519929313305873, 0.08535333280310842, 0.08033034182819143]}, "mutation_prompt": null}
{"id": "517cf719-0e32-4911-832d-9d210bd6e85b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.35 + np.random.rand() * 0.55  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a small dynamic adjustment to the mutation factor range to enhance adaptability.", "configspace": "", "generation": 83, "fitness": 0.46527865344456665, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8159522347532427, 0.8085628413353274, 0.8030396010872856, 0.8050738786113327, 0.8268003650379615, 0.8205330857843546, 0.8167665513280784, 0.8121880719922951, 0.7888932876588619, 0.6596788331186779, 0.6865662351663181, 0.654386733730635, 0.6655646564518358, 0.6943855328999713, 0.6622027802264261, 0.6709418855025983, 0.6658029636175833, 0.6723586762957972, 0.1203615520495912, 0.17148226511560538, 0.13572559313818344, 0.15007566185936516, 0.13549763682248817, 0.14735872347992973, 0.14277046588171338, 0.14233157427992338, 0.14934699645211058, 0.160559886100189, 0.1336043328210993, 0.13732583647700847, 0.11569669457157505, 0.10234506144803857, 0.10784937572573328, 0.1362636082777111, 0.11261649913376115, 0.09583051933272035, 0.9421337828054508, 0.8648755150143824, 0.97519059960897, 0.9353733775289903, 0.9571675143757413, 0.9217406340964368, 0.9484445644568381, 0.9862010077995937, 0.9339776229551077, 0.5924673721078522, 0.627990799253438, 0.6192631683910415, 0.5981605275364699, 0.5932138121934531, 0.6025809471575484, 0.5861424865089542, 0.5909818315667572, 0.5817913167821698, 0.8132311415955393, 0.8362322468828232, 0.8106744392059804, 0.2496990943948083, 0.8408199044912058, 0.8333565465674528, 0.8620355278131486, 0.840159241217861, 0.7939212595796765, 0.3747786651711693, 0.12606266165934432, 0.6298420068968262, 0.5923568738935201, 0.5653038432719958, 0.40257699638346023, 0.5464814219927423, 0.5126909545822286, 0.5342151770173234, 0.550751187979065, 0.5032633580797319, 0.4458214648648675, 0.34315149065319783, 0.5967862920627918, 0.5152523872521666, 0.6367069438882105, 0.5068745909759893, 0.4094261996345788, 0.637857407470399, 0.6648124616342568, 0.5939059360219673, 0.635384668551136, 0.6048649262731522, 0.5848719285116011, 0.6123281516372631, 0.6450731704375079, 0.6119945564050451, 0.6808946266721261, 0.7077919948632558, 0.7076159978259631, 0.6763084880178052, 0.7094416561136458, 0.7124300738950468, 0.6979534432412489, 0.7091014523594174, 0.6957234985340488, 0.3006594615025051, 0.20453159962820866, 0.11263287747507111, 0.5337893664802771, 0.4967053670713494, 0.1970609903737337, 0.3550282228766435, 0.3223225621057507, 0.17482761670475555, 0.5019453537163727, 0.45583930006655826, 0.4694684221107204, 0.5145001759677537, 0.4731033119970056, 0.4944146684179578, 0.503198050943189, 0.5191600983688271, 0.5028687567560757, 0.7735919673162719, 0.7781432135410544, 0.7680570525071028, 0.7688342353961726, 0.7915168007370935, 0.7805037172625139, 0.7717592168958346, 0.764778977329422, 0.78071714193154, 0.1279698171018535, 0.12142217835541502, 0.12399182590087099, 0.11297465821357033, 0.10398421668420599, 0.17207962841945224, 0.1043272448301974, 0.10056554806666662, 0.11677554329402029, 0.19401323170054896, 0.1845054831632187, 0.22629011807619392, 0.6613283577468468, 0.7323464059697093, 0.42004544039162184, 0.22838525313528535, 0.6715594848921234, 0.3174869307258924, 0.5236076010146595, 0.4995755724097698, 0.4995849102120191, 0.586777857145744, 0.5374032996024964, 0.544598280001923, 0.49325013125743633, 0.5694684432099322, 0.549142749243088, 0.3097557147827942, 0.42087677220133723, 0.4337008022585067, 0.438627611152577, 0.4678756262216449, 0.4164626945761988, 0.4503483395739296, 0.4989983443532743, 0.4986216597107387, 0.1760493843390497, 0.1696525783003877, 0.21544806391346394, 0.218683245624954, 0.22464970545497465, 0.18031635542521673, 0.20200264139292268, 0.19069389366339917, 0.1896793200070218, 0.6919170620818776, 0.20773578816804517, 0.1991261246182804, 0.21411754496237068, 0.2271799715855637, 0.21628866468136987, 0.20767507593620016, 0.7200959346025416, 0.235854601659228, 0.8919967827470237, 0.1829242550077178, 0.19595879946583405, 0.854147939787977, 0.1974911333123507, 0.8064081483772991, 0.1838678587420054, 0.16226385406159838, 0.2069374807458122, 0.8529848770181061, 0.7750109057973725, 0.15283250544113047, 0.8375436339309567, 0.813648475244915, 0.8350722810917794, 0.209150493071526, 0.20590677800919666, 0.2091443547742896, 0.17229291876178499, 0.17454301360067404, 0.19294159572759895, 0.17355515671205068, 0.17945347873316075, 0.1860947973581849, 0.1665710871864754, 0.179982988409487, 0.18564585345622275, 0.100270727989487, 0.10385022226195173, 0.10384202286282429, 0.18273640696712545, 0.08575214619106897, 0.0819422954164456, 0.07836076714792017, 0.08981528150689888, 0.08813183544063263]}, "mutation_prompt": null}
{"id": "7115bd04-e224-42e9-b92a-04d050aeccdf", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance mutation diversity by increasing the random component in mutation factor.", "configspace": "", "generation": 84, "fitness": 0.4518144668060469, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8118366868119664, 0.8074830259038351, 0.829652188093238, 0.8115228482872423, 0.828472821401063, 0.8208513626982015, 0.8108860978655709, 0.8179801651162821, 0.7954355111152802, 0.6657462905538295, 0.6723067097542357, 0.6712537357580304, 0.6727113712329447, 0.6750717043860676, 0.6584886639684172, 0.6378157471843144, 0.6625109720129334, 0.6675050977702697, 0.14987393470784505, 0.12396645968795661, 0.13808093927949472, 0.13164201048493906, 0.1700018777247977, 0.1718549885466688, 0.17109946168776247, 0.12582895286000817, 0.13124364120628873, 0.1186185600780193, 0.1275080402500629, 0.14152294458668435, 0.15828344615508427, 0.10519659243290336, 0.10887649088883022, 0.1332471456601414, 0.09872555262777638, 0.43185498147525536, 0.9394648509937931, 0.9386353714747141, 0.9348279370782008, 0.8744832607673507, 0.9683384269052163, 0.9055094661584321, 0.9512746300857433, 0.9861588171377941, 0.906784495302638, 0.6134616012104441, 0.5916103975761038, 0.6184123701851951, 0.5778208606009474, 0.6005978788287248, 0.599633470492219, 0.5879181357801595, 0.5577143255032374, 0.6330673830193028, 0.8559207810798524, 0.8640804281204474, 0.83257609876374, 0.7826973094448502, 0.8149423537169624, 0.8249173007738438, 0.818077473743299, 0.8396693800979834, 0.8518977638212748, 0.6697006535922838, 0.1279561104761695, 0.521201753274027, 0.5960997670712928, 0.48197064869370865, 0.12679046569538588, 0.49991816231719033, 0.5881124469131835, 0.4975523470191925, 0.49489970808866546, 0.6181311527818505, 0.5223771413029491, 0.6299201041428941, 0.4889994298015815, 0.6080724889060309, 0.3442074204888289, 0.44196438378991776, 0.5045220773961272, 0.601954027983129, 0.617503896912323, 0.5799483083397096, 0.6157903653107277, 0.6248845752117163, 0.5545328172198294, 0.6358946069723628, 0.6155416731722629, 0.6167910959385223, 0.6947564298647456, 0.6954632225503531, 0.6689559011569914, 0.7195555912850309, 0.6942044465241141, 0.7158072972934593, 0.695551331335573, 0.6974707951318924, 0.71676535350004, 0.3989201461111562, 0.25818686544497793, 0.12460501777317001, 0.4620773488474139, 0.1751156101325616, 0.24293197934447375, 0.17099217968059566, 0.17837444998645502, 0.21877980086887705, 0.4938624519265772, 0.47573994121665397, 0.45393018881230707, 0.45472442147764247, 0.4273615571822931, 0.45764745928231, 0.4865512317439268, 0.4491329466497511, 0.46681312980942835, 0.7704953746864299, 0.758865223363922, 0.765380075509289, 0.7841448046612904, 0.7584205998527798, 0.7416295342743886, 0.7753111425212025, 0.7763683993398856, 0.7353614733796348, 0.15074343291602776, 0.12377336198220068, 0.1468457151868806, 0.1407876374821222, 0.13566492535879482, 0.12833833061743993, 0.1332349004985386, 0.13792793609657672, 0.11400996957507847, 0.33813716600304966, 0.2731484187135267, 0.706201936693177, 0.2638577927994714, 0.19933124018395743, 0.26657372829998216, 0.25223317395869227, 0.6233637738067366, 0.4150819938309125, 0.49823019009065683, 0.49452681028089374, 0.5558386814616313, 0.5215465864891352, 0.5739855944533279, 0.5304653882031862, 0.5562850401517889, 0.5475553897077259, 0.48442431193828883, 0.42737289124377786, 0.47676306190769857, 0.39091889521564305, 0.4540386182177819, 0.46680168145462275, 0.40830618452958656, 0.46736243184239834, 0.29314580693182657, 0.4758189719898325, 0.1781522324712137, 0.1898584048357398, 0.18392405649346744, 0.15997492890649068, 0.166899033749625, 0.17427957463467902, 0.16658562323522796, 0.17092905624891608, 0.16861832839637536, 0.21553150455480286, 0.23673584412249715, 0.20485483803961824, 0.6213826575938681, 0.1911321971348824, 0.19247442333304365, 0.23589107518932728, 0.20476628461244906, 0.23636386793756214, 0.194039053223228, 0.19452737951822985, 0.152607175895639, 0.18351292013560183, 0.1965892159614261, 0.1636466607581809, 0.16600592974412665, 0.17171993301997768, 0.20541207597357902, 0.8130577086647015, 0.20864326343147954, 0.20176498891343653, 0.8349040168994657, 0.8173719066645722, 0.8388350724431458, 0.21006252952453852, 0.8255358472112572, 0.20887184959747795, 0.16643058321125304, 0.18099367504937247, 0.208906457335575, 0.17259816945216533, 0.17223436112390322, 0.3971983505787501, 0.17124141733873743, 0.20473304164428963, 0.3649326920156609, 0.08494906930029433, 0.09341768442356246, 0.08675864554814738, 0.09729346055162114, 0.07863851051526505, 0.10823955770982863, 0.07297520485910225, 0.08090833512760798, 0.08043124488801645]}, "mutation_prompt": null}
{"id": "74e6831d-cbcf-4838-96b0-97817cc7458b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Increased lower bound of mutation factor\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Refine the mutation strategy by increasing the mutation factors influence on exploration.", "configspace": "", "generation": 85, "fitness": 0.43484570951635165, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8154299546619077, 0.7729252969568665, 0.7984712723071014, 0.7843883454939451, 0.8042019780121896, 0.7871444347773175, 0.7982286819424058, 0.7992663069073304, 0.7736428063974266, 0.6457286208895029, 0.6404381267770067, 0.6332482823157124, 0.6250140452641744, 0.6182451504494293, 0.6281552736904961, 0.6367272366910098, 0.6318350550863019, 0.6310878943047964, 0.1290817123593031, 0.596172355470739, 0.16462473671687772, 0.14897048087931652, 0.14268704347178607, 0.12028791643825132, 0.5111149865218986, 0.5620983280917651, 0.14775740175068475, 0.11295091686435754, 0.0916814168832778, 0.11073370461533727, 0.12245213996393378, 0.08458361242376866, 0.14129596217243612, 0.1456154587486238, 0.09066209895375155, 0.11197639231400103, 0.8959966085727818, 0.9630020206451525, 0.9748366137179826, 0.9522044006524171, 0.9797521757116427, 0.9334574792105316, 0.9385507579980676, 0.9863556601382408, 0.9720985227375383, 0.5328802159177998, 0.5632385687659769, 0.5639314066198927, 0.5512272059093783, 0.5170385791872164, 0.6230968319996559, 0.5501133255685737, 0.5855835517676857, 0.5513107974644482, 0.8353598002486314, 0.8245054661855092, 0.7826224985880654, 0.8074709491725673, 0.8410387600047656, 0.8210715845989041, 0.8203604998605248, 0.8098301730119423, 0.8071582820549296, 0.5170607467990301, 0.45825406365128374, 0.46043993762179214, 0.46958951970934204, 0.5461308625237796, 0.11947575989026804, 0.5656492998672095, 0.5132751856435663, 0.6295786359054737, 0.11837506159142197, 0.4926607162060782, 0.6249470317679123, 0.48652265294374675, 0.5284663640977689, 0.4759287502370837, 0.5337205509509626, 0.6212071075409265, 0.4730998349356339, 0.526021629728531, 0.5199417957518795, 0.5691682904782708, 0.5412276758098833, 0.5747447662868449, 0.525455631485721, 0.5425692978355927, 0.5433821033969558, 0.5690601376917287, 0.6658422672847026, 0.6621083926665216, 0.7086944573247815, 0.6734293492514154, 0.6582682710355433, 0.6683746950985341, 0.6882212317567704, 0.6575276996954549, 0.6386556625080136, 0.30153137655995144, 0.41665938604214514, 0.11488782543318177, 0.1750158491370175, 0.23061716771109841, 0.3254689571717537, 0.15464998765340565, 0.29757908781573184, 0.14696532179954302, 0.4151444378209259, 0.4221326445237482, 0.4279962448296808, 0.441594634495043, 0.41340396028724014, 0.4358927493732092, 0.44489632633868825, 0.41823115198789373, 0.3991367454652114, 0.7624704716461047, 0.7368000897364703, 0.7517534000912779, 0.7458256876241609, 0.7279517874346138, 0.7643892848270221, 0.7624627099378123, 0.7207465806903073, 0.7487454732091012, 0.142046218348842, 0.1255200369456072, 0.09264513407904884, 0.10230346508307175, 0.08666298845719522, 0.16732416141578654, 0.1209136204764687, 0.1523143508212499, 0.09863168929894528, 0.22293942873428607, 0.18334524830355114, 0.3338921418789603, 0.22572887796323593, 0.19737437531206004, 0.20223931785467342, 0.3154718082623854, 0.26585128679447056, 0.3351026686353349, 0.46444618331988063, 0.4549924949669376, 0.41549166645963664, 0.38444555088745147, 0.46854954506177504, 0.4811760699380121, 0.5216076956828328, 0.4993496091912073, 0.5100275094729088, 0.3947089100646214, 0.4206565634460583, 0.41496710324442265, 0.40980181319150366, 0.42217516514135034, 0.4225986853400211, 0.4633199048722241, 0.40670827545097776, 0.389291744131653, 0.19750678410024347, 0.19137457400086022, 0.16651465591011327, 0.181557587356024, 0.16837285397374746, 0.1911751347509576, 0.21876959090323145, 0.22388651453344144, 0.1692411711176206, 0.19929773616226676, 0.19455899550743783, 0.18815330468953884, 0.21372967805780274, 0.16771903370874985, 0.2004465910752531, 0.2020851674435188, 0.20015662978872661, 0.2406218274496459, 0.8471846532645562, 0.19286840539111294, 0.1518359990887479, 0.16974829768057975, 0.19623893804963433, 0.7797846970135136, 0.8410921859926299, 0.17467582705762275, 0.8186845739521464, 0.8211844936800162, 0.20629095849874535, 0.8033560380183663, 0.20358031364319462, 0.20656497548536668, 0.16675338494431613, 0.20968590199153703, 0.1261149725153251, 0.20982042928502953, 0.17757913450053597, 0.19120305355473388, 0.19789504517859946, 0.17963296035035525, 0.17173093601290057, 0.1784954015004423, 0.1744730073848466, 0.17064975157851692, 0.19233379817473406, 0.0885505225145613, 0.073391319415965, 0.09528222433488731, 0.07467731739226768, 0.07650820559394256, 0.08754852841852989, 0.06833607936322028, 0.06878044025356644, 0.09130840491046088]}, "mutation_prompt": null}
{"id": "bcd05247-4ce0-4777-9fd9-c0eba71adc31", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * (0.7 if fitness[index] < np.mean(fitness) else 0.6)  # Adjusted mutation factor range based on fitness\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce diversity by modifying the mutation factor to adapt dynamically based on fitness improvements.", "configspace": "", "generation": 86, "fitness": 0.46441273035062275, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8298200697954079, 0.8140936086722416, 0.8205946654688772, 0.8218349168961188, 0.8285470171941564, 0.8027718440706785, 0.8230945365392625, 0.8069912634632459, 0.8092761902948569, 0.6799161820318331, 0.6933464876338742, 0.6710417539253873, 0.6558807708287029, 0.6788202330666261, 0.6503485492473351, 0.6655133428612997, 0.6722915361149957, 0.6637232356053081, 0.17344343967418407, 0.11183515966120561, 0.13395939392007727, 0.12559650243659415, 0.5798655200314978, 0.11074291157263538, 0.14809287404965799, 0.1120666173225, 0.16323661887582552, 0.11292707694285187, 0.10301308670419151, 0.14724970936657433, 0.10575562562837681, 0.13624115587944197, 0.13295528118514643, 0.10824294928464784, 0.16033686577093686, 0.10033472564638357, 0.9329080523679316, 0.8899294199555922, 0.9538427029603432, 0.9267556783352295, 0.9684599218811633, 0.9320222220070644, 0.9480859344006283, 0.9861636164903537, 0.9135092959838074, 0.5730204322422708, 0.642662853031668, 0.6558850686108313, 0.6116253452260378, 0.606202627505447, 0.6245583264669191, 0.5840210033986991, 0.6475400553357842, 0.5755695172658284, 0.8013842230169954, 0.8091630575957747, 0.8069259109773448, 0.8389257692255057, 0.8457493285300745, 0.8171935802222423, 0.8474396297942924, 0.8347665283943146, 0.8005512762027636, 0.39861892343322436, 0.510955100048468, 0.4776607676731668, 0.6703125482765286, 0.5220518954954384, 0.10979558460686623, 0.5610779800196017, 0.6512295009236537, 0.5150520403277803, 0.5869158579967533, 0.3602292417083931, 0.43590284321121464, 0.12753229590017212, 0.6712706516861209, 0.12656457336989968, 0.5151632270057109, 0.4320640540798708, 0.49145733480483533, 0.6115354710984675, 0.6156569677604945, 0.6355049346883122, 0.5897660423705109, 0.616588747280558, 0.6417519514690575, 0.6203316765969378, 0.6138370838413755, 0.6337669501834196, 0.6922243831073491, 0.6973815482128416, 0.6784576233002458, 0.7073241560138392, 0.6948264722600797, 0.6539808202403756, 0.6699166244861257, 0.6812368258384773, 0.7075970400810934, 0.1716739811193596, 0.37789763815847155, 0.28488438485746503, 0.519035702348081, 0.4757299858455515, 0.4869229752355576, 0.2712394126555546, 0.2674667620125569, 0.1194693102911849, 0.49105143427015785, 0.46831626272706994, 0.44357655235911475, 0.44639094678231517, 0.5302237734155073, 0.49123590999704414, 0.48260438507040093, 0.5155775601418324, 0.5095674507805898, 0.7982437313994037, 0.7851252839175276, 0.7492273932872247, 0.7834545497605832, 0.7872661610229469, 0.7791209165347679, 0.7665773535051987, 0.7446408339195145, 0.7738584288719997, 0.10512167815605422, 0.16611404384911566, 0.16940679879552267, 0.12614295600748737, 0.1349540611246337, 0.14756481868429216, 0.11376310429563508, 0.11538533016295827, 0.1012061309138027, 0.6666632125779652, 0.19932949616780848, 0.3531980978707827, 0.18820655142122367, 0.5075085973458111, 0.7066375670327337, 0.6807791038469337, 0.2074625846862439, 0.19356308124271393, 0.5124194513184275, 0.47516305944652115, 0.47795020086087237, 0.5458719882876599, 0.5282612126067884, 0.496263414333423, 0.5552480979071296, 0.5500995699256057, 0.5108077248673303, 0.3003577542630387, 0.4297204326092413, 0.44202868665259265, 0.4174309043089499, 0.4520383186246324, 0.43494156824854247, 0.4796323970293682, 0.5025064746173621, 0.46510551600509953, 0.1920809103641813, 0.19137051063504462, 0.19053504752047168, 0.19932070364775945, 0.21417448924856541, 0.18860989007558837, 0.1638658523431219, 0.24903633764824695, 0.19308088465345308, 0.23328665501307277, 0.20910286111884369, 0.19618352409362227, 0.6913633782909636, 0.17507013174866148, 0.2420238047686184, 0.21680669893922655, 0.16510176911845298, 0.2061109855887282, 0.8415887043653608, 0.18285456116031906, 0.17662509626683054, 0.85871760799793, 0.866633294036187, 0.8349124908667185, 0.182581613702265, 0.1667610040679276, 0.16413253430377117, 0.8367954384031959, 0.7922914304697566, 0.8466741817649964, 0.2026004279947421, 0.20806089885748225, 0.1641352298299722, 0.20557611055806302, 0.8257550607185195, 0.20831001715658182, 0.17011073928063702, 0.18597790913880985, 0.2118509891208964, 0.17457799272197294, 0.17824975089653894, 0.17667684921775295, 0.18038554146814023, 0.1675408908526359, 0.1726402419370544, 0.09079675949852284, 0.08224704341122069, 0.08396384661618994, 0.08142030116646293, 0.08982175667118952, 0.09596623634601786, 0.07471985514162971, 0.08359324196380657, 0.09704377208141546]}, "mutation_prompt": null}
{"id": "60a7cfc2-b868-4f76-a35d-6a369d42c712", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= (0.97 + 0.03 * np.random.rand())  # Dynamic adjustment\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a dynamic local search probability adjustment for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.4700175088582099, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.829405855884488, 0.8153669922185354, 0.8327487680036484, 0.8308366277127597, 0.8262718704342401, 0.8342993236343624, 0.8336464612574264, 0.8427848706337082, 0.8207985589014437, 0.6659611601861408, 0.6832067767162784, 0.7040009946408611, 0.715506969789971, 0.6773808235372745, 0.686234062388005, 0.6822733849332573, 0.6956055600162316, 0.6958496055671718, 0.6144072073811204, 0.14900780578828254, 0.1626647824037245, 0.12876885480009492, 0.13155116562213331, 0.14023488389258587, 0.1331175111616414, 0.14214544195115408, 0.1352516685832028, 0.10571927360422506, 0.12340925217746623, 0.11475184401046878, 0.13592745422684815, 0.14260350597820193, 0.14455465027696213, 0.14553832345504347, 0.1327078722668189, 0.14558755524961342, 0.912551450065713, 0.9542220850815903, 0.9048749607560848, 0.9593482413527926, 0.9455193317912955, 0.9139733563146006, 0.9179823305672256, 0.9738750324859132, 0.9737370370143871, 0.6401274851126342, 0.6404089162504127, 0.6255074420515938, 0.592697004735774, 0.5964917951383877, 0.6244866432712985, 0.5791010727969261, 0.5919525181487835, 0.6427102451043811, 0.8193008205441321, 0.8434470472938133, 0.8411338359088781, 0.8451872393884879, 0.8272013366016511, 0.8490962952580031, 0.383073511331148, 0.8449270687311361, 0.8412738115631576, 0.5140746157479528, 0.5207258218857965, 0.48390163357664107, 0.12842913041920379, 0.5196384004617107, 0.4918323654741473, 0.12904398886161184, 0.5441722774934825, 0.6887154811111381, 0.44511496916975946, 0.4224674948096079, 0.6163278759582447, 0.5432434088154738, 0.3886832947291987, 0.40164537062129657, 0.5429633752245707, 0.475761403717631, 0.6028394776218893, 0.6144096392825926, 0.6607240320584115, 0.6573983802439987, 0.6484772654346197, 0.6651256547686895, 0.6306320707592357, 0.6123986668382896, 0.6176872575795307, 0.6472423354535076, 0.7073213812248494, 0.6928979132858274, 0.7336880538329974, 0.7160331410579237, 0.7035093649659097, 0.7143358810684919, 0.7071160082640848, 0.7562559271329923, 0.7037701391073126, 0.3538033186213726, 0.3551394712235003, 0.10443234746227004, 0.5137382072830526, 0.5533086013161476, 0.48487033860416573, 0.18158207158833894, 0.12256485814850182, 0.1192735999915352, 0.5209084792465867, 0.5487617115383359, 0.526352212106612, 0.4663014219177094, 0.5138589337554195, 0.5302570414602084, 0.5349848927383141, 0.500834289246811, 0.520782495492288, 0.7958821197014855, 0.8008522984262363, 0.794678523100001, 0.7736706396048868, 0.7873408927696673, 0.7808163096844054, 0.7849468157700958, 0.7685228159173207, 0.7805114260597912, 0.0876886400901078, 0.12560259065370105, 0.12637547189951637, 0.13644841884679304, 0.1368004800393906, 0.11109141671340983, 0.11554312881618556, 0.13614080433075781, 0.14476036604031395, 0.4106964321958333, 0.16898352932120775, 0.1996450521323404, 0.27559079004607556, 0.6879075151078516, 0.6563557458604827, 0.16834836848205692, 0.668812689018122, 0.2020734812469528, 0.5594605393673642, 0.46359395381488744, 0.5575575506053936, 0.5486868068541639, 0.4713606400110639, 0.570901463370145, 0.5543335429395833, 0.5714513925526288, 0.577649151659118, 0.5093936660408986, 0.45828765538467353, 0.465789597048173, 0.484136939898808, 0.4593322853851388, 0.3599556395746073, 0.505580958611489, 0.4797609181539658, 0.4833217955108924, 0.19211214000434573, 0.18010990900025226, 0.17912527008128343, 0.208266710097611, 0.17348651770533818, 0.19170221681049138, 0.18767617040200724, 0.17332340992817685, 0.1985022591124841, 0.1887292649442155, 0.2484877502541738, 0.19511159271070078, 0.6933291035659079, 0.21852984943865028, 0.19280974049129196, 0.20243013584275682, 0.21233188813448145, 0.20114130322724055, 0.16839668261064666, 0.8093488391606687, 0.15302321808365904, 0.8534192153983775, 0.19854407964842102, 0.8557921356153856, 0.18132222054318992, 0.16929517845421482, 0.8026078148567136, 0.7984051248627076, 0.208337736044514, 0.20373968977471513, 0.8696427262932366, 0.20549656005017902, 0.165214346659187, 0.8059286834375808, 0.8361853246739194, 0.20909717076740042, 0.1628944102197194, 0.1876608447518674, 0.16612157052816912, 0.24225805775649512, 0.1868225365148095, 0.17191487136841532, 0.20389511458528464, 0.2367182619096071, 0.17352901863560988, 0.07555476793840843, 0.09448572680694067, 0.08310656479377121, 0.07578198856138241, 0.07819798415974999, 0.1101992596079805, 0.07301840150872263, 0.09380795712923407, 0.08547791550768047]}, "mutation_prompt": null}
{"id": "855e54cc-ee99-46fa-ad96-0ea9c7a61ae2", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.965  # Slightly increased adaptation rate", "name": "HybridDE", "description": "Improve convergence by slightly increasing the adaptation rate of the mutation factor.", "configspace": "", "generation": 88, "fitness": 0.4764235618475581, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.27.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8316267823304446, 0.8172924993458099, 0.8023113794019013, 0.8166273623821311, 0.8329821906423176, 0.84740065091231, 0.8390965349431122, 0.8161128602222785, 0.8227961903624075, 0.6953339028998864, 0.7075798142243466, 0.6971515675150257, 0.6919548836201543, 0.6898250672983712, 0.6833270377878844, 0.7034526428198036, 0.6835134642348417, 0.7099995530568368, 0.15173001578569112, 0.17085515293945575, 0.145824254285166, 0.14796165778364134, 0.13647103263854965, 0.1512865784541393, 0.11375920199205325, 0.12254115720414505, 0.5617149921039616, 0.14691628555361824, 0.1408008227607439, 0.16578656853076412, 0.1330233016325334, 0.10465083808597753, 0.5057023598365672, 0.14626220180346372, 0.12827514358508285, 0.10040018025129305, 0.8922444443663, 0.9058364780279881, 0.928143059847374, 0.9465896470439239, 0.9685501671323848, 0.9469624837922418, 0.9178906756621209, 0.9861471072206803, 0.9106762373397564, 0.6200336578802476, 0.677573277096514, 0.6333857393668327, 0.6497057202814427, 0.5929958280795181, 0.6250745930649335, 0.6359503139724362, 0.621387930288088, 0.5889373236943691, 0.8325300051045686, 0.8079037507201655, 0.8537553704451242, 0.8427008421630323, 0.8694365659936177, 0.8425141929977404, 0.8315141224012846, 0.8302751655421554, 0.8189517054513107, 0.48253513632316913, 0.5492491604980001, 0.679999641041698, 0.6135830969033338, 0.13100200245741256, 0.12023793342136546, 0.3669080603589703, 0.574654517953719, 0.6852945844407394, 0.12819479022074032, 0.563007382049661, 0.47098936322570273, 0.46830982429882795, 0.5528464271658534, 0.5275615187597578, 0.43357962800795213, 0.4316273665293472, 0.45212055816545715, 0.5954284633938882, 0.6239630086182129, 0.6655457095311728, 0.6310536734656483, 0.62646176117597, 0.6037760600710516, 0.6587106628820147, 0.6482780072520705, 0.6758324321309765, 0.6828987682588497, 0.6176749970367663, 0.7178262436211669, 0.7137149305390974, 0.6883813188663364, 0.7016165413805002, 0.7109437332825519, 0.7195980063540328, 0.6855460961074544, 0.06794454777524439, 0.20339787352550487, 0.29835003938661186, 0.5688091948914609, 0.5720023801187446, 0.47732220403321024, 0.33538828342351346, 0.3624506878696425, 0.19796052508721085, 0.5405283248153145, 0.503990012452051, 0.5159619743977764, 0.5090025912299759, 0.5575974130813517, 0.5289802167135811, 0.45143648108541923, 0.5263695979265353, 0.48021685997883556, 0.7522233670070194, 0.8027888208160998, 0.785444743146158, 0.7851891761575239, 0.7907864900064975, 0.7748911500853101, 0.7922999219484705, 0.7608204999597981, 0.7836388348286215, 0.12630775569066122, 0.13983720061194693, 0.15758530822048578, 0.10167469069917023, 0.1512722943040421, 0.14761995420726848, 0.09159991980636295, 0.10789462407665051, 0.17298239272920723, 0.34193416102103324, 0.7442535000376597, 0.22920008642808132, 0.19590199783133144, 0.201544458588108, 0.2920683171365085, 0.6851996580144676, 0.33319433697368517, 0.11864607291104257, 0.5666281175583976, 0.5701344543476716, 0.49459417696654595, 0.525617122523476, 0.568164911353706, 0.5408090958334351, 0.5426948815455508, 0.5228534743838331, 0.610340881725547, 0.41933846718538403, 0.45176851345238733, 0.433939930868001, 0.45421100286944616, 0.5432922814846068, 0.45248483869229617, 0.4711507693565311, 0.5040655048161483, 0.33594200435477906, 0.19279168494757182, 0.1788899654694689, 0.2596865667292324, 0.19948839378356864, 0.21898504296183552, 0.2023041509443787, 0.15895888333611752, 0.19454114900486474, 0.18545313722530532, 0.20017240305908035, 0.20713089709756027, 0.21412062275152255, 0.24213261271385222, 0.23443031415967064, 0.18278667602191745, 0.19258494780469393, 0.21251476361107524, 0.19939580402342838, 0.8732669034083131, 0.1940600583937362, 0.17595843901838293, 0.8656118247839707, 0.8722865962627464, 0.8394770926267094, 0.82290336547192, 0.16577227535873407, 0.17018918349411816, 0.8367104706044177, 0.8630082247088178, 0.8329636608089923, 0.7877866089641057, 0.20562172506974508, 0.1637931532905662, 0.20632503359054788, 0.8592340678665749, 0.20836594118913176, 0.17064941691286806, 0.2417330145163602, 0.16598481129597675, 0.18403626131784834, 0.18365001019977734, 0.1704741349180413, 0.18144045753545657, 0.19393748235940278, 0.1868536727905965, 0.09398771839352593, 0.08106218915795527, 0.07691496181065083, 0.0825455232187714, 0.07616563353923789, 0.09941385944006653, 0.1078561393159222, 0.10795642654420956, 0.07162169490392478]}, "mutation_prompt": null}
{"id": "a192c99f-7289-47a5-b9b0-5ecc1dc2b537", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance the exploration-exploitation balance by dynamically adjusting mutation factors and improving elitism.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8316267823304446, 0.8172924993458099, 0.8023113794019013, 0.8166273623821311, 0.8329821906423176, 0.84740065091231, 0.8390965349431122, 0.8161128602222785, 0.8227961903624075, 0.6953339028998864, 0.7075798142243466, 0.6971515675150257, 0.6919548836201543, 0.6898250672983712, 0.6833270377878844, 0.7034526428198036, 0.6835134642348417, 0.7099995530568368, 0.15173001578569112, 0.17085515293945575, 0.145824254285166, 0.14796165778364134, 0.13647103263854965, 0.1512865784541393, 0.11375920199205325, 0.12254115720414505, 0.5617149921039616, 0.14691628555361824, 0.1408008227607439, 0.16578656853076412, 0.1330233016325334, 0.10465083808597753, 0.5057023598365672, 0.14626220180346372, 0.12827514358508285, 0.10040018025129305, 0.8922444443663, 0.9058364780279881, 0.928143059847374, 0.9465896470439239, 0.9685501671323848, 0.9469624837922418, 0.9178906756621209, 0.9861471072206803, 0.9106762373397564, 0.6200336578802476, 0.677573277096514, 0.6333857393668327, 0.6497057202814427, 0.5929958280795181, 0.6250745930649335, 0.6359503139724362, 0.621387930288088, 0.5889373236943691, 0.8325300051045686, 0.8079037507201655, 0.8537553704451242, 0.8427008421630323, 0.8694365659936177, 0.8425141929977404, 0.8315141224012846, 0.8302751655421554, 0.8189517054513107, 0.48253513632316913, 0.5492491604980001, 0.679999641041698, 0.6135830969033338, 0.13100200245741256, 0.12023793342136546, 0.3669080603589703, 0.574654517953719, 0.6852945844407394, 0.12819479022074032, 0.563007382049661, 0.47098936322570273, 0.46830982429882795, 0.5528464271658534, 0.5275615187597578, 0.43357962800795213, 0.4316273665293472, 0.45212055816545715, 0.5954284633938882, 0.6239630086182129, 0.6655457095311728, 0.6310536734656483, 0.62646176117597, 0.6037760600710516, 0.6587106628820147, 0.6482780072520705, 0.6758324321309765, 0.6828987682588497, 0.6176749970367663, 0.7178262436211669, 0.7137149305390974, 0.6883813188663364, 0.7016165413805002, 0.7109437332825519, 0.7195980063540328, 0.6855460961074544, 0.06794454777524439, 0.20339787352550487, 0.29835003938661186, 0.5688091948914609, 0.5720023801187446, 0.47732220403321024, 0.33538828342351346, 0.3624506878696425, 0.19796052508721085, 0.5405283248153145, 0.503990012452051, 0.5159619743977764, 0.5090025912299759, 0.5575974130813517, 0.5289802167135811, 0.45143648108541923, 0.5263695979265353, 0.48021685997883556, 0.7522233670070194, 0.8027888208160998, 0.785444743146158, 0.7851891761575239, 0.7907864900064975, 0.7748911500853101, 0.7922999219484705, 0.7608204999597981, 0.7836388348286215, 0.12630775569066122, 0.13983720061194693, 0.15758530822048578, 0.10167469069917023, 0.1512722943040421, 0.14761995420726848, 0.09159991980636295, 0.10789462407665051, 0.17298239272920723, 0.34193416102103324, 0.7442535000376597, 0.22920008642808132, 0.19590199783133144, 0.201544458588108, 0.2920683171365085, 0.6851996580144676, 0.33319433697368517, 0.11864607291104257, 0.5666281175583976, 0.5701344543476716, 0.49459417696654595, 0.525617122523476, 0.568164911353706, 0.5408090958334351, 0.5426948815455508, 0.5228534743838331, 0.610340881725547, 0.41933846718538403, 0.45176851345238733, 0.433939930868001, 0.45421100286944616, 0.5432922814846068, 0.45248483869229617, 0.4711507693565311, 0.5040655048161483, 0.33594200435477906, 0.19279168494757182, 0.1788899654694689, 0.2596865667292324, 0.19948839378356864, 0.21898504296183552, 0.2023041509443787, 0.15895888333611752, 0.19454114900486474, 0.18545313722530532, 0.20017240305908035, 0.20713089709756027, 0.21412062275152255, 0.24213261271385222, 0.23443031415967064, 0.18278667602191745, 0.19258494780469393, 0.21251476361107524, 0.19939580402342838, 0.8732669034083131, 0.1940600583937362, 0.17595843901838293, 0.8656118247839707, 0.8722865962627464, 0.8394770926267094, 0.82290336547192, 0.16577227535873407, 0.17018918349411816, 0.8367104706044177, 0.8630082247088178, 0.8329636608089923, 0.7877866089641057, 0.20562172506974508, 0.1637931532905662, 0.20632503359054788, 0.8592340678665749, 0.20836594118913176, 0.17064941691286806, 0.2417330145163602, 0.16598481129597675, 0.18403626131784834, 0.18365001019977734, 0.1704741349180413, 0.18144045753545657, 0.19393748235940278, 0.1868536727905965, 0.09398771839352593, 0.08106218915795527, 0.07691496181065083, 0.0825455232187714, 0.07616563353923789, 0.09941385944006653, 0.1078561393159222, 0.10795642654420956, 0.07162169490392478]}, "mutation_prompt": null}
{"id": "de7d02d0-02b7-4e45-a67f-ce262118acb9", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func)\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.95  # More aggressive decrease in mutation factor", "name": "HybridDE", "description": "Improve the adaptive parameter strategy by using a more aggressive decrease in the mutation factor.", "configspace": "", "generation": 90, "fitness": 0.4764235618475581, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.27.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.8316267823304446, 0.8172924993458099, 0.8023113794019013, 0.8166273623821311, 0.8329821906423176, 0.84740065091231, 0.8390965349431122, 0.8161128602222785, 0.8227961903624075, 0.6953339028998864, 0.7075798142243466, 0.6971515675150257, 0.6919548836201543, 0.6898250672983712, 0.6833270377878844, 0.7034526428198036, 0.6835134642348417, 0.7099995530568368, 0.15173001578569112, 0.17085515293945575, 0.145824254285166, 0.14796165778364134, 0.13647103263854965, 0.1512865784541393, 0.11375920199205325, 0.12254115720414505, 0.5617149921039616, 0.14691628555361824, 0.1408008227607439, 0.16578656853076412, 0.1330233016325334, 0.10465083808597753, 0.5057023598365672, 0.14626220180346372, 0.12827514358508285, 0.10040018025129305, 0.8922444443663, 0.9058364780279881, 0.928143059847374, 0.9465896470439239, 0.9685501671323848, 0.9469624837922418, 0.9178906756621209, 0.9861471072206803, 0.9106762373397564, 0.6200336578802476, 0.677573277096514, 0.6333857393668327, 0.6497057202814427, 0.5929958280795181, 0.6250745930649335, 0.6359503139724362, 0.621387930288088, 0.5889373236943691, 0.8325300051045686, 0.8079037507201655, 0.8537553704451242, 0.8427008421630323, 0.8694365659936177, 0.8425141929977404, 0.8315141224012846, 0.8302751655421554, 0.8189517054513107, 0.48253513632316913, 0.5492491604980001, 0.679999641041698, 0.6135830969033338, 0.13100200245741256, 0.12023793342136546, 0.3669080603589703, 0.574654517953719, 0.6852945844407394, 0.12819479022074032, 0.563007382049661, 0.47098936322570273, 0.46830982429882795, 0.5528464271658534, 0.5275615187597578, 0.43357962800795213, 0.4316273665293472, 0.45212055816545715, 0.5954284633938882, 0.6239630086182129, 0.6655457095311728, 0.6310536734656483, 0.62646176117597, 0.6037760600710516, 0.6587106628820147, 0.6482780072520705, 0.6758324321309765, 0.6828987682588497, 0.6176749970367663, 0.7178262436211669, 0.7137149305390974, 0.6883813188663364, 0.7016165413805002, 0.7109437332825519, 0.7195980063540328, 0.6855460961074544, 0.06794454777524439, 0.20339787352550487, 0.29835003938661186, 0.5688091948914609, 0.5720023801187446, 0.47732220403321024, 0.33538828342351346, 0.3624506878696425, 0.19796052508721085, 0.5405283248153145, 0.503990012452051, 0.5159619743977764, 0.5090025912299759, 0.5575974130813517, 0.5289802167135811, 0.45143648108541923, 0.5263695979265353, 0.48021685997883556, 0.7522233670070194, 0.8027888208160998, 0.785444743146158, 0.7851891761575239, 0.7907864900064975, 0.7748911500853101, 0.7922999219484705, 0.7608204999597981, 0.7836388348286215, 0.12630775569066122, 0.13983720061194693, 0.15758530822048578, 0.10167469069917023, 0.1512722943040421, 0.14761995420726848, 0.09159991980636295, 0.10789462407665051, 0.17298239272920723, 0.34193416102103324, 0.7442535000376597, 0.22920008642808132, 0.19590199783133144, 0.201544458588108, 0.2920683171365085, 0.6851996580144676, 0.33319433697368517, 0.11864607291104257, 0.5666281175583976, 0.5701344543476716, 0.49459417696654595, 0.525617122523476, 0.568164911353706, 0.5408090958334351, 0.5426948815455508, 0.5228534743838331, 0.610340881725547, 0.41933846718538403, 0.45176851345238733, 0.433939930868001, 0.45421100286944616, 0.5432922814846068, 0.45248483869229617, 0.4711507693565311, 0.5040655048161483, 0.33594200435477906, 0.19279168494757182, 0.1788899654694689, 0.2596865667292324, 0.19948839378356864, 0.21898504296183552, 0.2023041509443787, 0.15895888333611752, 0.19454114900486474, 0.18545313722530532, 0.20017240305908035, 0.20713089709756027, 0.21412062275152255, 0.24213261271385222, 0.23443031415967064, 0.18278667602191745, 0.19258494780469393, 0.21251476361107524, 0.19939580402342838, 0.8732669034083131, 0.1940600583937362, 0.17595843901838293, 0.8656118247839707, 0.8722865962627464, 0.8394770926267094, 0.82290336547192, 0.16577227535873407, 0.17018918349411816, 0.8367104706044177, 0.8630082247088178, 0.8329636608089923, 0.7877866089641057, 0.20562172506974508, 0.1637931532905662, 0.20632503359054788, 0.8592340678665749, 0.20836594118913176, 0.17064941691286806, 0.2417330145163602, 0.16598481129597675, 0.18403626131784834, 0.18365001019977734, 0.1704741349180413, 0.18144045753545657, 0.19393748235940278, 0.1868536727905965, 0.09398771839352593, 0.08106218915795527, 0.07691496181065083, 0.0825455232187714, 0.07616563353923789, 0.09941385944006653, 0.1078561393159222, 0.10795642654420956, 0.07162169490392478]}, "mutation_prompt": null}
{"id": "409640e4-ee78-4a72-80ac-4c5b2191a334", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a small bias towards the current best individual during local search to enhance convergence.", "configspace": "", "generation": 91, "fitness": 0.47921526048271873, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "382c8092-508c-41d6-95d9-a0d87a7c91d9", "metadata": {"aucs": [0.819466226242494, 0.8342937780700272, 0.829008005911347, 0.82652428325167, 0.8207839161299869, 0.8095326113372071, 0.8192090173077613, 0.8146811749655616, 0.8239718572235417, 0.6706390669373778, 0.6947077078104591, 0.6752409865380166, 0.6772367730201929, 0.6847230086417999, 0.6898245190779309, 0.6762487558786665, 0.6979373727533451, 0.67239384296169, 0.14707571862927038, 0.572015913892191, 0.150413735939523, 0.10785002355505091, 0.16900343654597927, 0.12308399676706361, 0.1350631668441471, 0.12047217441325553, 0.15360161668623928, 0.1314453996359798, 0.1143946380570171, 0.13007010152097898, 0.10684690519446538, 0.1280888310229351, 0.10691910210970801, 0.1644935958960807, 0.09175362732549386, 0.13267641898007443, 0.8953633664870764, 0.943045998969659, 0.9664838981180047, 0.9505391941650533, 0.9519551577176474, 0.9216881489759442, 0.9408823261600798, 0.9861378430788528, 0.9343960932478311, 0.6526566536678906, 0.6366379576152692, 0.6458259016614618, 0.6332382986547933, 0.658503324159508, 0.6417782364451923, 0.6455143639562382, 0.6429247633997074, 0.6267291164105262, 0.8296373924583401, 0.8449905320115627, 0.7783622536353839, 0.8673752679884104, 0.83188921270362, 0.8265911305706313, 0.8566077243752306, 0.8372878937278865, 0.8100372515704558, 0.44802813321726176, 0.3695537511356223, 0.3077271667387501, 0.5442603894160598, 0.5471592240267806, 0.6070499920985972, 0.6269157706820405, 0.5507076944104192, 0.5373744328424781, 0.4854657505813742, 0.2953675537587984, 0.6501397639412524, 0.6507473629108719, 0.5711623181095995, 0.5844617879065788, 0.6925016782924412, 0.6312787843221569, 0.6431279118508137, 0.654952828411266, 0.6597743510384195, 0.6153926376338374, 0.6399624805560133, 0.6529225750826495, 0.6207198446596679, 0.641866317438573, 0.605685722610091, 0.6435039152432693, 0.7379545964553319, 0.7163514370621988, 0.6982260611728373, 0.6847375044663142, 0.7069546409203198, 0.698592352992728, 0.7290367815183376, 0.7108417505279219, 0.6937707602830874, 0.08688112729350195, 0.2145324354656013, 0.16237583368730701, 0.5590774870829729, 0.5533294824722909, 0.3003946911139961, 0.2269758520353795, 0.13998022539539068, 0.15125810177412768, 0.5016757498607405, 0.5212657710405545, 0.4789591043990604, 0.5203043064530551, 0.5003035280266317, 0.5195697471850969, 0.48684260336154617, 0.5004520200170168, 0.5080837935919098, 0.8042089212026373, 0.7977141795444028, 0.7900729025688301, 0.7847789737018931, 0.779148749269609, 0.7737035172011063, 0.7738806749213885, 0.7704534104763189, 0.7605185083221552, 0.11652741911170195, 0.09612407329166595, 0.10623762186350139, 0.10091275670848321, 0.12621677705165035, 0.12756766550193643, 0.12376889974094551, 0.15085260811168777, 0.14192316503079416, 0.4062507917250874, 0.7182704947539233, 0.17419929050990357, 0.2556160764534924, 0.22509961937838208, 0.681468160791183, 0.6390912050480381, 0.2800407982907862, 0.2159047140862811, 0.5171325175961212, 0.5254616203540983, 0.5418124589581159, 0.5261984425624484, 0.5164077653979069, 0.5649311564444139, 0.5138313060816486, 0.5289673401009325, 0.5718804355522854, 0.410785444193944, 0.4409122503731322, 0.47618720287935346, 0.4250199580359223, 0.4832676902888886, 0.36908209732896424, 0.4787511590490059, 0.49163579900415255, 0.4945972365740148, 0.21681594265977722, 0.2179284292789645, 0.19265890779635952, 0.18277163476180935, 0.23983999766849018, 0.18959842082015066, 0.19423703555666738, 0.1991430150939263, 0.20661795309686581, 0.2007610783336944, 0.20451027277472988, 0.21913550640566015, 0.21956553647303267, 0.1755353410607693, 0.2147718438209718, 0.21411718137942526, 0.23765873327078013, 0.19341458650816312, 0.8664310834856614, 0.2065000615714221, 0.17654779406513932, 0.8654757272654304, 0.1987915510839583, 0.8769721751780662, 0.8513207332355455, 0.8768034096683577, 0.8202399779345325, 0.8194992185657511, 0.20924401188243869, 0.857133716309441, 0.2033341987908428, 0.16394682811137917, 0.8130029854674664, 0.20884266735702273, 0.8037706110502734, 0.15363070032618165, 0.16841723785434537, 0.1853666407645138, 0.16252349406257494, 0.17217404371571776, 0.161455386425303, 0.17994457605953762, 0.1695159208126713, 0.17400670132957807, 0.17313130049223657, 0.07767911871836675, 0.09145789136640647, 0.07744403636119745, 0.09554346855248919, 0.09248603066767758, 0.0981878001642934, 0.10910994566643895, 0.06872683690082504, 0.10003461723307117]}, "mutation_prompt": null}
{"id": "b555e83a-4741-4208-b0aa-5b320491cc97", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce adaptive elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            num_elites = max(1, self.population_size // (budget_used // (self.budget // 10) + 1))\n            population[np.random.choice(range(self.population_size), size=num_elites, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce adaptive elitism by dynamically adjusting the number of elites based on current budget usage.", "configspace": "", "generation": 92, "fitness": 0.2774103731136626, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "409640e4-ee78-4a72-80ac-4c5b2191a334", "metadata": {"aucs": [0.7902881094819484, 0.8562102831624183, 0.8675175819552918, 0.708422172985719, 0.8064879308885193, 0.806684193539703, 0.8799197711368462, 0.8098592515884282, 0.7830790801792749, 0.5419934927448828, 0.33974956285283264, 0.4683197884987612, 0.5438715350498258, 0.6540510939696227, 0.6403338767637337, 0.04141375587546203, 0.6274225532845067, 0.5740087481298546, 0.06795700112539815, 0.06594646848050378, 0.06440096822620656, 0.09087260763917215, 0.05887041606031851, 0.048038980164916256, 0.07231179166118984, 0.11371897518821894, 0.09039528866468005, 0.06601513011647242, 0.05445174001666642, 0.04927532832671222, 0.07176872804805134, 0.043891181778932364, 0.06952534575565428, 0.04414920128160593, 0.047491475568440356, 0.026533292064400138, 0.8788207811866613, 0.8909694702185592, 0.861682397777835, 0.8711535341013681, 0.9422159850442856, 0.9039606738266739, 0.8964504965227524, 0.8643768737525965, 0.9586800159919243, 0.6462813952712145, 0.46893646578808446, 0.654690950231507, 0.5087648195576135, 0.6227350498976094, 0.5150527057705344, 0.4809098673506427, 0.4848888828583021, 0.5246088457460607, 0.20838155764937705, 0.2173323466060315, 0.22021848711997039, 0.24677075891342226, 0.20858078350749543, 0.20245289772749264, 0.1136980235907622, 0.17518234051407433, 0.14756066470029694, 0.43013663734052165, 0.2827175050576285, 0.3894190506689882, 0.11140580479149864, 0.27512173518221517, 0.14368486078944298, 0.28645038748553076, 0.2425985195832332, 0.35983630310310677, 0.49631562277940244, 0.45209900365398514, 0.17846843830947223, 0.3634855729799593, 0.633136492160389, 0.41293236698345703, 0.19033137021900737, 0.11845616614350751, 0.08981239037106392, 9.999999999998899e-05, 0.025364763545607127, 0.013375859391077771, 0.008284021432284683, 0.04841125035123639, 0.03988382239333532, 0.07064565199486239, 0.05946738409997765, 0.08979800270822547, 0.10668942850959684, 0.10142931280212197, 0.08262357364374073, 0.06488567259375755, 9.999999999998899e-05, 0.013358944142866536, 0.08832795919384206, 0.017889776016448145, 0.05220791133999103, 0.20265085710834208, 0.06578274416523366, 0.15931372125275578, 0.19981301123823225, 0.0791523069519644, 0.06749929466025151, 0.07672535957327742, 0.3311909494030074, 0.06872888227613716, 0.31404173442422545, 0.3314414670717045, 0.2744269685704086, 0.16963631401253498, 0.2896722174723556, 0.2583111974082851, 0.24935241881043835, 0.22819221134125933, 0.23520116843601524, 0.5616242198179091, 0.6842558661368134, 0.7293281160182057, 0.6544727333996976, 0.5487618937158883, 0.5971905361290561, 0.6490756352526384, 0.6667588065013409, 0.5970452912075168, 0.11642895201797532, 0.05525588001752835, 0.05327684886198403, 0.07342349976239548, 0.06993423645415497, 0.052337499397536846, 0.07258966248612564, 0.06590812413041225, 0.05453173425715063, 0.24740086399285766, 0.15495134208134054, 0.15383733480878858, 0.16799195202208395, 0.21584499394742374, 0.14610569002735374, 0.1618179758783268, 0.1893265211425269, 0.14773518153828136, 0.16016459804752592, 0.23673890839000467, 0.24757448178751607, 0.21710602991241712, 0.22090472999897948, 0.18283025549362797, 0.21870753059943904, 0.2567815026667297, 0.21633375653871634, 0.18538441020358376, 0.04030932430738554, 0.18457745021769645, 0.15746077349328103, 0.2324006855360572, 0.20107712293875268, 0.11640888329239318, 0.14373028868456517, 0.14760353918484614, 0.17565702448771825, 0.1250197418036516, 0.13441683204579769, 0.13723683415206145, 0.1702212986206909, 0.17059643637832744, 0.208886816593433, 0.2228735617700519, 0.15126744871264242, 0.17317819341561203, 0.16421079897090474, 0.16198479115234365, 0.15926517791060502, 0.20394877626504404, 0.21624377287840102, 0.16717511547516462, 0.17721315427602435, 0.16944237231210135, 0.16924135936475393, 0.1862349758700137, 0.15242890403027798, 0.8412287402979671, 0.19859247771084776, 0.7873157539430669, 0.1421670271271318, 0.15499807494507134, 0.1487271348494209, 0.7171985156018212, 0.20638418709882567, 0.07342622822993394, 0.10244978887804446, 0.72152171030363, 0.09321741846006026, 0.21070693866891432, 0.6816051539132251, 0.15561795837032455, 0.1483910866460083, 0.16339966776801007, 0.17353769226629467, 0.16647383684080197, 0.22214520855332598, 0.23170806515914122, 0.24192874196556335, 0.1618507763159701, 0.2199522415498747, 0.06233833007162848, 0.040777482963194056, 0.07054281706248533, 0.055435773856864046, 0.07211988748697329, 0.06074699357756841, 0.08140611366610118, 0.051578243446794625, 0.07011331675766064]}, "mutation_prompt": null}
{"id": "9cf4a260-de64-4bbe-a814-c874eedc698f", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=2, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        adaptive_step = (1 - (func(best) / func(target)))  # Adaptive step based on fitness\n        step_size = 0.2 * adaptive_step * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.97  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce adaptive step size in local search to better explore the search space.", "configspace": "", "generation": 93, "fitness": 0.4450762079862958, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "409640e4-ee78-4a72-80ac-4c5b2191a334", "metadata": {"aucs": [0.7931816689345959, 0.8086376553447874, 0.8035465947569836, 0.7950069600279128, 0.8030112048345948, 0.8200575690464246, 0.8082911235028493, 0.8095618918333725, 0.7912451799432825, 0.6577295573143297, 0.6762958125580445, 0.6318872972141889, 0.6651246713211545, 0.6402249034183447, 0.6493294464507139, 0.6583251653444055, 0.6617337018011245, 0.6442153768494518, 0.1144881900876753, 0.15140458159090975, 0.11027975950437052, 0.15041446107420364, 0.1696738280786707, 0.1233150171648949, 0.16333936710515518, 0.16724060578846434, 0.1676236646765441, 0.12404444781060031, 0.10208224089002083, 0.13270353339898444, 0.12664416689643, 0.17290093998893608, 0.10825554806506299, 0.16450498556929705, 0.12494136573543069, 0.11406466559920281, 0.9280809186575285, 0.8977630477371312, 0.9603531118461658, 0.9552275909914231, 0.9587154267524401, 0.9395918657384432, 0.8772990988144596, 0.98449435349892, 0.8991500548845689, 0.5954314342821384, 0.6206990641825854, 0.5724368759550094, 0.5623821283533263, 0.6036044408848508, 0.5768921998954291, 0.6330781646074486, 0.5663441907876734, 0.5736809682087924, 0.8297357242197044, 0.8068174530901648, 0.23453124472419362, 0.833374488299871, 0.8491799232998581, 0.8434377776963266, 0.8375048640389455, 0.8037542831603717, 0.7917909848865456, 0.3599175382239833, 0.12815123033757114, 0.583862090567703, 0.468363066175546, 0.25398874474518696, 0.6692332626263615, 0.35369357851857075, 0.6067303734904796, 0.4897393846415242, 0.5550930751919719, 0.16583140609928382, 0.5034975084985681, 0.3456802336549375, 0.5209601853566794, 0.64714643487971, 0.3271110075753749, 0.6880035732684278, 0.38825903338554846, 0.588490430688064, 0.5551897026256365, 0.5907842543770554, 0.6162443326006523, 0.6152970633168803, 0.6087847277899372, 0.5826352824872119, 0.6116586256841006, 0.5907287721852815, 0.7193510148956475, 0.6676084770222911, 0.6520816173362345, 0.6434688058095208, 0.6907449117814353, 0.674537500724351, 0.6768203616650941, 0.6869905965235352, 0.5979508517817727, 0.10059231020286863, 0.1190690458318453, 0.3444657688330697, 0.30909766126002314, 0.2828811450130737, 0.49251356992342077, 0.18601991491685543, 0.19005377525114875, 0.103528410780386, 0.4711440424339858, 0.45755635651936943, 0.4606115156189692, 0.49608564176175773, 0.4743382449701703, 0.47742505188291406, 0.487176562553266, 0.5222192950803454, 0.46680202889081146, 0.7450144794067408, 0.7851020080515423, 0.7423274101427167, 0.7909715099216836, 0.781096136984541, 0.7658795507652212, 0.7677501382021162, 0.7702444868239011, 0.7361608324811402, 0.1354017238326869, 0.07898575698752375, 0.09315310762900719, 0.14822029517499213, 0.08928488860805406, 0.09516705508860301, 0.1394935727743577, 0.09184145096104634, 0.09520215050804726, 0.716451156603584, 0.1769797796177105, 0.1201313807065113, 0.11373163766014405, 0.6169610711331952, 0.11620580982777517, 0.1768230300903506, 0.17439003701900269, 0.22665431662076108, 0.4812603827810257, 0.4383101681612245, 0.5027097750585816, 0.5241795754078344, 0.5048188328452063, 0.4739122827826934, 0.47508109857223735, 0.5078892789626647, 0.49897754523027915, 0.34101326417475275, 0.44459442523606363, 0.4250551657540944, 0.44271293446282134, 0.49773218449782364, 0.4318771678043941, 0.3532573760983966, 0.5339273708925731, 0.3748239644261171, 0.1637050599830907, 0.1745660064747928, 0.17333680746608116, 0.1802136312995808, 0.17146678491894707, 0.2212468290817856, 0.15080740380893398, 0.2688590103373284, 0.22509085169286058, 0.20274333103403708, 0.20377743020067596, 0.19483068617996302, 0.16822722852258776, 0.1712512492119611, 0.19048134914079717, 0.1937029571698563, 0.17723232718717263, 0.6175877373722163, 0.8439263180745424, 0.19402399987228713, 0.17663707219418923, 0.847718713904963, 0.1968224131076578, 0.8740575349949032, 0.14028739936456114, 0.7731783010766554, 0.79648541954479, 0.8408892351301672, 0.16690931223916627, 0.816881414917008, 0.8297693468843873, 0.20407672208100602, 0.6587014143546187, 0.21020578585740146, 0.8314784039008023, 0.15220254188242366, 0.19200472270266977, 0.15411026095784397, 0.1751167807624231, 0.16102083641863396, 0.16424167213804375, 0.1654580813959341, 0.16463697426444746, 0.17400139970555195, 0.17535237761673816, 0.07989910084300778, 0.08095053835508603, 0.06558003516649114, 0.07727502186659363, 0.08522336222042048, 0.06373657640253116, 0.07869594910813793, 0.0748259579598467, 0.05230745264742587]}, "mutation_prompt": null}
{"id": "9d9489f6-791c-441a-bc80-0cef6ab19bcc", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=3, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.98  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a slight increase in the mutation factor's adaptation rate and a more frequent elitism strategy to improve convergence and solution quality.", "configspace": "", "generation": 94, "fitness": 0.47964731355120094, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "409640e4-ee78-4a72-80ac-4c5b2191a334", "metadata": {"aucs": [0.8312301714735637, 0.824865152348608, 0.8368828760568804, 0.8295220017215044, 0.8557599631888575, 0.8548140492532639, 0.8360416631178329, 0.824087869895659, 0.8180114591636072, 0.7232623197904319, 0.70901309246491, 0.6967628674846342, 0.7126640927463048, 0.718002480847266, 0.697294533677216, 0.7191422059909133, 0.7277988636813292, 0.7010157556319399, 0.17366426115821376, 0.12225110935641992, 0.11257439668071967, 0.12160054159166211, 0.1467176411983473, 0.11350808950902469, 0.12394767754668534, 0.15649916954167953, 0.10719807920969959, 0.13407229090622763, 0.16009513254179708, 0.11281539817352004, 0.13389141596152565, 0.11817934504017591, 0.11389309206044529, 0.08898275053463023, 0.1093210389095115, 0.10492295292272558, 0.9104079351678991, 0.92651732045382, 0.9575710362775344, 0.9500270734299489, 0.9658972820088563, 0.9207257407669343, 0.9542703338432664, 0.9861378430788528, 0.9532821833663372, 0.6695218029308256, 0.698047215399191, 0.6454889233560964, 0.6360318244390837, 0.6495394905579042, 0.7242173725318735, 0.6750159704949852, 0.6897049936315858, 0.6797699252728642, 0.8747423357457295, 0.8428367744858858, 0.85891286383513, 0.8503896460842064, 0.8396913002467835, 0.8310415875085562, 0.8477543413572811, 0.8671425092397118, 0.8377867004862083, 0.12786700332448342, 0.4860779685195439, 0.6749515709062687, 0.7175334227238004, 0.44929479111876613, 0.5992432325325086, 0.4928588140916844, 0.5254156778918642, 0.595013577864627, 0.571014340325015, 0.42931022079305947, 0.500826222238369, 0.4920496938687876, 0.1250928817685666, 0.5166277369538513, 0.5065997305226839, 0.6067608049994082, 0.5043843180506918, 0.6723341958801015, 0.6144814384546802, 0.6405501214988336, 0.5656841143705273, 0.6860914182285133, 0.6270575121196069, 0.6109123274684978, 0.6794773724302724, 0.6867962344395036, 0.7652825858475027, 0.7105747644591381, 0.7085208024034495, 0.7375027621009537, 0.7427915036240547, 0.7311091995602134, 0.765957699167796, 0.738660280022475, 0.7385438846894364, 0.23522644636072587, 0.16925191197448763, 0.06678662649076472, 0.4007074703778096, 0.575182301811324, 0.2291447558395726, 0.2617144413849313, 0.14969166025894243, 0.1944195247123195, 0.5792020788098253, 0.5453672547706452, 0.5369864432124491, 0.5152403517107024, 0.5719669417842775, 0.5391469229999879, 0.5590857086709766, 0.5306143667512787, 0.5526630257596408, 0.7794697637070163, 0.8124237973246244, 0.8100708524753537, 0.7917043569537358, 0.8015079003058402, 0.8092490691681576, 0.8197611074624108, 0.7946413563509357, 0.7973135425241318, 0.13484097909184534, 0.10473786368677884, 0.1753436198867674, 0.09764818694210187, 0.10292422142772628, 0.14034951530438544, 0.13582862812231955, 0.10793819927909698, 0.08407022276906229, 0.38021127145858147, 0.1823230108887688, 0.2701839388801627, 0.27747908164404744, 0.7778586358322147, 0.17367135866065286, 0.7350192747175425, 0.280115878050595, 0.2831279070677578, 0.5990724199379382, 0.5129741783181896, 0.48055392910972927, 0.6394394118081204, 0.6619294442107226, 0.6774731377784744, 0.5199469479657169, 0.6649854706401915, 0.4389374869871294, 0.4821278743768098, 0.5915933809535556, 0.561572922134574, 0.5011266753812835, 0.4460607685745728, 0.5136449668878709, 0.48312049505425314, 0.5135218616081629, 0.3607329771619435, 0.16950237322396045, 0.19206582218995538, 0.1834276784220943, 0.18609267857034817, 0.19083635898501128, 0.20416319946503558, 0.17960336375326968, 0.1696018419172024, 0.1852006106363665, 0.19254874495378416, 0.19517394758408324, 0.18248008094360835, 0.21736442356499674, 0.23891321858652415, 0.2044619505063321, 0.24069588547813592, 0.2075073116642664, 0.7582964385330095, 0.1677620746861208, 0.2087222431940079, 0.17686982045750976, 0.8902104002596523, 0.879524209538402, 0.8864302387612817, 0.14198782112725616, 0.8724557895742909, 0.8703149389874729, 0.8497718581755251, 0.2104275369926636, 0.8648826721425736, 0.20573265295306442, 0.8104661204830041, 0.16397752830784207, 0.2116329265057526, 0.20666913743637538, 0.20800229928347835, 0.16863441995362227, 0.16294528853295054, 0.17002219465710589, 0.16244877477985886, 0.15227017587541158, 0.26056604120000293, 0.16770695421410642, 0.16993946571552154, 0.18314508853703437, 0.08926456382082126, 0.07809493201362383, 0.09616815779240895, 0.07902057461089862, 0.09676198016852011, 0.08976546060122637, 0.0949173852894335, 0.09746861803420126, 0.08384897823126358]}, "mutation_prompt": null}
{"id": "44544df2-5882-4c90-96cd-99886d9015d4", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=3, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        diversity = np.std(population, axis=0)  # Calculate population diversity\n        self.mutation_factor = 0.3 + np.random.rand() * (0.6 + 0.2 * np.mean(diversity))  # Adjusted mutation factor with diversity\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.98  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Enhance the mutation factor's adaptation to dynamically adjust based on population diversity.", "configspace": "", "generation": 95, "fitness": 0.4693130813369295, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "9d9489f6-791c-441a-bc80-0cef6ab19bcc", "metadata": {"aucs": [0.8288018914223532, 0.8235957982916133, 0.8312855987790273, 0.8335821578014504, 0.8383300650399517, 0.8315141799397991, 0.8248151128692895, 0.8154902853773256, 0.8187460767310254, 0.7026094268330487, 0.6487759433100043, 0.6637426820653836, 0.6633631856210452, 0.6841447906432188, 0.6926644078328252, 0.6761705471469115, 0.6750801169759522, 0.7107154713544117, 0.11280726091997872, 0.14990310084078706, 0.11716515970936525, 0.17375662545567006, 0.11581471560540291, 0.11654934173384024, 0.15334450046710446, 0.1367564755545403, 0.1751322793473239, 0.1309869248901081, 0.08019682297581654, 0.08159813826904316, 0.11622758749088968, 0.08752939988083586, 0.11149498905136623, 0.10799755035880576, 0.10955044710843254, 0.08641729207825266, 0.9708692219458028, 0.9667808171505738, 0.9847111958231148, 0.9742109276992608, 0.9824609510827407, 0.9318470524813276, 0.972962133607663, 0.9678153301294881, 0.98001183043055, 0.6644005146208629, 0.6164589548497321, 0.5988607544661324, 0.6460802116591058, 0.5683804844033153, 0.6413891763048818, 0.6718105993889416, 0.662978770243428, 0.6637917641953792, 0.8631461965206533, 0.834965134560622, 0.8333845835448862, 0.8215513928566777, 0.8393546400398892, 0.810742148644888, 0.8155573573133998, 0.8520276264558081, 0.8179399729908562, 0.5430361047713153, 0.5407647547198869, 0.5229837920184303, 0.7064494485342285, 0.30395999831512144, 0.4929371399756364, 0.7200358227367496, 0.6995933894786901, 0.7138485334906719, 0.3934624811264268, 0.6178550862797754, 0.2935614984256807, 0.4151782922760565, 0.4684305746127003, 0.5126746109218145, 0.1292755597029358, 0.6040971730877445, 0.4019662370509861, 0.6632271431210652, 0.6374089975803579, 0.5903017869303712, 0.6547068485005222, 0.6373175317512322, 0.6204162537623149, 0.6451291322734933, 0.6430858856401165, 0.6227631199303731, 0.6845361695670651, 0.7444115406144316, 0.7244282984396979, 0.6538286356278642, 0.630920908387007, 0.687242335869835, 0.72040691917505, 0.6235349124157723, 0.71186062712095, 0.346148535171684, 0.16152243741803796, 0.10930147596268092, 0.5234088619052806, 0.5640840602968584, 0.529394562146946, 0.5825222801702339, 0.39811621879076786, 0.2632801412057154, 0.5301078307007202, 0.5230501090779807, 0.5661644204560079, 0.5235403616699046, 0.5296822125133402, 0.548201666973546, 0.5185163908872668, 0.5431783741049789, 0.5550814816075358, 0.7820111009530024, 0.7984873909755411, 0.7870629590788294, 0.7859973080451622, 0.7856634966776699, 0.793182295055188, 0.7894260665111976, 0.8130824516534698, 0.7914662408023037, 0.1123164396630304, 0.15296314454345827, 0.09121206909557589, 0.13975196995282735, 0.13212846934420963, 0.07788817461280995, 0.10579518348375583, 0.12962960698462977, 0.17800448177057693, 0.18074695094665272, 0.1699471633074653, 0.21678863631900225, 0.14721099818596162, 0.15388251326057856, 0.6769653056542609, 0.7309736449317874, 0.3682945211382427, 0.14974055620979654, 0.6246859438929224, 0.3308955545502362, 0.47857785127812336, 0.4938854319125078, 0.5204027925172513, 0.48853812216912407, 0.5922055357181633, 0.4675883709144695, 0.5633515376905147, 0.33753997917316014, 0.41491209359092796, 0.45214580666695525, 0.41245930980558976, 0.4586808271975772, 0.4533867067379981, 0.38770234829390526, 0.39933257808030465, 0.3686383348078205, 0.1918503700613391, 0.2468017000184135, 0.17066164439701093, 0.19223785013903583, 0.17966266775514927, 0.22437039011698734, 0.23126946245307212, 0.30879947664680296, 0.17060111220805318, 0.21572475570863925, 0.20250595062876986, 0.1872546488366047, 0.19468444486680825, 0.18826963750280523, 0.24263323206036924, 0.20163563480361968, 0.20223060095253065, 0.18687004690022735, 0.20522240045954376, 0.1822875306275692, 0.15335534276945362, 0.8888815309733564, 0.19839809865724212, 0.8644224386164968, 0.16056366009848866, 0.13985298212632313, 0.8513317655294668, 0.20754109080781413, 0.20894299150187956, 0.12591863810427661, 0.8059229919185114, 0.7787581998398068, 0.8542937323738822, 0.7919323526971215, 0.806800295908955, 0.8135132392133783, 0.1601713750395748, 0.2255802403101579, 0.16593918562580312, 0.17707217785610996, 0.17727283338566446, 0.1659447828883489, 0.1814702040474544, 0.15628265143200037, 0.1730527176201786, 0.07604949795107385, 0.07419486299491163, 0.07630533141778428, 0.08347159984163988, 0.062173940639105196, 0.09172891248448578, 0.08809795398566134, 0.09996858579258328, 0.10321248455585175]}, "mutation_prompt": null}
{"id": "e5479137-d301-4407-8245-d3ded26415f6", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce dynamic elitism\n            if budget_used % (self.budget // 20) == 0:  # Changed from 10 to 20\n                best_index = np.argmin(fitness)\n                elite = population[best_index]\n                population[np.random.choice(range(self.population_size), size=3, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.98  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a dynamic adjustment of the elitism frequency to improve convergence speed.", "configspace": "", "generation": 96, "fitness": 0.4112375454655119, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "9d9489f6-791c-441a-bc80-0cef6ab19bcc", "metadata": {"aucs": [0.7782842403861826, 0.7631302195138412, 0.7805248958859329, 0.7591863245770774, 0.7873922586980096, 0.7815884933186659, 0.7801963594677284, 0.7657465849712952, 0.7550072140203742, 0.6362675981624335, 0.614305635450128, 0.6059529395642422, 0.5916311346524805, 0.6254556181650288, 0.6173003578325972, 0.6033506990985682, 0.6431245338641163, 0.6417704830218266, 0.09948342565920887, 0.09429014460004614, 0.10779256592583097, 0.12010671923411043, 0.1029000767619691, 0.10196637079085136, 0.107914406254775, 0.11710335531545957, 0.10504942802945938, 0.1049563930503904, 0.1059503196459366, 0.08847165316171779, 0.10056180939079473, 0.11727618607346979, 0.09787914665240915, 0.09708123974243354, 0.08813797340408092, 0.10806366876898321, 0.8530950375586075, 0.8382822445246176, 0.8894320407132214, 0.9280178347617419, 0.9559755474216777, 0.8976334466654413, 0.9110809221399996, 0.9652082590706292, 0.899196734243468, 0.49859468785549943, 0.47059010161907633, 0.48322338311328616, 0.5024860321882405, 0.468718317535062, 0.4553128640310147, 0.5038388990675096, 0.4747296138762709, 0.44604329967666523, 0.7684311970125847, 0.7744229934769757, 0.7405908494358941, 0.8347210023551763, 0.8132310386012763, 0.7595832859493236, 0.7798804712517706, 0.7935413166059845, 0.7653538802171891, 0.44544282177006533, 0.3914646771677608, 0.3960998243540448, 0.4928388197821122, 0.12327149239434076, 0.434209995449372, 0.35919528537252576, 0.2731586591898767, 0.3825619400206386, 0.23473583892639205, 0.20674088070416619, 0.5029544589452928, 0.5195563366991909, 0.2820914107384851, 0.35640158802418687, 0.3231995115747307, 0.5152781124817017, 0.31016827360712074, 0.5557744321687945, 0.5122060621352467, 0.5244281298631298, 0.5096201696962768, 0.5469018384070279, 0.5444937314508806, 0.5346942541868032, 0.5346549155061373, 0.4738374836996223, 0.6484811189496688, 0.641181679018102, 0.6054832737178126, 0.6348940554688117, 0.626599077676983, 0.559212985335964, 0.6390541720680005, 0.6631690855246812, 0.6704294472798693, 0.2894874473578457, 0.13615362518067542, 0.29911439218708624, 0.2962774555412485, 0.30483246202000536, 0.3296140486807134, 0.20050449250533708, 0.22306144108550985, 0.12849234447359925, 0.37027732282525194, 0.38052916311594265, 0.3832988694671712, 0.39056229361533445, 0.3838976883163304, 0.40595987913457054, 0.397690142576515, 0.391400764390353, 0.37894068475272114, 0.7248207737681862, 0.7535256740738334, 0.722571073058043, 0.7111389473639967, 0.7167944098815209, 0.7268552664693169, 0.7432895394863304, 0.7110030335426424, 0.6950376185820271, 0.10731737101135297, 0.10711230298166141, 0.09205850846370645, 0.10465100347986955, 0.10396993483643036, 0.11353438470801669, 0.10009799608736047, 0.1013490075667256, 0.10756886133934951, 0.44458483098183, 0.3114658571505625, 0.3208665681049895, 0.24701428029737527, 0.15391790377286363, 0.14596957068152028, 0.15047818048061345, 0.17121741995362993, 0.1651398332170162, 0.43835554277205724, 0.42907745431386846, 0.4205718952360443, 0.39282799755488496, 0.42496727084597086, 0.40338704098441025, 0.40223108465633184, 0.4134061430707541, 0.45090193167480097, 0.308409117400526, 0.33834410168120366, 0.34485813788732145, 0.3293485823462282, 0.3630920809165581, 0.33081123794105993, 0.33505302000830606, 0.3581751448123337, 0.34531711545218846, 0.21251648546904633, 0.2013938572101739, 0.20388718900054092, 0.19276054194371905, 0.18993773093366995, 0.21184773419127645, 0.21458952944336163, 0.18442097026034054, 0.1896497043150116, 0.2088636534990167, 0.1844184285220961, 0.23385651618886527, 0.2134369976645476, 0.19845686213837932, 0.2794162858670677, 0.18840850069370585, 0.18621203796666863, 0.1924855718757703, 0.16532284614485326, 0.7758834052363195, 0.17928330249986812, 0.7933340476303852, 0.6738538052161784, 0.7901574254374634, 0.7356609764158781, 0.6061344752649725, 0.7522105900222607, 0.12774141122863036, 0.66013914859213, 0.7420550880144079, 0.19844593725843263, 0.19712035902286296, 0.7772293450061812, 0.722758106932698, 0.7860492509258475, 0.20212790274307713, 0.17659039028012558, 0.17565443591698116, 0.18561424505708224, 0.19217873403027452, 0.18719379275549552, 0.19053755202383005, 0.17702709081385182, 0.16990447390963326, 0.17616669630703452, 0.07943852072371482, 0.08046067179336658, 0.0862272137212583, 0.07465567101076653, 0.07585864628322181, 0.07916246171949226, 0.07583119013332273, 0.0799829202621406, 0.07927791147496299]}, "mutation_prompt": null}
{"id": "9ce343f4-cf31-4482-99b9-02dd3b11b473", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism with frequent updates\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=3, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.98  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a more frequent adaptive elitism strategy for improved convergence.", "configspace": "", "generation": 97, "fitness": 0.47964731355120094, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "9d9489f6-791c-441a-bc80-0cef6ab19bcc", "metadata": {"aucs": [0.8312301714735637, 0.824865152348608, 0.8368828760568804, 0.8295220017215044, 0.8557599631888575, 0.8548140492532639, 0.8360416631178329, 0.824087869895659, 0.8180114591636072, 0.7232623197904319, 0.70901309246491, 0.6967628674846342, 0.7126640927463048, 0.718002480847266, 0.697294533677216, 0.7191422059909133, 0.7277988636813292, 0.7010157556319399, 0.17366426115821376, 0.12225110935641992, 0.11257439668071967, 0.12160054159166211, 0.1467176411983473, 0.11350808950902469, 0.12394767754668534, 0.15649916954167953, 0.10719807920969959, 0.13407229090622763, 0.16009513254179708, 0.11281539817352004, 0.13389141596152565, 0.11817934504017591, 0.11389309206044529, 0.08898275053463023, 0.1093210389095115, 0.10492295292272558, 0.9104079351678991, 0.92651732045382, 0.9575710362775344, 0.9500270734299489, 0.9658972820088563, 0.9207257407669343, 0.9542703338432664, 0.9861378430788528, 0.9532821833663372, 0.6695218029308256, 0.698047215399191, 0.6454889233560964, 0.6360318244390837, 0.6495394905579042, 0.7242173725318735, 0.6750159704949852, 0.6897049936315858, 0.6797699252728642, 0.8747423357457295, 0.8428367744858858, 0.85891286383513, 0.8503896460842064, 0.8396913002467835, 0.8310415875085562, 0.8477543413572811, 0.8671425092397118, 0.8377867004862083, 0.12786700332448342, 0.4860779685195439, 0.6749515709062687, 0.7175334227238004, 0.44929479111876613, 0.5992432325325086, 0.4928588140916844, 0.5254156778918642, 0.595013577864627, 0.571014340325015, 0.42931022079305947, 0.500826222238369, 0.4920496938687876, 0.1250928817685666, 0.5166277369538513, 0.5065997305226839, 0.6067608049994082, 0.5043843180506918, 0.6723341958801015, 0.6144814384546802, 0.6405501214988336, 0.5656841143705273, 0.6860914182285133, 0.6270575121196069, 0.6109123274684978, 0.6794773724302724, 0.6867962344395036, 0.7652825858475027, 0.7105747644591381, 0.7085208024034495, 0.7375027621009537, 0.7427915036240547, 0.7311091995602134, 0.765957699167796, 0.738660280022475, 0.7385438846894364, 0.23522644636072587, 0.16925191197448763, 0.06678662649076472, 0.4007074703778096, 0.575182301811324, 0.2291447558395726, 0.2617144413849313, 0.14969166025894243, 0.1944195247123195, 0.5792020788098253, 0.5453672547706452, 0.5369864432124491, 0.5152403517107024, 0.5719669417842775, 0.5391469229999879, 0.5590857086709766, 0.5306143667512787, 0.5526630257596408, 0.7794697637070163, 0.8124237973246244, 0.8100708524753537, 0.7917043569537358, 0.8015079003058402, 0.8092490691681576, 0.8197611074624108, 0.7946413563509357, 0.7973135425241318, 0.13484097909184534, 0.10473786368677884, 0.1753436198867674, 0.09764818694210187, 0.10292422142772628, 0.14034951530438544, 0.13582862812231955, 0.10793819927909698, 0.08407022276906229, 0.38021127145858147, 0.1823230108887688, 0.2701839388801627, 0.27747908164404744, 0.7778586358322147, 0.17367135866065286, 0.7350192747175425, 0.280115878050595, 0.2831279070677578, 0.5990724199379382, 0.5129741783181896, 0.48055392910972927, 0.6394394118081204, 0.6619294442107226, 0.6774731377784744, 0.5199469479657169, 0.6649854706401915, 0.4389374869871294, 0.4821278743768098, 0.5915933809535556, 0.561572922134574, 0.5011266753812835, 0.4460607685745728, 0.5136449668878709, 0.48312049505425314, 0.5135218616081629, 0.3607329771619435, 0.16950237322396045, 0.19206582218995538, 0.1834276784220943, 0.18609267857034817, 0.19083635898501128, 0.20416319946503558, 0.17960336375326968, 0.1696018419172024, 0.1852006106363665, 0.19254874495378416, 0.19517394758408324, 0.18248008094360835, 0.21736442356499674, 0.23891321858652415, 0.2044619505063321, 0.24069588547813592, 0.2075073116642664, 0.7582964385330095, 0.1677620746861208, 0.2087222431940079, 0.17686982045750976, 0.8902104002596523, 0.879524209538402, 0.8864302387612817, 0.14198782112725616, 0.8724557895742909, 0.8703149389874729, 0.8497718581755251, 0.2104275369926636, 0.8648826721425736, 0.20573265295306442, 0.8104661204830041, 0.16397752830784207, 0.2116329265057526, 0.20666913743637538, 0.20800229928347835, 0.16863441995362227, 0.16294528853295054, 0.17002219465710589, 0.16244877477985886, 0.15227017587541158, 0.26056604120000293, 0.16770695421410642, 0.16993946571552154, 0.18314508853703437, 0.08926456382082126, 0.07809493201362383, 0.09616815779240895, 0.07902057461089862, 0.09676198016852011, 0.08976546060122637, 0.0949173852894335, 0.09746861803420126, 0.08384897823126358]}, "mutation_prompt": null}
{"id": "46bb03ea-10b0-4a40-a24b-3966d5d9c9ac", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=3, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.35 + np.random.rand() * 0.6  # Adjusted mutation factor range, slight increase\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        self.crossover_probability = 0.9 + 0.1 * np.random.rand()\n        self.mutation_factor *= 0.98  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Slightly enhance mutation factor adaptation for improved convergence stability.", "configspace": "", "generation": 98, "fitness": 0.4789715917908244, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "9d9489f6-791c-441a-bc80-0cef6ab19bcc", "metadata": {"aucs": [0.8055393446201573, 0.8341380739853286, 0.8296399876560677, 0.8208252648933869, 0.8431827643898413, 0.8105190487669431, 0.8282623940198962, 0.8351002454695361, 0.8257217645147449, 0.6945209787924211, 0.6976551367448738, 0.6775795902892348, 0.6816044736933028, 0.691830337421981, 0.6743786132179216, 0.6780744498382457, 0.6895801810078881, 0.7013991478486432, 0.17180081457756657, 0.15188595557237972, 0.1125294988501162, 0.12790280131914789, 0.1142470554368723, 0.6132903889377854, 0.13657316281025655, 0.10646282900650927, 0.1386718823667894, 0.12117488429742895, 0.12216528222756551, 0.14758206178689814, 0.13917256554011725, 0.13574048985242793, 0.14639504680481952, 0.1093558377788546, 0.10496654813066675, 0.0811265718162747, 0.9617533989154597, 0.9143773299547713, 0.9779254194746213, 0.9736860457147941, 0.9581818811762368, 0.9612973785234638, 0.9377452698083667, 0.9862022253300549, 0.9681906363135008, 0.6264938825326509, 0.6314345103321246, 0.6573247570408474, 0.6254446892926845, 0.6375222083409329, 0.6079472963260582, 0.6413332741031883, 0.6828664800372781, 0.6575612492667611, 0.8454658141760883, 0.8530255620782676, 0.8490975708287185, 0.8531569515540729, 0.8533493754923477, 0.8669910176715188, 0.8562082242500162, 0.8596966623054745, 0.8248655131436003, 0.4936499512984799, 0.44898766258892886, 0.540213153491359, 0.47869248984236334, 0.4554313564355652, 0.4884898508484713, 0.5306613149151291, 0.6413805785797875, 0.6190987534070421, 0.5346200481611183, 0.5244610380161594, 0.12860541923784896, 0.6475150089714616, 0.13168181184371264, 0.4465678052680774, 0.5422113397512119, 0.6192087303758207, 0.5113969443276718, 0.6651518116039665, 0.5876177068507424, 0.6524905943077274, 0.5602564137029264, 0.6150168310972706, 0.6201183857674912, 0.6609654797423086, 0.6570337337520031, 0.648391089532972, 0.7038185033540811, 0.7049269022339607, 0.726726799229493, 0.7229265026334124, 0.7018650067358673, 0.70081423922896, 0.7121454944438178, 0.6906181043162843, 0.738693211671449, 0.38739948532961266, 0.10019689010793098, 0.3793052690517821, 0.5404186157109698, 0.5159767013121364, 0.5587999388292031, 0.15935147701578667, 0.3370610869390325, 0.3296613459832727, 0.5198203385589313, 0.49870116282271104, 0.4819304228158041, 0.5271554299700181, 0.5148280314475313, 0.5370731798329691, 0.48639888669732734, 0.544240715844589, 0.5239262164852494, 0.801155364232629, 0.7860459342602091, 0.7867270662680248, 0.7585213493047758, 0.8010440567410897, 0.807378314179383, 0.7998067457749085, 0.7848667534529452, 0.8113015594715134, 0.1409067139455228, 0.10161784257668682, 0.10661054210451826, 0.17900070145267344, 0.17348460977856162, 0.12722256204423288, 0.10656950576894175, 0.10889525160227154, 0.09026477217168571, 0.23223119200715947, 0.6912304045828241, 0.16595672076695622, 0.1857687928039219, 0.22903194029026985, 0.7249503016484764, 0.1874404255969131, 0.17529555966018828, 0.35917874337996747, 0.5769259869487253, 0.60634535618823, 0.5739814210870289, 0.5757555372001824, 0.5891292030074592, 0.5229132416938193, 0.5075875542631583, 0.46025062471533573, 0.5747194196749796, 0.4242884411020271, 0.3285939016055086, 0.44714567589544774, 0.48250564914334704, 0.46489967771113827, 0.4559622151529066, 0.5258274483267344, 0.35811226517019745, 0.4029201661405212, 0.18602665968622656, 0.18806004347406768, 0.17205467738880564, 0.18892496883069776, 0.1684279174586829, 0.16151804418340598, 0.22183138286280535, 0.20682687534714495, 0.17404422418467713, 0.211480137267392, 0.19840652380910284, 0.19547699372407645, 0.2228890857241883, 0.241313487489081, 0.20670087221684375, 0.22102763801558523, 0.23968922512299484, 0.17843170539068165, 0.8435046656234177, 0.18473176843124794, 0.17748707036234768, 0.8671705581996884, 0.8696605898009444, 0.8879664508719068, 0.21071054634595232, 0.8377310812795505, 0.8042197229614951, 0.8573016560723584, 0.20918846625860055, 0.8536357259435327, 0.8690232689441546, 0.126311452052135, 0.8426650605069089, 0.21108565273623758, 0.21053416095764377, 0.20996584859655187, 0.16823560908837476, 0.1636523945187781, 0.1797422094589669, 0.19148608806169243, 0.17997815774072345, 0.17498831444523677, 0.24555223799831294, 0.16904326316865137, 0.17099901178153054, 0.0856076526318631, 0.09340035627158161, 0.07897897308424329, 0.09915752679778889, 0.08890929978671325, 0.08539256438005527, 0.08057260258107668, 0.09084480373545556, 0.09049568168530442]}, "mutation_prompt": null}
{"id": "96c360f0-569a-4082-b8a8-1e2e2b05b66c", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.95\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            self.local_search_probability *= 0.99  # Slight decrease over iterations\n            if budget_used % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))  # Adjust population size\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    candidate = self.local_search(population[i], func, population[np.argmin(fitness)])\n                else:\n                    candidate = self.mutate_and_crossover(population, i, fitness)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                prev_best_fitness = current_best_fitness\n                self.adapt_parameters()\n\n            # Introduce elitism\n            best_index = np.argmin(fitness)\n            elite = population[best_index]\n            population[np.random.choice(range(self.population_size), size=3, replace=False)] = elite\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def mutate_and_crossover(self, population, index, fitness):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = np.random.choice(indices, size=3, replace=False)\n        self.mutation_factor = 0.3 + np.random.rand() * 0.6  # Adjusted mutation factor range\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        trial = np.copy(population[index])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_probability or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, target, func, best):\n        step_size = 0.2 * (self.upper_bound - self.lower_bound) * np.random.rand()  # Enhanced step size\n        direction = np.random.uniform(-1, 1, self.dim)\n        candidate = target + step_size * direction + 0.1 * (best - target)  # Added bias towards best\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adapt_parameters(self):\n        improvement_rate = np.random.rand()  # Introduced dynamic adjustment\n        self.crossover_probability = 0.9 + 0.1 * improvement_rate\n        self.mutation_factor *= 0.98  # Slightly adjusted adaptation rate", "name": "HybridDE", "description": "Introduce a dynamic adjustment to the crossover probability to balance exploration and exploitation based on fitness improvement rate.", "configspace": "", "generation": 99, "fitness": 0.47964731355120094, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "9d9489f6-791c-441a-bc80-0cef6ab19bcc", "metadata": {"aucs": [0.8312301714735637, 0.824865152348608, 0.8368828760568804, 0.8295220017215044, 0.8557599631888575, 0.8548140492532639, 0.8360416631178329, 0.824087869895659, 0.8180114591636072, 0.7232623197904319, 0.70901309246491, 0.6967628674846342, 0.7126640927463048, 0.718002480847266, 0.697294533677216, 0.7191422059909133, 0.7277988636813292, 0.7010157556319399, 0.17366426115821376, 0.12225110935641992, 0.11257439668071967, 0.12160054159166211, 0.1467176411983473, 0.11350808950902469, 0.12394767754668534, 0.15649916954167953, 0.10719807920969959, 0.13407229090622763, 0.16009513254179708, 0.11281539817352004, 0.13389141596152565, 0.11817934504017591, 0.11389309206044529, 0.08898275053463023, 0.1093210389095115, 0.10492295292272558, 0.9104079351678991, 0.92651732045382, 0.9575710362775344, 0.9500270734299489, 0.9658972820088563, 0.9207257407669343, 0.9542703338432664, 0.9861378430788528, 0.9532821833663372, 0.6695218029308256, 0.698047215399191, 0.6454889233560964, 0.6360318244390837, 0.6495394905579042, 0.7242173725318735, 0.6750159704949852, 0.6897049936315858, 0.6797699252728642, 0.8747423357457295, 0.8428367744858858, 0.85891286383513, 0.8503896460842064, 0.8396913002467835, 0.8310415875085562, 0.8477543413572811, 0.8671425092397118, 0.8377867004862083, 0.12786700332448342, 0.4860779685195439, 0.6749515709062687, 0.7175334227238004, 0.44929479111876613, 0.5992432325325086, 0.4928588140916844, 0.5254156778918642, 0.595013577864627, 0.571014340325015, 0.42931022079305947, 0.500826222238369, 0.4920496938687876, 0.1250928817685666, 0.5166277369538513, 0.5065997305226839, 0.6067608049994082, 0.5043843180506918, 0.6723341958801015, 0.6144814384546802, 0.6405501214988336, 0.5656841143705273, 0.6860914182285133, 0.6270575121196069, 0.6109123274684978, 0.6794773724302724, 0.6867962344395036, 0.7652825858475027, 0.7105747644591381, 0.7085208024034495, 0.7375027621009537, 0.7427915036240547, 0.7311091995602134, 0.765957699167796, 0.738660280022475, 0.7385438846894364, 0.23522644636072587, 0.16925191197448763, 0.06678662649076472, 0.4007074703778096, 0.575182301811324, 0.2291447558395726, 0.2617144413849313, 0.14969166025894243, 0.1944195247123195, 0.5792020788098253, 0.5453672547706452, 0.5369864432124491, 0.5152403517107024, 0.5719669417842775, 0.5391469229999879, 0.5590857086709766, 0.5306143667512787, 0.5526630257596408, 0.7794697637070163, 0.8124237973246244, 0.8100708524753537, 0.7917043569537358, 0.8015079003058402, 0.8092490691681576, 0.8197611074624108, 0.7946413563509357, 0.7973135425241318, 0.13484097909184534, 0.10473786368677884, 0.1753436198867674, 0.09764818694210187, 0.10292422142772628, 0.14034951530438544, 0.13582862812231955, 0.10793819927909698, 0.08407022276906229, 0.38021127145858147, 0.1823230108887688, 0.2701839388801627, 0.27747908164404744, 0.7778586358322147, 0.17367135866065286, 0.7350192747175425, 0.280115878050595, 0.2831279070677578, 0.5990724199379382, 0.5129741783181896, 0.48055392910972927, 0.6394394118081204, 0.6619294442107226, 0.6774731377784744, 0.5199469479657169, 0.6649854706401915, 0.4389374869871294, 0.4821278743768098, 0.5915933809535556, 0.561572922134574, 0.5011266753812835, 0.4460607685745728, 0.5136449668878709, 0.48312049505425314, 0.5135218616081629, 0.3607329771619435, 0.16950237322396045, 0.19206582218995538, 0.1834276784220943, 0.18609267857034817, 0.19083635898501128, 0.20416319946503558, 0.17960336375326968, 0.1696018419172024, 0.1852006106363665, 0.19254874495378416, 0.19517394758408324, 0.18248008094360835, 0.21736442356499674, 0.23891321858652415, 0.2044619505063321, 0.24069588547813592, 0.2075073116642664, 0.7582964385330095, 0.1677620746861208, 0.2087222431940079, 0.17686982045750976, 0.8902104002596523, 0.879524209538402, 0.8864302387612817, 0.14198782112725616, 0.8724557895742909, 0.8703149389874729, 0.8497718581755251, 0.2104275369926636, 0.8648826721425736, 0.20573265295306442, 0.8104661204830041, 0.16397752830784207, 0.2116329265057526, 0.20666913743637538, 0.20800229928347835, 0.16863441995362227, 0.16294528853295054, 0.17002219465710589, 0.16244877477985886, 0.15227017587541158, 0.26056604120000293, 0.16770695421410642, 0.16993946571552154, 0.18314508853703437, 0.08926456382082126, 0.07809493201362383, 0.09616815779240895, 0.07902057461089862, 0.09676198016852011, 0.08976546060122637, 0.0949173852894335, 0.09746861803420126, 0.08384897823126358]}, "mutation_prompt": null}
