{"id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "A novel hybrid metaheuristic that combines Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to balance exploration and exploitation in search space, efficiently optimizing black box functions.", "configspace": "", "generation": 0, "fitness": 0.8749174473540576, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.001. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8751349940097473, 0.8765864638805541, 0.8730308841718715], "final_y": [0.12034419948482689, 0.11817108597419124, 0.12148201888883736]}, "mutation_prompt": null}
{"id": "47245ce8-4e41-437d-bd63-a632e9324a0e", "solution": "import numpy as np\n\nclass HybridDEARS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        np.random.seed(0)  # For reproducibility\n\n        pop_size = 10 * self.dim\n        mutation_factor = 0.8\n        crossover_probability = 0.9\n        adaptive_threshold = 0.1  # Start with a small exploration\n\n        # Initialize the population within bounds\n        pop = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(fitness)\n        best_solution = pop[best_idx]\n        best_fitness = fitness[best_idx]\n        eval_count = pop_size\n\n        while eval_count < self.budget:\n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select three distinct candidates from the population\n                candidates = list(range(pop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(pop[a] + mutation_factor * (pop[b] - pop[c]), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Fitness evaluation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Random Search\n            if eval_count < self.budget and np.random.rand() < adaptive_threshold:\n                for i in range(pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    random_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                    random_fitness = func(random_solution)\n                    eval_count += 1\n\n                    if random_fitness < fitness[i]:\n                        pop[i] = random_solution\n                        fitness[i] = random_fitness\n                        if random_fitness < best_fitness:\n                            best_solution = random_solution\n                            best_fitness = random_fitness\n\n            # Adapt exploration rate over time\n            adaptive_threshold = max(0.01, adaptive_threshold * 0.95)\n\n        return best_solution, best_fitness", "name": "HybridDEARS", "description": "A hybrid metaheuristic combining Differential Evolution with Adaptive Random Search to efficiently explore and exploit the search space for complex and high-dimensional black box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.7821586627336569, "feedback": "The algorithm HybridDEARS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.782 with standard deviation 0.009. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7936576412599575, 0.7720182345085549, 0.7808001124324583], "final_y": [0.147134240983383, 0.1577050398640203, 0.15439566567342622]}, "mutation_prompt": null}
{"id": "dc774dcd-ffcf-40cc-8376-c62880d0b5ae", "solution": "import numpy as np\n\nclass HybridDEARS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        np.random.seed(0)  # For reproducibility\n\n        pop_size = 10 * self.dim\n        mutation_factor = 0.8\n        crossover_probability = 0.95  # Increased crossover probability for better exploration\n        adaptive_threshold = 0.1  # Start with a small exploration\n\n        # Initialize the population within bounds\n        pop = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(fitness)\n        best_solution = pop[best_idx]\n        best_fitness = fitness[best_idx]\n        eval_count = pop_size\n\n        while eval_count < self.budget:\n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select three distinct candidates from the population\n                candidates = list(range(pop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(pop[a] + mutation_factor * (pop[b] - pop[c]), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Fitness evaluation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Random Search\n            if eval_count < self.budget and np.random.rand() < adaptive_threshold:\n                for i in range(pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    random_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                    random_fitness = func(random_solution)\n                    eval_count += 1\n\n                    if random_fitness < fitness[i]:\n                        pop[i] = random_solution\n                        fitness[i] = random_fitness\n                        if random_fitness < best_fitness:\n                            best_solution = random_solution\n                            best_fitness = random_fitness\n\n            # Adapt exploration rate over time\n            adaptive_threshold = max(0.01, adaptive_threshold * 0.95)\n\n        return best_solution, best_fitness", "name": "HybridDEARS", "description": "Enhanced the crossover probability to improve exploration with minimal code change.  ", "configspace": "", "generation": 1, "fitness": 0.7726473963682353, "feedback": "The algorithm HybridDEARS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.773 with standard deviation 0.004. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "47245ce8-4e41-437d-bd63-a632e9324a0e", "metadata": {"aucs": [0.7784060948150195, 0.7702450252174777, 0.7692910690722089], "final_y": [0.15453858372077156, 0.1596781865006216, 0.15023169193381392]}, "mutation_prompt": null}
{"id": "cbf0bdb4-97e5-4e40-9ca4-173356cee0b3", "solution": "import numpy as np\n\nclass HybridDEARS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        np.random.seed(0)  # For reproducibility\n\n        pop_size = 10 * self.dim\n        mutation_factor = 0.9  # Adjusted for better exploration\n        crossover_probability = 0.85  # Adjusted for better exploitation\n        adaptive_threshold = 0.1  # Start with a small exploration\n\n        # Initialize the population within bounds\n        pop = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(fitness)\n        best_solution = pop[best_idx]\n        best_fitness = fitness[best_idx]\n        eval_count = pop_size\n\n        while eval_count < self.budget:\n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select three distinct candidates from the population\n                candidates = list(range(pop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(pop[a] + mutation_factor * (pop[b] - pop[c]), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Fitness evaluation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Random Search\n            if eval_count < self.budget and np.random.rand() < adaptive_threshold:\n                for i in range(pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    random_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                    random_fitness = func(random_solution)\n                    eval_count += 1\n\n                    if random_fitness < fitness[i]:\n                        pop[i] = random_solution\n                        fitness[i] = random_fitness\n                        if random_fitness < best_fitness:\n                            best_solution = random_solution\n                            best_fitness = random_fitness\n\n            # Adapt exploration rate over time\n            adaptive_threshold = max(0.01, adaptive_threshold * 0.95)\n\n        return best_solution, best_fitness", "name": "HybridDEARS", "description": "Enhanced HybridDEARS with dynamic mutation and crossover rates for improved adaptive exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 1, "fitness": 0.7845642597184898, "feedback": "The algorithm HybridDEARS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.014. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "47245ce8-4e41-437d-bd63-a632e9324a0e", "metadata": {"aucs": [0.8044159827534308, 0.7750695046893348, 0.7742072917127034], "final_y": [0.1389110432376257, 0.15560631455936924, 0.15671956991755154]}, "mutation_prompt": null}
{"id": "4a3ebbda-2025-4aa8-8580-da028ec33cc9", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.9  # Modified line: Start with a higher inertia weight\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Modified line: Decrease inertia weight over time\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA with dynamic inertia weight to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.8663205987614924, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.015. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.885789169097066, 0.8489770740737121, 0.8641955531136988], "final_y": [0.11692227647250053, 0.13231634339813214, 0.11524170589521687]}, "mutation_prompt": null}
{"id": "3b3e5fc6-5c22-43f8-9706-33f9b45e6fc2", "solution": "import numpy as np\n\nclass HybridDEARS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        np.random.seed(0)  # For reproducibility\n\n        pop_size = 10 * self.dim\n        mutation_factor = 0.85  # Increased mutation factor for better exploration\n        crossover_probability = 0.9\n        adaptive_threshold = 0.1  # Start with a small exploration\n\n        # Initialize the population within bounds\n        pop = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(fitness)\n        best_solution = pop[best_idx]\n        best_fitness = fitness[best_idx]\n        eval_count = pop_size\n\n        while eval_count < self.budget:\n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select three distinct candidates from the population\n                candidates = list(range(pop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(pop[a] + mutation_factor * (pop[b] - pop[c]), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Fitness evaluation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Random Search\n            if eval_count < self.budget and np.random.rand() < adaptive_threshold:\n                for i in range(pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    random_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                    random_fitness = func(random_solution)\n                    eval_count += 1\n\n                    if random_fitness < fitness[i]:\n                        pop[i] = random_solution\n                        fitness[i] = random_fitness\n                        if random_fitness < best_fitness:\n                            best_solution = random_solution\n                            best_fitness = random_fitness\n\n            # Adapt exploration rate over time\n            adaptive_threshold = max(0.01, adaptive_threshold * 0.95)\n\n        return best_solution, best_fitness", "name": "HybridDEARS", "description": "An enhanced HybridDEARS algorithm with increased mutation factor to improve exploration capabilities and solution diversity.", "configspace": "", "generation": 1, "fitness": 0.7711136308935805, "feedback": "The algorithm HybridDEARS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.771 with standard deviation 0.009. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "47245ce8-4e41-437d-bd63-a632e9324a0e", "metadata": {"aucs": [0.7582925820327071, 0.7766625148690287, 0.7783857957790057], "final_y": [0.15832824937723278, 0.15671541198325944, 0.12719367223381983]}, "mutation_prompt": null}
{"id": "e700e98c-c052-4ba4-ba19-45dc7e1bb2fc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for adaptive adjustment\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhancing the PSO and SA hybrid by introducing adaptive inertia weight to dynamically balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.8421382872131521, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.019. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.8670008832003372, 0.8398428104515039, 0.8195711679876153], "final_y": [0.12895099504516938, 0.13160909498893958, 0.13635262130521697]}, "mutation_prompt": null}
{"id": "8fd8ab84-a033-4ce0-b5cb-dd07c91b1f63", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - (0.5 / self.budget) * evaluations\n                \n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with dynamic inertia weight adjustment for improved convergence efficiency by fostering better balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.8685415949532023, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.023. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.8949493855691008, 0.839806227919062, 0.8708691713714442], "final_y": [0.12054513206741435, 0.1328514502031084, 0.12054665381403673]}, "mutation_prompt": null}
{"id": "6e276e1e-a072-4efa-84c6-09f81fb4fb9f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.8  # Increased social weight from 1.5 to 1.8\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with increased social weight to improve exploration in search space, optimizing black box functions.", "configspace": "", "generation": 1, "fitness": 0.8662150025119847, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.010. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.8798960897546326, 0.8634687236947591, 0.8552801940865622], "final_y": [0.12043123581289616, 0.11967435761123191, 0.11926220318927538]}, "mutation_prompt": null}
{"id": "e2ad4db8-2eec-4796-890e-45f257969736", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA using adaptive inertia weight for improved convergence control and dynamic movement adjustments.", "configspace": "", "generation": 1, "fitness": 0.8766755595870895, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.019. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.8946206544686819, 0.8504778080450048, 0.8849282162475819], "final_y": [0.11787801961603539, 0.1245365553112413, 0.1125854151701382]}, "mutation_prompt": null}
{"id": "0f6836fa-9dd5-48fc-a8c1-9e391807d850", "solution": "import numpy as np\n\nclass HybridDEARS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        np.random.seed(0)  # For reproducibility\n\n        pop_size = 10 * self.dim\n        mutation_factor = 0.8\n        crossover_probability = 0.9\n        adaptive_threshold = 0.1  # Start with a small exploration\n\n        # Initialize the population within bounds\n        pop = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(fitness)\n        best_solution = pop[best_idx]\n        best_fitness = fitness[best_idx]\n        eval_count = pop_size\n\n        while eval_count < self.budget:\n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Tournament selection for better candidate selection\n                candidates = np.random.choice(range(pop_size), 5, replace=False)\n                a, b, c = sorted(candidates, key=lambda idx: fitness[idx])[:3]\n\n                # Mutation\n                mutant = np.clip(pop[a] + mutation_factor * (pop[b] - pop[c]), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Fitness evaluation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Random Search\n            if eval_count < self.budget and np.random.rand() < adaptive_threshold:\n                for i in range(pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    random_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                    random_fitness = func(random_solution)\n                    eval_count += 1\n\n                    if random_fitness < fitness[i]:\n                        pop[i] = random_solution\n                        fitness[i] = random_fitness\n                        if random_fitness < best_fitness:\n                            best_solution = random_solution\n                            best_fitness = random_fitness\n\n            # Adapt exploration rate over time\n            adaptive_threshold = max(0.01, adaptive_threshold * 0.95)\n\n        return best_solution, best_fitness", "name": "HybridDEARS", "description": "Introduce tournament selection to improve candidate selection in Differential Evolution, enhancing convergence speed.", "configspace": "", "generation": 1, "fitness": 0.7945106210170456, "feedback": "The algorithm HybridDEARS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.795 with standard deviation 0.005. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "47245ce8-4e41-437d-bd63-a632e9324a0e", "metadata": {"aucs": [0.7881316412136716, 0.795168134094818, 0.8002320877426474], "final_y": [0.1452277684364729, 0.1429019695970325, 0.14761977956086325]}, "mutation_prompt": null}
{"id": "029a0304-2dfe-4fef-aa82-21a10db6ef4e", "solution": "import numpy as np\n\nclass HybridDEARS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        np.random.seed(0)  # For reproducibility\n\n        pop_size = 10 * self.dim\n        mutation_factor = 0.8\n        crossover_probability = 0.9\n        adaptive_threshold = 0.1  # Start with a small exploration\n\n        # Initialize the population within bounds\n        pop = np.random.uniform(func.bounds.lb, func.bounds.ub, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(fitness)\n        best_solution = pop[best_idx]\n        best_fitness = fitness[best_idx]\n        eval_count = pop_size\n\n        while eval_count < self.budget:\n            # Self-adaptive mutation factor\n            mutation_factor = 0.5 + 0.5 * np.random.rand()\n\n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select three distinct candidates from the population\n                candidates = list(range(pop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(pop[a] + mutation_factor * (pop[b] - pop[c]), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Fitness evaluation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Random Search\n            if eval_count < self.budget and np.random.rand() < adaptive_threshold:\n                for i in range(pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    random_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                    random_fitness = func(random_solution)\n                    eval_count += 1\n\n                    if random_fitness < fitness[i]:\n                        pop[i] = random_solution\n                        fitness[i] = random_fitness\n                        if random_fitness < best_fitness:\n                            best_solution = random_solution\n                            best_fitness = random_fitness\n\n            # Adapt exploration rate over time\n            adaptive_threshold = max(0.01, adaptive_threshold * 0.95)\n\n        return best_solution, best_fitness", "name": "HybridDEARS", "description": "An improved Hybrid Differential Evolution and Adaptive Random Search algorithm that incorporates self-adaptive parameters to enhance convergence and exploration capabilities for black box optimization problems within a limited budget.", "configspace": "", "generation": 1, "fitness": 0.7705695650778205, "feedback": "The algorithm HybridDEARS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.771 with standard deviation 0.007. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "47245ce8-4e41-437d-bd63-a632e9324a0e", "metadata": {"aucs": [0.7608187080366952, 0.7757751804191186, 0.7751148067776478], "final_y": [0.15165108493002877, 0.14474160860330065, 0.15827765237935976]}, "mutation_prompt": null}
{"id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with dynamic social and cognitive weights for improved exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8814515781361424, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.010. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8895759504774081, 0.8680377589158362, 0.8867410250151828], "final_y": [0.11915308586685436, 0.1172677481462967, 0.11863506951409153]}, "mutation_prompt": null}
{"id": "682c3124-c933-4c5f-803d-2391931a8e72", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + 0.5 * (evaluations / self.budget)  # Adaptive cognitive weight\n                self.social_weight = 1.5 - 0.5 * (evaluations / self.budget)  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Further enhanced HybridPSO_SA with adaptive social and cognitive weights to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8712243113471638, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.004. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8738649469696231, 0.8655045997881534, 0.8743033872837151], "final_y": [0.12046290380921354, 0.12001322246999935, 0.12276194547547425]}, "mutation_prompt": null}
{"id": "57864f62-1fdc-452f-adcb-c021cd233902", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n            \n            # Added line for chaotic map\n            global_best_position += 0.1 * (np.sin(evaluations) - 0.5)\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by introducing chaotic maps for diversification and better escape from local optima.", "configspace": "", "generation": 2, "fitness": 0.8736684939878515, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.023. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8941283548414269, 0.8417648408319196, 0.885112286290208], "final_y": [0.1189579499497585, 0.1330680740916933, 0.11822541465517433]}, "mutation_prompt": null}
{"id": "efe61231-c650-4388-8384-457c299655f8", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment with hybrid mutation\n            gaussian_mutation = np.random.normal(0, 1, self.dim)\n            cauchy_mutation = np.random.standard_cauchy(self.dim) * 0.1\n            best_candidate = global_best_position + 0.5 * gaussian_mutation + 0.5 * cauchy_mutation\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with hybrid mutation strategy blending Gaussian and Cauchy distributions for improved exploration.", "configspace": "", "generation": 2, "fitness": 0.8811702764022175, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.016. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.9007130788405598, 0.8811311287808399, 0.8616666215852526], "final_y": [0.11148480447388331, 0.11820335274318206, 0.1176446723360165]}, "mutation_prompt": null}
{"id": "3432a208-7069-4a41-b950-527d0ac86867", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]) + np.random.normal(0, 0.1, self.dim))  # Added Gaussian noise\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with refined velocity update for better solution precision.", "configspace": "", "generation": 2, "fitness": 0.8597942033718816, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.012. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8765640362530813, 0.8514390848883071, 0.8513794889742563], "final_y": [0.12026915983077835, 0.1252515474522683, 0.12433888155426398]}, "mutation_prompt": null}
{"id": "937868ab-ac0d-4d67-b32d-d9c9b3f24c9b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget / 2:  # Dynamic population size adjustment\n                self.population_size = max(5, int(self.population_size * 0.9))\n            for i in range(self.population_size):\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA using adaptive cooling rate and dynamic population size adjustment for improved solution quality.", "configspace": "", "generation": 2, "fitness": 0.8672515711283836, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.023. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.894726275464936, 0.8395889335364225, 0.8674395043837924], "final_y": [0.11435408352849719, 0.13187051937500238, 0.12038483339386175]}, "mutation_prompt": null}
{"id": "bc4fae07-06e4-41a5-b8f7-8a6dd4424af7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                dynamic_adjustment = evaluations / self.budget  # Dynamic adjustment factor\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               (self.cognitive_weight + dynamic_adjustment) * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               (self.social_weight - dynamic_adjustment) * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by integrating a dynamic cognitive and social weight adaptation mechanism based on evaluations.", "configspace": "", "generation": 2, "fitness": 0.8448517258641527, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.016. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8675551869648016, 0.8372788497349426, 0.8297211408927139], "final_y": [0.1267946883999609, 0.1260616959474573, 0.12647908014565934]}, "mutation_prompt": null}
{"id": "3eee55d2-64d5-45e8-91b6-e109ebd04254", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Fine-tuned adaptive inertia weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved convergence control by fine-tuning the adaptive inertia weight formula for smoother exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.875934942646636, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.009. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8785377181771061, 0.863858689693319, 0.8854084200694828], "final_y": [0.12133605469691378, 0.1225113299008066, 0.11794269154524184]}, "mutation_prompt": null}
{"id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive social weight adjustment for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8846449339039287, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.009. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "e2ad4db8-2eec-4796-890e-45f257969736", "metadata": {"aucs": [0.8963599100800849, 0.8735771861304459, 0.8839977055012556], "final_y": [0.119439507790848, 0.12038385139415664, 0.113726532166473]}, "mutation_prompt": null}
{"id": "9200cfb0-08ac-4e99-81be-4f2e75e28951", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            self.cognitive_weight = 1.5 + progress_ratio  # Dynamic adjustment\n            self.social_weight = 1.5 - progress_ratio     # Dynamic adjustment\n            \n            for i in range(self.population_size):\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by dynamically adjusting cognitive and social weights based on progress, enhancing balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.871757385005956, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.872 with standard deviation 0.021. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "cfa23742-c7bf-4910-bdb9-7f0ecd50cba2", "metadata": {"aucs": [0.8895169381395548, 0.8421245154909334, 0.8836307013873798], "final_y": [0.11293695121227676, 0.13300374035708318, 0.11305671172996401]}, "mutation_prompt": null}
{"id": "587e6e0d-463a-48f3-8d21-72f34ebb2106", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.97  # Changed cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]) +\n                               0.1 * np.random.rand() * (np.random.uniform(lb, ub) - positions[i]))  # Added random learning component\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive temperature cooling and additional learning component in velocity update to improve optimization convergence.", "configspace": "", "generation": 3, "fitness": 0.8812187763925036, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.012. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.8840083836752191, 0.8652350214325272, 0.8944129240697641], "final_y": [0.1175083583815244, 0.11916688452124335, 0.11351397079446512]}, "mutation_prompt": null}
{"id": "1f6cb369-7ca2-4ffb-bcb0-4cfee7e74796", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                velocity[i] = np.clip(velocity[i], -0.1, 0.1)  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced adaptive velocity clamping to improve convergence by limiting excessive velocity swings.", "configspace": "", "generation": 3, "fitness": 0.844781538462148, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.043. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.7850475149336925, 0.8634869894192267, 0.885810111033525], "final_y": [0.16097892908403877, 0.12181224450726413, 0.12068639852774898]}, "mutation_prompt": null}
{"id": "72612178-1391-4113-b528-3d88ad077ea0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                velocity[i] = np.clip(velocity[i], -1, 1)  # Velocity clamping\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with additional velocity clamping for improved solution stability and convergence.", "configspace": "", "generation": 3, "fitness": 0.8541527128110317, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.050. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.7842649865615634, 0.885440623364811, 0.8927525285067208], "final_y": [0.15959340737619898, 0.11942332633375619, 0.1181436232903198]}, "mutation_prompt": null}
{"id": "300c00cd-f7f5-4d82-a719-1f9422428d77", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Adjusted cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Adjusted adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive inertia weight and dynamic cooling rate for improving convergence speed and solution quality.", "configspace": "", "generation": 3, "fitness": 0.8749337790893731, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.8802861026288302, 0.8613987257991942, 0.8831165088400951], "final_y": [0.11872260410836055, 0.1214878490780904, 0.11615542562041647]}, "mutation_prompt": null}
{"id": "24a2accd-57f5-4bdb-8c8b-d83f32cff0ae", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]) +\n                               0.1 * np.random.rand() * (ub - lb))  # Improved velocity update\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with improved velocity update strategy for better convergence and solution quality.", "configspace": "", "generation": 3, "fitness": 0.8523249911471686, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.852 with standard deviation 0.016. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "metadata": {"aucs": [0.8373597557968838, 0.8452149511342701, 0.8744002665103522], "final_y": [0.13528143511510204, 0.12225262935515258, 0.11589488680019544]}, "mutation_prompt": null}
{"id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a more aggressive dynamic cognitive weight scheduling for better exploration in early stages.", "configspace": "", "generation": 3, "fitness": 0.8871476771671193, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.009. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.881895890038049, 0.8993999120074911, 0.8801472294558175], "final_y": [0.12343331749794217, 0.11388038442586601, 0.11956036307406193]}, "mutation_prompt": null}
{"id": "c82e036d-d081-4243-bb4d-266c9b4e4ed0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.5 + 0.4 * (np.cos((evaluations / self.budget) * np.pi))  # Improved inertia weight adaptation\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with improved inertia weight adaptation for better convergence and stability.", "configspace": "", "generation": 3, "fitness": 0.8762851632238197, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.007. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.8863754157634146, 0.87103239742502, 0.8714476764830246], "final_y": [0.11903613826446269, 0.12072128648745672, 0.1180102081680724]}, "mutation_prompt": null}
{"id": "b49bc86c-7490-4ac8-9f88-ca17499d50f2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Slightly faster cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Enhanced Simulated Annealing with elite random search\n            candidates = global_best_position + np.random.normal(0, 0.1, (5, self.dim))  # Elite random search\n            candidates = np.clip(candidates, lb, ub)\n            candidate_scores = np.array([func(c) for c in candidates])\n            evaluations += len(candidates)\n            \n            best_candidate_idx = np.argmin(candidate_scores)\n            best_candidate_score = candidate_scores[best_candidate_idx]\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = candidates[best_candidate_idx]\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA with elite random search and adaptive temperature to enhance exploration.", "configspace": "", "generation": 3, "fitness": 0.8603266125782585, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.012. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.8697622753047907, 0.8428582971233878, 0.8683592653065969], "final_y": [0.11985506706714155, 0.1256190982678671, 0.12497815495644315]}, "mutation_prompt": null}
{"id": "bea6d5f0-a6eb-46a1-b43e-ff58a598440a", "solution": "import numpy as np\n\nclass HybridPSO_SA_Levy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Apply Lvy flight for additional exploration\n            if np.random.rand() < 0.1:\n                levy_step = self.levy_flight(self.dim)\n                for i in range(self.population_size):\n                    positions[i] = np.clip(positions[i] + levy_step, lb, ub)\n                    current_score = func(positions[i])\n                    evaluations += 1\n                    if current_score < personal_best_scores[i]:\n                        personal_best_scores[i] = current_score\n                        personal_best_positions[i] = positions[i]\n                    if current_score < global_best_score:\n                        global_best_score = current_score\n                        global_best_position = positions[i]\n\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA_Levy", "description": "Enhanced HybridPSO_SA with adaptive inertia weight and Lvy flight mechanism for improved exploration and convergence.", "configspace": "", "generation": 3, "fitness": 0.8709377245206293, "feedback": "The algorithm HybridPSO_SA_Levy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.011. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.8761080530038473, 0.8555460969205373, 0.8811590236375032], "final_y": [0.12034981762077335, 0.12788518281225736, 0.11614171440004628]}, "mutation_prompt": null}
{"id": "1aba6293-54f7-44f9-8ce7-aa850fc74d6d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.cooling_rate = 0.99 + 0.01 * (evaluations / self.budget)  # Dynamic cooling rate adjustment\n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by dynamically adjusting the cooling rate for better exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8710284306825368, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.010. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "491cf840-6e9c-4ea6-a5cc-58342910d096", "metadata": {"aucs": [0.8850670496142227, 0.8620712167591909, 0.8659470256741967], "final_y": [0.12233589592641936, 0.12508533839483615, 0.1190739942760266]}, "mutation_prompt": null}
{"id": "33840a26-bb12-475f-80fc-c08569388169", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.chaotic_map = self.init_chaotic_map()\n\n    def init_chaotic_map(self):\n        x = 0.7  # Initial value for chaotic map\n        chaotic_map = []\n        for _ in range(self.budget):\n            x = 4 * x * (1 - x)\n            chaotic_map.append(x)\n        return chaotic_map\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                \n                chaotic_factor = self.chaotic_map[evaluations]  # Apply chaotic map\n                \n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * chaotic_factor * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * chaotic_factor * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "HybridPSO_SA optimized with chaotic maps for enhanced exploration and simulated annealing for global convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {}, "mutation_prompt": null}
{"id": "7c1874f3-65cd-454e-b02c-8be333496dd3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.random.uniform(lb, ub, (self.population_size, self.dim))  # Modifying this line\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce diversity by initializing personal best positions to random positions, enhancing exploration capabilities early on.", "configspace": "", "generation": 4, "fitness": 0.8556545941582062, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.043. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "metadata": {"aucs": [0.796095598799655, 0.8769126745812239, 0.8939555090937398], "final_y": [0.146357883060119, 0.1134865388741908, 0.11764430060267239]}, "mutation_prompt": null}
{"id": "259804a7-11a8-4ae1-a733-a0031cec3baa", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i] + np.random.normal(0, 0.1, self.dim)  # Enhanced personal best update\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - evaluations / self.budget)  # Adaptive temperature scaling\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Incorporating adaptive temperature scaling and enhanced personal best update strategy into HybridPSO_SA for better performance.", "configspace": "", "generation": 4, "fitness": 0.8853019791394825, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.010. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "metadata": {"aucs": [0.8987430120115257, 0.8802296870827967, 0.8769332383241248], "final_y": [0.1146198739818105, 0.11833574300891747, 0.11746697306645548]}, "mutation_prompt": null}
{"id": "288fde88-b206-4974-8172-4643089d31ce", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a more aggressive dynamic social weight scheduling for better convergence in later stages.", "configspace": "", "generation": 4, "fitness": 0.8845846856764706, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.004. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8785301416517522, 0.8887400274262272, 0.8864838879514325], "final_y": [0.12229963918761988, 0.11702148306380789, 0.11758674624463694]}, "mutation_prompt": null}
{"id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a more gradual cooling rate for simulated annealing to allow better exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.8854614169541272, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.011. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8789042967739553, 0.8767411093996268, 0.9007388446887994], "final_y": [0.12121505365722296, 0.11804776193738964, 0.11751444535837385]}, "mutation_prompt": null}
{"id": "c8107011-8ddb-456d-ae1d-5d3c4d5f3c5b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.chaotic_sequence = np.random.rand(self.population_size)  # Initialize chaotic sequence\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))\n                # Chaotic cognitive weight\n                self.chaotic_sequence[i] = 0.7 * self.chaotic_sequence[i] * (1 - self.chaotic_sequence[i])\n                self.cognitive_weight = 1.5 * (1 - self.chaotic_sequence[i])\n                \n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment with modified cooling schedule\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / (self.temperature + evaluations / self.budget)):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a novel adaptive temperature cooling strategy and chaotic cognitive weight for improved convergence dynamics and solution diversity.", "configspace": "", "generation": 4, "fitness": 0.8850047271603788, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.012. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "metadata": {"aucs": [0.880321799363692, 0.9019857822240699, 0.8727065998933743], "final_y": [0.11912233912627457, 0.11089451074848644, 0.1150537296994133]}, "mutation_prompt": null}
{"id": "956e89c1-090b-43e6-a365-72f9a9e4996a", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.985  # Slightly increase cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce a slight increase in temperature cooling rate for improved exploration capabilities in the Simulated Annealing component.", "configspace": "", "generation": 4, "fitness": 0.8628225023111925, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.022. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "metadata": {"aucs": [0.8689344096648328, 0.8338475006815969, 0.885685596587148], "final_y": [0.1186614171173106, 0.13255981780434478, 0.11461752530835823]}, "mutation_prompt": null}
{"id": "b50bfd57-90db-42fc-b00e-c49797d2fda1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.8 - (0.4 * (evaluations / self.budget))  # Adjusted adaptive inertia weight\n                self.social_weight = 0.9 + (0.6 * (evaluations / self.budget))  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved convergence by enhancing the velocity update with dynamic inertia weight bounds adjustment.", "configspace": "", "generation": 4, "fitness": 0.8696829523996694, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.031. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "7d3d9c30-dcd1-463c-9483-2d9125797f6e", "metadata": {"aucs": [0.9084971717859315, 0.8314668402203722, 0.8690848451927048], "final_y": [0.11193829502663655, 0.13699242300336767, 0.11978627761246152]}, "mutation_prompt": null}
{"id": "e592a43f-0c06-47b5-b24d-1fef48ac56fa", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Changed cooling rate for simulated annealing\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]) * np.random.rand())  # Added random factor to social component\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced exploration-exploitation balance by slightly modifying the velocity update rule and annealing schedule.", "configspace": "", "generation": 4, "fitness": 0.8714519151119638, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.013. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8852813953466683, 0.8541459351817102, 0.8749284148075127], "final_y": [0.11482752955720021, 0.12765875995883724, 0.11461185894779424]}, "mutation_prompt": null}
{"id": "65a10ddd-1eb7-47a0-bbc7-3c75b45499fb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate + (0.01 * (evaluations / self.budget))\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance the exploration by modifying the cooling rate dynamically based on evaluations, allowing for a more flexible annealing schedule.", "configspace": "", "generation": 4, "fitness": 0.873458759345696, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.003. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8710328180520155, 0.8775832399882918, 0.8717602199967802], "final_y": [0.11786445033685233, 0.11617550830611945, 0.11480997217551137]}, "mutation_prompt": null}
{"id": "575fcb96-d9ab-4ae1-ba45-0508ff3d290d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.5  # Changed from 1.0 to 1.5\n        self.cooling_rate = 0.996  # Changed from 0.995 to 0.996\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a more adaptive cooling rate and increased initial temperature for improved exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.8540165706107988, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.027. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8916539290674063, 0.8344617269708521, 0.8359340557941379], "final_y": [0.11815604503374733, 0.13352239169411462, 0.12207541953157786]}, "mutation_prompt": null}
{"id": "691c9914-7885-406c-80ab-f82d6612aa79", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Changed line: Adjusted inertia weight for improved dynamic balance\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Refine inertia weight to improve dynamic balance between exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.8735937019675087, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.011. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8776804565243889, 0.8587490317143388, 0.8843516176637988], "final_y": [0.12140258837836981, 0.11506048615080533, 0.11741501109126251]}, "mutation_prompt": null}
{"id": "871c2840-e9f5-4fb6-a8a4-d5a5eb98fd2c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Slightly faster cooling rate\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget)) \n                \n                # Adaptive weights based on score differences\n                score_factor = np.abs(personal_best_scores[i] - global_best_score) / (1 + global_best_score)\n                self.cognitive_weight = 1.5 + score_factor  \n                self.social_weight = 1.5 + score_factor  \n\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 0.5, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive social and cognitive weights based on current and global best scores for improved adaptability and exploitation. ", "configspace": "", "generation": 5, "fitness": 0.8526521620365681, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.023. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8850958437170073, 0.8400524566458344, 0.8328081857468626], "final_y": [0.11811568422593044, 0.13337786249094274, 0.12649738201257488]}, "mutation_prompt": null}
{"id": "3d3edb9f-dd8c-4d4f-9970-1d797ba1e636", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.996  # Adjusted cooling rate for better convergence\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 2.0 - (0.5 * (evaluations / self.budget))  # Balanced cognitive weight\n                self.social_weight = 1.2 + (0.3 * np.random.rand())  # Dynamic social weight adjustment\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Adaptive cooling schedule\n            self.temperature *= self.cooling_rate + 0.001 * np.log(1 + evaluations)\n        \n        return global_best_position", "name": "EnhancedHybridPSO_SA_Adaptive", "description": "The Enhanced HybridPSO_SA_Adaptive dynamically adjusts inertia, cognitive, and social weights along with an adaptive temperature cooling schedule for improved convergence performance.", "configspace": "", "generation": 5, "fitness": 0.8633003157923551, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.032. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8856850842690402, 0.8173885996205008, 0.8868272634875243], "final_y": [0.11830912841380581, 0.13983956765547345, 0.11376702253608428]}, "mutation_prompt": null}
{"id": "d278251b-a92e-4840-8b61-5ebd0c052310", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.3 * (evaluations / self.budget))  # Modified social weight strategy\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with modified social weight strategy to improve balance between exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.8569062270625455, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.025. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8750587075344387, 0.82116001060895, 0.8744999630442474], "final_y": [0.11741491685431871, 0.1372628519514033, 0.11250007687868513]}, "mutation_prompt": null}
{"id": "2eb939c2-44f0-498b-8b94-f00d39e6881c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * self.dim  # Modified population size\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995 - (0.5 * (self.budget / 10000))  # Adapted cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced adaptive cooling rate and variable population size for improving exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.8628513500162672, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.013. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8576960192898696, 0.8506734125953519, 0.88018461816358], "final_y": [0.12840396745202498, 0.12551318565474245, 0.11918203836495611]}, "mutation_prompt": null}
{"id": "fba35a51-81a5-4e7b-a4e2-9fadaee89df3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Adaptive temperature scaling\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA with adaptive temperature scaling for better convergence control and precision.", "configspace": "", "generation": 5, "fitness": 0.8440406292921612, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.039. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8835719713022329, 0.8583835378406192, 0.7901663787336317], "final_y": [0.12104724640974573, 0.12149153492085574, 0.15429924249292926]}, "mutation_prompt": null}
{"id": "10630d47-d41b-40b9-b1d2-6763379ee19c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= (0.99 + 0.005 * (evaluations / self.budget))  # Adaptive cooling rate based on evaluations\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive cooling rate based on function evaluations for improved convergence balance.", "configspace": "", "generation": 5, "fitness": 0.8640666748088929, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.025. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8794332870694308, 0.8289593754555336, 0.8838073619017142], "final_y": [0.12178780932714128, 0.13495126890722065, 0.11548556667103804]}, "mutation_prompt": null}
{"id": "65b1cbb2-71d1-4372-93f0-8b430f71a900", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.992  # Slightly increased cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improve HybridPSO_SA by slightly increasing the cooling rate for better convergence.", "configspace": "", "generation": 5, "fitness": 0.8827332479600631, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.015. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.9037171158703485, 0.8685909185131714, 0.8758917094966698], "final_y": [0.1126967446799626, 0.11415416690932367, 0.11799808741802087]}, "mutation_prompt": null}
{"id": "c500b74b-c471-44ff-80ac-c70a20b0bd07", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Improved cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with an improved cooling rate function for better convergence control.", "configspace": "", "generation": 5, "fitness": 0.8738587981289312, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.021. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.9023276526769596, 0.8545535843079302, 0.8646951574019037], "final_y": [0.11355505253040687, 0.1198546341215484, 0.12212137741534679]}, "mutation_prompt": null}
{"id": "93439056-f00d-4102-a74c-248f8a4b7f47", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.9 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.75 * (evaluations / self.budget))\n                \n                random_subspace = np.random.choice(self.dim, size=int(self.dim * 0.5), replace=False)\n                velocity[i, random_subspace] = (self.inertia_weight * velocity[i, random_subspace] +\n                                                self.cognitive_weight * np.random.rand() * (personal_best_positions[i, random_subspace] - positions[i, random_subspace]) +\n                                                self.social_weight * np.random.rand() * (global_best_position[random_subspace] - positions[i, random_subspace]))\n                positions[i, random_subspace] = np.clip(positions[i, random_subspace] + velocity[i, random_subspace], lb[random_subspace], ub[random_subspace])\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim // 2)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive dynamic parameters and a random subspace strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {}, "mutation_prompt": null}
{"id": "66f8db08-3993-4e04-8fb3-6d081d898c9e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Modified adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved inertia weight decay to enhance diversity and avoid premature convergence.", "configspace": "", "generation": 6, "fitness": 0.8835919160190238, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.006. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8838790059991436, 0.8766571626849731, 0.8902395793729547], "final_y": [0.12025102077439165, 0.12479009347277603, 0.11713429203575432]}, "mutation_prompt": null}
{"id": "3c961352-2645-4e45-ba1b-c3405619513c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.9  # Initial inertia weight changed\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.993  # Slightly adjusted cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear inertia weight adaptation\n                self.inertia_weight = 0.9 * ((self.budget - evaluations) / self.budget)**0.5\n                self.cognitive_weight = 1.5 + 0.75 * np.sin(np.pi * evaluations / self.budget)  # Adaptive cognitive weight\n                self.social_weight = 1.5 - 0.5 * np.cos(np.pi * evaluations / self.budget)  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with non-linear decreasing inertia weight and adaptive learning strategy for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.8827043824302652, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.004. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8882750381850448, 0.8785232073784879, 0.8813149017272628], "final_y": [0.1133756920526724, 0.11261634542199417, 0.12023489208538507]}, "mutation_prompt": null}
{"id": "c6aca7d1-9c64-47df-b6ab-e2c971c42a3c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Dynamic cooling rate adjustment\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved Simulated Annealing with dynamically adjusted cooling rate based on evaluations to enhance exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.865708914392186, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.024. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8976647395738206, 0.8600166748735903, 0.839445328729147], "final_y": [0.11280065583621546, 0.12187223303023154, 0.12781680866213863]}, "mutation_prompt": null}
{"id": "8172f3b0-52cb-4f4b-98ad-6e3ab9ee87d5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n                \n            # Introduce perturbation if exploration stagnates\n            if np.random.rand() < 0.1:\n                global_best_position = np.random.uniform(lb, ub, self.dim)  # Perturbation\n\n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce a perturbation probability to enhance exploration during stagnation to refine HybridPSO_SA.", "configspace": "", "generation": 6, "fitness": 0.8802647173803583, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.008. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8870469927070761, 0.8840571286787231, 0.8696900307552757], "final_y": [0.12083951978580576, 0.11783405928684532, 0.1210845522396331]}, "mutation_prompt": null}
{"id": "6b625b78-1fb0-4158-913b-e11433b16524", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * self.dim  # Changed from 10 * self.dim to 12 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a fine-tuned population size to improve exploration and convergence speed. ", "configspace": "", "generation": 6, "fitness": 0.8743874649270911, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.003. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8782772949724813, 0.8748873873062526, 0.8699977125025391], "final_y": [0.12042054888984344, 0.12009465177203626, 0.12126252289638617]}, "mutation_prompt": null}
{"id": "7c33efdd-39f8-4c04-b4f7-ead891ea9246", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Fine-tuned the cooling rate to enhance exploration-exploitation balance in the latter stages.", "configspace": "", "generation": 6, "fitness": 0.8608869144921334, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.010. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8544674483103235, 0.8535141003394615, 0.8746791948266155], "final_y": [0.12722137817178247, 0.12606275948065426, 0.12085850351280791]}, "mutation_prompt": null}
{"id": "e68cded7-c44d-44c1-8f0e-828f279992af", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * self.dim  # Adjusted population size for better exploration\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhancing HybridPSO_SA by adjusting the population size for improved exploration and convergence.", "configspace": "", "generation": 6, "fitness": 0.8710049024672207, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.017. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8949456544514351, 0.8602890924177787, 0.8577799605324486], "final_y": [0.11998751655328976, 0.12153587468495242, 0.12225067655829713]}, "mutation_prompt": null}
{"id": "532c7975-1ab6-4bd8-a4f9-a72940a64df5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= (self.cooling_rate - 0.01 * evaluations / self.budget)  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced adaptive cooling rate based on evaluation progress to enhance the exploration-exploitation trade-off.", "configspace": "", "generation": 6, "fitness": 0.8694440797604086, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.015. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8866902263900553, 0.8716717524496725, 0.8499702604414983], "final_y": [0.119984525278365, 0.12385344008852817, 0.12228881183331619]}, "mutation_prompt": null}
{"id": "384c5457-ca4f-416a-870a-f2555e5f23c5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                # Adaptive personal best update with dynamic threshold\n                dynamic_threshold = 0.01 * (self.budget - evaluations) / self.budget\n                if current_score < personal_best_scores[i] - dynamic_threshold:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by introducing adaptive personal best updating based on a dynamic threshold for enhanced convergence.", "configspace": "", "generation": 6, "fitness": 0.8690979348309181, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.009. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8768053014034091, 0.8558101763432855, 0.8746783267460598], "final_y": [0.1176825773339294, 0.13084715181422757, 0.12163416040056274]}, "mutation_prompt": null}
{"id": "4ba6c2ba-f325-400c-a35b-cf7e4e7d9dc0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - (global_best_score / func(global_best_position)))  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive cooling rate based on convergence to improve late-stage exploitation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ZeroDivisionError('float division by zero').", "error": "ZeroDivisionError('float division by zero')", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {}, "mutation_prompt": null}
{"id": "1e47ab27-568b-4731-8063-d50b4ae65ae9", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n                \n            # Diversity preservation by reinitializing the worst-performing particles\n            if evaluations < self.budget:\n                worst_idx = np.argmax(personal_best_scores)\n                positions[worst_idx] = np.random.uniform(lb, ub, self.dim)\n                personal_best_scores[worst_idx] = func(positions[worst_idx])\n                evaluations += 1\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Modified HybridPSO_SA by introducing diversity preservation through random reinitialization of worst-performing particles.", "configspace": "", "generation": 7, "fitness": 0.8760781711774502, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.011. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8809917006720084, 0.8604453383637183, 0.886797474496624], "final_y": [0.12079737194496021, 0.13049441154846653, 0.11801498881240513]}, "mutation_prompt": null}
{"id": "e00c83ee-3bf5-43df-975e-131aed473910", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= 0.97  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA algorithm with adaptive cooling rate to enhance exploration in later stages.", "configspace": "", "generation": 7, "fitness": 0.8685991232330018, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.030. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8986782122968547, 0.8276733054128452, 0.8794458519893054], "final_y": [0.11376637272681944, 0.13812252476264653, 0.1188700205268256]}, "mutation_prompt": null}
{"id": "1744772e-753f-4cbb-a51e-764be738a97a", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introducing dynamic temperature decay based on evaluations to enhance exploration-exploitation trade-off.", "configspace": "", "generation": 7, "fitness": 0.8860244979511265, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.018. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.9001100883411559, 0.8608976996625953, 0.8970657058496279], "final_y": [0.11797729451014383, 0.12700973691787376, 0.11895803351787138]}, "mutation_prompt": null}
{"id": "0d5bcb71-de15-47e8-9a36-3a2f7cbbdc5e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity_scale = 1 - (evaluations / self.budget)  # New: Dynamic velocity scaling\n                velocity[i] = velocity_scale * (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:  # Enhanced update condition\n                    personal_best_scores[i] = current_score \n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA with enhanced personal best update and dynamic velocity scaling for better convergence.", "configspace": "", "generation": 7, "fitness": 0.8829787443249596, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.025. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.9140222629475977, 0.8533822616503399, 0.8815317083769415], "final_y": [0.11385586784376844, 0.11808831282960686, 0.11941090613086491]}, "mutation_prompt": null}
{"id": "23b133cd-6ab3-4e58-95d8-fb9b9c83e4de", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= (0.99 + 0.01 * (evaluations / self.budget))  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive cooling rate based on iteration progress for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.8824437734913517, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.008. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8897385224552538, 0.8709506638479177, 0.8866421341708836], "final_y": [0.12184993383725096, 0.11959906342018689, 0.11942683204694071]}, "mutation_prompt": null}
{"id": "40b43f0d-6b1d-4a68-afc1-de1da8fd2d1d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (1.0 * (evaluations / self.budget))  # More aggressive cognitive weight increase\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a more aggressive cognitive weight increase rate for faster convergence in early stages.", "configspace": "", "generation": 7, "fitness": 0.8735116731710186, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.006. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.880625255356951, 0.8664540965545076, 0.8734556676015974], "final_y": [0.1151391003672495, 0.11994336607109979, 0.11581702569082208]}, "mutation_prompt": null}
{"id": "7ee68ec7-2d53-4cb6-9ce9-06d7fbe0ae7b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.9 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with a further refined cognitive weight adjustment strategy for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.8618859891613915, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.022. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8666124634161758, 0.8325546248295986, 0.8864908792384001], "final_y": [0.12946830939663223, 0.1347727618448583, 0.1221165961123839]}, "mutation_prompt": null}
{"id": "3b37f386-071c-4266-9076-fe16f43fa297", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.994  # Changed from 0.995 to 0.994\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                \n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                \n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n                    \n            # Adaptive local search\n            perturbation = np.random.rand(self.dim) * (ub - lb) * (self.temperature / 10)\n            local_candidate = global_best_position + perturbation\n            local_candidate = np.clip(local_candidate, lb, ub)\n            local_candidate_score = func(local_candidate)\n            evaluations += 1\n            \n            if local_candidate_score < global_best_score:\n                global_best_position = local_candidate\n                global_best_score = local_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced adaptive local search and elite retention mechanisms to enhance convergence speed and solution quality.", "configspace": "", "generation": 7, "fitness": 0.8790419655531951, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.007. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8696658728380979, 0.8852917464858536, 0.882168277335634], "final_y": [0.11456221930087884, 0.11849362476146474, 0.12037389574765378]}, "mutation_prompt": null}
{"id": "1e9f2139-3f4d-47b9-bceb-8a4874f9c1a2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * self.dim  # Changed from 10 * self.dim to 12 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.996  # Changed from 0.995 to 0.996\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive cooling rate and increased population for better exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8625673537148054, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.022. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a8e78d38-221c-4dd2-90e7-9811bbda73a1", "metadata": {"aucs": [0.8925727564500471, 0.8431681750486286, 0.8519611296457406], "final_y": [0.11945273848378857, 0.133456863414548, 0.1250993847032471]}, "mutation_prompt": null}
{"id": "c0a93940-b549-4332-8f01-769426a4654b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                # Periodic velocity reinitialization for enhanced exploration\n                if evaluations % (self.budget // 10) == 0:\n                    velocity[i] = np.random.uniform(-1, 1, self.dim)\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment with adaptive cooling rate\n            self.cooling_rate = 0.99 + 0.01 * (evaluations / self.budget)\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA with adaptive cooling rate and enhanced exploration using periodic velocity reinitialization.", "configspace": "", "generation": 8, "fitness": 0.8716687253397769, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.872 with standard deviation 0.012. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8690147662641484, 0.8580666065080701, 0.8879248032471121], "final_y": [0.12770296939796355, 0.12137193241811584, 0.11399193164555388]}, "mutation_prompt": null}
{"id": "5e3dc33a-3b28-4d44-bfb9-0e110bb82a1a", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Swarm density adaptation\n            swarm_density = np.std(positions, axis=0)\n            dynamic_cognitive_weight = np.clip(self.cognitive_weight * (1 + 0.5 * (1 - (swarm_density / (ub - lb)))), 1, 2)\n            \n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Slightly adjusted adaptive inertia weight\n                self.cognitive_weight = dynamic_cognitive_weight[i % self.dim]  # Use dynamic cognitive weight\n                self.social_weight = 1.5 - (0.3 * (evaluations / self.budget))  # Adjusted dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, swarm_density.mean(), self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with dynamic swarm density adaptation to improve convergence rate and exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.86576006975747, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.025. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8754575448991633, 0.8317237333887082, 0.8900989309845385], "final_y": [0.12151392529794203, 0.13529367092025024, 0.11890903110180684]}, "mutation_prompt": null}
{"id": "32b9ee5e-b50c-4907-99fa-d739ce1e6f3e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= 0.995 + 0.005 * (evaluations / self.budget)  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introducing adaptive cooling rate based on budget utilization to enhance exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.8603130081982769, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.031. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.891472969098504, 0.8187872965319203, 0.8706787589644066], "final_y": [0.11807010727480749, 0.1393456082190686, 0.12074871829181455]}, "mutation_prompt": null}
{"id": "7bc02a61-9b9d-4a30-a7d8-c6e0e434b75c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - (evaluations * 0.5) / self.budget)  # Adjusted cooling rate formula\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjusted the cooling rate formula to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.8580704204666354, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.028. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8949355295584387, 0.8522653582533899, 0.8270103735880777], "final_y": [0.1189770973194687, 0.12805301371535693, 0.1296791883176891]}, "mutation_prompt": null}
{"id": "033f83e4-4220-4f47-86c3-c36410475605", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.997  # Adjusted from 0.995 to 0.997\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            if np.random.rand() < 0.1:  # Introduce mutation with a small probability\n                best_candidate += np.random.normal(0, 0.1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive cooling rate and improved diversity via mutation strategy.", "configspace": "", "generation": 8, "fitness": 0.8720870188389979, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.872 with standard deviation 0.009. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8836199780283467, 0.8615704054458087, 0.8710706730428379], "final_y": [0.11963238511424923, 0.12277295522869047, 0.1174393558676482]}, "mutation_prompt": null}
{"id": "afe83ba2-fe02-476f-8a2f-9a5e93248d31", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Improved cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            mutation = np.random.normal(0, 0.1, self.dim)  # Introduced dynamic mutation\n            best_candidate = global_best_position + mutation\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced exploration by introducing dynamic mutation and improved annealing schedule for better convergence.", "configspace": "", "generation": 8, "fitness": 0.8772414425794811, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.010. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.880138465550259, 0.8641382009390004, 0.8874476612491837], "final_y": [0.11923050939202617, 0.12304814326990177, 0.117929851009127]}, "mutation_prompt": null}
{"id": "2dcd15d7-c4da-4581-981a-57e9fdc308b2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Adjusted adaptive inertia weight\n                self.cognitive_weight = 1.8 + (0.5 * (evaluations / self.budget))  # Enhanced dynamic cognitive weight\n                self.social_weight = 1.3 - (0.3 * (evaluations / self.budget))  # Adjusted dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment with enhanced candidate generation\n            best_candidate = global_best_position + np.random.normal(0, 0.5, self.dim)  # Using smaller variance for better local search\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay with improved rate\n            self.temperature *= self.cooling_rate * (1 - evaluations / (1.5 * self.budget))  # Adjusted to increase exploration\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with improved adaptive parameter tuning and exploration mechanism for superior optimization performance.", "configspace": "", "generation": 8, "fitness": 0.8746911672952226, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.010. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8854734692935377, 0.8609588086069884, 0.8776412239851415], "final_y": [0.11933088307086848, 0.130186753740671, 0.11920442501036854]}, "mutation_prompt": null}
{"id": "847c2a7e-6ca5-4d8a-8be1-0b14bee5034f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget)) * np.cos(np.pi * evaluations / self.budget)  # Adaptive inertia weight with dynamic scaling\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with additional dynamic scaling for inertia weight to balance exploration-exploitation more effectively.", "configspace": "", "generation": 8, "fitness": 0.8817632972999517, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.012. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8959713625137374, 0.8835729536092152, 0.8657455757769028], "final_y": [0.12020422211959314, 0.11510438818081636, 0.11849590447213099]}, "mutation_prompt": null}
{"id": "2a3fe65c-35f6-4c35-b713-205b96ad3ed1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.7  # Changed from 0.5 to 0.7 to enhance exploration\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhance exploration during initial stages by using a more aggressive initial inertia weight before adapting dynamically.", "configspace": "", "generation": 8, "fitness": 0.8606830799610096, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.034. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8947276426462, 0.8140663019707247, 0.8732552952661038], "final_y": [0.11775978467740833, 0.132432786473768, 0.11875993128607443]}, "mutation_prompt": null}
{"id": "f92149e5-5e31-4bbe-8fac-c78226051da8", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 5\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                progress = evaluations / self.budget\n                self.inertia_weight = (self.inertia_weight_initial - self.inertia_weight_final) * (1 - progress ** 2) + self.inertia_weight_final\n                self.cognitive_weight = 1.5 + (0.75 * progress)\n                self.social_weight = 1.5 - (0.5 * progress)\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            if evaluations >= self.budget / 2 and self.population_size > self.min_population_size:\n                self.population_size -= 1  # Adaptive population size reduction\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introducing adaptive population size and non-linear inertia weight scheduling to enhance exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.8828288081759524, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.004. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8812166262163235, 0.878436887849067, 0.8888329104624668], "final_y": [0.12038461624437946, 0.12192698810630631, 0.11595800367216558]}, "mutation_prompt": null}
{"id": "b72484e9-b8b5-4c1f-9e53-09c1c2196591", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= (0.99 + 0.01 * (evaluations / self.budget))  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introducing adaptive cooling rate in Simulated Annealing based on evaluations to improve convergence.", "configspace": "", "generation": 9, "fitness": 0.8554220122132712, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.021. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8831263671871352, 0.8324746769262007, 0.8506649925264774], "final_y": [0.12014060358350609, 0.13426779633873287, 0.12027298085971405]}, "mutation_prompt": null}
{"id": "b86c82a0-da7a-4d71-be21-4702120bef67", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))\n            self.cooling_rate = 0.995 + 0.005 * (1 - evaluations / self.budget)  # Dynamically adjust cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Further enhance exploration by adjusting the cooling rate dynamically based on the remaining budget.  ", "configspace": "", "generation": 9, "fitness": 0.8576590826976326, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.024. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8894385271142287, 0.8305899424439189, 0.85294877853475], "final_y": [0.11783994217429017, 0.13501439627746403, 0.12405902715310357]}, "mutation_prompt": null}
{"id": "5831cc3e-3e71-4099-92b4-09d609927154", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * self.dim  # Changed from 10 to 8\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-2, 2, (self.population_size, self.dim))  # Changed from (-1, 1) to (-2, 2)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive population size and more aggressive velocity initialization to improve convergence speed.", "configspace": "", "generation": 9, "fitness": 0.8574845648165873, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.024. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8736917372364467, 0.8751425287796966, 0.8236194284336185], "final_y": [0.11859864304065815, 0.11898362490882408, 0.13354335607991252]}, "mutation_prompt": null}
{"id": "74ab9b33-63ab-407f-aa96-1fb1eff4122e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if (best_candidate_score < global_best_score or \n                np.random.rand() < np.exp(-(best_candidate_score - global_best_score) / self.temperature)):  # Stochastic tunneling acceptance criterion\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by incorporating a stochastic tunneling acceptance criterion for better exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8856807787937275, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.006. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8861981836188141, 0.8931492898805152, 0.8776948628818533], "final_y": [0.1189335653571364, 0.11619893391279768, 0.11666827039438699]}, "mutation_prompt": null}
{"id": "87726e1d-9ac6-42b4-944f-1bc99626a03e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay based on current best score\n            self.temperature *= self.cooling_rate * (1 - global_best_score / (1 + global_best_score)) \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improved exploration by adapting the temperature cooling rate dynamically based on the current global best score.", "configspace": "", "generation": 9, "fitness": 0.8788527573811288, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.030. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.9043187782815141, 0.8370914388518971, 0.8951480550099752], "final_y": [0.1143710011034812, 0.13536227726196526, 0.11484961460929144]}, "mutation_prompt": null}
{"id": "d116cd0d-a933-4c85-86e9-9dc5ce736c39", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  \n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            convergence_rate = evaluations / self.budget\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.4 * convergence_rate)\n                self.cognitive_weight = 1.5 + (0.9 * convergence_rate)\n                self.social_weight = 1.5 - (0.6 * convergence_rate)\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            mutation_chance = convergence_rate / 2\n            if np.random.rand() < mutation_chance:\n                mutation = np.random.normal(0, 0.1, self.dim)\n                best_candidate += mutation\n                best_candidate = np.clip(best_candidate, lb, ub)\n                best_candidate_score = func(best_candidate)\n                evaluations += 1\n\n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - convergence_rate)\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhancing HybridPSO_SA by incorporating adaptive mutation based on convergence rate and refined inertia-cognitive-social adjustment for improved solution diversity and quality.", "configspace": "", "generation": 9, "fitness": 0.871706953001452, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.872 with standard deviation 0.019. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8941284507654026, 0.8743075261299814, 0.8466848821089719], "final_y": [0.12008122915513664, 0.11994242669700617, 0.12472708351231065]}, "mutation_prompt": null}
{"id": "9feec841-76de-4054-86bf-2513225da76e", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.8 - (0.3 * (evaluations / self.budget))  # Adjusted adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Improve exploration-exploitation balance by adjusting inertia and adding diversity through Gaussian mutation.", "configspace": "", "generation": 9, "fitness": 0.8693372213593369, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.020. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8844504632856196, 0.8404450025982033, 0.883116198194188], "final_y": [0.12079606795402442, 0.13182818101428073, 0.11541282977193168]}, "mutation_prompt": null}
{"id": "16b38b75-474c-4758-afd4-d42071c1a3c7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Nonlinear temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations**0.5 / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce a nonlinear temperature decay function for improved exploration-exploitation balance in HybridPSO_SA.", "configspace": "", "generation": 9, "fitness": 0.8759371243139372, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.025. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8940989229160264, 0.8409511765858638, 0.8927612734399214], "final_y": [0.11950259643004635, 0.13368526834150107, 0.1144649650340116]}, "mutation_prompt": null}
{"id": "8a2a1678-557c-415b-a3d9-1df2066487e7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]) +\n                               0.1 * np.random.randn(self.dim))  # Added stochastic component\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introducing stochastic component in velocity update for enhanced diversity and exploration.", "configspace": "", "generation": 9, "fitness": 0.8670375702440231, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.014. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8863374846960612, 0.8535142517045368, 0.8612609743314714], "final_y": [0.11810358705250434, 0.13270282436656033, 0.12584354372847928]}, "mutation_prompt": null}
{"id": "8df3d363-b2b7-4521-92da-7b574c819c1b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * self.dim  # Adjusted population size\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb - 0.1*(ub-lb), ub + 0.1*(ub-lb), (self.population_size, self.dim))  # Diversified initialization\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                perturbation = np.random.normal(0, 0.1 * (1 - evaluations / self.budget), self.dim)  # Adaptive velocity perturbation\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]) +\n                               perturbation)  # Added perturbation\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced adaptive velocity perturbation and diversified initialization to improve exploration in HybridPSO_SA.", "configspace": "", "generation": 9, "fitness": 0.8408582359008475, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.841 with standard deviation 0.025. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8763040256726253, 0.8224872550414914, 0.8237834269884254], "final_y": [0.11872248576554878, 0.13639238970407663, 0.13746145592774428]}, "mutation_prompt": null}
{"id": "d46b5c9d-abca-449e-8d58-231fdb62f84c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n            # Mutation step\n            if np.random.rand() < 0.1:  # 10% probability to apply mutation step\n                mutation = np.random.normal(0, 0.1, self.dim)\n                global_best_position = np.clip(global_best_position + mutation, lb, ub)\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce a mutation step with Gaussian noise to improve global exploration.", "configspace": "", "generation": 10, "fitness": 0.8807083696660761, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.002. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8787964290306567, 0.8806951323986306, 0.8826335475689412], "final_y": [0.11978420655060451, 0.11928073147852158, 0.11683607191111545]}, "mutation_prompt": null}
{"id": "1d3b94da-2bcc-47af-80ba-b81af254c3cf", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= (self.cooling_rate - 0.01 * (evaluations / self.budget))  # Adaptive cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive cooling rate for Simulated Annealing to better balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.8861352471981953, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.017. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.9103926271933808, 0.8732496064175932, 0.8747635079836119], "final_y": [0.11125630621218452, 0.12110327891275319, 0.12055813724223763]}, "mutation_prompt": null}
{"id": "735c1dc8-94e9-4647-97e9-68a33759db97", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def levy_flight(self, lam=1.5):\n        # Generating a step from Levy distribution\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) /\n                 (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v)**(1 / lam)\n        return 0.01 * step\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                \n                # Levy flight strategy added\n                if np.random.rand() < 0.3:\n                    positions[i] += self.levy_flight()\n                else:\n                    velocity[i] = (self.inertia_weight * velocity[i] +\n                                   self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                                   self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                    positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with adaptive population size and levy flight strategy for improved exploration and convergence.", "configspace": "", "generation": 10, "fitness": 0.86801456590171, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.008. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8757426073296731, 0.8711710498644611, 0.8571300405109957], "final_y": [0.1187969248386106, 0.12198930615884973, 0.123204919150671]}, "mutation_prompt": null}
{"id": "25f4f878-681f-48de-b7a8-b8ec9285aadc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        def levy_flight(Lambda):\n            sigma1 = np.power((np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2)) / \n                              (np.math.gamma((1 + Lambda) / 2) * Lambda * np.power(2, (Lambda - 1) / 2)), 1 / Lambda)\n            u = np.random.normal(0, sigma1, size=self.dim)\n            v = np.random.normal(0, 1, size=self.dim)\n            step = u / np.power(np.abs(v), 1 / Lambda)\n            return step\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  \n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  \n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment with Levy flight perturbation\n            best_candidate = global_best_position + levy_flight(1.5)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by introducing Levy flight-based perturbation and adaptive inertia weight to improve exploration and convergence.", "configspace": "", "generation": 10, "fitness": 0.864886097826394, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.021. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.894883813230281, 0.8471020942851207, 0.8526723859637804], "final_y": [0.11757590329555245, 0.1209015560183766, 0.11875737697525801]}, "mutation_prompt": null}
{"id": "32f4610a-6890-4e2e-ba37-99b7d883a47f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            average_best_score = np.mean(personal_best_scores)\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget) + average_best_score / (2 * self.budget))\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced an adaptive cooling rate and improved velocity calculation using a historical average of best scores to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.8666165580734752, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.020. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8799855664694157, 0.8380512618264111, 0.8818128459245989], "final_y": [0.11944824140974675, 0.13504041526258725, 0.12133955694691023]}, "mutation_prompt": null}
{"id": "ee5d4b1c-6930-408d-825c-fd0d7a88c717", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate + np.random.uniform(-0.005, 0.005)  # Randomized adaptive cooling\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce a randomized adaptive cooling schedule for temperature in Simulated Annealing to improve exploration.", "configspace": "", "generation": 10, "fitness": 0.8693053551189233, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.013. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8850690853572023, 0.8543621822878331, 0.8684847977117343], "final_y": [0.11822591715616049, 0.11987533074937551, 0.11792242864493618]}, "mutation_prompt": null}
{"id": "c0fe76bd-be81-4744-86cf-44bb15cd8c00", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 2.0  # Increased initial cognitive weight\n        self.social_weight = 1.0  # Decreased initial social weight\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate for SA\n        self.c1_decay = 0.99  # Decay rate for cognitive weight\n        self.c2_increase = 1.01  # Increase rate for social weight\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_weight *= self.c1_decay  # Adaptive cognitive weight\n                self.social_weight *= self.c2_increase  # Adaptive social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n\n                current_score = func(positions[i])\n                evaluations += 1\n\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n\n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by introducing adaptive learning rates for velocity components to improve convergence.", "configspace": "", "generation": 10, "fitness": 0.8497939589773681, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.022. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8286432879087844, 0.8403687105376139, 0.8803698784857058], "final_y": [0.1416116785353062, 0.13522058684336524, 0.11520559638468719]}, "mutation_prompt": null}
{"id": "5842aff5-d5be-4a24-a2e6-e079d5fb90fb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Changed from 0.99 to 0.995\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.7 + (0.75 * (evaluations / self.budget))  # Enhanced cognitive weight factor\n                self.social_weight = 1.3 - (0.5 * (evaluations / self.budget))  # Adjusted social weight for precision\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            # Dynamic temperature decay\n            self.temperature *= self.cooling_rate * (1 - evaluations / (2 * self.budget))  \n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Adjusted cognitive and social weight dynamics for enhanced convergence precision.", "configspace": "", "generation": 10, "fitness": 0.8777198159422067, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.012. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "1744772e-753f-4cbb-a51e-764be738a97a", "metadata": {"aucs": [0.8916470875017061, 0.8799446067638935, 0.8615677535610207], "final_y": [0.11459734816954104, 0.11931182994161016, 0.12396931379720422]}, "mutation_prompt": null}
{"id": "c5f1d02b-7dc8-4814-9b8f-32209543fd95", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n                self.cognitive_weight = 1.5 + (0.75 * (evaluations / self.budget))  # More aggressive dynamic cognitive weight\n                self.social_weight = 1.5 - (0.5 * (evaluations / self.budget))  # Dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Simulated Annealing adjustment\n            best_candidate = global_best_position + np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate * (0.5 + 0.5 * (evaluations / self.budget))  # Dynamic cooling rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduced a dynamic cooling rate for the temperature to adapt more flexibly to different problem landscapes.", "configspace": "", "generation": 10, "fitness": 0.8790343984532436, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.012. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8906607755591025, 0.8842375645774688, 0.8622048552231598], "final_y": [0.1189264547716955, 0.11928157946668727, 0.11939979017988267]}, "mutation_prompt": null}
{"id": "50556d89-5454-4e5b-8c79-04dc7e329790", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.97  # Adjusted cooling rate\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(p) for p in positions])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 * (1 - (evaluations / self.budget)**2)  # Non-linear inertia weight\n                self.cognitive_weight = 1.5 + (0.5 * (evaluations / self.budget))  # Slightly adjusted cognitive weight\n                self.social_weight = 1.5 - (0.7 * (evaluations / self.budget))  # More dynamic social weight\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_weight * np.random.rand() * (personal_best_positions[i] - positions[i]) +\n                               self.social_weight * np.random.rand() * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocity[i], lb, ub)\n                \n                current_score = func(positions[i])\n                evaluations += 1\n                \n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = positions[i]\n                    \n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = positions[i]\n            \n            # Adaptive mutation based on convergence rate\n            mutation_factor = np.exp(-evaluations / self.budget)\n            best_candidate = global_best_position + mutation_factor * np.random.normal(0, 1, self.dim)\n            best_candidate = np.clip(best_candidate, lb, ub)\n            best_candidate_score = func(best_candidate)\n            evaluations += 1\n            \n            if best_candidate_score < global_best_score or np.random.rand() < np.exp((global_best_score - best_candidate_score) / self.temperature):\n                global_best_position = best_candidate\n                global_best_score = best_candidate_score\n            \n            self.temperature *= self.cooling_rate\n        \n        return global_best_position", "name": "HybridPSO_SA", "description": "Introduce adaptive mutation based on convergence rate and non-linear inertia weight adaptation for improved exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8707823915824013, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.010. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d47f8f1a-3367-484e-b50c-486e2eecee85", "metadata": {"aucs": [0.8768516984344177, 0.8568993408865847, 0.8785961354262017], "final_y": [0.1213876295428058, 0.12407017480604587, 0.12167261936392293]}, "mutation_prompt": null}
