{"id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "A novel swarm-based metaheuristic inspired by flocking behavior of birds, where agents adaptively adjust their exploration and exploitation by dynamically balancing local and global search based on the quality of solutions found.", "configspace": "", "generation": 0, "fitness": 0.860792849686885, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.008. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8576920036483033, 0.8523962961650402, 0.8722902492473114], "final_y": [0.13080292809433447, 0.13617186830162054, 0.12354272349717565]}, "mutation_prompt": null}
{"id": "43c4b985-dd56-4ad7-b32d-384009d4576a", "solution": "import numpy as np\n\nclass HGPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.inertia_weight = 0.5\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = personal_best_scores.min()\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Update velocities and positions based on PSO\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (personal_best - population) +\n                          self.social_coef * r2 * (global_best - population))\n            population = population + velocities\n            \n            # Ensure bounds\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate population\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # Update personal and global bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best[better_mask] = population[better_mask]\n            \n            if personal_best_scores.min() < global_best_score:\n                global_best_score = personal_best_scores.min()\n                global_best = personal_best[personal_best_scores.argmin()]\n            \n            # Genetic operators: crossover and mutation\n            if evaluations < self.budget:\n                for i in range(0, self.population_size, 2):\n                    if evaluations >= self.budget: break\n                    if np.random.rand() < self.crossover_rate:\n                        cross_point = np.random.randint(1, self.dim - 1)\n                        offspring1 = np.concatenate((population[i, :cross_point], population[i + 1, cross_point:]))\n                        offspring2 = np.concatenate((population[i + 1, :cross_point], population[i, cross_point:]))\n                        population[i], population[i + 1] = offspring1, offspring2\n                        scores[i], scores[i + 1] = func(offspring1), func(offspring2)\n                        evaluations += 2\n                    \n                    if evaluations < self.budget and np.random.rand() < self.mutation_rate:\n                        mutation_idx = np.random.randint(0, self.dim)\n                        population[i, mutation_idx] = np.random.uniform(lb[mutation_idx], ub[mutation_idx])\n                        scores[i] = func(population[i])\n                        evaluations += 1\n\n        return global_best, global_best_score", "name": "HGPSO", "description": "Hybrid Genetic Particle Swarm Optimization (HGPSO) combines genetic crossover and mutation with particle swarm intelligence to explore and exploit the search space effectively.", "configspace": "", "generation": 0, "fitness": 0.797120796828624, "feedback": "The algorithm HGPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.012. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7815774678535606, 0.8097723816753213, 0.80001254095699], "final_y": [0.14677179729222378, 0.14036845378818652, 0.15244671569567747]}, "mutation_prompt": null}
{"id": "445813c2-cc3d-4ab8-af9f-6255b659ad9f", "solution": "import numpy as np\n\nclass HGPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.inertia_weight = 0.9\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = personal_best_scores.min()\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (personal_best - population) +\n                          self.social_coef * r2 * (global_best - population))\n            population = population + velocities\n            population = np.clip(population, lb, ub)\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best[better_mask] = population[better_mask]\n            \n            if personal_best_scores.min() < global_best_score:\n                global_best_score = personal_best_scores.min()\n                global_best = personal_best[personal_best_scores.argmin()]\n\n            # Adaptive inertia weight\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)\n            \n            if np.std(scores) < self.diversity_threshold and evaluations < self.budget:\n                mutation_idx = np.random.randint(0, self.dim, size=self.population_size)\n                mutation_values = np.random.uniform(lb, ub, size=self.population_size)\n                population[np.arange(self.population_size), mutation_idx] = mutation_values\n                scores = np.array([func(ind) for ind in population])\n                evaluations += self.population_size\n\n            if evaluations < self.budget:\n                for i in range(0, self.population_size, 2):\n                    if evaluations >= self.budget: break\n                    if np.random.rand() < self.crossover_rate:\n                        cross_point = np.random.randint(1, self.dim - 1)\n                        offspring1 = np.concatenate((population[i, :cross_point], population[i + 1, cross_point:]))\n                        offspring2 = np.concatenate((population[i + 1, :cross_point], population[i, cross_point:]))\n                        population[i], population[i + 1] = offspring1, offspring2\n                        scores[i], scores[i + 1] = func(offspring1), func(offspring2)\n                        evaluations += 2\n                    \n                    if evaluations < self.budget and np.random.rand() < self.mutation_rate:\n                        mutation_idx = np.random.randint(0, self.dim)\n                        population[i, mutation_idx] = np.random.uniform(lb[mutation_idx], ub[mutation_idx])\n                        scores[i] = func(population[i])\n                        evaluations += 1\n\n        return global_best, global_best_score", "name": "HGPSO", "description": "Enhanced HGPSO with adaptive parameters and diversity maintenance to improve exploration and convergence speed.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).')", "parent_id": "43c4b985-dd56-4ad7-b32d-384009d4576a", "metadata": {}, "mutation_prompt": null}
{"id": "f1bbbdd3-1209-4332-a2a4-59c038728bad", "solution": "import numpy as np\n\nclass HGPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.inertia_weight = 0.9  # Modified for adaptive adjustment\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = personal_best_scores.min()\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Update velocities and positions based on PSO\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.4 + 0.5 * ((self.budget - evaluations) / self.budget)  # Adaptive inertia weight update\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (personal_best - population) +\n                          self.social_coef * r2 * (global_best - population))\n            population = population + velocities\n            \n            # Ensure bounds\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate population\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # Update personal and global bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best[better_mask] = population[better_mask]\n            \n            if personal_best_scores.min() < global_best_score:\n                global_best_score = personal_best_scores.min()\n                global_best = personal_best[personal_best_scores.argmin()]\n            \n            # Genetic operators: crossover and mutation\n            if evaluations < self.budget:\n                for i in range(0, self.population_size, 2):\n                    if evaluations >= self.budget: break\n                    if np.random.rand() < self.crossover_rate:\n                        cross_point = np.random.randint(1, self.dim - 1)\n                        offspring1 = np.concatenate((population[i, :cross_point], population[i + 1, cross_point:]))\n                        offspring2 = np.concatenate((population[i + 1, :cross_point], population[i, cross_point:]))\n                        population[i], population[i + 1] = offspring1, offspring2\n                        scores[i], scores[i + 1] = func(offspring1), func(offspring2)\n                        evaluations += 2\n                    \n                    if evaluations < self.budget and np.random.rand() < self.mutation_rate:\n                        mutation_idx = np.random.randint(0, self.dim)\n                        population[i, mutation_idx] = np.random.uniform(lb[mutation_idx], ub[mutation_idx])\n                        scores[i] = func(population[i])\n                        evaluations += 1\n\n        return global_best, global_best_score", "name": "HGPSO", "description": "Modified Hybrid Genetic Particle Swarm Optimization (HGPSO) with adaptive inertia weight adjustment for enhanced exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).')", "parent_id": "43c4b985-dd56-4ad7-b32d-384009d4576a", "metadata": {}, "mutation_prompt": null}
{"id": "2af70a50-3622-441b-b449-ce10395b4ff4", "solution": "import numpy as np\n\nclass HGPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.inertia_weight = 0.9  # Change: starting higher for better exploration\n        self.inertia_weight_min = 0.4  # Change: add minimum inertia weight for adaptation\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = personal_best_scores.min()\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Update velocities and positions based on PSO\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            # Change: Adaptive inertia weight based on budget usage\n            self.inertia_weight = self.inertia_weight_min + (0.9 - self.inertia_weight_min) * (1 - evaluations / self.budget)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (personal_best - population) +\n                          self.social_coef * r2 * (global_best - population))\n            population = population + velocities\n            \n            # Ensure bounds\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate population\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # Update personal and global bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best[better_mask] = population[better_mask]\n            \n            if personal_best_scores.min() < global_best_score:\n                global_best_score = personal_best_scores.min()\n                global_best = personal_best[personal_best_scores.argmin()]\n            \n            # Genetic operators: crossover and mutation\n            if evaluations < self.budget:\n                for i in range(0, self.population_size, 2):\n                    if evaluations >= self.budget: break\n                    if np.random.rand() < self.crossover_rate:\n                        cross_point = np.random.randint(1, self.dim - 1)\n                        offspring1 = np.concatenate((population[i, :cross_point], population[i + 1, cross_point:]))\n                        offspring2 = np.concatenate((population[i + 1, :cross_point], population[i, cross_point:]))\n                        population[i], population[i + 1] = offspring1, offspring2\n                        scores[i], scores[i + 1] = func(offspring1), func(offspring2)\n                        evaluations += 2\n                    \n                    if evaluations < self.budget and np.random.rand() < self.mutation_rate:\n                        mutation_idx = np.random.randint(0, self.dim)\n                        population[i, mutation_idx] = np.random.uniform(lb[mutation_idx], ub[mutation_idx])\n                        scores[i] = func(population[i])\n                        evaluations += 1\n\n        return global_best, global_best_score", "name": "HGPSO", "description": "Enhanced HGPSO with adaptive inertia to dynamically balance exploration and exploitation based on convergence progress.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).')", "parent_id": "43c4b985-dd56-4ad7-b32d-384009d4576a", "metadata": {}, "mutation_prompt": null}
{"id": "7961d2ca-46b7-47d5-a52b-d95aa7f690eb", "solution": "import numpy as np\n\nclass HGPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        # Adaptive inertia weight parameters\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = personal_best_scores.min()\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Update inertia weight\n            self.inertia_weight = self.inertia_weight_min + (self.inertia_weight - self.inertia_weight_min) * (self.budget - evaluations) / self.budget\n            \n            # Update velocities and positions based on PSO\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (personal_best - population) +\n                          self.social_coef * r2 * (global_best - population))\n            population = population + velocities\n            \n            # Ensure bounds\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate population\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # Update personal and global bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best[better_mask] = population[better_mask]\n            \n            if personal_best_scores.min() < global_best_score:\n                global_best_score = personal_best_scores.min()\n                global_best = personal_best[personal_best_scores.argmin()]\n            \n            # Genetic operators: crossover and mutation\n            if evaluations < self.budget:\n                for i in range(0, self.population_size, 2):\n                    if evaluations >= self.budget: break\n                    if np.random.rand() < self.crossover_rate:\n                        cross_point = np.random.randint(1, self.dim - 1)\n                        offspring1 = np.concatenate((population[i, :cross_point], population[i + 1, cross_point:]))\n                        offspring2 = np.concatenate((population[i + 1, :cross_point], population[i, cross_point:]))\n                        population[i], population[i + 1] = offspring1, offspring2\n                        scores[i], scores[i + 1] = func(offspring1), func(offspring2)\n                        evaluations += 2\n                    \n                    if evaluations < self.budget and np.random.rand() < self.mutation_rate:\n                        mutation_idx = np.random.randint(0, self.dim)\n                        population[i, mutation_idx] = np.random.uniform(lb[mutation_idx], ub[mutation_idx])\n                        scores[i] = func(population[i])\n                        evaluations += 1\n\n        return global_best, global_best_score", "name": "HGPSO", "description": "Enhanced HGPSO by integrating adaptive inertia weights and elite preservation to improve convergence and solution quality.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20,) and arg 1 with shape (10,).')", "parent_id": "43c4b985-dd56-4ad7-b32d-384009d4576a", "metadata": {}, "mutation_prompt": null}
{"id": "d1359e0a-5ae9-4cab-9e95-821cf5ea2add", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                # Change: Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by adjusting the inertia weight dynamically based on function evaluations to better balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.8231140732730644, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.012. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8320781036579742, 0.8305062871087114, 0.8067578290525077], "final_y": [0.13240808251297542, 0.13827038415701487, 0.15270514514977773]}, "mutation_prompt": null}
{"id": "4e238dd5-1db2-463a-92dc-45c4a6ae64dc", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adaptive inertia weight based on progress\n                self.inertia_weight = 0.9 - ((0.9 - 0.4) * (evaluations / self.budget))\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with adaptive inertia weight for improved convergence through better balance of exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.825911346929928, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.005. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8273910055853653, 0.8308587268187327, 0.819484308385686], "final_y": [0.13117734555040517, 0.1390537991292896, 0.14915584876606924]}, "mutation_prompt": null}
{"id": "dc651605-1f3f-47b1-8f72-590b0a03a966", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        velocity_clamp = np.abs(ub - lb)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-velocity_clamp, velocity_clamp, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                inertia_weight_dynamic = self.inertia_weight - (self.inertia_weight - self.inertia_weight_min) * (evaluations / self.budget)\n                \n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "An enhanced swarm-based optimization algorithm integrating adaptive velocity clamping and non-linear inertia weight adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 1, "fitness": 0.8235422157618179, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8331030548278926, 0.8133029350688484, 0.8242206573887122], "final_y": [0.12605875521398646, 0.14361697432374343, 0.1343939504228897]}, "mutation_prompt": null}
{"id": "58a4df4f-6864-46d2-8ee3-0b76b6a135bc", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.final_inertia_weight = 0.4  # Final inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                inertia_weight = (self.final_inertia_weight + \n                                  (self.inertia_weight - self.final_inertia_weight) * \n                                  (self.budget - evaluations) / self.budget)\n\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with adaptive inertia weight to improve convergence by dynamically adjusting exploration and exploitation during the optimization process.", "configspace": "", "generation": 1, "fitness": 0.8193371438122266, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.018. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8380008902551783, 0.8241974517500087, 0.7958130894314928], "final_y": [0.13316528148419005, 0.14333660842369256, 0.14584452978193752]}, "mutation_prompt": null}
{"id": "f774e404-16c3-4c38-9478-40a63bdba790", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adaptive inertia weight based on evaluations\n                self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introducing adaptive inertia weight updating mechanism to enhance convergence behavior and solution quality.", "configspace": "", "generation": 1, "fitness": 0.8225112438979073, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.016. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8383790066422585, 0.8292662324057534, 0.7998884926457099], "final_y": [0.12137590687142152, 0.1457095197902467, 0.15316632225585491]}, "mutation_prompt": null}
{"id": "c92aa654-71ea-48ec-8104-e284af8df471", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.inertia_damping = 0.99  # Add inertia damping\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Local search enhancement\n                local_search_position = np.clip(population[i] + np.random.uniform(-0.1, 0.1, self.dim), lb, ub)\n                local_search_score = func(local_search_position)\n                \n                score = func(population[i])\n                evaluations += 1\n\n                if local_search_score < score:\n                    score = local_search_score\n                    population[i] = local_search_position  # Update position if local search is better\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with adaptive inertia weight and local search to improve convergence and solution quality.", "configspace": "", "generation": 1, "fitness": 0.8317618407622357, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.017. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8083265132489649, 0.84907172870093, 0.8378872803368125], "final_y": [0.13867409717948576, 0.13877619692356702, 0.13341248854928078]}, "mutation_prompt": null}
{"id": "5cb24586-4d33-4b62-ad21-27f3b121cd2d", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Modified initial inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Dynamic inertia weight\n                inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n                \n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with dynamic inertia weight based on iteration progress and an elite selection mechanism to improve convergence and solution quality.", "configspace": "", "generation": 2, "fitness": 0.8505903695434949, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.851 with standard deviation 0.019. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8753956089082814, 0.845786870601203, 0.8305886291210003], "final_y": [0.11452979364587124, 0.13473432238799565, 0.13648251347034535]}, "mutation_prompt": null}
{"id": "d98e9dda-3941-4c5a-98ef-e471ed07aeae", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Increased inertia weight for greater exploration initially\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Introduce chaotic local search using sine function\n                sine_factor = np.sin(np.pi * evaluations / self.budget)  # Line changed\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 sine_factor * velocities[i])  # Line changed\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved swarm-based optimizer with dynamic inertia weight and chaotic local search for enhanced exploration and convergence.", "configspace": "", "generation": 2, "fitness": 0.836716157357631, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.029. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8000569852019552, 0.8399913521866071, 0.8701001346843309], "final_y": [0.15404716084079317, 0.12960587825737824, 0.11781686629906118]}, "mutation_prompt": null}
{"id": "9a9dce04-8eb3-4204-8dd7-623018479e87", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed line\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        # Chaotic initialization using sinusoidal function for enhanced diversity\n        population = lb + (ub - lb) * np.abs(np.sin(np.random.rand(self.population_size, self.dim) * np.pi))  # Changed line\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adaptive inertia weight linearly decreasing over time for balance\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Changed line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduce adaptive inertia weight to balance exploration and exploitation dynamically, and implement chaotic initialization for enhanced global search.", "configspace": "", "generation": 2, "fitness": 0.8237061841564352, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.044. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.7645106974719218, 0.8679233591049551, 0.8386844958924289], "final_y": [0.16583294790795222, 0.1286411706270505, 0.13398959716747483]}, "mutation_prompt": null}
{"id": "3c5dd3d4-cef9-47e6-b439-ffee2de578c4", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.inertia_damping = 0.99  # Add inertia damping\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)  # Dynamically adjust social weight\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Local search enhancement\n                local_search_position = np.clip(population[i] + np.random.uniform(-0.1, 0.1, self.dim), lb, ub)\n                local_search_score = func(local_search_position)\n                \n                score = func(population[i])\n                evaluations += 1\n\n                if local_search_score < score:\n                    score = local_search_score\n                    population[i] = local_search_position  # Update position if local search is better\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced a dynamic social weight adjustment to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.8401739792696724, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.019. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "c92aa654-71ea-48ec-8104-e284af8df471", "metadata": {"aucs": [0.8166963510515092, 0.8627510198232538, 0.8410745669342541], "final_y": [0.1417267105376281, 0.12722337507174353, 0.1354716771571549]}, "mutation_prompt": null}
{"id": "eb5a0a21-5454-498f-868a-c2a732a24d80", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.inertia_damping = 0.99  # Add inertia damping\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -0.1, 0.1)  # Velocity clamping\n\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Local search enhancement\n                local_search_position = np.clip(population[i] + np.random.uniform(-0.1, 0.1, self.dim), lb, ub)\n                local_search_score = func(local_search_position)\n                \n                score = func(population[i])\n                evaluations += 1\n\n                if local_search_score < score:\n                    score = local_search_score\n                    population[i] = local_search_position  # Update position if local search is better\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced a velocity clamping mechanism to limit maximum velocity and enhance stability.", "configspace": "", "generation": 2, "fitness": 0.783370078655096, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.783 with standard deviation 0.077. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.038.", "error": "", "parent_id": "c92aa654-71ea-48ec-8104-e284af8df471", "metadata": {"aucs": [0.6750790378882379, 0.8364204233958756, 0.8386107746811748], "final_y": [0.2109537321215902, 0.1266293689515654, 0.13294286821903956]}, "mutation_prompt": null}
{"id": "13f3bdba-6c70-40a7-8972-a7514817a499", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by dynamically adjusting inertia weight based on iteration to balance exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.8710352259447568, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.012. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8543692442794437, 0.8757136485492916, 0.8830227850055354], "final_y": [0.1306220155108131, 0.12345006264695768, 0.1158840461154017]}, "mutation_prompt": null}
{"id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for more emphasis on exploration initially\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:  # No change\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added non-linear decay for inertia weight\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by incorporating non-linear inertia weight decay for better exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8646083313681633, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.032. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.8300599576397628, 0.855783159448242, 0.9079818770164849], "final_y": [0.13971687856058734, 0.1282553516272723, 0.11278903983423061]}, "mutation_prompt": null}
{"id": "b37021e4-fdb7-49b3-bbb1-316e64373edd", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.inertia_damping = 0.98  # Change inertia damping\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Local search enhancement\n                local_search_position = np.clip(population[i] + np.random.uniform(-0.2, 0.2, self.dim), lb, ub)  # Increase search range\n                local_search_score = func(local_search_position)\n                \n                score = func(population[i])\n                evaluations += 1\n\n                if local_search_score < score:\n                    score = local_search_score\n                    population[i] = local_search_position  # Update position if local search is better\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "A refined SwarmOptimizer with improved inertia damping and enhanced local search exploration for better convergence.", "configspace": "", "generation": 2, "fitness": 0.8390918874453362, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.038. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "c92aa654-71ea-48ec-8104-e284af8df471", "metadata": {"aucs": [0.8066625338509119, 0.8921793196404206, 0.8184338088446763], "final_y": [0.14339286980620136, 0.11790696949606194, 0.1438554616607418]}, "mutation_prompt": null}
{"id": "31449cdf-2b7f-41e1-b065-7d6c730d84dd", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7  # Slightly increased inertia for better exploration\n        self.social_weight = 1.5\n        self.cognitive_weight = 2.0  # Enhanced cognitive weight for personal best attraction\n        self.min_inertia_weight = 0.4  # Minimum inertia weight for dynamic adaptation\n        self.max_inertia_weight = 0.9  # Maximum inertia weight for dynamic adaptation\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Adjusted velocity initialization\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Dynamic inertia weight adaptation based on iterations\n                self.inertia_weight = self.max_inertia_weight - (self.max_inertia_weight - self.min_inertia_weight) * (evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n\n                # Velocity clamping to prevent excessive speed\n                velocities[i] = np.clip(velocities[i], -0.5, 0.5)\n\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm-based algorithm incorporating adaptive dynamic learning rates and velocity clamping to improve exploration-exploitation balance and convergence speed.", "configspace": "", "generation": 2, "fitness": 0.7435140677085172, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.744 with standard deviation 0.044. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.6813641689418085, 0.7727038482060272, 0.7764741859777162], "final_y": [0.20060714512841338, 0.16853132799827164, 0.16099455398031104]}, "mutation_prompt": null}
{"id": "60762dfb-eba6-4d5f-9843-7882a014258f", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.social_weight = 1.5\n        self.cognitive_weight = 2.0  # Adjusted cognitive weight\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -0.5, 0.5)  # Limit velocity\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "A refined swarm-based optimizer with dynamic parameter adjustments, including inertia weight and neighborhood search, to enhance convergence speed and solution precision.", "configspace": "", "generation": 2, "fitness": 0.8076497562050303, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.090. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "2b9f4e9a-6ea7-47e9-bb26-8e8eb573e7bc", "metadata": {"aucs": [0.6810670767952344, 0.8806656195261522, 0.8612165722937044], "final_y": [0.19987898584572872, 0.11733174507940869, 0.12962073885932224]}, "mutation_prompt": null}
{"id": "06dd7c4c-dd99-435f-82d4-916f95fc6925", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Dynamic social weight adjustment\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced particle movement in SwarmOptimizer by adjusting the social weight dynamically based on evaluations for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8444292487209765, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.008. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8535018550422493, 0.8460300424057003, 0.8337558487149794], "final_y": [0.13248609560024238, 0.13139556472402136, 0.13624525673808408]}, "mutation_prompt": null}
{"id": "7309701f-4d69-42dd-9b3f-f6dff899ecfd", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for more emphasis on exploration initially\n        self.social_weight = 1.7  # Adjusted from 1.5 to 1.7 for improved social influence\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:  # No change\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added non-linear decay for inertia weight\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by fine-tuning social and cognitive weights to improve convergence reliability.", "configspace": "", "generation": 3, "fitness": 0.8332502591050653, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.008. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.825036473376794, 0.8446652404737915, 0.8300490634646103], "final_y": [0.13941752298700683, 0.1269148401622292, 0.1365490684177173]}, "mutation_prompt": null}
{"id": "a29d24bb-fe22-462b-8358-abd1e9025c6b", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                self.cognitive_weight = 1.5 - (1.0 * evaluations / self.budget)  # Adaptive cognitive weight\n                self.social_weight = 1.0 + (1.0 * evaluations / self.budget)  # Adaptive social weight\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with adaptive social and cognitive weights for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.8416916422326994, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.016. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8501898998790407, 0.8197803375946286, 0.8551046892244288], "final_y": [0.12618307083236446, 0.13057937106015094, 0.12346638158000145]}, "mutation_prompt": null}
{"id": "ba6be580-043a-48d5-a15f-6b7694ea0cce", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Constriction factor added to velocity update\n                constriction_factor = 0.729\n                velocities[i] = constriction_factor * (\n                    self.inertia_weight * velocities[i] +\n                    self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                    self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced velocity update with constriction factor for improved convergence and stability.", "configspace": "", "generation": 3, "fitness": 0.8607926010431953, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.028. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8873642302316195, 0.8225868967487776, 0.8724266761491888], "final_y": [0.1184171790134162, 0.1323568812091086, 0.12255403003856125]}, "mutation_prompt": null}
{"id": "37df8400-24dd-4e7f-9263-9a1c91132f4e", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                    self.social_weight *= 1.05  # Adaptive increase\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating adaptive social weight adjustment based on performance improvement.", "configspace": "", "generation": 3, "fitness": 0.8256850640650404, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.011. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8107660364598812, 0.8305918461047759, 0.8356973096304642], "final_y": [0.140973127182626, 0.13755219788323247, 0.13243540842623502]}, "mutation_prompt": null}
{"id": "72d71ea8-7d91-43eb-92e9-7f8205b5ecf0", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.7  # Changed from 1.5 to 1.7\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "SwarmOptimizer with improved cognitive and social weights to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 3, "fitness": 0.8367747978303877, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.014. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8248157249319644, 0.8567999727444008, 0.8287086958147978], "final_y": [0.13765565020903436, 0.12551245123273236, 0.14286753757265358]}, "mutation_prompt": null}
{"id": "4d64e441-5270-462a-9efb-bc99c8255de3", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.social_weight = 1.5  # No change\n        self.cognitive_weight = 1.5  # No change\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # No change\n            # Adaptive population size change\n            if evaluations % 50 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by integrating adaptive population size for dynamic exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8359067848402261, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.836 with standard deviation 0.010. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8419957539915842, 0.8441568564066299, 0.8215677441224639], "final_y": [0.13398269800753704, 0.12417281135343483, 0.14075721009624298]}, "mutation_prompt": null}
{"id": "e7b29618-968d-44ef-9d1f-16176fcdb5df", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Modified inertia weight adjustment for enhanced exploration\n                self.inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced the exploration capability by slightly altering the inertia weight formula for better performance.", "configspace": "", "generation": 3, "fitness": 0.8528128466382731, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.022. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8840417071782265, 0.8416885671534868, 0.8327082655831058], "final_y": [0.11683282421801289, 0.13528086434481523, 0.1347729046103754]}, "mutation_prompt": null}
{"id": "bfbaf185-fce4-4633-a07b-5a3414250799", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for more emphasis on exploration initially\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:  # No change\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added non-linear decay for inertia weight\n            self.cognitive_weight = 1.5 + 0.5 * (global_best_score / np.max(personal_best_scores))  # Adaptive adjustment\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating adaptive cognitive weight adjustment to boost convergence speed.", "configspace": "", "generation": 3, "fitness": 0.8476803928259082, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.026. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8119376204372096, 0.8610279478892553, 0.8700756101512597], "final_y": [0.13802167776617125, 0.11865147290278832, 0.12262225106830116]}, "mutation_prompt": null}
{"id": "b2e5c1b0-9e6a-4b11-afce-3f1855bd636e", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        # Adjusted weights for better adaptation\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adjust social and cognitive weights dynamically\n                self.cognitive_weight = 1.5 + 0.1 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.1 * (1 - evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating adaptive social and cognitive weights to improve convergence speed and accuracy.", "configspace": "", "generation": 3, "fitness": 0.8415309153350504, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.006. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8406780063886095, 0.8340368792664731, 0.849877860350069], "final_y": [0.12853017998522898, 0.12372556310969174, 0.126192397528468]}, "mutation_prompt": null}
{"id": "502c703e-d347-416a-a721-37e721a9d273", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for more emphasis on exploration initially\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                self.social_weight = 0.5 + (self.budget - evaluations) / (2 * self.budget)  # Adjusted social weight\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:  # No change\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added non-linear decay for inertia weight\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved exploration and exploitation by dynamically adjusting social and cognitive weights based on the evaluations.", "configspace": "", "generation": 4, "fitness": 0.8577130732858542, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.002. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8548804451953544, 0.8599380700995876, 0.8583207045626206], "final_y": [0.123321559442371, 0.1231201584231254, 0.12474623169428112]}, "mutation_prompt": null}
{"id": "d9d8e128-adb0-4882-9d28-c8b88bec14cb", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adaptive weights based on function evaluations\n                self.social_weight = 0.5 + 2.0 * (1 - evaluations / self.budget)\n                self.cognitive_weight = 0.5 + 2.5 * (evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive social and cognitive weights to dynamically adjust learning influences.", "configspace": "", "generation": 4, "fitness": 0.8488026956867379, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.034. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8072264775837353, 0.849243710643576, 0.8899378988329025], "final_y": [0.12479679778717356, 0.12800409094752918, 0.11596243875285028]}, "mutation_prompt": null}
{"id": "0c225f39-768b-4719-b7cc-67fe81f12afe", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for more emphasis on exploration initially\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adaptive cognitive and social weights\n                adaptive_factor = evaluations / self.budget\n                self.cognitive_weight = 1.5 * (1 - adaptive_factor) + 0.5 * adaptive_factor\n                self.social_weight = 1.5 * adaptive_factor + 0.5 * (1 - adaptive_factor)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added non-linear decay for inertia weight\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive cognitive and social weights based on evaluations to dynamically balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8464308504652388, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.022. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8684288241956615, 0.8160641379671301, 0.8547995892329248], "final_y": [0.12123297526536414, 0.12853291461836724, 0.12459902548200508]}, "mutation_prompt": null}
{"id": "7366c6a0-3f49-47a9-b180-fa3ee0dc5bf0", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.7  # Modified social weight\n        self.cognitive_weight = 1.3  # Modified cognitive weight\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by modifying the cognitive and social weights for improved convergence speed.", "configspace": "", "generation": 4, "fitness": 0.8488829520671128, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.021. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.825332205231692, 0.8443908639068458, 0.8769257870628008], "final_y": [0.13709688499807915, 0.1222590978296183, 0.1259826490247251]}, "mutation_prompt": null}
{"id": "0636818e-043d-4797-9a74-0210761c75e8", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                # Adjust cognitive and social weights\n                self.cognitive_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 - 0.5 * (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by adjusting cognitive and social weights based on iteration to improve convergence in early phases.", "configspace": "", "generation": 4, "fitness": 0.8455684967126049, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.017. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8213889992919493, 0.8612102601854723, 0.8541062306603932], "final_y": [0.11497624065157475, 0.11741207695263334, 0.13130697955889925]}, "mutation_prompt": null}
{"id": "bab48040-c2fe-436f-be65-52926b3d33e5", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive social and cognitive weights to further balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8653229328514683, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.012. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8747430913653865, 0.8721742537667028, 0.8490514534223152], "final_y": [0.12176409226307172, 0.12729286682751384, 0.12215033099867534]}, "mutation_prompt": null}
{"id": "3d9e18f4-3a87-42d6-9ef9-5f75543a8d43", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            global_best_position += np.random.uniform(-0.1, 0.1, self.dim) * (np.random.rand(self.dim) < 0.1)  # New mutation step\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved particle diversity by introducing mutation to the best position in the swarm.", "configspace": "", "generation": 4, "fitness": 0.8494724979001038, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.006. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8420966785598454, 0.8496096558214704, 0.8567111593189953], "final_y": [0.13848844095492086, 0.12819107532033625, 0.12434492276979914]}, "mutation_prompt": null}
{"id": "45b28ae9-8e07-439e-b7c5-f57c33207de4", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # More emphasis on exploration initially\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            diversity = np.mean(np.std(population, axis=0))\n            convergence_speed = (np.max(personal_best_scores) - np.min(personal_best_scores)) / self.population_size\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                self.cognitive_weight = 2.0 / (1 + np.exp(-diversity))  # Make cognitive weight adaptive\n                self.social_weight = 2.0 / (1 + np.exp(-convergence_speed))  # Make social weight adaptive\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Non-linear decay for inertia weight\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive cognition and social coefficients based on convergence speed and diversity.", "configspace": "", "generation": 4, "fitness": 0.8110754385525921, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.011. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "88acb591-dcd4-46a1-a112-4810c73ef70c", "metadata": {"aucs": [0.8086184957406795, 0.8262224467727068, 0.7983853731443898], "final_y": [0.14804348435423786, 0.12391183118758864, 0.14996267291100307]}, "mutation_prompt": null}
{"id": "b8c55754-ba20-489a-97bc-ae5d40e4319d", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                # Adaptive social and cognitive weights\n                self.social_weight = 1.5 + 0.5 * (global_best_score / (global_best_score + 1e-5))\n                self.cognitive_weight = 1.5 + 0.5 * (personal_best_scores[i] / (personal_best_scores[i] + 1e-5))\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive social and cognitive weights based on the current performance, to further improve solution precision and convergence speed.", "configspace": "", "generation": 4, "fitness": 0.8386069816805888, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.019. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8216919463274084, 0.8655780729675195, 0.8285509257468382], "final_y": [0.140329017903023, 0.12413114667764225, 0.1327095283749472]}, "mutation_prompt": null}
{"id": "0bc85dfe-8972-49e4-9cc3-27f7744d059a", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n\n                # Randomly reset velocity to enhance exploration\n                if np.random.rand() < 0.05:\n                    velocities[i] = np.random.uniform(-1, 1, self.dim)\n                    \n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by incorporating random resetting of velocities when particles stagnate to enhance exploration.", "configspace": "", "generation": 4, "fitness": 0.8344462383948891, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.006. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8320202146879779, 0.8285254989055186, 0.8427930015911707], "final_y": [0.13847902715330396, 0.13875300655068734, 0.13436414843272482]}, "mutation_prompt": null}
{"id": "3b87bc58-56d9-4371-841b-d8e4f83963e9", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                # Adaptive population size\n                if evaluations < self.budget / 2:\n                    self.population_size = 30 + int((self.budget - evaluations) / self.budget * 10)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by introducing adaptive population size to enhance exploration and exploitation phases.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "6676e3f2-6199-48a4-9a34-0008ff1c9aef", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamic population size adjustment\n            current_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget)))\n            for i in range(current_population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduce a dynamic population size adjustment that reduces population size as evaluations approach the budget to enhance exploitation in the latter stages.", "configspace": "", "generation": 5, "fitness": 0.8460778836893373, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.033. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8078388466433859, 0.8415512154296081, 0.8888435889950179], "final_y": [0.13870775340673114, 0.12389209907837118, 0.11880930934924416]}, "mutation_prompt": null}
{"id": "a5fb0bb8-90f5-4c4f-b58e-fec5d59ee93e", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adjust cognitive and social weights dynamically\n                decay_factor = evaluations / self.budget\n                adjusted_cognitive_weight = self.cognitive_weight * (1 - decay_factor)\n                adjusted_social_weight = self.social_weight * (1 - decay_factor)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adjusted_cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 adjusted_social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing a decay factor to the cognitive and social weights for improved convergence over time.", "configspace": "", "generation": 5, "fitness": 0.8626973400261279, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.018. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8836280058803281, 0.8646731299287932, 0.8397908842692622], "final_y": [0.12132952531464247, 0.12419144454563047, 0.1361349952594465]}, "mutation_prompt": null}
{"id": "f6bdf902-cd2c-4769-aa27-e05c316e32e2", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Implementing stochastic culling and resizing population\n            worst_indices = np.argsort(personal_best_scores)[-5:]\n            population = np.delete(population, worst_indices, axis=0)\n            new_individuals = np.random.uniform(lb, ub, (5, self.dim))\n            population = np.vstack((population, new_individuals))\n            \n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced stochastic culling and dynamic population sizing to enhance exploration in adaptive swarm optimization.", "configspace": "", "generation": 5, "fitness": 0.823389428613727, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.013. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8081570932666694, 0.8220000999617578, 0.8400110926127539], "final_y": [0.14728130104204606, 0.13707069945817107, 0.1259294952466934]}, "mutation_prompt": null}
{"id": "9a8dcb83-8081-4375-8a70-0f464f6fc26f", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear inertia weight adjustment\n                self.inertia_weight = 0.9 * (1 - (evaluations / self.budget)**2)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                # Adaptive mutation\n                if np.random.rand() < 0.1:\n                    mutation = np.random.normal(0, 0.1, self.dim)\n                    population[i] = np.clip(population[i] + mutation, lb, ub)\n                else:\n                    population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing a nonlinear decline in inertia weight and adaptive mutation to enhance exploration.", "configspace": "", "generation": 5, "fitness": 0.84193181656793, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8396306765767604, 0.8345261370821286, 0.851638636044901], "final_y": [0.13043894593224736, 0.1396222121935229, 0.13282032742715677]}, "mutation_prompt": null}
{"id": "02f5dc01-9e4f-4caa-988b-5295377688fd", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear decay for inertia weight\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)**2\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Further refined SwarmOptimizer by introducing non-linear decay for inertia weight to enhance convergence rate.", "configspace": "", "generation": 5, "fitness": 0.8317608569319779, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.025. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8164988812913125, 0.8664587296153895, 0.8123249598892317], "final_y": [0.13975145782796583, 0.12240626606888216, 0.1424200549638096]}, "mutation_prompt": null}
{"id": "f1c15632-6116-4c92-9a6d-7764e11fdd91", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2, mutation = np.random.rand(), np.random.rand(), np.random.standard_normal(self.dim) * 0.01\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 mutation)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Optimized velocity update by introducing a mutation factor to foster diversity and prevent premature convergence.", "configspace": "", "generation": 5, "fitness": 0.8344020399148911, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.020. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8181561262437422, 0.8227066503454981, 0.8623433431554329], "final_y": [0.14285088209122876, 0.12732664671748406, 0.12298505586770148]}, "mutation_prompt": null}
{"id": "8785afa8-f81d-48d1-8490-1bc63b8d2649", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adjusted inertia weight decay\n                self.inertia_weight = 0.9 - 0.3 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by adjusting the inertia weight decay to maintain better exploration throughout the optimization process. ", "configspace": "", "generation": 5, "fitness": 0.8391571274193838, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.006. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8354253762646758, 0.8345754633670444, 0.8474705426264313], "final_y": [0.13427830757793913, 0.13363850334068583, 0.12971499959519572]}, "mutation_prompt": null}
{"id": "4de0a3c3-24fb-4ffe-a9de-bea575424869", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive inertia weight\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n\n                # Time-varying acceleration coefficients\n                c_min, c_max = 0.5, 2.5\n                self.social_weight = c_min + (c_max - c_min) * (evaluations / self.budget)\n                self.cognitive_weight = c_max - (c_max - c_min) * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by employing a time-varying acceleration coefficient strategy to dynamically adjust control parameters, further refining the balance between exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.8530299751487821, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.029. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8526918706727135, 0.8177708182349921, 0.8886272365386405], "final_y": [0.12056125826081188, 0.13441772808724683, 0.11406481419258585]}, "mutation_prompt": null}
{"id": "e31e1503-6dc7-4171-9b29-bd6e41f9453e", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget)**2)  # Non-linear decay for inertia_weight\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing non-linear velocity decay for better convergence control.", "configspace": "", "generation": 5, "fitness": 0.8263252069136301, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.051. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.7541811864384631, 0.8603883671312196, 0.8644060671712077], "final_y": [0.17377060325026006, 0.1270335351632993, 0.11862798647583472]}, "mutation_prompt": null}
{"id": "f4dbc0be-b4be-407f-aaac-ad314ee04245", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.population_size = 30 + int(10 * (1 - evaluations / self.budget))  # Dynamic population size adjustment\n            population = np.vstack([population, np.random.uniform(lb, ub, (self.population_size - len(population), self.dim))])  # Adjust population size\n            velocities = np.vstack([velocities, np.random.uniform(-1, 1, (self.population_size - len(velocities), self.dim))])\n\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating a dynamic population size to improve diversity and convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "3e6a0dcc-d8ed-48e6-bf5e-61425c1206fe", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamic population size\n            self.population_size = max(5, int(30 * (1 - evaluations / self.budget)))\n            \n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing a dynamic population size that decreases over time to focus exploration in early stages and emphasize exploitation in later stages.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {}, "mutation_prompt": null}
{"id": "07d1aa17-3d65-4601-a175-9ac6ff3c75e4", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                # Velocity clamping\n                velocities[i] = np.clip(velocities[i], -0.1, 0.1)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing a velocity clamping mechanism to prevent excessive exploration and maintain stability.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {}, "mutation_prompt": null}
{"id": "9d587eac-9137-40b4-b766-ef8db88884ac", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added random perturbation\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced random perturbation to velocities for enhanced diversity and convergence in the SwarmOptimizer.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {}, "mutation_prompt": null}
{"id": "bad8050c-9e55-49ad-8282-3ec6fec66115", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear inertia weight reduction\n                self.inertia_weight = 0.9 - 0.5 * ((evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by using a non-linear inertia weight reduction for improved balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "01650641-9dd0-4a25-9a32-18ace6649105", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                # Time-varying cognitive and social weights\n                self.cognitive_weight = 0.5 + 2.5 * (1 - evaluations / self.budget)\n                self.social_weight = 0.5 + 2.5 * (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced exploration-exploitation trade-off by introducing time-varying cognitive and social weights.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "15908617-7b13-41cc-8861-e469756e37d5", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * ((evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                \n                # Adaptive velocity clamping\n                velocities[i] = np.clip(velocities[i], -0.1 * (ub - lb), 0.1 * (ub - lb))\n                \n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced a non-linear inertia weight adjustment and adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "b08c1cd8-7179-4318-a2de-d8da71b6897b", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget) ** 2  # Non-linear inertia decay\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n                velocities[i] = np.clip(velocities[i], -0.1, 0.1)  # Adaptive velocity clamping\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined Swarm Optimizer by introducing a non-linear inertia weight decay and adaptive velocity clamping to balance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {}, "mutation_prompt": null}
{"id": "1631b7a5-2b23-4e53-bf3b-8eac24b3a8e0", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * ((evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced inertia weight adjustment by incorporating a nonlinear decay factor for improved convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "422bb3f9-4d12-4c35-8323-50336dea58cf", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear inertia weight adjustment\n                self.inertia_weight = 0.9 * (1 - (evaluations / self.budget)**2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                # Introduce chaotic random factor\n                chaotic_factor = np.sin(evaluations)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 chaotic_factor * velocities[i])\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by integrating a nonlinear inertia weight decay and a chaotic random factor to boost exploration and convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {}, "mutation_prompt": null}
{"id": "69e412cd-2db4-40a1-bc4f-5b9b981d8745", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.population_size = self.initial_population_size + int(10 * evaluations / self.budget)  # Dynamic population\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_weight + r3) * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced random perturbation in velocity updates to enhance exploration and dynamic population size adjustment to balance solution diversity.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {}, "mutation_prompt": null}
{"id": "e3137c1e-d0e0-40e9-ae39-f56f397df19f", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)**2\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing a non-linear dynamic inertia weight adjustment to balance exploration and exploitation.", "configspace": "", "generation": 7, "fitness": 0.8002949107016324, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.041. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.858593294327493, 0.7704787648327553, 0.7718126729446486], "final_y": [0.1264491369876305, 0.1695800077942834, 0.16379276153823008]}, "mutation_prompt": null}
{"id": "2dd015e2-2f7c-417e-9eb1-638095c3d4bf", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Adjusting cognitive and social weights dynamically\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Dynamic adjustment of cognitive and social weights to enhance convergence speed without compromising exploration.", "configspace": "", "generation": 7, "fitness": 0.7923920080395441, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.792 with standard deviation 0.029. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8314076158776312, 0.7826757354700652, 0.7630926727709361], "final_y": [0.14153472491943409, 0.1629544081552653, 0.1719642896917547]}, "mutation_prompt": null}
{"id": "d5b372c1-82b5-47d8-a6e9-c9c8f347b34b", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.velocity_clamp = 0.2  # New velocity clamp factor\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Apply velocity clamping\n                velocities[i] = np.clip(\n                    self.inertia_weight * velocities[i] +\n                    self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                    self.social_weight * r2 * (global_best_position - population[i]),\n                    -self.velocity_clamp, self.velocity_clamp\n                )\n\n                # Differential evolution-inspired mutation for exploration\n                if np.random.rand() < 0.1:\n                    idxs = [j for j in range(self.population_size) if j != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutant = a + 0.8 * (b - c)  # Mutation step\n                    population[i] = np.clip(mutant, lb, ub)\n                else:\n                    population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating an adaptive velocity clamping mechanism and differential evolution-inspired mutation to boost exploration.", "configspace": "", "generation": 7, "fitness": 0.777219800131637, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.777 with standard deviation 0.015. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.7986570258010883, 0.770198250928454, 0.7628041236653686], "final_y": [0.1524996328656124, 0.16970480646868713, 0.1721291468293351]}, "mutation_prompt": null}
{"id": "695d3f96-71c6-46c6-86a4-f8e196464837", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear adaptive inertia weight\n                self.inertia_weight = 0.4 + 0.5 * np.cos((evaluations / self.budget) * np.pi)\n                # Nonlinear adaptive weights\n                self.social_weight = 1.5 + 0.5 * np.sin((evaluations / self.budget) * np.pi)\n                self.cognitive_weight = 1.5 - 0.5 * np.cos((evaluations / self.budget) * np.pi)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with nonlinear adaptive inertia, cognitive and social weights for improved convergence. ", "configspace": "", "generation": 7, "fitness": 0.7906639376550858, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.027. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8287515592742556, 0.76890311738062, 0.7743371363103817], "final_y": [0.13742936186030474, 0.1702433386818767, 0.16389983962380972]}, "mutation_prompt": null}
{"id": "ed8e4d2d-87f9-40d5-bbd6-7c018e4c3552", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                # Time-varying cognitive weight adjustment\n                self.cognitive_weight = 0.5 + (1.5 - 0.5) * (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing a time-varying cognitive weight for improved adaptability.", "configspace": "", "generation": 7, "fitness": 0.798558595207623, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.799 with standard deviation 0.030. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8389525800636399, 0.7692105110500924, 0.7875126945091363], "final_y": [0.13151229983741974, 0.1699547629040027, 0.15770932644314717]}, "mutation_prompt": null}
{"id": "8220d65c-759e-4506-80ed-2a0edf64bfae", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.alpha = 0.5  # added for adaptive learning rate\n\n    def levy_flight(self, lam=1.5):\n        u = np.random.normal(0, 1, self.dim) * (0.01 ** (1 / lam))\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / lam))\n        return step\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 self.alpha * self.levy_flight())  # added Lvy flight\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced Lvy Flight and adaptive learning rates to enhance exploration capabilities for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.7898261791282287, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.790 with standard deviation 0.034. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8374952114403298, 0.7709095089965814, 0.7610738169477751], "final_y": [0.13569266057758445, 0.16934517378068525, 0.17296403364081692]}, "mutation_prompt": null}
{"id": "c1de2499-f5a0-428e-91d9-3795d93fefd6", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * ((evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating a non-linear dynamic inertia weight adjustment to improve convergence.", "configspace": "", "generation": 7, "fitness": 0.7992378839028396, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.799 with standard deviation 0.044. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8614597803280482, 0.7713243785780539, 0.7649294928024165], "final_y": [0.11674907838793502, 0.16914909762809172, 0.17048545516369118]}, "mutation_prompt": null}
{"id": "87a78f09-8839-4154-ac61-33c1c6188684", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                # Dynamic cognitive and social weight adjustment\n                self.cognitive_weight = 2.0 - (evaluations / self.budget)\n                self.social_weight = 2.0 - (evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced dynamic adjustment of cognitive and social weights based on function evaluations to enhance convergence.", "configspace": "", "generation": 7, "fitness": 0.7880084132132685, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.026. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8254066562838507, 0.770198250928454, 0.7684203324275012], "final_y": [0.1375379440381952, 0.16970480646868713, 0.1678316846183332]}, "mutation_prompt": null}
{"id": "d8a57be4-972b-4aa5-99a3-03a68a3014f2", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                # Adaptive mutation\n                mutation_strength = 0.1 * (1 - evaluations / self.budget)\n                mutation = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n                population[i] = np.clip(population[i] + velocities[i] + mutation, lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing time-varying adaptive mutation to maintain diversity in the search space.", "configspace": "", "generation": 7, "fitness": 0.7982199554219903, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.045. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8616633875617418, 0.7706998807385921, 0.7622965979656369], "final_y": [0.11731461101186813, 0.16947822271873392, 0.17237426206535977]}, "mutation_prompt": null}
{"id": "031566b6-ff4d-47dc-8602-72ef28556de5", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia and cognitive weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by dynamically adjusting both inertia and cognitive weights based on iteration to enhance exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.86678158053916, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.013. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8772972120894946, 0.8749988908161204, 0.848048638711865], "final_y": [0.1146180930721028, 0.11234498511522517, 0.13094169022531732]}, "mutation_prompt": null}
{"id": "cd49035a-70bd-4b35-8c0e-d0885097a448", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 2.0 - 1.5 * (evaluations / self.budget)  # Time-varying cognitive weight\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by incorporating a time-varying cognitive weight for better exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.8476644310405111, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.027. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8172219261956782, 0.8419967899610463, 0.8837745769648085], "final_y": [0.13303853438313895, 0.13616108778497882, 0.1159625965563269]}, "mutation_prompt": null}
{"id": "81334267-ee1f-49b5-a1e5-6641b43e1682", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment with nonlinear decay\n                self.inertia_weight = 0.9 - 0.4 * np.sin(np.pi * (evaluations / self.budget))\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced dynamic inertia adaptation by incorporating a nonlinear decay based on the sinusoidal function to better balance exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.8615588160476801, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.025. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8369615482232812, 0.8961659168579749, 0.8515489830617844], "final_y": [0.13839804405929113, 0.11877873932734917, 0.1229188838159001]}, "mutation_prompt": null}
{"id": "d97d1eba-1213-4dcd-a6f4-13e099ee3d00", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n                \n                # Mutation step to increase diversity\n                if np.random.rand() < 0.1:\n                    mutation = np.random.uniform(-0.1, 0.1, self.dim)\n                    population[i] = np.clip(population[i] + mutation, lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by adding mutation step to increase diversity and prevent premature convergence.", "configspace": "", "generation": 8, "fitness": 0.8678870659497089, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.022. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.8365303219398907, 0.8844527508110537, 0.8826781250981822], "final_y": [0.133488621419677, 0.12030363960991153, 0.1153216051243523]}, "mutation_prompt": null}
{"id": "1c882452-3da1-4772-a90b-c9621cfa2f6c", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget) ** 2\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing nonlinear inertia weight decay for improved balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.8560176710849298, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.031. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8185282735871005, 0.8943508203967805, 0.8551739192709085], "final_y": [0.13236319717291845, 0.11699088253726608, 0.1312381988031076]}, "mutation_prompt": null}
{"id": "f156318f-f2be-4171-8b4f-75d20a896778", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Increase population size every iteration to explore better solutions\n            self.population_size += 1\n            population = np.vstack((population, np.random.uniform(lb, ub, (1, self.dim))))\n            velocities = np.vstack((velocities, np.random.uniform(-1, 1, (1, self.dim))))\n            personal_best_positions = np.vstack((personal_best_positions, population[-1]))\n            personal_best_scores = np.append(personal_best_scores, func(population[-1]))\n\n            if evaluations >= self.budget:\n                break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by incorporating a mechanism to increase the population size dynamically to enhance exploration capabilities over iterations.", "configspace": "", "generation": 8, "fitness": 0.8559771748035465, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.006. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8509284764272907, 0.8638409788814337, 0.8531620691019152], "final_y": [0.13287283331569244, 0.12047742013813778, 0.12277155623868707]}, "mutation_prompt": null}
{"id": "935afa8c-83cc-4e72-a6bf-b3197068f7c7", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 * (1 - (evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n\n                # Velocity clamping\n                velocities[i] = np.clip(velocities[i], lb - population[i], ub - population[i])\n\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by implementing a nonlinear dynamic inertia weight and introducing a velocity clamping mechanism to improve convergence.", "configspace": "", "generation": 8, "fitness": 0.8555772417723378, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.014. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8491211489499493, 0.87486605812904, 0.8427445182380242], "final_y": [0.13218086918458005, 0.12141006896653639, 0.12842366100832825]}, "mutation_prompt": null}
{"id": "673dd190-2f4b-4dbd-b2d8-5889bdc97f21", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear inertia weight adjustment\n                self.inertia_weight = 0.9 * (1 - (evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                # Velocity clamping\n                velocities[i] = np.clip(velocities[i], -0.5, 0.5)\n\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by introducing non-linear inertia weight decay and velocity clamping to enhance stability and convergence speed.", "configspace": "", "generation": 8, "fitness": 0.8027404471943838, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.087. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.6817062144706139, 0.8817513012638525, 0.8447638258486849], "final_y": [0.20011850348654492, 0.11679656085275603, 0.1327493342668663]}, "mutation_prompt": null}
{"id": "c4d72dec-51e9-4f4d-b499-e1b44b0d6da1", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Nonlinear component added to velocity update\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 0.1 * np.sin(2 * np.pi * velocities[i])) # Modified line\n\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by adding a nonlinear component to the velocity update to enhance exploration in complex landscapes.", "configspace": "", "generation": 8, "fitness": 0.8586134705760992, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.010. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8471692681673767, 0.8725154894682625, 0.8561556540926584], "final_y": [0.1309632557336038, 0.11790899057434956, 0.1271623161233727]}, "mutation_prompt": null}
{"id": "7bacb2d4-d864-49ce-8587-1027e2f3eb68", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)  # Adaptive velocity clamping\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating adaptive velocity clamping to prevent premature convergence.", "configspace": "", "generation": 8, "fitness": 0.8707637373783245, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.025. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "bab48040-c2fe-436f-be65-52926b3d33e5", "metadata": {"aucs": [0.9045244001359282, 0.8643704986397001, 0.8433963133593452], "final_y": [0.11197275799805251, 0.1262437106136851, 0.13316728803566102]}, "mutation_prompt": null}
{"id": "26f8d2db-244c-4ac7-af90-4e83b5d82353", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                # Introduce time-varying social weight\n                self.social_weight = 1.5 + (0.5 * (evaluations / self.budget))\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by introducing a time-varying social weight to adaptively balance exploration and exploitation over time.", "configspace": "", "generation": 9, "fitness": 0.8758833524789796, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.008. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8744030119634356, 0.867185681826939, 0.8860613636465641], "final_y": [0.11929735157266996, 0.11805652591932603, 0.11725010687188886]}, "mutation_prompt": null}
{"id": "9e9138d3-741f-4c4d-914e-4ef1ee166044", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * np.sin((evaluations / self.budget) * np.pi / 2)  # Nonlinear dynamic adjustment\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)  # Adaptive velocity clamping\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by incorporating a nonlinear dynamic inertia weight adjustment to improve exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.884337016302667, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.005. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "7bacb2d4-d864-49ce-8587-1027e2f3eb68", "metadata": {"aucs": [0.8774825113928694, 0.8866338187941765, 0.8888947187209552], "final_y": [0.12132169205539256, 0.11336967430813683, 0.11348630481581379]}, "mutation_prompt": null}
{"id": "a6a29b5f-b8d9-4624-b75d-ecc0c7e4443e", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            current_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Change here\n            for i in range(min(self.population_size, current_population_size)):  # Adjust loop for varying population\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                # Adaptive weights\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)  # Adaptive velocity clamping\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced time-varying population size to enhance balance between exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.8845535665372171, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.013. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7bacb2d4-d864-49ce-8587-1027e2f3eb68", "metadata": {"aucs": [0.8996024036128621, 0.8860856385086949, 0.867972657490094], "final_y": [0.11588200114886771, 0.12033971650091102, 0.1234552888964664]}, "mutation_prompt": null}
{"id": "9f2cb53f-e72f-44d3-9c7d-82d848cf929f", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * np.sin((evaluations / self.budget) * (np.pi / 2))\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by introducing a non-linear dynamic inertia adjustment to better balance exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.8821296136622282, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.021. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8529203732393738, 0.8934892610566008, 0.8999792066907101], "final_y": [0.13069002592137569, 0.11654413132479202, 0.11407299717719488]}, "mutation_prompt": null}
{"id": "e7483fb7-7db9-41b5-9c07-d6c128bf3d10", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        stagnation_counter = np.zeros(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                    stagnation_counter[i] = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter[i] += 1\n                    \n                if stagnation_counter[i] > 10:  # Reinitialize particle if stagnating\n                    population[i] = np.random.uniform(lb, ub, self.dim)\n                    stagnation_counter[i] = 0\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by augmenting population diversity with random reinitialization of stagnating particles to avoid local optima.", "configspace": "", "generation": 9, "fitness": 0.8911186018261844, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.019. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7bacb2d4-d864-49ce-8587-1027e2f3eb68", "metadata": {"aucs": [0.9131749239957494, 0.8923687705468595, 0.8678121109359442], "final_y": [0.1100107134971724, 0.11695473739966833, 0.11666554274582808]}, "mutation_prompt": null}
{"id": "d24f04b7-8beb-493e-93aa-9ebb7e812106", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Non-linear inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * ((evaluations / self.budget)**2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by integrating non-linear inertia weight decay to promote exploration in early stages and exploitation in later stages.", "configspace": "", "generation": 9, "fitness": 0.8646602658076964, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.028. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.825234561751649, 0.8772783971696214, 0.8914678385018187], "final_y": [0.1348454860077587, 0.1180572110694087, 0.11718693813424541]}, "mutation_prompt": null}
{"id": "320dd555-499e-4a11-9932-e661e317af48", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Improved SwarmOptimizer by incorporating dynamic population size adjustment to balance exploration and exploitation more effectively over time.", "configspace": "", "generation": 9, "fitness": 0.8934254139872934, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.016. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "7bacb2d4-d864-49ce-8587-1027e2f3eb68", "metadata": {"aucs": [0.9138403403263785, 0.8760186037564934, 0.8904172978790077], "final_y": [0.11221002076720765, 0.11901567878244357, 0.120235196806603]}, "mutation_prompt": null}
{"id": "f167dfac-f9cc-474b-8cdc-4946a1952ab1", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        local_best_positions = np.copy(personal_best_positions)  # New line\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()  # Added r3 for local influence\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]) +\n                                 0.5 * r3 * (local_best_positions[i] - population[i]))  # Local influence added\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhance the original SwarmOptimizer by introducing local best position influence, refining exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8679472693671734, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.031. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8239534203274286, 0.8955509254514278, 0.8843374623226634], "final_y": [0.13727514360491377, 0.11167829734323087, 0.1193297425277301]}, "mutation_prompt": null}
{"id": "092c1ad4-2c8a-4e91-8800-d3ec3dacea0c", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n\n                diversity = np.std(population, axis=0).mean()\n                self.social_weight = 1.5 + 0.5 * (1 - diversity)\n                self.cognitive_weight = 1.5 + 0.5 * diversity\n\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by integrating adaptive social and cognitive weights based on swarm diversity to improve convergence.", "configspace": "", "generation": 9, "fitness": 0.8260937155531103, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.091. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.038.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.7020969563916508, 0.9185496342434178, 0.8576345560242621], "final_y": [0.19726845521532632, 0.11105295876466803, 0.12160284258990917]}, "mutation_prompt": null}
{"id": "1a4d938e-98d1-48b1-9c90-50ca3b408711", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Nonlinear dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * ((evaluations / self.budget) ** 2)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by introducing a nonlinear dynamic adjustment for inertia weight based on evaluations to further enhance exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8859533151312641, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.028. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "13f3bdba-6c70-40a7-8972-a7514817a499", "metadata": {"aucs": [0.8473446483750471, 0.909343084775833, 0.9011722122429122], "final_y": [0.12584345316933954, 0.11093987588088705, 0.10988290308882953]}, "mutation_prompt": null}
{"id": "2676e8fd-7428-4017-9f50-4ba3a8c7a992", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                # Apply adaptive mutation based on evaluations\n                mutation_amount = 0.1 * (1 - evaluations / self.budget)\n                population[i] = np.clip(population[i] + velocities[i] + np.random.uniform(-mutation_amount, mutation_amount, self.dim), lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Integrate adaptive mutation strategy to enhance exploration and avoid premature convergence.", "configspace": "", "generation": 10, "fitness": 0.8897068239591993, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.890 with standard deviation 0.012. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "320dd555-499e-4a11-9932-e661e317af48", "metadata": {"aucs": [0.8740874271124969, 0.8921544848688955, 0.9028785598962057], "final_y": [0.12028213425462642, 0.11720814923103784, 0.11392349924432998]}, "mutation_prompt": null}
{"id": "d5dac70e-f055-421f-b656-3f2de7f44db8", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb) * (1 - evaluations / self.budget)  # Adaptive velocity clamping\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced adaptive velocity clamping to improve convergence stability and performance.", "configspace": "", "generation": 10, "fitness": 0.893531416171145, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.003. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "320dd555-499e-4a11-9932-e661e317af48", "metadata": {"aucs": [0.8973708560795611, 0.8914832687966326, 0.8917401236372411], "final_y": [0.1119788772919238, 0.1116412028423357, 0.1205303012147354]}, "mutation_prompt": null}
{"id": "f81d0719-5cf3-4b69-8fb7-0af83c24e6cd", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 1.0 * (evaluations / self.budget)  # Changed line\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Introduced adaptive social weight to increase global influence as the search progresses, improving global exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.886153841838599, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.012. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "320dd555-499e-4a11-9932-e661e317af48", "metadata": {"aucs": [0.9023096070188263, 0.8760408654405327, 0.8801110530564378], "final_y": [0.11201324746059782, 0.11408489147509338, 0.12149066354678684]}, "mutation_prompt": null}
{"id": "8bb3e89d-7655-45ce-bd56-5173421fa3ad", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        stagnation_counter = np.zeros(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                    stagnation_counter[i] = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter[i] += 1\n                    \n                if stagnation_counter[i] > 10:  # Reinitialize particle if stagnating\n                    population[i] = np.random.uniform(lb, ub, self.dim) + np.random.normal(0, 0.1, self.dim)\n                    stagnation_counter[i] = 0\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive mutation in stagnating particles to explore diverse regions of the search space more effectively.", "configspace": "", "generation": 10, "fitness": 0.8883034627057466, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.008. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "e7483fb7-7db9-41b5-9c07-d6c128bf3d10", "metadata": {"aucs": [0.8992621748275392, 0.882094768479555, 0.8835534448101451], "final_y": [0.11541675627360526, 0.12010666129002656, 0.12182959799728132]}, "mutation_prompt": null}
{"id": "0105cc8c-62aa-4237-9690-08aac7c9cf19", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n        self.mutation_probability = 0.1  # New parameter\n        self.mutation_strength = 0.1  # New parameter\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                if np.random.rand() < self.mutation_probability:  # Apply mutation with some probability\n                    mutation = np.random.normal(0, self.mutation_strength, self.dim)\n                    population[i] = np.clip(population[i] + mutation, lb, ub)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer by introducing adaptive mutation to diversify search, complementing the dynamic population size adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8804227716732379, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.009. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "320dd555-499e-4a11-9932-e661e317af48", "metadata": {"aucs": [0.8874284154948586, 0.8857194755430577, 0.8681204239817973], "final_y": [0.11879980760542697, 0.11632058544604063, 0.12202993142663487]}, "mutation_prompt": null}
{"id": "ed539c65-8e7d-4160-ad6e-1745c5b9a110", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        stagnation_counter = np.zeros(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                \n                v_max = 0.1 * (ub - lb) * (1 - global_best_score / (global_best_score + 0.01))  # Adaptive velocity clamping\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                    stagnation_counter[i] = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter[i] += 1\n                    \n                if stagnation_counter[i] > 10:  # Reinitialize particle if stagnating\n                    population[i] = np.random.uniform(lb, ub, self.dim)\n                    stagnation_counter[i] = 0\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhance SwarmOptimizer by integrating adaptive velocity clamping based on global best improvement rate to maintain exploration and speed up convergence.", "configspace": "", "generation": 10, "fitness": 0.8179285678702882, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.075. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "e7483fb7-7db9-41b5-9c07-d6c128bf3d10", "metadata": {"aucs": [0.7166978589384276, 0.8957995194681108, 0.8412883252043261], "final_y": [0.16592771579053467, 0.11393233373288247, 0.12803593745774888]}, "mutation_prompt": null}
{"id": "4e5ccd9c-2f8d-43f7-82ad-a0b2e508f394", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        stagnation_counter = np.zeros(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (stagnation_counter[i] / 10)  # New inertia weight update based on stagnation\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                    stagnation_counter[i] = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter[i] += 1\n                    \n                if stagnation_counter[i] > 10:  # Reinitialize particle if stagnating\n                    population[i] = np.random.uniform(lb, ub, self.dim)\n                    stagnation_counter[i] = 0\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced exploration by varying inertia weight based on particle stagnation instead of generation progress.", "configspace": "", "generation": 10, "fitness": 0.8785916987524739, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.021. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "e7483fb7-7db9-41b5-9c07-d6c128bf3d10", "metadata": {"aucs": [0.8490069313659059, 0.8929910864646421, 0.8937770784268738], "final_y": [0.12738842178773813, 0.11778410093053093, 0.11871047172866855]}, "mutation_prompt": null}
{"id": "06393ab5-cc61-4937-92bc-178af7bfe61b", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n                \n                if np.random.rand() < 0.05:  # Mutation operation\n                    population[i] += np.random.normal(0, 0.1, self.dim)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced SwarmOptimizer with adaptive inertia weight and mutation for enhanced exploration.", "configspace": "", "generation": 10, "fitness": 0.8884983126702289, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.007. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "320dd555-499e-4a11-9932-e661e317af48", "metadata": {"aucs": [0.8880193488855569, 0.8796218075249203, 0.8978537816002096], "final_y": [0.1108454730418108, 0.11948090144536605, 0.1160960059210937]}, "mutation_prompt": null}
{"id": "738e7b28-65a7-4419-a1c3-ee691d96c77e", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        stagnation_counter = np.zeros(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                # Adaptive cognitive and social weight\n                self.social_weight = 1.5 + 0.5 * (global_best_score / (personal_best_scores[i] + 1e-10))\n                self.cognitive_weight = 1.5 - 0.5 * (personal_best_scores[i] / (global_best_score + 1e-10))\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.1 * (ub - lb)\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                    stagnation_counter[i] = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter[i] += 1\n                    \n                if stagnation_counter[i] > 10:  # Reinitialize particle if stagnating\n                    population[i] = np.random.uniform(lb, ub, self.dim)\n                    stagnation_counter[i] = 0\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Enhanced particle swarm by introducing adaptive cognitive and social weights, modulating individual and collective influences dynamically.", "configspace": "", "generation": 10, "fitness": 0.8885864203298607, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.012. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e7483fb7-7db9-41b5-9c07-d6c128bf3d10", "metadata": {"aucs": [0.9044706963096483, 0.884718749775661, 0.8765698149042725], "final_y": [0.11310610467136184, 0.11596701051576841, 0.11630456807891498]}, "mutation_prompt": null}
{"id": "d4118c17-2886-41df-b9fe-edfb93985452", "solution": "import numpy as np\n\nclass SwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight = 0.5\n        self.social_weight = 1.5\n        self.cognitive_weight = 1.5\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            population_size = int(\n                self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget)\n            )\n            for i in range(population_size):\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.social_weight = 1.5 + 0.5 * (evaluations / self.budget)\n                self.cognitive_weight = 1.5 - 0.5 * (evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_weight * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_weight * r2 * (global_best_position - population[i]))\n                v_max = 0.5 * (ub - lb) * (1 - evaluations / self.budget)  # Change applied here\n                velocities[i] = np.clip(velocities[i], -v_max, v_max)\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "SwarmOptimizer", "description": "Refined SwarmOptimizer by introducing adaptive velocity clamping to enhance convergence precision.", "configspace": "", "generation": 10, "fitness": 0.8786616518677098, "feedback": "The algorithm SwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.009. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "320dd555-499e-4a11-9932-e661e317af48", "metadata": {"aucs": [0.8783912977388202, 0.8682753637962796, 0.88931829406803], "final_y": [0.11469396160897449, 0.124546515281453, 0.12044965046550116]}, "mutation_prompt": null}
