{"id": "96a10a5a-a49c-4597-8a8f-fedc621053f6", "solution": "import numpy as np\n\nclass HybridEvolutionarySwarmAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.w = 0.5  # Inertia weight\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.population_size, self.dim) * (ub - lb)\n\n    def mutate(self, target_idx, pop):\n        candidates = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(pop[a] + self.F * (pop[b] - pop[c]), 0, 1)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop = self.initialize_population(lb, ub)\n        velocities = np.random.rand(self.population_size, self.dim) * (ub - lb)\n        personal_best = pop.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                mutant = self.mutate(i, pop)\n                trial = self.crossover(pop[i], mutant)\n                trial_score = func(trial)\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial\n                    personal_best_scores[i] = trial_score\n\n                    if trial_score < global_best_score:\n                        global_best = trial\n                        global_best_score = trial_score\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (global_best - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], lb, ub)\n\n            # Encourage periodicity by modifying fitness function\n            if func.name == 'bragg':\n                pop = self.apply_periodicity_constraint(pop)\n\n        return global_best\n\n    def apply_periodicity_constraint(self, pop):\n        # Enforce periodicity in the solution\n        for i in range(self.population_size):\n            pop[i] = np.tile(np.mean(pop[i].reshape(-1, 2), axis=0), self.dim // 2)\n        return pop\n\n    def __call__(self, func):\n        best_solution = self.optimize(func)\n        return best_solution\n\n# Example usage:\n# optimizer = HybridEvolutionarySwarmAlgorithm(budget=1000, dim=20)\n# best_solution = optimizer(func)", "name": "HybridEvolutionarySwarmAlgorithm", "description": "Hybrid Evolutionary-Swarm Algorithm (HESA) that combines Differential Evolution for global exploration with Particle Swarm Optimization for local refinement, incorporating periodicity-promoting constraints to optimize multilayer structures.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 281, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 143, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 71, in __call__\n  File \"<string>\", line 59, in optimize\nAttributeError: 'ioh.iohcpp.problem.RealSingleObjectiveWrappedProbl' object has no attribute 'name'\n.", "error": "AttributeError(\"'ioh.iohcpp.problem.RealSingleObjectiveWrappedProbl' object has no attribute 'name'\")Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 281, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 143, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 71, in __call__\n  File \"<string>\", line 59, in optimize\nAttributeError: 'ioh.iohcpp.problem.RealSingleObjectiveWrappedProbl' object has no attribute 'name'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "A hybrid Differential Evolution with periodicity encouragement, utilizing global exploration with periodicity-aware local search to optimize multilayer photonic structures effectively.", "configspace": "", "generation": 0, "fitness": 0.9785910160958465, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.9752494152235853, 0.977248946345406, 0.983274686718548], "final_y": [0.16485603832335616, 0.16485656906426904, 0.16486073521745614]}, "mutation_prompt": null}
{"id": "78d6c13b-2e31-4b7c-a7cf-f5bb15b9ff65", "solution": "import numpy as np\n\nclass EnhancedHybridEvolutionarySwarmAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient, increased for better convergence\n        self.w = 0.5  # Inertia weight\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.population_size, self.dim) * (ub - lb)\n\n    def mutate(self, target_idx, pop):\n        candidates = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(pop[a] + self.F * (pop[b] - pop[c]), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop = self.initialize_population(lb, ub)\n        velocities = np.random.rand(self.population_size, self.dim) * (ub - lb)\n        personal_best = pop.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                mutant = self.mutate(i, pop)\n                trial = self.crossover(pop[i], mutant)\n                trial_score = func(trial)\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial\n                    personal_best_scores[i] = trial_score\n\n                    if trial_score < global_best_score:\n                        global_best = trial\n                        global_best_score = trial_score\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (global_best - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], lb, ub)\n\n            pop = self.apply_periodicity_constraint(pop)\n\n        return global_best\n\n    def apply_periodicity_constraint(self, pop):\n        for i in range(self.population_size):\n            period = self.dim // 2\n            repeat_unit = np.mean(pop[i].reshape(-1, 2), axis=0)\n            pop[i] = np.tile(repeat_unit, period)\n        return pop\n\n    def __call__(self, func):\n        best_solution = self.optimize(func)\n        return best_solution\n\n# Example usage:\n# optimizer = EnhancedHybridEvolutionarySwarmAlgorithm(budget=1000, dim=20)\n# best_solution = optimizer(func)", "name": "EnhancedHybridEvolutionarySwarmAlgorithm", "description": "Enhanced Hybrid Evolutionary-Swarm Algorithm (HESA+) integrating adaptive parameter tuning and robust periodic constraints to optimize multilayer photonic structures with improved global exploration and local refinement.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'lb' is not defined\").", "error": "NameError(\"name 'lb' is not defined\")", "parent_id": "96a10a5a-a49c-4597-8a8f-fedc621053f6", "metadata": {}, "mutation_prompt": null}
{"id": "8583e551-0908-4cfa-836f-2ce12507abd2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.adaptive_rate = 0.05\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.population_size, self.dim) * (ub - lb)\n\n    def mutate(self, target_idx, pop):\n        candidates = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(pop[a] + self.F * (pop[b] - pop[c]), 0, 1)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_optimization(self, pop, func, lb, ub):\n        for i in range(self.population_size):\n            result = minimize(func, pop[i], bounds=np.array(list(zip(lb, ub))), method='L-BFGS-B')\n            pop[i] = result.x\n        return pop\n\n    def optimize(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop = self.initialize_population(lb, ub)\n        scores = np.array([func(ind) for ind in pop])\n        best_idx = np.argmin(scores)\n        global_best = pop[best_idx]\n        global_best_score = scores[best_idx]\n\n        evals = self.population_size\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i, pop)\n                trial = self.crossover(pop[i], mutant)\n                trial_score = func(trial)\n\n                if trial_score < scores[i]:\n                    pop[i] = trial\n                    scores[i] = trial_score\n\n                    if trial_score < global_best_score:\n                        global_best = trial\n                        global_best_score = trial_score\n\n            # Apply local optimization periodically\n            if evals % (self.population_size * 5) == 0:\n                pop = self.local_optimization(pop, func, lb, ub)\n                scores = np.array([func(ind) for ind in pop])\n                best_idx = np.argmin(scores)\n                global_best = pop[best_idx]\n                global_best_score = scores[best_idx]\n\n            # Dynamically adapt search parameters\n            self.F = max(0.5, self.F - self.adaptive_rate)\n            self.CR = min(0.9, self.CR + self.adaptive_rate)\n\n            evals += self.population_size\n\n        return global_best\n\n    def __call__(self, func):\n        best_solution = self.optimize(func)\n        return best_solution\n\n# Example usage:\n# optimizer = AdaptiveMemeticAlgorithm(budget=1000, dim=20)\n# best_solution = optimizer(func)", "name": "AdaptiveMemeticAlgorithm", "description": "Adaptive Memetic Algorithm that integrates Differential Evolution for global exploration with a BFGS-based local optimizer, dynamically adapting search parameters to optimize multilayer photonic structures efficiently.", "configspace": "", "generation": 1, "fitness": 0.9443353885577223, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.944 with standard deviation 0.036. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "96a10a5a-a49c-4597-8a8f-fedc621053f6", "metadata": {"aucs": [0.9625440305483248, 0.9762245708653703, 0.894237564259472], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485851450227862]}, "mutation_prompt": null}
{"id": "c757bd42-b09e-493e-89e8-1a737e7ba382", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = np.random.uniform(0.5, 1.0)  # Adaptive DE scaling factor\n        self.cr = np.random.uniform(0.8, 1.0) # Adaptive Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "An enhanced Differential Evolution with adaptive scaling factor and crossover probability for improved exploration and exploitation while optimizing multilayer photonic structures.", "configspace": "", "generation": 1, "fitness": 0.976496903135709, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.976 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "metadata": {"aucs": [0.9800502121185433, 0.977249087058591, 0.9721914102299928], "final_y": [0.16485896872350925, 0.16485650569633226, 0.164855955106187]}, "mutation_prompt": null}
{"id": "ad3471f9-1a3b-4652-94e6-5ddd26fc5784", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        # Changed optimization method to 'TNC' for faster convergence\n        result = minimize(func, x0, method='TNC', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Enhanced PeriodicDEOptimizer by refining local optimization step for faster convergence.", "configspace": "", "generation": 1, "fitness": 0.9742872611902685, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.009. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "metadata": {"aucs": [0.9623365479775912, 0.9772491465856437, 0.983276089007571], "final_y": [0.164870920855134, 0.16485641213362512, 0.16485995032036094]}, "mutation_prompt": null}
{"id": "c452b0c5-fc97-4033-87d8-e1dd0c44d0ca", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                # Perform periodic swapping within the population\n                swap_idx = np.random.choice(self.population_size, 2, replace=False)\n                self.population[swap_idx[0]], self.population[swap_idx[1]] = self.population[swap_idx[1]], self.population[swap_idx[0]]\n\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Enhancing exploration by introducing periodic swapping within the population to encourage diverse searching paths.", "configspace": "", "generation": 1, "fitness": 0.9597931665867107, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.024. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "metadata": {"aucs": [0.9762620810909124, 0.9772491439685979, 0.9258682747006215], "final_y": [0.164856122030702, 0.16485639548867415, 0.18188097312615292]}, "mutation_prompt": null}
{"id": "b50b8e71-6f9f-4260-8c39-b27a4f09361b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Enhances solution refinement by applying a periodicity-aware gradient descent step after local optimization to better explore the optimization landscape.", "configspace": "", "generation": 1, "fitness": 0.980213983746184, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "metadata": {"aucs": [0.9813075622779674, 0.9772491590089046, 0.9820852299516797], "final_y": [0.1648581757730565, 0.16485644248321563, 0.16485926369863246]}, "mutation_prompt": null}
{"id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Adaptive Periodic DE with Diversity Preservation (APDE-DP) incorporates adaptive scaling factors and crossover rates while preserving population diversity to enhance exploration and convergence in optimizing multilayer photonic structures.", "configspace": "", "generation": 1, "fitness": 0.9789515649670695, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "metadata": {"aucs": [0.9752494152235853, 0.977248946345406, 0.984356333332217], "final_y": [0.16485603832335616, 0.16485656906426904, 0.1648577911829444]}, "mutation_prompt": null}
{"id": "11329600-3b00-45f1-9bf8-0dfc27519ace", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveSymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f_min, self.f_max = 0.5, 0.9  # Adaptive DE scaling factor range\n        self.cr = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Symmetric initialization\n        for i in range(self.population_size // 2):\n            self.population[self.population_size // 2 + i] = upper_bound + lower_bound - self.population[i]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = np.random.uniform(self.f_min, self.f_max)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptiveSymmetricDE", "description": "Adaptive Symmetric Differential Evolution (ASDE) with Periodicity Reinforcement, which employs adaptive scaling factors and symmetric initialization to enhance exploration while reinforcing periodic solutions in optimizing multilayer photonic structures.", "configspace": "", "generation": 1, "fitness": 0.9430701862024263, "feedback": "The algorithm AdaptiveSymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.943 with standard deviation 0.025. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "9203a976-2b32-424a-8b44-1bcfcb7b0cb0", "metadata": {"aucs": [0.9279264633609269, 0.9225238068690831, 0.978760288377269], "final_y": [0.1818851863939165, 0.18187968905672636, 0.1648568487921228]}, "mutation_prompt": null}
{"id": "5027c1d7-0b90-4999-b6d8-42c5401b8d7f", "solution": "import numpy as np\n\nclass HybridEvolutionarySwarmAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.w = 0.5  # Inertia weight\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.population_size, self.dim) * (ub - lb)\n\n    def mutate(self, target_idx, pop):\n        candidates = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(pop[a] + self.F * (pop[b] - pop[c]), 0, 1)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop = self.initialize_population(lb, ub)\n        velocities = np.random.rand(self.population_size, self.dim) * (ub - lb)\n        personal_best = pop.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        adapt_w = lambda iter, max_iter: max(0.4, self.w * (1 - iter / max_iter))\n\n        for iter in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                mutant = self.mutate(i, pop)\n                trial = self.crossover(pop[i], mutant)\n                trial_score = func(trial)\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial\n                    personal_best_scores[i] = trial_score\n\n                    if trial_score < global_best_score:\n                        global_best = trial\n                        global_best_score = trial_score\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (adapt_w(iter, self.budget // self.population_size) * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (global_best - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], lb, ub)\n\n            pop = self.apply_periodicity_constraint(pop, self.dim)\n\n        return global_best\n\n    def apply_periodicity_constraint(self, pop, dim):\n        for i in range(self.population_size):\n            period_length = dim // 4\n            pop[i] = np.tile(np.mean(pop[i].reshape(-1, period_length), axis=0), dim // period_length)\n        return pop\n\n    def __call__(self, func):\n        best_solution = self.optimize(func)\n        return best_solution", "name": "HybridEvolutionarySwarmAlgorithm", "description": "Enhanced Hybrid Evolutionary-Swarm Algorithm (EHESA) that incorporates an adaptive velocity update mechanism and improved periodicity constraints, ensuring better exploration and exploitation in optimizing multilayer photonic structures.", "configspace": "", "generation": 1, "fitness": 0.3964901296812821, "feedback": "The algorithm HybridEvolutionarySwarmAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.396 with standard deviation 0.025. And the mean value of best solutions found was 0.490 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "96a10a5a-a49c-4597-8a8f-fedc621053f6", "metadata": {"aucs": [0.40116926828217403, 0.36359203406564744, 0.4247090866960248], "final_y": [0.4851222111652522, 0.5192011663143732, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "f056db00-7849-4094-afb3-5c590809b640", "solution": "import numpy as np\n\nclass HybridEvolutionarySwarmAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.w = 0.5  # Inertia weight\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.population_size, self.dim) * (ub - lb)\n\n    def mutate(self, target_idx, pop):\n        candidates = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(pop[a] + self.F * (pop[b] - pop[c]), 0, 1)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop = self.initialize_population(lb, ub)\n        velocities = np.random.rand(self.population_size, self.dim) * (ub - lb)\n        personal_best = pop.copy()\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                mutant = self.mutate(i, pop)\n                trial = self.crossover(pop[i], mutant)\n                trial_score = func(trial)\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial\n                    personal_best_scores[i] = trial_score\n\n                    if trial_score < global_best_score:\n                        global_best = trial\n                        global_best_score = trial_score\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (global_best - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], lb, ub)\n\n            # Introduce periodic population initialization\n            if _ == 0:\n                pop = self.apply_periodicity_constraint(pop)\n\n        return global_best\n\n    def apply_periodicity_constraint(self, pop):\n        # Enforce periodicity in the solution\n        for i in range(self.population_size):\n            pop[i] = np.tile(np.mean(pop[i].reshape(-1, 2), axis=0), self.dim // 2)\n        return pop\n\n    def __call__(self, func):\n        best_solution = self.optimize(func)\n        return best_solution\n\n# Example usage:\n# optimizer = HybridEvolutionarySwarmAlgorithm(budget=1000, dim=20)\n# best_solution = optimizer(func)", "name": "HybridEvolutionarySwarmAlgorithm", "description": "Hybrid Evolutionary-Swarm Algorithm with improved periodicity constraint, leveraging periodic initialization to boost initial exploration and preserve diversity.", "configspace": "", "generation": 1, "fitness": 0.3964901296812821, "feedback": "The algorithm HybridEvolutionarySwarmAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.396 with standard deviation 0.025. And the mean value of best solutions found was 0.490 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "96a10a5a-a49c-4597-8a8f-fedc621053f6", "metadata": {"aucs": [0.40116926828217403, 0.36359203406564744, 0.4247090866960248], "final_y": [0.4851222111652522, 0.5192011663143732, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "c994b102-f49d-4506-85d2-6f258c469042", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introducing a diversity-enhanced adaptive periodic DE with competitive learning and adaptive mutation scaling to improve convergence efficiency and solution quality.", "configspace": "", "generation": 2, "fitness": 0.9813106570738817, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "metadata": {"aucs": [0.9800937014220019, 0.9835224655326021, 0.980315804267041], "final_y": [0.16485697250134346, 0.16486112897227856, 0.1648624657732709]}, "mutation_prompt": null}
{"id": "3725e849-29cf-4f54-8092-9c6ad11f3dec", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedAdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _niche_local_search(self, x, func):\n        perturbations = np.random.uniform(-0.01, 0.01, self.dim)\n        local_sol = np.clip(x + perturbations, self.bounds[0], self.bounds[1])\n        return self._local_optimize(local_sol, func)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._niche_local_search(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "EnhancedAdaptivePeriodicDEOptimizer", "description": "Enhanced Adaptive Periodic DE with Local Niching (EAPDE-LN) incorporates local niching around best solutions to improve exploration and convergence in complex optimization landscapes.", "configspace": "", "generation": 2, "fitness": 0.9785971967180428, "feedback": "The algorithm EnhancedAdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "metadata": {"aucs": [0.9752519433641678, 0.9772587744019766, 0.9832808723879836], "final_y": [0.16485690263324082, 0.16485642223688413, 0.16485927286817492]}, "mutation_prompt": null}
{"id": "510357a0-e1a9-42a9-83b3-f7375b94fc79", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        adaptive_perturbation = 0.01 * (self.best_score / np.mean([func(ind) for ind in self.population]))\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * adaptive_perturbation\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduces adaptive perturbation scaling during periodicity-aware refinement to dynamically adjust exploration potential.", "configspace": "", "generation": 2, "fitness": 0.9781930591262737, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b50b8e71-6f9f-4260-8c39-b27a4f09361b", "metadata": {"aucs": [0.9752494152235853, 0.9760546648498812, 0.9832750973053549], "final_y": [0.16485603832335616, 0.16485744903282595, 0.16485993349150818]}, "mutation_prompt": null}
{"id": "6c8457ab-7f89-46ff-b83e-9c0e2c80b32c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = np.where(j % 2 == 0, self.population[i, :period], self.population[i, :period][::-1])\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance periodicity by modifying the initialization to enforce stronger periodic patterns in alternating layers for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.9014737440490016, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.113. And the mean value of best solutions found was 0.196 (0. is the best) with standard deviation 0.044.", "error": "", "parent_id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "metadata": {"aucs": [0.7422788685484749, 0.9784829825154789, 0.9836593810830505], "final_y": [0.2578131180679175, 0.16485656906426904, 0.1648563860558021]}, "mutation_prompt": null}
{"id": "83d135c8-f01e-4087-ac67-a3dc929fbf62", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        results = [minimize(func, x0 + np.random.randn(*x0.shape) * 0.05, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)]) for _ in range(3)]\n        return min(results, key=lambda res: res.fun).x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved Adaptive Periodic DE with Dynamic Local Search (APDE-DLS) fine-tunes outcomes by selectively converting local optimization to a dynamic multi-start strategy, enhancing solution precision.", "configspace": "", "generation": 2, "fitness": 0.9793675691980009, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "metadata": {"aucs": [0.9759544841918263, 0.9784888423191256, 0.9836593810830505], "final_y": [0.16485603065080112, 0.16485972816541838, 0.1648563860558021]}, "mutation_prompt": null}
{"id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduces adaptive crossover probability based on function evaluations to improve exploration and convergence in PeriodicDEOptimizer.", "configspace": "", "generation": 2, "fitness": 0.9825670775567489, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b50b8e71-6f9f-4260-8c39-b27a4f09361b", "metadata": {"aucs": [0.9752497618027264, 0.9891754565476106, 0.9832760143199095], "final_y": [0.164855876756558, 0.16485842918581173, 0.1648598793954772]}, "mutation_prompt": null}
{"id": "518d1583-69d6-46fd-b7c0-b48b8ba34b55", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            # Dynamic scaling of population size\n            self.population_size = max(10, int(10 * self.dim * (1 - self.best_score)))\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Added a dynamic scaling of the population size based on convergence to explore more effectively.", "configspace": "", "generation": 2, "fitness": 0.8343671908899816, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.105. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "metadata": {"aucs": [0.7832284820092925, 0.7389959286864805, 0.9808771619741717], "final_y": [0.1818818275553603, 0.25781296093264705, 0.1648624657732709]}, "mutation_prompt": null}
{"id": "1100eede-73ce-4a34-a478-8576a0ecb6d4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_start = 0.8  # DE initial scaling factor\n        self.f_end = 0.4    # DE final scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, generation, max_generations):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f = self.f_start - (self.f_start - self.f_end) * (generation / max_generations)\n        mutant = self.population[a] + f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        generation = 0\n        max_generations = self.budget // self.population_size\n        \n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, generation, max_generations)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n            generation += 1\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduce a dynamic scaling factor that linearly decreases over time to improve the balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.9781193047977145, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b50b8e71-6f9f-4260-8c39-b27a4f09361b", "metadata": {"aucs": [0.9752495726741364, 0.9758324351630399, 0.983275906555967], "final_y": [0.1648559681982269, 0.16485759911682996, 0.16485985135102843]}, "mutation_prompt": null}
{"id": "ff0e1784-cb6e-4571-80be-e46e63af9fcf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_f = np.random.uniform(0.5, 1.0)  # Introducing diversity in scaling factor\n        mutant = self.population[a] + diversity_f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Implements a refined mutation strategy by introducing diversity in the differential weight to enhance exploration.", "configspace": "", "generation": 2, "fitness": 0.9769110136936047, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b50b8e71-6f9f-4260-8c39-b27a4f09361b", "metadata": {"aucs": [0.9752495189032763, 0.9722080149515813, 0.9832755072259564], "final_y": [0.16485595202937975, 0.16485629654827838, 0.16486020713549543]}, "mutation_prompt": null}
{"id": "f7daa50a-d04f-4a5f-8c89-89d765ff3b89", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n            if num_evaluations < self.budget:  # Apply additional local optimization with periodic boundary\n                periodic_solution = self._local_optimize(self.best_solution, lambda x: func(np.tile(x[:self.dim // 2], 2)))\n                periodic_score = func(periodic_solution)\n                num_evaluations += 1\n                if periodic_score < self.best_score:\n                    self.best_score = periodic_score\n                    self.best_solution = periodic_solution\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "The refined strategy incorporates periodicity reinforcement by applying an additional local optimization step using periodic boundary conditions to further enhance convergence towards optimal periodic solutions.", "configspace": "", "generation": 2, "fitness": 0.9785625671148167, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "24413c93-81d1-44b2-ae0e-ecd17aae94e1", "metadata": {"aucs": [0.9737988374428651, 0.9786141771830372, 0.983274686718548], "final_y": [0.16485746631256637, 0.1648561291127647, 0.16486073521745614]}, "mutation_prompt": null}
{"id": "2ef974d3-b23e-4b41-9c9e-6c691e3d6b8b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introducing a diversity-enhanced adaptive periodic DE with competitive learning and adaptive mutation scaling to improve convergence efficiency and solution quality.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "c994b102-f49d-4506-85d2-6f258c469042", "metadata": {"aucs": [0.9800937014220019, 0.9835224655326021, 0.980315804267041], "final_y": [0.16485697250134346, 0.16486112897227856, 0.1648624657732709]}, "mutation_prompt": null}
{"id": "73489791-e35b-4139-a435-9251ff3c7052", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.mutation_memory = np.full(self.population_size, self.f_min)\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + self.mutation_memory[target_idx] * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n                        self.mutation_memory[i] = f_adaptive\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introducing competitive mutation with adaptive memory to improve diversity and convergence in AdaptivePeriodicDEOptimizer.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'f_adaptive' is not defined\").", "error": "NameError(\"name 'f_adaptive' is not defined\")", "parent_id": "c994b102-f49d-4506-85d2-6f258c469042", "metadata": {}, "mutation_prompt": null}
{"id": "4052539c-d690-47dd-b6e0-832e6e49beb0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.4  # Changed from 0.5\n        self.f_max = 0.95  # Changed from 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced diversity by updating `self.f_min` and `self.f_max` to 0.4 and 0.95 for improved exploration and convergence.", "configspace": "", "generation": 3, "fitness": 0.9653852592730473, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.025. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c994b102-f49d-4506-85d2-6f258c469042", "metadata": {"aucs": [0.9810574146899645, 0.9295731088647188, 0.9855252542644584], "final_y": [0.16486179017087077, 0.18188032344973382, 0.1648618993986647]}, "mutation_prompt": null}
{"id": "031f92d7-6320-4846-91a8-83e96b202ec3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        best_indices = np.argsort(scores)[:2]  # Change made here: consider top 2 solutions for mutation\n        a, b = np.random.choice(best_indices, 2, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance competitive learning by using only the top two solutions for selecting mutation components to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'c' is not defined\").", "error": "NameError(\"name 'c' is not defined\")", "parent_id": "c994b102-f49d-4506-85d2-6f258c469042", "metadata": {}, "mutation_prompt": null}
{"id": "fbbcf2f9-ca42-4930-800d-131d6bf7a7e7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            # Change here: Introduce adaptive scaling factor\n            self.f = 0.5 + 0.5 * (np.std(scores) / np.mean(scores))\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduces adaptive scaling factor based on current population diversity in PeriodicDEOptimizer to improve convergence.", "configspace": "", "generation": 3, "fitness": 0.979243717727425, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9772063584568453, 0.9772491298783587, 0.9832756648470709], "final_y": [0.16486135883477937, 0.1648564182757959, 0.16486027564064942]}, "mutation_prompt": null}
{"id": "38a4e1a0-9db9-447a-96e3-8a9bf84dcb9e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with quasi-oppositional strategy\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        opposite_population = upper_bound + lower_bound - self.population\n        self.population = np.concatenate((self.population, opposite_population))\n        self.population_size *= 2\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Improved initialization by introducing quasi-oppositional strategy for better exploration in the PeriodicDEOptimizer.", "configspace": "", "generation": 3, "fitness": 0.9783628750076497, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9745631595623612, 0.9772494596627754, 0.9832760057978125], "final_y": [0.16486036423552164, 0.16485632024570285, 0.16486006800143416]}, "mutation_prompt": null}
{"id": "3e89a58b-f645-4eae-b179-efd0cfa15843", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        progress_ratio = self.best_score / (self.best_score + 1e-9)  # Progress-based scaling\n        self.f = 0.8 + 0.4 * progress_ratio  # Dual-phase mutation scaling\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduces dual-phase mutation scaling based on progress to enhance exploration and exploitation balance in PeriodicDEOptimizer.", "configspace": "", "generation": 3, "fitness": 0.9773307677590388, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9752496811468577, 0.9734668251314178, 0.9832757969988412], "final_y": [0.16485591641067765, 0.16485675856505844, 0.1648600284498718]}, "mutation_prompt": null}
{"id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduce an adaptive mutation differential factor directly proportional to the diversity of the population to enhance exploration.", "configspace": "", "generation": 3, "fitness": 0.9837784034784908, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c994b102-f49d-4506-85d2-6f258c469042", "metadata": {"aucs": [0.9809451802360734, 0.9848586746085591, 0.9855313555908397], "final_y": [0.16485880695166888, 0.16485616538466408, 0.16485599895239367]}, "mutation_prompt": null}
{"id": "e8286eff-4aa4-4ca8-bd1c-eb213e13bdb4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.6  # Changed from 0.5 to 0.6 to slightly increase mutation factor\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.random.rand()\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Slightly increasing the mutation factor range to enhance exploration capabilities for better convergence in complex landscapes.", "configspace": "", "generation": 3, "fitness": 0.9824564971629984, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c994b102-f49d-4506-85d2-6f258c469042", "metadata": {"aucs": [0.9825757850986704, 0.9789058794589267, 0.9858878269313985], "final_y": [0.16485786013698944, 0.16485636828557337, 0.16485810253858324]}, "mutation_prompt": null}
{"id": "bd0b01f7-2aaa-46b6-8ec7-98738a584b29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedPeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # Initial DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.population, axis=0)\n        adaptive_f = self.f * (1 + 0.5 * np.random.randn())\n        mutant = self.population[a] + adaptive_f * (self.population[b] - self.population[c]) * diversity_factor\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "EnhancedPeriodicDEOptimizer", "description": "Introduces a hybrid diversity-preserving mechanism and adaptive mutation scaling to improve exploration and convergence in PeriodicDEOptimizer.", "configspace": "", "generation": 3, "fitness": 0.9800626863854874, "feedback": "The algorithm EnhancedPeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.975249566676844, 0.9816625128119676, 0.9832759796676509], "final_y": [0.16485594065157727, 0.16486188912682276, 0.16485967390647904]}, "mutation_prompt": null}
{"id": "d3f5a2d9-97a8-448b-8e39-2fdac9ff52ae", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = max(1, self.dim // np.random.randint(2, 6))  # Dynamic period adjustment\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = max(1, self.dim // np.random.randint(2, 6))  # Dynamic period update in mutation\n        mutant[:period] = np.mean(mutant[:period])  # Enforce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Incorporate a dynamic periodic adjustment approach in the mutation and initialization phases to improve convergence on periodic landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (3,) into shape (1,)').", "error": "ValueError('could not broadcast input array from shape (3,) into shape (1,)')", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {}, "mutation_prompt": null}
{"id": "cb7246fd-24dd-4067-8909-e23425fa0aeb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Integrate a dynamic population size adjustment strategy to better adapt to the landscape over time while respecting the change constraint.", "configspace": "", "generation": 4, "fitness": 0.9839506419758068, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.9869767000731006, 0.9805883202149431, 0.9842869056393766], "final_y": [0.16485664647428167, 0.16485859593273489, 0.1648561131705153]}, "mutation_prompt": null}
{"id": "8ddf4d6d-d3ed-4a1e-86cb-5d9408249806", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(indices, 3, replace=False)  # Select from entire population\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance adaptive mutation by adjusting the selection of mutant vectors to encourage diversity and robustness.", "configspace": "", "generation": 4, "fitness": 0.9175626992021041, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.918 with standard deviation 0.089. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.7924114659243832, 0.977248946345406, 0.9830276853365234], "final_y": [0.16485657542013354, 0.16485656906426904, 0.16485830100880416]}, "mutation_prompt": null}
{"id": "516f6d7f-19aa-4b61-aa93-e8579dc49f7c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity_factor = np.std(self.population, axis=0)  \n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr * diversity_factor)\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduce a diversity-based recombination strategy to enhance solution variety and convergence.", "configspace": "", "generation": 4, "fitness": 0.9824533067993576, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.9868362873341187, 0.977248946345406, 0.983274686718548], "final_y": [0.1648566037098853, 0.16485656906426904, 0.16486073521745614]}, "mutation_prompt": null}
{"id": "f565aa44-89e8-40d9-9217-aadf7c8d1c7e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n            self.f = 0.8 - 0.3 * (num_evaluations / self.budget)  # Adaptive DE scaling factor\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduce adaptive DE scaling factor based on the number of evaluations to further balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.964242900583758, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.021. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9356348575319815, 0.9738176999496023, 0.9832761442696902], "final_y": [0.16485594103400625, 0.16486320931747744, 0.16485966784192285]}, "mutation_prompt": null}
{"id": "97faadfc-a6f3-4614-8a5a-9f573338514c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_f = self.f * (1 - (self.budget / (self.budget + 1)))  # Adaptive mutation strategy\n        mutant = self.population[a] + adaptive_f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduces an additional adaptive mutation strategy based on the budget usage to enhance convergence in PeriodicDEOptimizer.", "configspace": "", "generation": 4, "fitness": 0.978591587819421, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9752495832586974, 0.9772490364442796, 0.983276143755286], "final_y": [0.16485590121798743, 0.1648565095193374, 0.16485963536672865]}, "mutation_prompt": null}
{"id": "a9bec104-c201-43b2-938d-343301f52f95", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.population, axis=0)  # Calculate diversity\n        self.f = 0.5 + 0.5 * np.mean(diversity_factor)  # Adjust mutation factor\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Introduce diversity-driven mutation to balance exploration and exploitation in PeriodicDEOptimizer.", "configspace": "", "generation": 4, "fitness": 0.9785914126918259, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9752497644292457, 0.977249193829298, 0.9832752798169341], "final_y": [0.16485585999650032, 0.16485644620074513, 0.16486015617064675]}, "mutation_prompt": null}
{"id": "26b35cc2-e9ba-4f0c-8022-9e8a3efce9fc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        sorted_indices = np.argsort(scores)\n        rank = np.where(sorted_indices == target_idx)[0][0]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) / (np.mean(scores) + 1e-9)) * (1 - rank / self.population_size)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduce dynamic weighting based on the rank of individuals to enhance the exploration-exploitation balance in AdaptivePeriodicDEOptimizer.", "configspace": "", "generation": 4, "fitness": 0.938465548549322, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.938 with standard deviation 0.059. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.8545072847967781, 0.97761467413264, 0.983274686718548], "final_y": [0.20725531742811032, 0.16485694290425568, 0.16486073521745614]}, "mutation_prompt": null}
{"id": "e2927d31-34cd-4a01-82c4-689a731d4deb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            diversity = np.std(scores) / (np.mean(scores) + 1e-9)  # Dynamic crossover probability range adjustment\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max * diversity) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Implements dynamic adjustment of the crossover probability range based on diversity to enhance local exploitation while maintaining exploration.", "configspace": "", "generation": 4, "fitness": 0.9788639896768497, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.9747370109471195, 0.9781955770003794, 0.9836593810830505], "final_y": [0.16486176696137889, 0.16485921219183952, 0.1648563860558021]}, "mutation_prompt": null}
{"id": "6ff02687-fc4d-4a2a-99ac-1eb8c8621ed7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.9 # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        # Initialize population with periodic encouragement\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        # Encouraging periodicity in initial population\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        pop_std = np.std(self.population, axis=0) + 1e-9  # Diversity measure\n        adaptive_f = self.f * (1 + pop_std.mean())  # Adaptive scaling factor\n        mutant = self.population[a] + adaptive_f * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def _periodicity_aware_refine(self, solution, func):\n        # Small gradient descent step to encourage periodic solutions\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            perturbation = np.random.randn(period) * 0.01\n            solution[j:j+period] += perturbation\n            solution[j:j+period] = np.clip(solution[j:j+period], self.bounds[0][j:j+period], self.bounds[1][j:j+period])\n        return solution\n\n    def __call__(self, func):\n        # Set bounds for convenience\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n            self.cr = 0.9 - 0.5 * (num_evaluations / self.budget)  # Adaptive crossover probability\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n            \n            if num_evaluations < self.budget:\n                # Perform periodicity-aware local optimization\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best = self._periodicity_aware_refine(local_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "PeriodicDEOptimizer", "description": "Integrate diversity-based mutation scaling to enhance exploration and convergence.", "configspace": "", "generation": 4, "fitness": 0.9773739105048186, "feedback": "The algorithm PeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "08315a15-f0e4-4633-ae15-3f13863c0a7d", "metadata": {"aucs": [0.9752495053328885, 0.9738683944497413, 0.9830038317318258], "final_y": [0.16485594627416766, 0.16486405057506692, 0.16485629527557533]}, "mutation_prompt": null}
{"id": "4cba61ce-d598-42b5-926a-0df2a7913bbb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        probabilities = (np.max(scores) - scores) / (np.max(scores) - np.min(scores) + 1e-9)\n        best_indices = np.random.choice(indices, 3, replace=False, p=probabilities/np.sum(probabilities))\n        a, b, c = best_indices\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance the mutation strategy by selecting indices proportional to their fitness, increasing the chance of selecting higher quality solutions for mutation.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "cb7246fd-24dd-4067-8909-e23425fa0aeb", "metadata": {}, "mutation_prompt": null}
{"id": "d9f53f5b-4410-4ad1-9f0e-19be19f8f8bd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity = np.std(self.population)  # Calculate population diversity\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr * diversity)  # Adjust crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance crossover by dynamically adjusting the crossover rate based on diversity, promoting better exploration-exploitation trade-offs.", "configspace": "", "generation": 5, "fitness": 0.9842029772259752, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.9870160190010531, 0.9782265175872552, 0.9873663950896172], "final_y": [0.16485646049383085, 0.16485646763804185, 0.1648594569294326]}, "mutation_prompt": null}
{"id": "a6ed2e2f-f92a-4833-8032-51c5b6ec6066", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            elite_idx = np.argmin(scores)\n            elite_solution = self.population[elite_idx].copy()  # Preserve elite solution\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * np.std(scores) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            self.population[0] = elite_solution  # Restore elite solution\n            scores[0] = func(elite_solution)  # Re-evaluate elite solution\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance population diversity by incorporating dynamic crossover rates based on score variance and introduce an elitism strategy to preserve top solutions.", "configspace": "", "generation": 5, "fitness": 0.979664188709921, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cb7246fd-24dd-4067-8909-e23425fa0aeb", "metadata": {"aucs": [0.9763464221970712, 0.9785419042559234, 0.9841042396767684], "final_y": [0.16485889718716262, 0.16485738737193756, 0.1648563924046681]}, "mutation_prompt": null}
{"id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced crossover strategy for better diversity and exploration during the mutation process.", "configspace": "", "generation": 5, "fitness": 0.9839911889955667, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cb7246fd-24dd-4067-8909-e23425fa0aeb", "metadata": {"aucs": [0.979266704571717, 0.985880946555856, 0.9868259158591268], "final_y": [0.16485616181164353, 0.16485935645109673, 0.16485934991633988]}, "mutation_prompt": null}
{"id": "8d411850-dd92-405a-b823-66afc8b05cea", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            elite_count = max(1, int(0.1 * self.population_size))  # Elitism introduction\n            elite_indices = np.argsort(scores)[:elite_count]\n            elite = self.population[elite_indices]  # Preserve elite\n\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n            self.population[:elite_count] = elite  # Reinsert elite\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduce elitism by maintaining a portion of the best individuals in each generation to enhance convergence.", "configspace": "", "generation": 5, "fitness": 0.9820100799878874, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cb7246fd-24dd-4067-8909-e23425fa0aeb", "metadata": {"aucs": [0.9849005516040815, 0.9739295408557609, 0.98720014750382], "final_y": [0.16485652605940626, 0.16485763560811095, 0.1648586188664939]}, "mutation_prompt": null}
{"id": "478bab96-efbe-4818-8e0e-5be1c0d02117", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n        \n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance exploration and exploitation by introducing a dynamic selection strategy and leveraging multi-objective optimization principles.", "configspace": "", "generation": 5, "fitness": 0.9802396011080575, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cb7246fd-24dd-4067-8909-e23425fa0aeb", "metadata": {"aucs": [0.9783396200445778, 0.9760820136621067, 0.9862971696174881], "final_y": [0.16485601180538878, 0.16486672641998334, 0.16486647487206685]}, "mutation_prompt": null}
{"id": "04154c29-6eb2-4988-b7d0-af2466001f1e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * np.std(self.population) / (np.mean(self.population) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduce adaptive crossover probability based on population diversity to enhance balancing exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.9635637895399708, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.031. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.981916088293822, 0.9205044855306875, 0.9882707947954029], "final_y": [0.1648577923207145, 0.16485801367623465, 0.1648559334352656]}, "mutation_prompt": null}
{"id": "c516c861-3aec-43ac-816b-5c095a78441f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, scores):\n        diversity = np.std(scores) / (np.mean(scores) + 1e-9)\n        adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * diversity\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                trial = self._crossover(self.population[i], mutant, scores)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Incorporate dynamic crossover rate adjustment based on population diversity to enhance convergence speed.", "configspace": "", "generation": 5, "fitness": 0.9437449618502288, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.944 with standard deviation 0.051. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.9754444777822278, 0.8714523860905671, 0.9843380216778919], "final_y": [0.1648583357012231, 0.20044758630420867, 0.16486180320247923]}, "mutation_prompt": null}
{"id": "a9ac3211-539f-4e86-98bc-3d8113435bdb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        generation = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                adaptive_cr *= 0.5 * (1 + np.tanh(generation / 10))  # Adaptive crossover based on generation\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n            generation += 1\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduce adaptive crossover probability based on the generation number to balance exploration and exploitation over time.", "configspace": "", "generation": 5, "fitness": 0.9835290403586944, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.9805823122724042, 0.9830012719295145, 0.9870035368741641], "final_y": [0.16485814564900125, 0.16485956053225526, 0.16485776081089887]}, "mutation_prompt": null}
{"id": "466853c8-0ead-4b3f-a3b3-073fe595f5da", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        diversity_preserving = np.random.uniform(-0.1, 0.1, self.dim)  # Add diversity-preserving\n        mutant = mutant + diversity_preserving\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance exploration by introducing a diversity-preserving function during mutation to maintain robustness against local minima.", "configspace": "", "generation": 5, "fitness": 0.9058526100838385, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.075. And the mean value of best solutions found was 0.187 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "64308a56-484a-4e30-b8a2-9fb75af37a6c", "metadata": {"aucs": [0.8089792352789464, 0.9182891574694622, 0.990289437503107], "final_y": [0.2072547958214812, 0.1881327885342967, 0.16486440623239096]}, "mutation_prompt": null}
{"id": "db717d9c-c122-4033-ae2a-556ef54cb55d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        # Modified line: Use the best individual more frequently.\n        mutant = self.best_solution + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity = np.std(self.population)\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr * diversity)\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Adjust mutation strategy to utilize best individual more frequently, ensuring convergence towards optimal solutions.", "configspace": "", "generation": 6, "fitness": 0.9829021464978066, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d9f53f5b-4410-4ad1-9f0e-19be19f8f8bd", "metadata": {"aucs": [0.982915733292366, 0.977248946345406, 0.9885417598556476], "final_y": [0.16485612920914394, 0.16485656906426904, 0.1648563502330339]}, "mutation_prompt": null}
{"id": "562415a4-2ba2-44c0-94f5-b814fa05e158", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr + 0.15)  # Adjusted crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance local exploration by dynamically adjusting the CR (crossover rate) to improve solution refinement. ", "configspace": "", "generation": 6, "fitness": 0.9531149591611113, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.048. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "metadata": {"aucs": [0.9832065428452719, 0.8858536245362352, 0.9902847101018271], "final_y": [0.16485606824058818, 0.1648608600478112, 0.16486463065185264]}, "mutation_prompt": null}
{"id": "9585e387-cf72-444e-bf39-e9074065552d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        mutation_benefits = []\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n                \n                mutation_benefits.append(trial_score - scores[i])\n                \n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Apply dynamic adjustment to the mutation factor by considering the variance of mutation benefits over time, ensuring a more informed exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.9838361343086177, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "metadata": {"aucs": [0.9854002405786404, 0.9780858474760137, 0.9880223148711992], "final_y": [0.16485892248660117, 0.16485812352453022, 0.1648571621452234]}, "mutation_prompt": null}
{"id": "a6b9065d-a3fc-4995-aec1-a519a63b9bcc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:4]  # Select from top 4 instead of best 3\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improve mutation by selecting top individuals adaptively, enhancing convergence speed and robustness.", "configspace": "", "generation": 6, "fitness": 0.9824226804552563, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "metadata": {"aucs": [0.9824305040624713, 0.977248946345406, 0.9875885909578913], "final_y": [0.1648611964892296, 0.16485656906426904, 0.16485807562988386]}, "mutation_prompt": null}
{"id": "5073fa14-e5ee-4edc-abb7-88a639d98c3d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n        self.diversity_memory = []\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity = np.std(self.population)\n        self.diversity_memory.append(diversity)  # Record diversity over time\n        avg_diversity = np.mean(self.diversity_memory[-5:]) if len(self.diversity_memory) >= 5 else diversity\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr * avg_diversity)  # Adjust crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improve crossover probability by incorporating historical diversity information for better convergence.", "configspace": "", "generation": 6, "fitness": 0.9834253435483852, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d9f53f5b-4410-4ad1-9f0e-19be19f8f8bd", "metadata": {"aucs": [0.9870160190010531, 0.977248946345406, 0.9860110652986961], "final_y": [0.16485646049383085, 0.16485656906426904, 0.16485630602005363]}, "mutation_prompt": null}
{"id": "6e796fb2-2292-4d1f-80ed-66368cfff522", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n        self.period = dim // 2  # Ensure periodicity\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        for i in range(self.population_size):\n            for j in range(0, self.dim, self.period):\n                self.population[i, j:j+self.period] = self.population[i, :self.period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.random.choice(indices, 3, replace=False)\n        a, b, c = best_indices\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity = np.std(self.population)\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr * diversity)\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Incorporate diversity preservation and periodic reinforcement to improve solution quality in the adaptive DE framework.", "configspace": "", "generation": 6, "fitness": 0.9820543672174166, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d9f53f5b-4410-4ad1-9f0e-19be19f8f8bd", "metadata": {"aucs": [0.9800502121185433, 0.9812884626136167, 0.9848244269200898], "final_y": [0.16485896872350925, 0.164864237931179, 0.16485695025607172]}, "mutation_prompt": null}
{"id": "463e0a04-b31c-4cca-bc4d-6c65888b48c3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.95  # Changed from 0.9 to 0.95\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved exploration by dynamically adjusting the crossover probability range to increase diversity.", "configspace": "", "generation": 6, "fitness": 0.9860137787231059, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.986 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "metadata": {"aucs": [0.9857632520607039, 0.9807684040538087, 0.991509680054805], "final_y": [0.16485605221937216, 0.16485720706535179, 0.16485972847455277]}, "mutation_prompt": null}
{"id": "be504d02-93a9-4142-80b9-29635fd58df0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improve adaptive mutation scaling by using the standard deviation of scores weighted by the inverse of evaluations.", "configspace": "", "generation": 6, "fitness": 0.9875631243135036, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.988 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "metadata": {"aucs": [0.9864953640530097, 0.9857444200701623, 0.9904495888173385], "final_y": [0.16485820617093871, 0.16485837473552212, 0.16486399612510738]}, "mutation_prompt": null}
{"id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduced periodic mutation strategy to enhance global exploration by promoting periodic solutions.", "configspace": "", "generation": 6, "fitness": 0.9886606230101451, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.989 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "603e024d-40f4-4179-9ae7-6144804c0fc7", "metadata": {"aucs": [0.9882528664035383, 0.9861710637462726, 0.9915579388806247], "final_y": [0.1648620706483832, 0.16486104848422023, 0.16485848363372757]}, "mutation_prompt": null}
{"id": "ce51e830-02bd-49e1-ad0f-a5eeda0a2203", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        top_indices = np.argsort(scores)[:5]  # Extended to top 5 for diversity\n        a, b, c = np.random.choice(top_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity = np.std(self.population)  # Calculate population diversity\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr * diversity)  # Adjust crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        improved_x0 = np.clip(x0, self.bounds[0], self.bounds[1])  # Ensure x0 within bounds\n        result = minimize(func, improved_x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhances mutation strategy by incorporating top performers dynamically, improving convergence, with refined local search initialization.", "configspace": "", "generation": 6, "fitness": 0.9853115427515658, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.985 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d9f53f5b-4410-4ad1-9f0e-19be19f8f8bd", "metadata": {"aucs": [0.9870168662210934, 0.9809646614975803, 0.9879531005360241], "final_y": [0.16486346638485505, 0.1648579024405291, 0.1648561411480015]}, "mutation_prompt": null}
{"id": "ec4f2e37-e943-44c3-8b60-12fdaca76d62", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improve adaptive mutation scaling by using the standard deviation of scores weighted by the inverse of evaluations.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9864953640530097, 0.9857444200701623, 0.9904495888173385], "final_y": [0.16485820617093871, 0.16485837473552212, 0.16486399612510738]}, "mutation_prompt": null}
{"id": "e11b7301-5227-44da-89af-669b1c9bd5bc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:2] + [np.random.choice(indices)]  # Modified to include random choice\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced mutation strategy by modifying the selection mechanism to improve exploration of the search space.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 180 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 180 is out of bounds for axis 0 with size 100')", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {}, "mutation_prompt": null}
{"id": "117b761d-cf2c-4099-a262-9e87a6fb7026", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            diversity = np.std(scores) / (np.mean(scores) + 1e-9)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * diversity\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget and (num_evaluations % (self.budget // 10) == 0):\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced exploration by incorporating dynamic crossover rates based on fitness diversity and adjusted local optimization frequency.", "configspace": "", "generation": 7, "fitness": 0.887596312856584, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.084. And the mean value of best solutions found was 0.196 (0. is the best) with standard deviation 0.035.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9043289461734567, 0.9808015605228403, 0.7776584318734548], "final_y": [0.17687818026293156, 0.16486053251320343, 0.24486937075865645]}, "mutation_prompt": null}
{"id": "868af80c-80b2-4c85-bec8-2c250610c53b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(self.population[:, :period], axis=0)  # Refine periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Refine periodicity introduction by averaging across entire population instead of mean of single mutant.", "configspace": "", "generation": 7, "fitness": 0.8557212511986374, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.094. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.983123487760798, 0.8246361609665331, 0.7594041048685809], "final_y": [0.16485996436005834, 0.22563665943615274, 0.22320779600684837]}, "mutation_prompt": null}
{"id": "5b951281-1001-43ac-94b6-4e33cb4a32eb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period]) + 0.1  # Enhance periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - 0.9 * num_evaluations / self.budget)))  # Refined adaptation\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Refined population size adaptation and enhanced periodic mutation to improve solution exploration.", "configspace": "", "generation": 7, "fitness": 0.8608987300697123, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.094. And the mean value of best solutions found was 0.200 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.9885900419423083, 0.8301913369750997, 0.7639148112917286], "final_y": [0.16485801296916436, 0.22084910384904544, 0.21368520384545053]}, "mutation_prompt": null}
{"id": "243fd625-316d-4546-8979-304e85a1eeb1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        weights = np.linspace(0.5, 1.5, 3) / np.sum(np.linspace(0.5, 1.5, 3))  # Adaptive weighting for mutation\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + weights[0] * f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduced adaptive weighting for mutation to improve convergence in challenging landscapes.", "configspace": "", "generation": 7, "fitness": 0.8225934007938717, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.131. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.033.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.9886747696113759, 0.6681555329570907, 0.8109498998131484], "final_y": [0.16485616527125924, 0.24641781748650793, 0.20479562616484281]}, "mutation_prompt": null}
{"id": "1e2e5dce-4a20-4b92-9a7e-a48162ffbbe5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period]) + 0.1 * np.sin(2 * np.pi * j / period)  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced periodicity enforcement by adding a sinusoidal periodicity constraint in mutation.", "configspace": "", "generation": 7, "fitness": 0.8312102397727662, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.112. And the mean value of best solutions found was 0.204 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.9887321723332053, 0.7711403371045887, 0.7337582098805049], "final_y": [0.16485745453526457, 0.2276298466842458, 0.2209249016729108]}, "mutation_prompt": null}
{"id": "7582c612-3a86-49cc-8de2-edf3c84d330c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        tournament_size = 5  # Tournament selection size\n        tournament_indices = np.random.choice(self.population_size, tournament_size, replace=False)\n        tournament_scores = scores[tournament_indices]\n        fittest_index = tournament_indices[np.argmin(tournament_scores)]\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance the selection of mutant vectors by including a tournament selection mechanism to improve diversity and convergence.", "configspace": "", "generation": 7, "fitness": 0.7613906388746764, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.761 with standard deviation 0.153. And the mean value of best solutions found was 0.226 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9768882989498309, 0.6694655124663209, 0.6378181052078775], "final_y": [0.16486226950996263, 0.29495048781218614, 0.21773628352678498]}, "mutation_prompt": null}
{"id": "d6dc1271-f9fb-4b63-a2ac-f6ebd56dc874", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.15  # Increase crossover probability slightly more\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Adjusted crossover probability to increase the likelihood of exploring diverse solutions while maintaining constructive interference properties.", "configspace": "", "generation": 7, "fitness": 0.8086778596934373, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.126. And the mean value of best solutions found was 0.217 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9865102746149597, 0.7242781259288523, 0.7152451785365002], "final_y": [0.164858096261573, 0.26282806505904366, 0.22451463615480893]}, "mutation_prompt": null}
{"id": "c69f88fc-ee9e-41b4-a94c-6c6b2840177a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        \n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        \n        periodic_component = np.sin(2 * np.pi * mutant / (self.bounds[1] - self.bounds[0])) * 0.1\n        mutant += periodic_component\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.15\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget and num_evaluations % (self.budget // 10) == 0:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced adaptive mutation and crossover strategies to improve exploration and maintain diversity while incorporating a dynamic local search frequency. ", "configspace": "", "generation": 7, "fitness": 0.7399670334682815, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.740 with standard deviation 0.041. And the mean value of best solutions found was 0.234 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.7743734320270711, 0.6828414382983699, 0.7626862300794035], "final_y": [0.23910183360317916, 0.23070183880643047, 0.2327986082556205]}, "mutation_prompt": null}
{"id": "5b821b44-941f-4f75-b86d-a37780f83911", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adjust_periodicity(self, scores):\n        performance = np.mean(scores) / (self.best_score + 1e-9)\n        period_step = performance * self.dim // 10\n        period = max(1, self.dim // 2 - int(period_step))\n        return period\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            period = self._adjust_periodicity(scores)  # Dynamically adjust periodicity\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduced a dynamic periodic adjustment technique that adjusts periodicity based on performance to further enhance periodic mutation strategies.", "configspace": "", "generation": 8, "fitness": 0.9846759755179567, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.985 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9870398581871234, 0.982406519936316, 0.984581548430431], "final_y": [0.16486478737823562, 0.1648558725378908, 0.1648625242353281]}, "mutation_prompt": null}
{"id": "5a2d82ee-2359-4652-a1b1-978005f827a7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = 2 + (self.dim // 4)  # Modified: Adaptive period based on dimension\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = 2 + (self.dim // 4)  # Modified: Adaptive period based on dimension\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced diversity by introducing adaptive periodicity based on progress to promote exploration.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (4,) into shape (2,)').", "error": "ValueError('could not broadcast input array from shape (4,) into shape (2,)')", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {}, "mutation_prompt": null}
{"id": "65e89a9e-b615-4194-83f2-a4b810e106cb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(self.population[:period], axis=0)  # Altered line for better periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < min(1.0, adaptive_cr + 0.2)  # Adjusted crossover rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved mutation and crossover strategies to enhance exploitation and exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (10,) into shape (5,)').", "error": "ValueError('could not broadcast input array from shape (10,) into shape (5,)')", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {}, "mutation_prompt": null}
{"id": "f51162f6-c5a4-4561-870f-539f2a33cfe8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.2  # Changed from 0.1 to 0.2\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Increased the crossover probability to improve solution diversity and convergence rate.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (10,) into shape (5,)').", "error": "ValueError('could not broadcast input array from shape (10,) into shape (5,)')", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {}, "mutation_prompt": null}
{"id": "b99a6de2-dafb-4002-a4d2-94859554d882", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity_factor = np.mean(np.std(self.population, axis=0)) / (np.std(scores) + 1e-9)\n        crossover_mask = np.random.rand(self.dim) < (adaptive_cr + 0.1) * diversity_factor # Changed line\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved exploration by using a dynamic crossover probability adaptation based on population diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'scores' is not defined\").", "error": "NameError(\"name 'scores' is not defined\")", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {}, "mutation_prompt": null}
{"id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduced a periodicity bias to the initialization process to enhance alignment with optimal solutions.", "configspace": "", "generation": 8, "fitness": 0.9916774128789264, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.990983510022109, 0.9928625674349214, 0.9911861611797489], "final_y": [0.16485759594177551, 0.1648609221477837, 0.16485647018474625]}, "mutation_prompt": null}
{"id": "4137eb44-85a4-4754-a83b-4fc56e01cd35", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        diversity = np.std(self.population, axis=0).std()  # Compute overall diversity\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * diversity * np.cos(np.pi * scores[target_idx] / np.max(scores))\n        a, b, c = np.random.choice(indices, 3, replace=False)  # Changed to ensure diversity\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.05  # Adjusted crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved convergence by introducing oscillatory mutation scaling and adaptive crossover based on solution diversity.", "configspace": "", "generation": 8, "fitness": 0.9649307885051587, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.027. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9786230876610043, 0.9274333584092808, 0.9887359194451907], "final_y": [0.16485606462570812, 0.1818781366763671, 0.1648609087898255]}, "mutation_prompt": null}
{"id": "6080d5eb-8e28-4d46-9e25-357e24fce6fb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)], options={'maxiter': 150})\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced local optimization by increasing the L-BFGS-B optimizer's iterations to improve fine-tuning of solutions.", "configspace": "", "generation": 8, "fitness": 0.985250914873307, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.985 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.9887224685719764, 0.977248946345406, 0.9897813297025382], "final_y": [0.16486188978359873, 0.16485656906426904, 0.1648563078452948]}, "mutation_prompt": null}
{"id": "c5c7c3d4-5b56-4029-9c06-6cc1a5fcd16f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        a, b, c = np.random.choice(indices, 3, replace=False)  # Diversified index selection\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved mutation strategy by selecting more diverse indices to enhance exploration capabilities.", "configspace": "", "generation": 8, "fitness": 0.981700421861766, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9779300862381077, 0.980008072911026, 0.987163106436164], "final_y": [0.16486607623791127, 0.16485644545879352, 0.16485683828528286]}, "mutation_prompt": null}
{"id": "03f24813-8fb2-4cee-b207-7e867ce89475", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (np.std(scores) * (self.budget - self.population_size) / self.budget) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  \n        elite_idx = np.random.choice(best_indices[:2])  # New line: Promote elitism by choosing from top 2\n        mutant = self.population[elite_idx] + f_adaptive * (self.population[b] - self.population[c])  # Modified line\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  \n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced mutation strategy by including an elitism factor that emphasizes exploiting the top solutions.", "configspace": "", "generation": 8, "fitness": 0.9672922403934114, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.029. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "be504d02-93a9-4142-80b9-29635fd58df0", "metadata": {"aucs": [0.9870733890458702, 0.9269540030246897, 0.9878493291096744], "final_y": [0.16486033538548228, 0.18187870264781758, 0.1648610927084314]}, "mutation_prompt": null}
{"id": "1176c569-6eb5-432e-891f-7d8598d819b7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period]) * (1 + 0.01 * np.random.randn())  # Introduce adaptive periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.2  # Improve crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduced adaptive periodic mutation and improved crossover strategy for enhanced convergence and exploration.", "configspace": "", "generation": 9, "fitness": 0.9906108986667242, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9904586221553525, 0.993189364292242, 0.988184709552578], "final_y": [0.16485964913788032, 0.1648565390396438, 0.16485629292941473]}, "mutation_prompt": null}
{"id": "56f2d3cf-7530-40f9-ad6d-ba3551aba624", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            f_adaptive = self.f_min + (self.f_max - self.f_min) * (self.budget - num_evaluations) / self.budget  # Change made here\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Introduced adaptive scaling factor based on iteration to improve convergence speed.", "configspace": "", "generation": 9, "fitness": 0.9888526379880371, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.989 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9907982275824048, 0.9887092629961299, 0.9870504233855768], "final_y": [0.1648672439495107, 0.1648644914134446, 0.16486868592291182]}, "mutation_prompt": null}
{"id": "eae96e75-26fe-4bdd-994b-2ba683edecc0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            periodic_pattern = self.population[i, :period]\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = periodic_pattern\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  \n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  \n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.2  \n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced periodic initialization and crossover strategies to improve solution convergence while maintaining global exploration.", "configspace": "", "generation": 9, "fitness": 0.990859326630523, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.988316562102462, 0.9927432029340734, 0.9915182148550337], "final_y": [0.1648615205469638, 0.16486099863991965, 0.16486547336882418]}, "mutation_prompt": null}
{"id": "d778cbe4-e1b9-4946-93af-bf9382c579be", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period//2])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Reduced dimensionality for periodic mean calculation to potentially enhance alignment with optimal periodic solutions.", "configspace": "", "generation": 9, "fitness": 0.9873783998270874, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.987 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.9883465988197598, 0.9839007606570923, 0.9898878400044099], "final_y": [0.16486237931342151, 0.16485996713088602, 0.16485617274034603]}, "mutation_prompt": null}
{"id": "858d2c14-502a-45ec-a6f2-6bea40bbbf84", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            periodic_block = self.population[i, :period] * 0.8  # Stronger periodicity in initialization\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = periodic_block\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced periodicity enforcement and local search improvements for better solution refinement.", "configspace": "", "generation": 9, "fitness": 0.9909887046777927, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9928552974334316, 0.9892378283692101, 0.9908729882307362], "final_y": [0.1648615200422946, 0.16485947579320726, 0.16486294745193675]}, "mutation_prompt": null}
{"id": "ec5c6db7-063b-4de2-b881-ef7c25ddc546", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:5]  # Increased from 3 to 5\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved mutation strategy by selecting from a wider range of top solutions for enhanced global exploration.", "configspace": "", "generation": 9, "fitness": 0.9913044196925357, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9905682851878388, 0.9867116637574738, 0.9966333101322943], "final_y": [0.16485891725968582, 0.16486047086010203, 0.16485718585154308]}, "mutation_prompt": null}
{"id": "721b122f-a6ca-4d9b-8cdc-211bd15177c0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        # Adjust periodicity strength based on best score\n        periodicity_strength = (scores[target_idx] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = (1 - periodicity_strength) * mutant[j:j+period] + periodicity_strength * np.mean(mutant[:period])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced adaptive mutation by scaling periodicity strength based on current solution quality.", "configspace": "", "generation": 9, "fitness": 0.9889863767743164, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.989 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.9913251370639649, 0.9849319561024901, 0.9907020371564945], "final_y": [0.16485796188101964, 0.16486045752361944, 0.16486244518989324]}, "mutation_prompt": null}
{"id": "c354e62d-5ef8-40f1-90b2-c0240763a42d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True) \n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            wave_pattern = (np.sin(np.linspace(0, np.pi, period)) + 1) / 2  \n            mutant[j:j+period] = self.population[a, j:j+period] * wave_pattern \n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced adaptive crossover with wave-patterned mutations to improve convergence by promoting periodic solutions in multilayer optimization.", "configspace": "", "generation": 9, "fitness": 0.987280663657441, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.987 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9836447657412954, 0.989583333614028, 0.9886138916169996], "final_y": [0.16485651948829683, 0.16485811851569054, 0.16485810849698168]}, "mutation_prompt": null}
{"id": "0d0ccec3-2f19-49f6-8820-42161c32d46f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = self.population[i, :period]\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 4  # Increase periodic block influence\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced periodic mutation strategy by expanding periodic block influence for improved global exploration.", "configspace": "", "generation": 9, "fitness": 0.9841275187336315, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "11fe4581-eb25-4778-8d98-a49cd0fe1c5b", "metadata": {"aucs": [0.988763545732674, 0.9803272813905108, 0.9832917290777097], "final_y": [0.1648560604922762, 0.16485684430397507, 0.16486259433496886]}, "mutation_prompt": null}
{"id": "c868b050-8bbc-45c1-89a4-18c102c01f89", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicGroupingPeriodicRepairDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (self.best_score - scores[target_idx]) / (np.max(scores) - np.min(scores) + 1e-9)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        self._periodic_repair(mutant)\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _periodic_repair(self, vector):\n        period = self.dim // 4  # Novel dynamic grouping\n        for i in range(0, self.dim, period):\n            if i + period <= self.dim:\n                avg_value = np.mean(vector[i:i+period])\n                vector[i:i+period] = avg_value\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "DynamicGroupingPeriodicRepairDE", "description": "Introduced a dynamic grouping and periodic repair strategy to maintain effective constructive interference and enhance convergence toward optimal solutions.", "configspace": "", "generation": 9, "fitness": 0.9787171905928704, "feedback": "The algorithm DynamicGroupingPeriodicRepairDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9749563699570217, 0.9786274840679757, 0.9825677177536138], "final_y": [0.164856862652201, 0.16485867330015058, 0.1648617842912956]}, "mutation_prompt": null}
{"id": "92bb580a-101e-4818-82cb-6ff3d66700d5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:5]  # Increased from 3 to 5\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved mutation strategy by selecting from a wider range of top solutions for enhanced global exploration.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "ec5c6db7-063b-4de2-b881-ef7c25ddc546", "metadata": {"aucs": [0.9905682851878388, 0.9867116637574738, 0.9966333101322943], "final_y": [0.16485891725968582, 0.16486047086010203, 0.16485718585154308]}, "mutation_prompt": null}
{"id": "07167320-2a45-4e5c-bd17-287c9f93f82c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :2*period] + self.population[i, 2*period:4*period]) / 4  # Changed line\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced the periodicity of the initialization by averaging over a broader segment, thus aligning better with optimal periodic solutions.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (0,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (0,) ')", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {}, "mutation_prompt": null}
{"id": "ebb8600d-db7a-417f-a6cf-7ebb233bb22d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr  # Remove additional probability increase\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced crossover strategy by dynamically adjusting trial vector construction based on historical performance.", "configspace": "", "generation": 10, "fitness": 0.9911794984377087, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9902052269232837, 0.9896073022448264, 0.993725966145016], "final_y": [0.1648559392759522, 0.16485775365996447, 0.1648584250272439]}, "mutation_prompt": null}
{"id": "97bd4209-fd81-4fb1-b4a3-af333d0bb764", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = np.sin(self.population[i, :period])  # Modified periodicity with sine\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period]) + 0.01 * np.random.rand()  # Added small randomness\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.2  # Further increased crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced periodicity bias and improved mutation strategy with crossover diversity to achieve better exploration.", "configspace": "", "generation": 10, "fitness": 0.6774561803172552, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.677 with standard deviation 0.446. And the mean value of best solutions found was 0.416 (0. is the best) with standard deviation 0.355.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.04742106813867941, 0.992909268818528, 0.992038203994558], "final_y": [0.9183673469387753, 0.1648589728321196, 0.16485710467155545]}, "mutation_prompt": null}
{"id": "6db781bd-e7b0-4e5c-9105-b30d838aa3f7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.sin(np.pi * mutant[:period])  # Introduce refined periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced exploration by refining the periodicity introduction strategy in the mutation process for better alignment with optimal solutions.", "configspace": "", "generation": 10, "fitness": 0.9888702633756905, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.989 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9836447657412954, 0.9930000887603877, 0.9899659356253885], "final_y": [0.16485651948829683, 0.16486443730114753, 0.16485896274203404]}, "mutation_prompt": null}
{"id": "a1f5a9c7-8e2e-4cda-a076-b28e92e89b9d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                center_value = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n                self.population[i, j:j+period] = center_value  # Harmonize central values for periodicity\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:5]  # Increased from 3 to 5\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Improved periodicity introduction by harmonizing layer group's central values to promote more stable interference patterns.", "configspace": "", "generation": 10, "fitness": 0.9906790816390965, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ec5c6db7-063b-4de2-b881-ef7c25ddc546", "metadata": {"aucs": [0.9905578645837338, 0.9932020015910789, 0.9882773787424767], "final_y": [0.1648596808758308, 0.16486023417885987, 0.1648563093354618]}, "mutation_prompt": null}
{"id": "d7e6c4d2-93fd-4459-b3db-d46811ec4358", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * ((np.std(scores) / (np.mean(scores) + 1e-9)) ** 0.5)  # Modified line\n        best_indices = np.argsort(scores)[:5]  # Increased from 3 to 5\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhance exploration by increasing the dynamic range of scale factor `f_adaptive` computation.", "configspace": "", "generation": 10, "fitness": 0.990412134821757, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.990 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ec5c6db7-063b-4de2-b881-ef7c25ddc546", "metadata": {"aucs": [0.9907180507689998, 0.992683328910758, 0.9878350247855134], "final_y": [0.16485872477781305, 0.16485951222716988, 0.16486036157609907]}, "mutation_prompt": null}
{"id": "3fdc5216-d002-457e-ab40-958f31d62210", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])  # Introduce periodicity\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        diversity = np.std(self.population, axis=0).mean()  # Calculate population diversity\n        adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (1 - diversity)  # Adjust crossover rate based on diversity\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced crossover strategy by incorporating dynamic selection of crossover rates based on population diversity.", "configspace": "", "generation": 10, "fitness": 0.9896367812239039, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.990 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9877230389592884, 0.9929517650699554, 0.988235539642468], "final_y": [0.1648564377966717, 0.16485612174295983, 0.16486594664603593]}, "mutation_prompt": null}
{"id": "32f25a4d-9209-4086-aff5-53fead7be38d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim \n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * np.std(scores) / (np.mean(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:5]  # Increased from 3 to 5\n        a, b, c = np.random.choice(best_indices, 3, replace=True)  # Select from best\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        # Dynamic periodicity during mutation\n        period_length = np.random.randint(1, self.dim // 2 + 1)\n        for j in range(0, self.dim, period_length):\n            mutant[j:j+period_length] = np.mean(mutant[:period_length])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr + 0.1  # Increase crossover probability\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        # Introduce dynamic periodicity during crossover\n        period_length = np.random.randint(1, self.dim // 2 + 1)\n        for j in range(0, self.dim, period_length):\n            trial[j:j+period_length] = np.mean(trial[:period_length])\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            # Adjust population size dynamically based on progress\n            self.population_size = max(5, int(self.population_size * (1 - num_evaluations / self.budget)))\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                local_best = self._local_optimize(self.best_solution, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "AdaptivePeriodicDEOptimizer", "description": "Enhanced trial vector generation by introducing a dynamic periodicity component during mutation and crossover to maintain constructive interference and improve global exploration.", "configspace": "", "generation": 10, "fitness": 0.9911166572900116, "feedback": "The algorithm AdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ec5c6db7-063b-4de2-b881-ef7c25ddc546", "metadata": {"aucs": [0.9926339955113395, 0.992912032255712, 0.9878039441029834], "final_y": [0.16485937188820843, 0.16485590776331016, 0.16485837392520974]}, "mutation_prompt": null}
{"id": "1b42db9d-88f7-4741-89a7-6702245a812c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedAdaptivePeriodicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_score = np.inf\n        self.bounds = None\n        self.elite_archive = []\n\n    def _initialize_population(self):\n        lower_bound, upper_bound = self.bounds\n        self.population = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) + lower_bound\n        period = self.dim // 2\n        for i in range(self.population_size):\n            for j in range(0, self.dim, period):\n                self.population[i, j:j+period] = (self.population[i, :period] + self.population[i, period:2*period]) / 2\n\n    def _evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_index = np.argmin(scores)\n        if scores[best_index] < self.best_score:\n            self.best_score = scores[best_index]\n            self.best_solution = self.population[best_index]\n        self.elite_archive.extend([self.population[i] for i in np.argsort(scores)[:5]])\n        return scores\n\n    def _mutate(self, target_idx, scores):\n        f_adaptive = self.f_min + (self.f_max - self.f_min) * (self.best_score - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-9)\n        best_indices = np.argsort(scores)[:3]\n        a, b, c = np.random.choice(best_indices, 3, replace=True)\n        mutant = self.population[a] + f_adaptive * (self.population[b] - self.population[c])\n        period = self.dim // 2\n        for j in range(0, self.dim, period):\n            mutant[j:j+period] = np.mean(mutant[:period])\n        return np.clip(mutant, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_optimize(self, x0, func):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(*self.bounds)])\n        return result.x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self._initialize_population()\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            scores = self._evaluate(func)\n            num_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if num_evaluations >= self.budget:\n                    break\n                mutant = self._mutate(i, scores)\n                adaptive_cr = self.cr_min + (self.cr_max - self.cr_min) * (scores[i] - self.best_score) / (np.max(scores) - np.min(scores) + 1e-9)\n                trial = self._crossover(self.population[i], mutant, adaptive_cr)\n                trial_score = func(trial)\n                num_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n\n            if num_evaluations < self.budget:\n                archived_best = min(self.elite_archive, key=func)\n                local_best = self._local_optimize(archived_best, func)\n                local_best_score = func(local_best)\n                num_evaluations += 1\n                if local_best_score < self.best_score:\n                    self.best_score = local_best_score\n                    self.best_solution = local_best\n\n        return self.best_solution", "name": "EnhancedAdaptivePeriodicDEOptimizer", "description": "Enhanced AdaptivePeriodicDEOptimizer by incorporating elite archiving and dynamic parameter adaptation for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.9900042113423714, "feedback": "The algorithm EnhancedAdaptivePeriodicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.990 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ba38a9fc-c1be-4c34-ad3f-3055c0942fe9", "metadata": {"aucs": [0.9900338646952794, 0.9929794547515419, 0.9869993145802924], "final_y": [0.16485613704652047, 0.16485772182235947, 0.16485612617309164]}, "mutation_prompt": null}
