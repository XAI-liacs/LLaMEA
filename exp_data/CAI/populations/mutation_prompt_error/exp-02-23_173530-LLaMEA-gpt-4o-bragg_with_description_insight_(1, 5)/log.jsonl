{"id": "9a2eb0d4-9c5b-465b-a485-c24174e4abc7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for _ in range(max_iter):\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < 0.9\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "The algorithm combines Differential Evolution for global exploration, quasi-oppositional symmetry for enhanced search space sampling, and a local BFGS optimizer for fine-tuning around promising solutions, integrating periodicity through custom constraints.", "configspace": "", "generation": 0, "fitness": 0.7446206108450767, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.745 with standard deviation 0.035. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7694533227722982, 0.7697545473176886, 0.6946539624452432], "final_y": [0.18187904406372957, 0.16486126127448364, 0.18188386945343515]}, "mutation_prompt": null}
{"id": "d5600ea2-df93-45e1-b323-c73e7349ed97", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PSOHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            # Adding a penalty for non-periodic solutions\n            penalty = np.sum(np.abs(np.diff(params, n=2)))\n            return func(params) + penalty\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _particle_swarm_optimization(self, func, bounds, num_particles=30, max_iter=200):\n        lb, ub = bounds.lb, bounds.ub\n        position = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocity = np.random.uniform(-1, 1, (num_particles, self.dim))\n        personal_best_position = position.copy()\n        personal_best_value = np.array([self._reflectivity_cost(p, func) for p in position])\n        global_best_idx = np.argmin(personal_best_value)\n        global_best_position = personal_best_position[global_best_idx]\n\n        for t in range(max_iter):\n            inertia_weight = 0.9 - t * (0.5 / max_iter)\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = 2.0 * r1 * (personal_best_position[i] - position[i])\n                social_velocity = 2.0 * r2 * (global_best_position - position[i])\n                velocity[i] = inertia_weight * velocity[i] + cognitive_velocity + social_velocity\n                position[i] = np.clip(position[i] + velocity[i], lb, ub)\n                \n                cost = self._reflectivity_cost(position[i], func)\n                if cost < personal_best_value[i]:\n                    personal_best_value[i] = cost\n                    personal_best_position[i] = position[i].copy()\n\n            global_best_idx = np.argmin(personal_best_value)\n            global_best_position = personal_best_position[global_best_idx]\n\n        return global_best_position\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Particle Swarm Optimization\n        best_global = self._particle_swarm_optimization(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "PSOHybridOptimizer", "description": "The algorithm integrates a Particle Swarm Optimization (PSO) with adaptive inertia weight for global exploration and a periodicity-enforcing penalty in the cost function to guide solutions towards constructive interference patterns.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Exceeded budget!').", "error": "RuntimeError('Exceeded budget!')", "parent_id": "9a2eb0d4-9c5b-465b-a485-c24174e4abc7", "metadata": {}, "mutation_prompt": null}
{"id": "1417b850-3bec-4ede-919f-4dbeaa0cc5f0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for _ in range(max_iter):\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Introduce periodic enforcement in mutation\n                mutant = np.clip(a + 0.8 * (b - c) + np.sin(a - b) * 0.01, lb, ub)\n                cross_points = np.random.rand(self.dim) < 0.9\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n\n        # Adaptive local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', \n                          bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)], options={'maxiter': int(0.1 * self.budget)})\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "The algorithm enhances exploration and exploitation by incorporating a periodicity-enforced mutation step into Differential Evolution and an adaptive local search phase using BFGS to dynamically tune parameters based on convergence speed.  ", "configspace": "", "generation": 1, "fitness": 0.725768250446051, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.726 with standard deviation 0.033. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "9a2eb0d4-9c5b-465b-a485-c24174e4abc7", "metadata": {"aucs": [0.761949353641783, 0.733472348903853, 0.6818830487925167], "final_y": [0.18187839800492211, 0.16486124709639793, 0.18188157193399979]}, "mutation_prompt": null}
{"id": "d6af1627-6525-430f-bb26-72388e51a0cf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for _ in range(max_iter):\n            mutation_rate = 0.5 + np.random.rand() * 0.3  # Adaptive mutation rate\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + mutation_rate * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < 0.6 + np.random.rand() * 0.3  # Adaptive crossover rate\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Introduce adaptive crossover and mutation rates to improve exploration and exploitation balance in Differential Evolution.", "configspace": "", "generation": 1, "fitness": 0.7052070548811131, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.705 with standard deviation 0.032. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "9a2eb0d4-9c5b-465b-a485-c24174e4abc7", "metadata": {"aucs": [0.7499086371616326, 0.6853074777911117, 0.680405049690595], "final_y": [0.1648619242015058, 0.20725462486322954, 0.16485712264093855]}, "mutation_prompt": null}
{"id": "276ffa76-c22c-44be-9136-ffd211fd1b69", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for _ in range(max_iter):\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Introduced periodicity bias in the mutation step\n                period = (ub - lb) / 2\n                mutant = np.clip(a + 0.8 * (b - c) + 0.1 * np.sin(2 * np.pi * (a / period)), lb, ub)\n                cross_points = np.random.rand(self.dim) < 0.9\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by introducing a periodicity bias in the differential evolution mutation step to better exploit constructive interference.", "configspace": "", "generation": 1, "fitness": 0.7137456500385984, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.714 with standard deviation 0.047. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "9a2eb0d4-9c5b-465b-a485-c24174e4abc7", "metadata": {"aucs": [0.7499212784580451, 0.6468583015298603, 0.7444573701278894], "final_y": [0.18187828822750285, 0.20044656821654494, 0.1648616871257974]}, "mutation_prompt": null}
{"id": "6e43386a-4377-4fe0-962a-044cd9c5f5c2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with dynamic mutation and crossover \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter  # Dynamic crossover probability\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Enhanced the algorithm by incorporating a dynamic adjustment of mutation factor and crossover probability in Differential Evolution to improve convergence performance.", "configspace": "", "generation": 1, "fitness": 0.7379278130427297, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.738 with standard deviation 0.033. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9a2eb0d4-9c5b-465b-a485-c24174e4abc7", "metadata": {"aucs": [0.7841130385434473, 0.7127575520429732, 0.7169128485417686], "final_y": [0.1648606503701262, 0.16485985416954763, 0.1648559635836332]}, "mutation_prompt": null}
{"id": "de2569cc-5233-424a-8033-0e1da5ea9d03", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with dynamic mutation and crossover \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for gen in range(max_iter):\n            pop_size = int(20 + 0.4 * gen)  # Adaptive population size\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter  # Dynamic crossover probability\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c) * np.sin(2 * np.pi * gen / max_iter), lb, ub)  # Periodical bias\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Introduced adaptive population size and periodical bias to enhance exploration and convergence in Differential Evolution.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "6e43386a-4377-4fe0-962a-044cd9c5f5c2", "metadata": {}, "mutation_prompt": null}
{"id": "7c52c006-0bbc-459f-81bd-23ca4ce61d6b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _levy_flight(self, size):\n        \"\"\" Generate Lévy flight steps \"\"\"\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1/beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v)**(1/beta)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with dynamic mutation and crossover \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter  # Dynamic crossover probability\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c) + 0.01 * self._levy_flight(self.dim), lb, ub)  # Added Levy flight\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Improved exploration by adding Lévy flight steps to Differential Evolution to escape local optima.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "6e43386a-4377-4fe0-962a-044cd9c5f5c2", "metadata": {}, "mutation_prompt": null}
{"id": "1eaba2db-880f-45a8-a2a2-3a09a12cb710", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with dynamic mutation and crossover, plus elitism \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n        \n        for gen in range(max_iter):\n            F = 0.6 + (0.8 - 0.6) * (max_iter - gen) / max_iter  # Adjusted mutation factor\n            CR = 0.4 + (0.9 - 0.4) * gen / max_iter  # Adjusted crossover probability\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                if self._reflectivity_cost(trial, func) < self._reflectivity_cost(population[i], func):\n                    population[i] = trial\n                    if self._reflectivity_cost(trial, func) < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n            best = np.clip(best, lb, ub)  # Ensure best is within bounds\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Improved convergence by introducing elitism and adaptive boundary control in Differential Evolution, maintaining a balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "6e43386a-4377-4fe0-962a-044cd9c5f5c2", "metadata": {}, "mutation_prompt": null}
{"id": "0cb6e1e7-4652-4c41-892e-042d4285a6be", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _quasi_oppositional(self, population, bounds):\n        \"\"\" Quasi-oppositional initialization \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        pop_size = population.shape[0]\n        opp_population = lb + ub - population + np.random.rand(pop_size, self.dim) * (ub - lb) * 0.1\n        return np.clip(opp_population, lb, ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with dynamic mutation and crossover \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = np.concatenate((population, self._quasi_oppositional(population, bounds)))\n        scores = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(scores)\n        best = population[best_idx].copy()\n        \n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter  # Dynamic crossover probability\n            diversity = np.std(scores)  # Calculate diversity\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                if diversity < 1e-5:  # Adaptive mutation strategy\n                    F *= 1.2\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_cost = self._reflectivity_cost(trial, func)\n                if trial_cost < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_cost\n                    if trial_cost < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "HybridOptimizer", "description": "Introduced diversity preservation via crowding distance and adaptive mutation strategies to enhance convergence and robustness of Differential Evolution.", "configspace": "", "generation": 2, "fitness": 0.8379001994065787, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.031. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "6e43386a-4377-4fe0-962a-044cd9c5f5c2", "metadata": {"aucs": [0.8565058630882384, 0.7945328207347904, 0.8626619143967073], "final_y": [0.16486440236526134, 0.18813888220942876, 0.1648560423372014]}, "mutation_prompt": null}
{"id": "a91d10c5-e401-4b39-84a8-d63253ea176a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2  # Assuming periodicity of 2 layers\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg, avg] * (period // 2), axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Introduce a novel Crowding Differential Evolution (CDE) algorithm that employs crowding distance for diversity maintenance and a periodic constraint to encourage constructive interference in multilayered photonic structures.", "configspace": "", "generation": 2, "fitness": 0.946809060175934, "feedback": "The algorithm CrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.947 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6e43386a-4377-4fe0-962a-044cd9c5f5c2", "metadata": {"aucs": [0.9515433401731112, 0.9425479755552699, 0.946335864799421], "final_y": [0.1648585336066709, 0.16486271760794247, 0.16485917666083683]}, "mutation_prompt": null}
{"id": "907b4c3b-f6d8-48cc-a954-991ce1ae8985", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg] * period, axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Refine the CrowdingDEOptimizer by introducing adaptive periodicity in constraints and a dynamic mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "a91d10c5-e401-4b39-84a8-d63253ea176a", "metadata": {}, "mutation_prompt": null}
{"id": "cf156ab7-51b9-43db-ac49-c87a26903dcf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds, gen, max_iter):\n        \"\"\" Constrain solutions to encourage periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + (gen // (max_iter // 2))  # Dynamic periodicity adjustment\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.tile(avg[:, None], (1, min(period, self.dim-i))), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds, 0, max_iter)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter\n            CR = 0.6 + (0.3 * np.random.rand())  # Adaptive crossover rate\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds, gen, max_iter)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Refine Crowding Differential Evolution by dynamically adjusting periodic constraints and utilizing adaptive crossover rates to enhance search efficiency and solution quality.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Exceeded budget!').", "error": "RuntimeError('Exceeded budget!')", "parent_id": "a91d10c5-e401-4b39-84a8-d63253ea176a", "metadata": {}, "mutation_prompt": null}
{"id": "2085e2da-3c2d-4dad-a1ec-eb17e96b5687", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2  # Adaptive modulation of periodicity\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg, avg] * (period // 2), axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Introduce adaptive periodicity modulation to further enhance constructive interference in Crowding Differential Evolution.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "a91d10c5-e401-4b39-84a8-d63253ea176a", "metadata": {}, "mutation_prompt": null}
{"id": "dcb41f74-8f58-469a-a0a0-c87db6390560", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2  # Assuming periodicity of 2 layers\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg, avg] * (period // 2), axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter\n            CR = 0.9 - (0.5 * gen / max_iter)  # Adjusted line for CR\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Refine the CrowdingDEOptimizer by dynamically adjusting the crossover rate CR based on generation progress to balance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "a91d10c5-e401-4b39-84a8-d63253ea176a", "metadata": {}, "mutation_prompt": null}
{"id": "dbacdb93-b5ca-46a9-9dfe-5c6425ef2bd8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = self.dim // 5  # Adaptive periodicity based on dimensionality\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg]*period, axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (max_iter - gen) / max_iter\n            CR = 0.1 + (0.8 * np.exp(-gen/max_iter))  # Dynamic crossover rate\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Introduce adaptive periodic constraints and dynamic crossover rates to improve diversity and convergence in the Crowding Differential Evolution algorithm for multilayer photonic structure optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "a91d10c5-e401-4b39-84a8-d63253ea176a", "metadata": {}, "mutation_prompt": null}
{"id": "dc5e4f7c-6887-4e67-8bc1-bd9205413c82", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg] * period, axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Refine the CrowdingDEOptimizer by introducing adaptive periodicity in constraints and a dynamic mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "907b4c3b-f6d8-48cc-a954-991ce1ae8985", "metadata": {}, "mutation_prompt": null}
{"id": "06b5d175-9ed6-4f00-a3b7-fc1fc62ad51a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.repeat(avg[:, None], period, axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / (max_iter * 2) * np.pi)  # Adjusted dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Refine the CrowdingDEOptimizer by fixing the broadcasting error in the trial matrix and adapting mutation more effectively for diverse exploration.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "907b4c3b-f6d8-48cc-a954-991ce1ae8985", "metadata": {}, "mutation_prompt": null}
{"id": "5852d6b4-37ae-4eea-8b5d-860c3b4fb75d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1, keepdims=True)  # Ensure broadcasting compatibility\n            population[:, i:i+period] = np.clip(np.repeat(avg, period, axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance the periodic constraint application to prevent dimension mismatches, ensuring correct broadcasting during optimization.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "907b4c3b-f6d8-48cc-a954-991ce1ae8985", "metadata": {}, "mutation_prompt": null}
{"id": "3fabb233-3732-4999-a2aa-dd8c44d96d3c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, self.dim, period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.tile(avg[:, None], (1, min(period, self.dim-i))), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance adaptive periodicity in constraints and adjust cross-points selection to resolve broadcasting error.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "907b4c3b-f6d8-48cc-a954-991ce1ae8985", "metadata": {}, "mutation_prompt": null}
{"id": "88ff5f8c-3e8a-4a2a-945d-e086c4b2c35b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, population.shape[1], period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            avg = np.clip(avg, lb[i:i+period], ub[i:i+period])\n            population[:, i:i+period] = np.tile(avg[:, None], (1, period))\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance the CrowdingDEOptimizer by refining periodic constraints and correcting a broadcasting issue.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,) (2,) (2,) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,) (2,) (2,) ')", "parent_id": "907b4c3b-f6d8-48cc-a954-991ce1ae8985", "metadata": {}, "mutation_prompt": null}
{"id": "3cdf33bd-a3d7-4be6-a555-673174a1acf0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, population.shape[1], max(1, period)):  # Safeguard with max(1, period)\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg] * period, axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance population initialization to prevent IndexError by adding a safeguard for periodic constraint calculation.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "dc5e4f7c-6887-4e67-8bc1-bd9205413c82", "metadata": {}, "mutation_prompt": null}
{"id": "95618622-fbc2-4fcf-9b39-c9e67076f39a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, self.dim, period):\n            start, end = i, min(i + period, self.dim)\n            avg = np.mean(population[:, start:end], axis=1)\n            population[:, start:end] = np.clip(np.stack([avg] * (end - start), axis=1), lb[start:end], ub[start:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance the CrowdingDEOptimizer by refining periodic constraint handling and ensuring dynamic mutation adapts to evaluation progress for better solution diversity and convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "dc5e4f7c-6887-4e67-8bc1-bd9205413c82", "metadata": {}, "mutation_prompt": null}
{"id": "ced99b12-01ea-4f28-b220-8bc80e94b630", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, self.dim, period):\n            end_idx = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end_idx], axis=1)\n            population[:, i:end_idx] = np.clip(np.stack([avg] * (end_idx - i), axis=1), lb[i:end_idx], ub[i:end_idx])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < costs[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance CrowdingDEOptimizer by refining adaptive periodicity constraints and dynamic mutation strategy to improve performance and address indexing issues.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "dc5e4f7c-6887-4e67-8bc1-bd9205413c82", "metadata": {}, "mutation_prompt": null}
{"id": "0fcd5cfb-f785-4211-8f21-13eddcf4e7e9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adaptive periodicity\n        for i in range(0, self.dim, period):\n            avg = np.mean(population[:, i:i+period], axis=1)\n            population[:, i:i+period] = np.clip(np.stack([avg] * min(period, self.dim-i), axis=1), lb[i:i+period], ub[i:i+period])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        best_idx = np.argmin([self._reflectivity_cost(ind, func) for ind in population])\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                cost_i = self._reflectivity_cost(population[i], func)\n                if cost_trial < cost_i or (cost_trial == cost_i and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global search with Crowding Differential Evolution\n        best_global = self._differential_evolution(func, bounds)\n\n        # Local search using BFGS\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "CrowdingDEOptimizer", "description": "Enhance the CrowdingDEOptimizer by fixing the IndexError and incorporating an adaptive crowding distance strategy to improve diversity and convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (1,3) into shape (1,1)').", "error": "ValueError('could not broadcast input array from shape (1,3) into shape (1,1)')", "parent_id": "dc5e4f7c-6887-4e67-8bc1-bd9205413c82", "metadata": {}, "mutation_prompt": null}
{"id": "0bc099f9-c831-4c9a-88f5-0809a3ecf597", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improve the CrowdingDEOptimizer by addressing index errors and refining periodic constraints to stabilize periodicity in solutions.", "configspace": "", "generation": 5, "fitness": 0.9771226892383874, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dc5e4f7c-6887-4e67-8bc1-bd9205413c82", "metadata": {"aucs": [0.9819821356170744, 0.9759053308463407, 0.9734806012517473], "final_y": [0.16485944567300514, 0.16485759023088353, 0.1648606514953842]}, "mutation_prompt": null}
{"id": "4aed7072-1ecf-473c-8bb2-1359714760d0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.3 + (0.6 - 0.3) * gen / max_iter  # Modified crossover rate calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Modify the crossover rate calculation to enhance exploration and refinement balance.", "configspace": "", "generation": 6, "fitness": 0.9645194298555939, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.011. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0bc099f9-c831-4c9a-88f5-0809a3ecf597", "metadata": {"aucs": [0.9754867357189012, 0.9681117302650627, 0.9499598235828177], "final_y": [0.16485690718671775, 0.16485616792585134, 0.16485602384655074]}, "mutation_prompt": null}
{"id": "b2cc03d4-9c25-4b0a-8f1d-e089bbe34125", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.random.rand()  # Modified line for adaptive F\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Modify the mutation strategy to adaptively vary the scaling factor for enhanced diversity and convergence.", "configspace": "", "generation": 6, "fitness": 0.9735555687357657, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0bc099f9-c831-4c9a-88f5-0809a3ecf597", "metadata": {"aucs": [0.9738860981677848, 0.9714539495000648, 0.9753266585394471], "final_y": [0.1648581588309923, 0.16485736672978213, 0.16486123035881517]}, "mutation_prompt": null}
{"id": "ae1810f3-a5a7-4c64-a511-1744b9da0b7d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1, keepdims=True)\n            population[:, i:end] = np.clip(np.repeat(avg, end - i, axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Refine the adaptive periodicity constraint to more effectively stabilize periodicity in solutions.", "configspace": "", "generation": 6, "fitness": 0.9733851509674087, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0bc099f9-c831-4c9a-88f5-0809a3ecf597", "metadata": {"aucs": [0.9765955481645896, 0.9665734959430996, 0.9769864087945369], "final_y": [0.16485801924060484, 0.16485771245334557, 0.1648647537937773]}, "mutation_prompt": null}
{"id": "544987f9-8fed-4d57-93fc-80feca543980", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1) * 0.9  # Modified line\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhance periodicity enforcement and adapt local optimization integration to improve solution refinement.", "configspace": "", "generation": 6, "fitness": 0.9692764268086161, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.010. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0bc099f9-c831-4c9a-88f5-0809a3ecf597", "metadata": {"aucs": [0.9561023227925983, 0.9702626434247605, 0.9814643142084893], "final_y": [0.16485734507807281, 0.1648578512090696, 0.1648624642235177]}, "mutation_prompt": null}
{"id": "30cfec71-ac60-4e44-92b5-66c8e121e0f1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive periodicity by improving the constraining function with dynamic period adjustment based on dimension scalability.", "configspace": "", "generation": 6, "fitness": 0.9741301276541129, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0bc099f9-c831-4c9a-88f5-0809a3ecf597", "metadata": {"aucs": [0.9734247756859202, 0.9708957600854334, 0.978069847190985], "final_y": [0.1648581384621457, 0.1648561175428238, 0.164860640670203]}, "mutation_prompt": null}
{"id": "bb538f86-0b96-47a8-8247-5d9200ae8222", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.6 + 0.3 * np.cos(gen / max_iter * np.pi)  # Adjusted control parameter\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive periodicity with dynamic control of differential evolution parameters and enforced periodic symmetry.", "configspace": "", "generation": 7, "fitness": 0.967231480043688, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "30cfec71-ac60-4e44-92b5-66c8e121e0f1", "metadata": {"aucs": [0.9668589750542825, 0.9635694957763331, 0.9712659693004482], "final_y": [0.16485655604121607, 0.1648581165141938, 0.16485842545801055]}, "mutation_prompt": null}
{"id": "ce657480-9ce0-4276-89c1-b7673a957dca", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n        \n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi)  # Modified scaling factor\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved solution exploration via adaptive parameter scaling and enhanced periodicity enforcement for superior optimization performance.", "configspace": "", "generation": 7, "fitness": 0.9698023969862096, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.970 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "30cfec71-ac60-4e44-92b5-66c8e121e0f1", "metadata": {"aucs": [0.960854219870767, 0.9741461713551388, 0.9744067997327227], "final_y": [0.16485934401437885, 0.16486288016720552, 0.1648567604948401]}, "mutation_prompt": null}
{"id": "37b05f79-2f05-4727-8d05-1f8fc89660a0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.4 - 0.5) * np.cos(gen / max_iter * np.pi)  # Adjusted mutation factor adaptation\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved mutation factor adaptation strategy in the differential evolution process.", "configspace": "", "generation": 7, "fitness": 0.9712330630968444, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "30cfec71-ac60-4e44-92b5-66c8e121e0f1", "metadata": {"aucs": [0.9721579287009687, 0.9671079821616837, 0.9744332784278809], "final_y": [0.16485911002328046, 0.1648574990885947, 0.16485778376547255]}, "mutation_prompt": null}
{"id": "10a9061d-45cd-4859-8396-dfa0b3b5b427", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved periodic constraint by dynamic adaptation to dimensionality, enhancing fine-tuning proximity to known periodic solutions.", "configspace": "", "generation": 7, "fitness": 0.972070061832769, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.972 with standard deviation 0.007. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "30cfec71-ac60-4e44-92b5-66c8e121e0f1", "metadata": {"aucs": [0.9742260258059228, 0.9627141169756588, 0.9792700427167252], "final_y": [0.16485810366954023, 0.16485631262464806, 0.16485810136381496]}, "mutation_prompt": null}
{"id": "27ecc438-94e8-45f5-86d2-ab2145e5fda7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.1 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive periodicity with dynamic crowding distance weighting and improved exploitation-exploration balance.", "configspace": "", "generation": 7, "fitness": 0.9737621120758689, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "30cfec71-ac60-4e44-92b5-66c8e121e0f1", "metadata": {"aucs": [0.9697990745271825, 0.9767075187982154, 0.9747797429022087], "final_y": [0.16485923258534962, 0.1648596118031712, 0.1648579552693198]}, "mutation_prompt": null}
{"id": "c917ca21-d726-4f4f-a953-bf5f4e31a6c6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.1 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = max(1, 2 + int((self.eval_count / self.budget) * (self.dim // 4)))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 * np.log(1 + 2 * gen / max_iter))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved periodicity constraint adaptation and enhanced dynamic parameter tuning for better performance.", "configspace": "", "generation": 8, "fitness": 0.9719469431138691, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.972 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "27ecc438-94e8-45f5-86d2-ab2145e5fda7", "metadata": {"aucs": [0.9722866720210741, 0.9728214959363781, 0.9707326613841547], "final_y": [0.1648566835877754, 0.16485941810173022, 0.16485716991043964]}, "mutation_prompt": null}
{"id": "c4a08471-f969-4e75-a678-b4f3a82118a4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.1 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.6 + (0.9 - 0.5) * gen / max_iter  # Slightly increased CR for improved diversity\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved exploitation balance by adjusting crossover rate (CR) to maintain diversity.", "configspace": "", "generation": 8, "fitness": 0.9675651421531039, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "27ecc438-94e8-45f5-86d2-ab2145e5fda7", "metadata": {"aucs": [0.9612840354212014, 0.9688722238056999, 0.97253916723241], "final_y": [0.16485738687234908, 0.1648614898504135, 0.16485928558852714]}, "mutation_prompt": null}
{"id": "d075d983-e4e4-445c-9944-5fe6074ba4c3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.1 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Adjusted exploration-exploitation balance\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.75 + 0.25 * np.cos(gen / max_iter * np.pi))  # Refined enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved balance of exploration and exploitation by refining the mutation factor adaptive mechanism.", "configspace": "", "generation": 8, "fitness": 0.970781896052666, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "27ecc438-94e8-45f5-86d2-ab2145e5fda7", "metadata": {"aucs": [0.9678855821920483, 0.9707798990397882, 0.9736802069261615], "final_y": [0.16485876862815663, 0.16486042053112637, 0.16485722081768928]}, "mutation_prompt": null}
{"id": "144a6909-10d0-4026-b3d8-09983fc60613", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=25, max_iter=120):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive periodicity with dynamic crowding distance weighting and improved parameter tuning for better convergence.", "configspace": "", "generation": 8, "fitness": 0.9716998131238692, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.972 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "27ecc438-94e8-45f5-86d2-ab2145e5fda7", "metadata": {"aucs": [0.9663890727659193, 0.9746822333641331, 0.9740281332415551], "final_y": [0.16485724735294582, 0.1648574041176154, 0.1648629509521684]}, "mutation_prompt": null}
{"id": "bb0a1a17-f76a-4f51-882e-75a2ed1d75fc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive periodicity with dynamic crowding distance weighting, improved exploration-exploitation balance, and refined selection mechanisms.", "configspace": "", "generation": 8, "fitness": 0.9723168296244126, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.972 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "27ecc438-94e8-45f5-86d2-ab2145e5fda7", "metadata": {"aucs": [0.9750991566254634, 0.9681575845790903, 0.9736937476686842], "final_y": [0.1648612028665356, 0.16485924248102457, 0.16485786239698286]}, "mutation_prompt": null}
{"id": "6752a0f2-9d85-4a16-87c1-5af251778945", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi)  # Improved mutation factor calculation\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved exploration by modifying the mutation factor calculation to enhance convergence.", "configspace": "", "generation": 9, "fitness": 0.9692544541682522, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb0a1a17-f76a-4f51-882e-75a2ed1d75fc", "metadata": {"aucs": [0.9677350293925872, 0.9706188593646884, 0.969409473747481], "final_y": [0.1648567197784092, 0.1648582043313951, 0.1648579926506577]}, "mutation_prompt": null}
{"id": "e24cf04c-4a8e-485c-bcba-1f89ed691710", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 4))  # Modified period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.6 + (0.8 - 0.6) * np.sin(gen / max_iter * np.pi)\n            CR = 0.6 + (0.8 - 0.6) * gen / max_iter\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "EnhancedCrowdingDEOptimizer with adaptive periodic constraint adjustment and improved exploitation by dynamic parameter tuning.", "configspace": "", "generation": 9, "fitness": 0.9728087379079318, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb0a1a17-f76a-4f51-882e-75a2ed1d75fc", "metadata": {"aucs": [0.9706260156401513, 0.9725359562101135, 0.9752642418735308], "final_y": [0.16485841448845318, 0.16485744013615122, 0.16485865679866585]}, "mutation_prompt": null}
{"id": "27cabed6-f059-4f90-8858-bc12108a47fb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.25 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive periodicity with sinusoidal adjustment for improved convergence performance.", "configspace": "", "generation": 9, "fitness": 0.9706748537077982, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb0a1a17-f76a-4f51-882e-75a2ed1d75fc", "metadata": {"aucs": [0.9698180305646963, 0.9686173854906406, 0.9735891450680574], "final_y": [0.1648605479282398, 0.1648568056012074, 0.1648562703705505]}, "mutation_prompt": null}
{"id": "fdef3201-fa96-40eb-820b-a5fce9ae11d0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Refined exploration balance with adjusted mutation factor for improved convergence.", "configspace": "", "generation": 9, "fitness": 0.974771905594063, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb0a1a17-f76a-4f51-882e-75a2ed1d75fc", "metadata": {"aucs": [0.9738417848031133, 0.9747959411318348, 0.9756779908472408], "final_y": [0.16486434422253116, 0.16485718847131436, 0.16485909222711337]}, "mutation_prompt": null}
{"id": "8a50c7b7-15d4-47f0-a3b0-b37ba2406d5a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.2) * np.sin(gen / max_iter * np.pi)  # Changed 0.5 to 0.2\n            CR = 0.5 + (0.9 - 0.4) * gen / max_iter  # Changed 0.5 to 0.4\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced mutation strategy and adaptive recombination to improve exploration and fine-tuning.", "configspace": "", "generation": 9, "fitness": 0.9738750111300134, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb0a1a17-f76a-4f51-882e-75a2ed1d75fc", "metadata": {"aucs": [0.9762975288744753, 0.9705698525850049, 0.97475765193056], "final_y": [0.16486148834289904, 0.16485813931679816, 0.1648576629183054]}, "mutation_prompt": null}
{"id": "1f7f8497-8af4-4ffc-863d-e0eed3fbeca1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Fine-tuning the mutation factor variability to optimize convergence speed and solution quality.", "configspace": "", "generation": 10, "fitness": 0.9646300148423181, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fdef3201-fa96-40eb-820b-a5fce9ae11d0", "metadata": {"aucs": [0.9695378827708162, 0.9615285256436032, 0.9628236361125347], "final_y": [0.1648561408323218, 0.16485664618821505, 0.16485906532210148]}, "mutation_prompt": null}
{"id": "d112dffa-238f-4cf9-94a5-f721d4a82998", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi / 2)  # Changed line\n            CR = 0.3 + (0.9 - 0.3) * gen / max_iter  # Changed line\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptive control parameters and diversity preservation in DE for improved convergence efficiency.", "configspace": "", "generation": 10, "fitness": 0.9710597265192337, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fdef3201-fa96-40eb-820b-a5fce9ae11d0", "metadata": {"aucs": [0.9712691236308735, 0.9674078798803611, 0.9745021760464666], "final_y": [0.16485793438898888, 0.16485811960831132, 0.164858725836859]}, "mutation_prompt": null}
{"id": "ff25479c-9403-4b54-bdfe-19ad22f2a66c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration-exploitation balance with adaptive crowding based on evaluation count.", "configspace": "", "generation": 10, "fitness": 0.9714213725924109, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fdef3201-fa96-40eb-820b-a5fce9ae11d0", "metadata": {"aucs": [0.9773854165571961, 0.965942848013496, 0.9709358532065404], "final_y": [0.16485763203330717, 0.1648560643914827, 0.16485895330782152]}, "mutation_prompt": null}
{"id": "96952ced-3c26-4284-b044-afff49ba75c7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(2 * gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Adjusted the sin function in mutation factor calculation for enhanced global exploration.", "configspace": "", "generation": 10, "fitness": 0.9709089697148552, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fdef3201-fa96-40eb-820b-a5fce9ae11d0", "metadata": {"aucs": [0.9736572136912626, 0.965707200757788, 0.9733624946955152], "final_y": [0.16485913153588028, 0.16485947862905648, 0.1648589298938976]}, "mutation_prompt": null}
{"id": "edc040a9-fedf-4c62-a6d2-9fae50291175", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.2 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.3 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration via dynamic mutation strategy and refined crowding distance for diversity.", "configspace": "", "generation": 10, "fitness": 0.9709759246045396, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fdef3201-fa96-40eb-820b-a5fce9ae11d0", "metadata": {"aucs": [0.966872589210732, 0.9700452040923533, 0.9760099805105337], "final_y": [0.16485913462932444, 0.16485614944521687, 0.16485776403553043]}, "mutation_prompt": null}
{"id": "0e225faa-aadc-4a72-b393-6374567b6fc7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        population = np.roll(population, shift=1, axis=1)  # Added line for improved periodicity\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced Differential Evolution with adaptive crowding and refined periodicity constraints for improved reflectivity optimization.", "configspace": "", "generation": 11, "fitness": 0.9786759322346424, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff25479c-9403-4b54-bdfe-19ad22f2a66c", "metadata": {"aucs": [0.9795114661605555, 0.9753038285960367, 0.9812125019473351], "final_y": [0.16486200627538516, 0.16485621264110062, 0.16486153164782724]}, "mutation_prompt": null}
{"id": "b74ad5a7-869e-4d71-88c6-12a8d4da3865", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + 0.4 * np.sin(gen / max_iter * np.pi)  # Changed line\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced a sinusoidal annealing strategy for the crossover rate (CR) to dynamically balance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.976942714843365, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff25479c-9403-4b54-bdfe-19ad22f2a66c", "metadata": {"aucs": [0.9754086158238172, 0.9722390083508632, 0.9831805203554147], "final_y": [0.16486511394656078, 0.1648576621023372, 0.16485750277934508]}, "mutation_prompt": null}
{"id": "7d542b4e-1511-4a58-a7d8-3369d7b73a52", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced a dynamic scaling factor in the mutation operation to further balance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.9780784789564846, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff25479c-9403-4b54-bdfe-19ad22f2a66c", "metadata": {"aucs": [0.9711424223926599, 0.9815117636635251, 0.9815812508132686], "final_y": [0.164860133340051, 0.16485996599040653, 0.16486025555160622]}, "mutation_prompt": null}
{"id": "8d446a8a-c738-4f69-abb5-feec81c356cc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.8 + 0.2 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "An enhanced DE algorithm with adaptive crowding and dynamic exploration-exploitation balance to optimize multilayer photonic structures.", "configspace": "", "generation": 11, "fitness": 0.9791270809631967, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff25479c-9403-4b54-bdfe-19ad22f2a66c", "metadata": {"aucs": [0.9743209482870241, 0.9791001777486626, 0.9839601168539033], "final_y": [0.16486093666432278, 0.16485786058681606, 0.1648560685639333]}, "mutation_prompt": null}
{"id": "180356ca-0521-4272-938b-0723a69ff495", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * gen / max_iter\n            F = F * (0.7 + 0.3 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved exploration via adaptive mutation scaling and diversity maintenance using adjusted periodic constraints.", "configspace": "", "generation": 11, "fitness": 0.9797281077051601, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ff25479c-9403-4b54-bdfe-19ad22f2a66c", "metadata": {"aucs": [0.9770928054419629, 0.9820553901952408, 0.9800361274782767], "final_y": [0.16485876343453287, 0.16485927512183796, 0.16485801817795898]}, "mutation_prompt": null}
{"id": "0aedeaca-3d4c-432a-b159-f7ceefe78d49", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.5 + (0.9 - 0.5) * gen / max_iter\n            F = F * (0.65 + 0.35 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved exploration-exploitation balance and diversity preservation through adaptive parameter tuning and periodic constraints.", "configspace": "", "generation": 12, "fitness": 0.9781219544733051, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "180356ca-0521-4272-938b-0723a69ff495", "metadata": {"aucs": [0.9744984809996416, 0.9798578282826996, 0.9800095541375741], "final_y": [0.16485706799560795, 0.16485722541097259, 0.16485631789985633]}, "mutation_prompt": null}
{"id": "471be235-12cb-4955-8eb9-09f12b495287", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(2 * gen / max_iter * np.pi)  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * gen / max_iter\n            F = F * (0.7 + 0.3 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration using sinusoidal adaptive mutation scaling to optimize periodic multilayer structures.", "configspace": "", "generation": 12, "fitness": 0.979970798343126, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "180356ca-0521-4272-938b-0723a69ff495", "metadata": {"aucs": [0.9814869545487479, 0.9813208502893618, 0.9771045901912678], "final_y": [0.16485802684783313, 0.16485756364686233, 0.16485709230116208]}, "mutation_prompt": null}
{"id": "df16c3d7-7bb2-4bfc-977a-007aa9b7015b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * gen / max_iter\n            F = F * (0.75 + 0.25 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration-exploitation balance through adaptive periodic constraints and refined mutation scaling.", "configspace": "", "generation": 12, "fitness": 0.9805484656602864, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "180356ca-0521-4272-938b-0723a69ff495", "metadata": {"aucs": [0.9792618067929404, 0.9791986461399862, 0.9831849440479328], "final_y": [0.16486199007046798, 0.16485748426438807, 0.16485776469928737]}, "mutation_prompt": null}
{"id": "4b891011-84c6-4622-9d99-386d9c785442", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * gen / max_iter\n            F = F * (0.7 + 0.3 * np.cos(2 * np.pi * gen / max_iter))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration with adaptive cosine-based mutation and refined periodic constraint enforcement.", "configspace": "", "generation": 12, "fitness": 0.9778633426810494, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "180356ca-0521-4272-938b-0723a69ff495", "metadata": {"aucs": [0.9724212607604815, 0.9808350673364907, 0.9803336999461754], "final_y": [0.16486074178417354, 0.16485834310385195, 0.1648574227324302]}, "mutation_prompt": null}
{"id": "eca3cdb4-2033-42b5-b9e4-cbf55af71e6a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.20 * np.sin(self.eval_count / self.budget * np.pi))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * gen / max_iter\n            F = F * (0.7 + 0.3 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced crowding distance calculation by introducing non-linear scaling based on the evaluation count.", "configspace": "", "generation": 12, "fitness": 0.9783798416197871, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "180356ca-0521-4272-938b-0723a69ff495", "metadata": {"aucs": [0.9765013681998399, 0.9772383732827116, 0.9813997833768099], "final_y": [0.16485743096530103, 0.1648573637976336, 0.16485824220420897]}, "mutation_prompt": null}
{"id": "d6e582ea-d03e-4916-b724-687ac3d4e9b1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.20 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 4 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.7 + (0.9 - 0.7) * gen / max_iter\n            F = F * (0.75 + 0.25 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced diversity and adaptive periodic constraints for improved optimization accuracy.", "configspace": "", "generation": 13, "fitness": 0.9793482625944208, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "df16c3d7-7bb2-4bfc-977a-007aa9b7015b", "metadata": {"aucs": [0.97651794720008, 0.9801739791009338, 0.9813528614822485], "final_y": [0.16485941892432132, 0.16485814572440516, 0.16485779637042652]}, "mutation_prompt": null}
{"id": "15b4053e-217a-47c8-9ded-1c2960c12abb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.65 + (0.9 - 0.65) * gen / max_iter  # Altered crossover range for enhanced diversity\n            F = F * (0.75 + 0.25 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced adaptation to dynamic periods and crossover rates for improved periodicity and convergence.", "configspace": "", "generation": 13, "fitness": 0.9796566250690718, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "df16c3d7-7bb2-4bfc-977a-007aa9b7015b", "metadata": {"aucs": [0.9786301215115103, 0.980037154322383, 0.980302599373322], "final_y": [0.16485708243549468, 0.16485751166766005, 0.16485995338970327]}, "mutation_prompt": null}
{"id": "95732677-1655-4aa2-9317-93ec520f1647", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (1 - np.cos(gen / max_iter * np.pi/2))  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Changed line\n            F *= 0.8  # Changed line\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Adaptive mutation and crossover rate adjustments enhance convergence by dynamically balancing exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.9819465102702697, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "df16c3d7-7bb2-4bfc-977a-007aa9b7015b", "metadata": {"aucs": [0.9781783824851298, 0.9846731394448731, 0.9829880088808062], "final_y": [0.16485751751134836, 0.16485770063342065, 0.16485762092588507]}, "mutation_prompt": null}
{"id": "beb20785-2ee5-4bf9-b57c-e3f16baec99b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * gen / max_iter\n            F = F * (0.75 + 0.25 * np.sin(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced adaptive mutation scaling to enhance solution diversity and convergence efficiency.", "configspace": "", "generation": 13, "fitness": 0.9781646883503865, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "df16c3d7-7bb2-4bfc-977a-007aa9b7015b", "metadata": {"aucs": [0.9807824107705183, 0.9763419917905671, 0.977369662490074], "final_y": [0.16485783903595264, 0.16485894263509404, 0.16486102131320268]}, "mutation_prompt": null}
{"id": "02e3e453-8ed7-4138-8587-fc8ca7d582ed", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Changed line (0.10 to 0.15)\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 4 + int((self.eval_count / self.budget) * (self.dim // 3))  # Changed line (3 to 4, 2 to 3)\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line (0.9 to 0.8)\n            CR = 0.65 + (0.9 - 0.65) * gen / max_iter  # Changed line (0.6 to 0.65)\n            F = F * (0.75 + 0.25 * np.cos(gen / max_iter * np.pi))  # Enhanced exploration-exploitation balance\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved adaptive periodic constraints and enhanced mutation scaling for better exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.9784400880134639, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "df16c3d7-7bb2-4bfc-977a-007aa9b7015b", "metadata": {"aucs": [0.976570056331015, 0.9844160560891358, 0.9743341516202407], "final_y": [0.16485623680417893, 0.16485805606432535, 0.16485655793112597]}, "mutation_prompt": null}
{"id": "5e760ae9-742c-4153-97a9-898dacb79b45", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2) + 1)  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (1 - np.cos(gen / max_iter * np.pi/2))  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Changed line\n            F *= 0.82  # Changed line\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhancing the periodic constraint adaptation and fine-tuning to improve convergence to optimal solutions.", "configspace": "", "generation": 14, "fitness": 0.9791761581114852, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "95732677-1655-4aa2-9317-93ec520f1647", "metadata": {"aucs": [0.9795124644727425, 0.9807067826979765, 0.9773092271637367], "final_y": [0.16485883127825085, 0.16486135954442305, 0.164860718564379]}, "mutation_prompt": null}
{"id": "da7aab3b-f3aa-4b2f-b083-6f5723c6b6de", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting, line 1\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line 2\n            CR = 0.6 + (0.8 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Changed line 3\n            F *= 0.85  # Changed line 4\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced adaptive mutation scaling and a periodicity bias to enhance convergence towards periodic solutions.", "configspace": "", "generation": 14, "fitness": 0.9810143319568022, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "95732677-1655-4aa2-9317-93ec520f1647", "metadata": {"aucs": [0.9801400458895045, 0.9786075843712317, 0.9842953656096702], "final_y": [0.16485703918536998, 0.16486009475327568, 0.16485964989891977]}, "mutation_prompt": null}
{"id": "f215afd3-54c8-4132-a894-c9a9619fd3fd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.6 + (0.9 - 0.6) * (1 - np.cos(gen / max_iter * np.pi/2))  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi/2)\n            F *= 0.8\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration through dynamic mutation scaling and periodic constraint adaptation for better global search in DE.", "configspace": "", "generation": 14, "fitness": 0.9778285875725602, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "95732677-1655-4aa2-9317-93ec520f1647", "metadata": {"aucs": [0.9738869406549774, 0.9815787205046677, 0.9780201015580358], "final_y": [0.16485675973573088, 0.16485875958846907, 0.16485835367062007]}, "mutation_prompt": null}
{"id": "aa692d04-b250-415d-a88a-b0ddd658ef13", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (1 - np.cos(gen / max_iter * np.pi/2))  # Changed line\n            CR = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Changed line\n            F *= 0.85  # Changed line\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced population diversity by adjusting mutation factor scaling to promote exploration.", "configspace": "", "generation": 14, "fitness": 0.9798132179586996, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "95732677-1655-4aa2-9317-93ec520f1647", "metadata": {"aucs": [0.9813829710717609, 0.9794685662727879, 0.9785881165315499], "final_y": [0.16485742753921906, 0.16485706295251057, 0.16485747200933176]}, "mutation_prompt": null}
{"id": "e7e1ccd0-ca02-4c51-99ec-ae9b7805948c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.10 * (self.eval_count / self.budget))  # Adjusted distance weighting\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (1 - np.cos(gen / max_iter * np.pi/2))\n            CR = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi/2)\n            CR *= 1.2  # Changed line\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced a dynamic adjustment to the crossover rate to enhance exploration early in the optimization process.", "configspace": "", "generation": 14, "fitness": 0.9796923939726208, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "95732677-1655-4aa2-9317-93ec520f1647", "metadata": {"aucs": [0.9784105848523124, 0.9811151989612795, 0.9795513981042702], "final_y": [0.16485722125035085, 0.1648580355868141, 0.1648592887868845]}, "mutation_prompt": null}
{"id": "f9e281c6-b1fd-49bd-9dde-aeab21d2ed07", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting, line 1\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line 2\n            CR = 0.6 + (0.8 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Changed line 3\n            F *= 0.85  # Changed line 4\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < (CR * np.random.rand())  # Modified trial mutation strategy\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced adaptive trial mutation to further enhance population diversity and convergence efficiency.", "configspace": "", "generation": 15, "fitness": 0.9782124891744001, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "da7aab3b-f3aa-4b2f-b083-6f5723c6b6de", "metadata": {"aucs": [0.9795281299287439, 0.9743980661716554, 0.9807112714228008], "final_y": [0.16485793709365282, 0.16485871838807997, 0.16485645092048018]}, "mutation_prompt": null}
{"id": "e1d7541c-7ea9-4aeb-9187-f2eef09208aa", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting, line 1\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line 2\n            CR = 0.6 + (0.8 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Changed line 3\n            F *= 0.85  # Changed line 4\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced mutation factor adaptation to balance exploration and exploitation in DE for better convergence.", "configspace": "", "generation": 15, "fitness": 0.9815085128033623, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "da7aab3b-f3aa-4b2f-b083-6f5723c6b6de", "metadata": {"aucs": [0.9757636010062538, 0.983712844989463, 0.98504909241437], "final_y": [0.16485615801933085, 0.16485608072797897, 0.16485626566010614]}, "mutation_prompt": null}
{"id": "5ebd61ca-ca36-46b7-b1d8-eada8bd56ebf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            T = 1 - (gen / max_iter)  # Simulated annealing-inspired cooling schedule\n            F = 0.5 + T * (0.9 - 0.5) * np.random.rand()  # Adaptive mutation scaling\n            CR = 0.6 + T * (0.9 - 0.6) * np.random.rand()\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved adaptive mutation and simulated annealing-inspired cooling schedule to enhance convergence and escape local minima.", "configspace": "", "generation": 15, "fitness": 0.9777425272303853, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "da7aab3b-f3aa-4b2f-b083-6f5723c6b6de", "metadata": {"aucs": [0.9809492601233367, 0.9789395274129691, 0.9733387941548505], "final_y": [0.16485967134003388, 0.16485917307709463, 0.1648564633643742]}, "mutation_prompt": null}
{"id": "b32d64aa-6db0-46ed-91aa-c5897d1374be", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.6 + (0.8 - 0.6) * np.sin(gen / max_iter * np.pi/2)\n            F *= 0.87  # Adjustment made here to improve exploration\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced Differential Evolution with adaptive periodic constraints to improve solution exploration and convergence.", "configspace": "", "generation": 15, "fitness": 0.9812571451647676, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "da7aab3b-f3aa-4b2f-b083-6f5723c6b6de", "metadata": {"aucs": [0.9802008065746509, 0.9819638387556388, 0.9816067901640133], "final_y": [0.16485669658899238, 0.1648625182672926, 0.16485766459985096]}, "mutation_prompt": null}
{"id": "e45af655-9f81-45db-9cbb-40dd128fe4cb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting, line 1\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line 2\n            CR = 0.6 + (0.8 - 0.6) * np.cos(gen / max_iter * np.pi/2)  # Changed line 3\n            F *= 0.85  # Changed line 4\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced a dynamic crossover rate to balance exploration and exploitation adaptively throughout the optimization process.", "configspace": "", "generation": 15, "fitness": 0.9819608536473163, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "da7aab3b-f3aa-4b2f-b083-6f5723c6b6de", "metadata": {"aucs": [0.9813709845785, 0.9829973817242104, 0.9815141946392387], "final_y": [0.1648561895500752, 0.16485819645289135, 0.16486043281033402]}, "mutation_prompt": null}
{"id": "a62cf5f8-14e8-4a2a-b0b0-d45f3bd68b29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricAdaptiveMutationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _symmetric_initialization(self, bounds, pop_size):\n        \"\"\" Initialize population using symmetric sampling \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        mid_point = (lb + ub) / 2\n        radius = (ub - lb) / 2\n        population = mid_point + (np.random.rand(pop_size, self.dim) - 0.5) * 2 * radius\n        return np.clip(population, lb, ub)\n\n    def _adaptive_periodic_mutation(self, individual, F, bounds):\n        \"\"\" Apply adaptive mutation with periodicity to individuals \"\"\"\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 3))\n        lb, ub = bounds.lb, bounds.ub\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            noise = F * (np.random.rand(end - i) - 0.5) * (ub[i:end] - lb[i:end])\n            individual[i:end] = np.clip(individual[i:end] + noise, lb[i:end], ub[i:end])\n        return individual\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with symmetric initialization and adaptive periodic mutation \"\"\"\n        population = self._symmetric_initialization(bounds, pop_size)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + 0.3 * np.cos(gen / max_iter * np.pi)\n            CR = 0.6 + 0.2 * np.sin(gen / max_iter * np.pi/2)\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self._adaptive_periodic_mutation(a + F * (b - c), F, bounds)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i]:\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n\n        return result.x if result.success else best_global", "name": "SymmetricAdaptiveMutationDE", "description": "Introduced a dual-phase strategy combining Symmetric Initialization with Adaptive Periodic Mutation to enhance exploration and exploitation balance in solving multilayer structure optimization.", "configspace": "", "generation": 16, "fitness": 0.8444941231786961, "feedback": "The algorithm SymmetricAdaptiveMutationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.021. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "e45af655-9f81-45db-9cbb-40dd128fe4cb", "metadata": {"aucs": [0.8691435311750582, 0.8169606915820228, 0.8473781467790074], "final_y": [0.18188446080925846, 0.16485622518404364, 0.16486295161819664]}, "mutation_prompt": null}
{"id": "f35d5514-b9e7-4ca0-af4e-15d18afad3dc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Integrated adaptive inheritance of periodicity with enhanced local refinement to improve solution accuracy.", "configspace": "", "generation": 16, "fitness": 0.9805749435076065, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e45af655-9f81-45db-9cbb-40dd128fe4cb", "metadata": {"aucs": [0.9811223860505018, 0.9814297789499089, 0.9791726655224088], "final_y": [0.16485739627332185, 0.16485639090744275, 0.16486460937514236]}, "mutation_prompt": null}
{"id": "64400fb8-73b0-46e2-98c8-a98fc23e669e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)\n            CR = 0.6 + (0.8 - 0.6) * np.cos(gen / max_iter * np.pi/2)\n            F *= 0.85\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced periodic adaptation by modifying the periodicity constraint to dynamically adjust based on exploration-exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.9736522691441539, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e45af655-9f81-45db-9cbb-40dd128fe4cb", "metadata": {"aucs": [0.9746356531182061, 0.974009836553808, 0.9723113177604478], "final_y": [0.1648598969063253, 0.1648570175972004, 0.1648584533184414]}, "mutation_prompt": null}
{"id": "04c8ee63-7650-4e58-800c-6cf21513ccd2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))  # Adjusted distance weighting, line 1\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi)  # Changed line 2\n            CR = 0.65 + (0.7 - 0.65) * np.cos(gen / max_iter * np.pi/2)  # Modified crossover rate slightly\n            F *= 0.85  # Changed line 4\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Refined crossover rate adjustment and introduced adaptive perturbation for better exploration. ", "configspace": "", "generation": 16, "fitness": 0.9742974607941113, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e45af655-9f81-45db-9cbb-40dd128fe4cb", "metadata": {"aucs": [0.9787843494451395, 0.9714400050425238, 0.9726680278946707], "final_y": [0.1648575287191878, 0.16485920968988454, 0.1648560935067348]}, "mutation_prompt": null}
{"id": "dd2798e4-30f0-4e8b-957a-af98e0989766", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * (gen / max_iter)  # Changed line: updated dynamic mutation factor\n            CR = 0.6 + (0.8 - 0.6) * np.cos(gen / max_iter * np.pi/2)\n            F *= 0.9  # Changed line: updated factor scaling\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced periodicity awareness by refining the period calculation and dynamic mutation strategy to improve the convergence speed and accuracy.", "configspace": "", "generation": 16, "fitness": 0.9670420357985631, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e45af655-9f81-45db-9cbb-40dd128fe4cb", "metadata": {"aucs": [0.9717472816063537, 0.9649345765835693, 0.9644442492057662], "final_y": [0.16485762370638768, 0.16485716952459717, 0.16485664783178966]}, "mutation_prompt": null}
{"id": "bb10599e-8f65-4c7f-aa1d-c04c6ef59fda", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced adaptive scaling for the mutation factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.9799498237064111, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f35d5514-b9e7-4ca0-af4e-15d18afad3dc", "metadata": {"aucs": [0.9804607481401666, 0.9800936823003554, 0.9792950406787116], "final_y": [0.16485877826721695, 0.1648580467006976, 0.16486148427898428]}, "mutation_prompt": null}
{"id": "2cfa4e20-8612-48f6-9114-9ab871308378", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.std(population)   # Adjusted mutation factor F based on population diversity\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced dynamic adjustment of mutation factor F based on diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.9361017039550571, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.056. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f35d5514-b9e7-4ca0-af4e-15d18afad3dc", "metadata": {"aucs": [0.8570303506302791, 0.9836375318722073, 0.9676372293626846], "final_y": [0.1648582141390561, 0.16485918301725566, 0.16486194947388766]}, "mutation_prompt": null}
{"id": "cb691946-e4af-4a70-828c-f4b419cf2247", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=22, max_iter=120):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.3 + (0.9 - 0.3) * np.sin(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced periodic adaptation with dynamic parameter tuning for improved precision.", "configspace": "", "generation": 17, "fitness": 0.9767493831998643, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.008. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f35d5514-b9e7-4ca0-af4e-15d18afad3dc", "metadata": {"aucs": [0.965336585425231, 0.9852349901215377, 0.9796765740528239], "final_y": [0.16485621340004564, 0.16485733222365195, 0.16485745557307796]}, "mutation_prompt": null}
{"id": "a4ee9139-2e25-41b0-9e72-2ad7e56c4648", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n        self.history = []\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            self.history.append(params)\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _local_search(self, candidate, bounds):\n        \"\"\" Neighborhood search using historical data \"\"\"\n        neighbor = candidate + 0.1 * np.random.randn(self.dim)\n        return np.clip(neighbor, bounds.lb, bounds.ub)\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.sin(gen / max_iter * np.pi)\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                if self.eval_count > self.budget * 0.5:  # Adaptive learning\n                    trial = self._local_search(trial, bounds)\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced the DE algorithm with adaptive historical learning and neighborhood search to improve search efficiency and convergence.", "configspace": "", "generation": 17, "fitness": 0.9760610973158169, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.976 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f35d5514-b9e7-4ca0-af4e-15d18afad3dc", "metadata": {"aucs": [0.9785992289230784, 0.9713029993845737, 0.9782810636397986], "final_y": [0.16485755742636987, 0.16485836254173747, 0.16485875752080714]}, "mutation_prompt": null}
{"id": "38a3ce2d-ace9-4e99-9b9a-eef105eaa750", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + 0.3 * np.random.rand()  # Modified F calculation to introduce randomness\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Integrated adaptive inheritance with dynamic mutation strategy to enhance solution exploration.", "configspace": "", "generation": 17, "fitness": 0.9756420090569601, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.976 with standard deviation 0.011. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f35d5514-b9e7-4ca0-af4e-15d18afad3dc", "metadata": {"aucs": [0.9601938327070082, 0.9824195276117742, 0.9843126668520975], "final_y": [0.16485673463923423, 0.16485688416052402, 0.16485778342548962]}, "mutation_prompt": null}
{"id": "65fa9fc9-6474-40d3-9b9c-0e4355f0852b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicPeriodicityDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _dynamic_periodicity_constrain(self, population, bounds):\n        \"\"\" Encourage solutions to adopt adaptive periodicity based on progress \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _cosine_similarity(self, a, b):\n        \"\"\" Compute cosine similarity between two vectors \"\"\"\n        dot_product = np.dot(a, b)\n        norm_a = np.linalg.norm(a)\n        norm_b = np.linalg.norm(b)\n        return dot_product / (norm_a * norm_b)\n\n    def _select_parents(self, population, costs):\n        \"\"\" Select parents based on cosine similarity to the best solution \"\"\"\n        best_idx = np.argmin(costs)\n        best = population[best_idx]\n        similarities = np.array([self._cosine_similarity(best, ind) for ind in population])\n        probs = similarities / np.sum(similarities)\n        indices = np.random.choice(len(population), size=3, p=probs, replace=False)\n        return population[indices]\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with dynamic periodicity and cosine similarity selection \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._dynamic_periodicity_constrain(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + 0.5 * np.cos(gen / max_iter * np.pi)\n            CR = 0.8\n            for i in range(pop_size):\n                a, b, c = self._select_parents(population, costs)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._dynamic_periodicity_constrain(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i]:\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "DynamicPeriodicityDEOptimizer", "description": "Introduced a dynamic periodicity constraint with cosine similarity-based parent selection to enhance convergence towards optimal periodic solutions.", "configspace": "", "generation": 18, "fitness": 0.9683674505103855, "feedback": "The algorithm DynamicPeriodicityDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb10599e-8f65-4c7f-aa1d-c04c6ef59fda", "metadata": {"aucs": [0.9594928704588591, 0.974506270375691, 0.971103210696606], "final_y": [0.16485883444077976, 0.164857703358817, 0.16486182328799392]}, "mutation_prompt": null}
{"id": "163f1c99-39dc-47a4-b261-17557dcbeaae", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration by adjusting the crossover rate's modulation using a sine function, maintaining exploitation capabilities.", "configspace": "", "generation": 18, "fitness": 0.9788984356577671, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb10599e-8f65-4c7f-aa1d-c04c6ef59fda", "metadata": {"aucs": [0.9800107593015832, 0.9816882513495836, 0.9749962963221341], "final_y": [0.16485771506509095, 0.1648584230834016, 0.16485883219826236]}, "mutation_prompt": null}
{"id": "b65264bb-d784-4466-b19e-4258bf5f4285", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.3 + (0.9 - 0.3) * np.sin(gen / max_iter * np.pi)  # Altered CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced a dynamic adjustment to the crossover rate CR for enhanced adaptability.", "configspace": "", "generation": 18, "fitness": 0.9729882532311712, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.008. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb10599e-8f65-4c7f-aa1d-c04c6ef59fda", "metadata": {"aucs": [0.9781498441275807, 0.9796447892712249, 0.9611701262947082], "final_y": [0.16485759578600911, 0.16486110976275492, 0.1648615743912043]}, "mutation_prompt": null}
{"id": "7d561f74-9075-4a28-9e09-7fe63f47ab2f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c) * np.random.rand(), lb, ub)  # Enhanced mutation step\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced mutation strategy by dynamically adjusting the influence of the trial vector.", "configspace": "", "generation": 18, "fitness": 0.9665262056655619, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.010. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb10599e-8f65-4c7f-aa1d-c04c6ef59fda", "metadata": {"aucs": [0.9522987798364406, 0.9710657673729488, 0.9762140697872961], "final_y": [0.16485606361444494, 0.16485981981835918, 0.16485639400313157]}, "mutation_prompt": null}
{"id": "eeb10d2d-8b91-40f1-b40e-29e590bca1cd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Modified CR calculation\n            chaos_factor = 0.5 + 0.5 * np.sin(gen)  # Added chaotic factor\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * chaos_factor * (b - c), lb, ub)  # Applied chaotic factor\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced chaotic factor in mutation to enhance exploration capabilities and escape local minima.", "configspace": "", "generation": 18, "fitness": 0.9705476898012032, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.007. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bb10599e-8f65-4c7f-aa1d-c04c6ef59fda", "metadata": {"aucs": [0.9619155509747347, 0.9790317572290813, 0.970695761199794], "final_y": [0.1648561492282783, 0.16486291035560618, 0.16486044983549486]}, "mutation_prompt": null}
{"id": "362d3cd3-0d0d-49ea-8ae0-ab0f586c7a84", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Minor adjustment in CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Minor adjustment in the crossover rate calculation to balance exploration and exploitation.", "configspace": "", "generation": 19, "fitness": 0.9810982945392999, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "163f1c99-39dc-47a4-b261-17557dcbeaae", "metadata": {"aucs": [0.9811763725128971, 0.9809712952975023, 0.9811472158075002], "final_y": [0.1648585142828758, 0.16485816894147054, 0.16485706837594383]}, "mutation_prompt": null}
{"id": "2042df53-18e5-46fa-b5f0-7c2c6c9d94c6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c) + 0.01 * (population[best_idx] - a), lb, ub)  # Self-adaptive mutation\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Incorporate a self-adaptive mutation strategy to dynamically balance exploration and exploitation.", "configspace": "", "generation": 19, "fitness": 0.9807492865000595, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "163f1c99-39dc-47a4-b261-17557dcbeaae", "metadata": {"aucs": [0.9803453922209351, 0.9822491492589026, 0.9796533180203411], "final_y": [0.16486168479634566, 0.1648604461764187, 0.16485860113386386]}, "mutation_prompt": null}
{"id": "afa20657-bcde-4be5-b3c2-a148f5eafa4c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.9 * np.exp(-gen / max_iter)  # Modified F calculation using exponential decay\n            CR = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced exploration by adapting the differential weight 'F' using an exponential decay function to promote effective global exploration.", "configspace": "", "generation": 19, "fitness": 0.9733316488605568, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "163f1c99-39dc-47a4-b261-17557dcbeaae", "metadata": {"aucs": [0.9655967421564908, 0.9789417351915796, 0.9754564692336], "final_y": [0.16485666517976172, 0.1648566677060589, 0.1648563697555211]}, "mutation_prompt": null}
{"id": "7f905357-4b2c-4a10-b95b-49a78cfe321b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.2 * (self.eval_count / self.budget))  # Adjusted scaling factor\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 4 + int((self.eval_count / self.budget) * (self.dim // 2))  # Adjusted period calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=25, max_iter=100):  # Increased population size\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.tanh(gen / max_iter * np.pi)  # Adjusted F calculation\n            CR = 0.6 + (0.9 - 0.6) * np.sin(gen / max_iter * np.pi/2)  # Adjusted CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved exploration and exploitation balance through adaptive scaling and diversity maintenance.", "configspace": "", "generation": 19, "fitness": 0.9779754854377257, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "163f1c99-39dc-47a4-b261-17557dcbeaae", "metadata": {"aucs": [0.9778512293282713, 0.9785142353559191, 0.9775609916289869], "final_y": [0.16485792976012548, 0.16485757766956766, 0.16486249541881937]}, "mutation_prompt": null}
{"id": "67c56f4c-76b6-47ad-aac4-96408e13831f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.4 + (0.9 - 0.4) * np.cos(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi/2)  # Modified CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Improved exploitation by adjusting the differential weight's amplitude using a cosine function, enhancing solution quality.", "configspace": "", "generation": 19, "fitness": 0.9760212538124291, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.976 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "163f1c99-39dc-47a4-b261-17557dcbeaae", "metadata": {"aucs": [0.9776823226317064, 0.9770089301729968, 0.9733725086325842], "final_y": [0.1648571784057068, 0.16486004592185544, 0.16485758389378014]}, "mutation_prompt": null}
{"id": "d8be876b-4177-4cd2-aa8b-1b76bad939f3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=25, max_iter=150):  # Increased population size and iterations\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.7 - 0.5) * np.sin(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.4 + (0.8 - 0.4) * np.sin(gen / max_iter * np.pi / 2)  # Adjusted CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced crowding DE with adaptive mutation and crossover strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.9670698866015003, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "362d3cd3-0d0d-49ea-8ae0-ab0f586c7a84", "metadata": {"aucs": [0.9657209416724384, 0.9731214845488683, 0.9623672335831943], "final_y": [0.16485678927067726, 0.1648565735638523, 0.16485856919718145]}, "mutation_prompt": null}
{"id": "4e42df64-fa60-4f91-bd41-f5b5f03f33b5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.tanh(gen / max_iter * np.pi)  # Adjusted F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Minor adjustment in CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Refines the strategy by adjusting the mutation factor `F` for a more balanced exploration and exploitation. ", "configspace": "", "generation": 20, "fitness": 0.9733822168642137, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.007. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "362d3cd3-0d0d-49ea-8ae0-ab0f586c7a84", "metadata": {"aucs": [0.9648992656308906, 0.98179233071929, 0.9734550542424605], "final_y": [0.16485719261905207, 0.16485749330957877, 0.1648630505716261]}, "mutation_prompt": null}
{"id": "7a3f9c51-898d-4cb6-be22-f1d476e0c632", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances\n\n    def _constrain_to_periodic(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.8 - 0.5) * np.sin(gen / max_iter * np.pi / 2)  # Adaptive F calculation\n            CR = 0.6 + (0.9 - 0.6) * np.cos(gen / max_iter * np.pi / 2)  # Minor adjustment in CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Introduced adaptive mutation scaling and periodicity reinforcement for enhanced exploration and solution quality.", "configspace": "", "generation": 20, "fitness": 0.9735644065551172, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "362d3cd3-0d0d-49ea-8ae0-ab0f586c7a84", "metadata": {"aucs": [0.9686258727359028, 0.9771290735259502, 0.9749382734034987], "final_y": [0.16485706236884712, 0.16486355324497703, 0.16485797716129802]}, "mutation_prompt": null}
{"id": "4251b14c-b85c-412b-88c7-a23ad31f1fa0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 2 + int((self.eval_count / self.budget) * (self.dim // 3))  # Adjusted periodicity calculation\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.sin(gen / max_iter * np.pi/2)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Minor adjustment in CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Enhanced mutation strategy and periodic constraint adjustment to improve solution accuracy.", "configspace": "", "generation": 20, "fitness": 0.9772068436585263, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "362d3cd3-0d0d-49ea-8ae0-ab0f586c7a84", "metadata": {"aucs": [0.9708746259299875, 0.9850586943662786, 0.9756872106793129], "final_y": [0.16485803651518582, 0.16485636774465717, 0.16486288177835018]}, "mutation_prompt": null}
{"id": "b7c07cb9-9ea3-4102-a891-a42690e12f90", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedCrowdingDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n\n    def _reflectivity_cost(self, params, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(params)\n        else:\n            raise RuntimeError(\"Exceeded budget!\")\n\n    def _crowding_distance(self, population):\n        \"\"\" Calculate crowding distance to maintain diversity \"\"\"\n        pop_size = population.shape[0]\n        distances = np.zeros(pop_size)\n        for dim in range(self.dim):\n            sorted_indices = np.argsort(population[:, dim])\n            sorted_population = population[sorted_indices]\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            min_val, max_val = sorted_population[0, dim], sorted_population[-1, dim]\n            if max_val > min_val:\n                distances[sorted_indices[1:-1]] += (sorted_population[2:, dim] - sorted_population[:-2, dim]) / (max_val - min_val)\n        return distances * (1 + 0.15 * (self.eval_count / self.budget))\n\n    def _constrain_to_periodic(self, population, bounds):\n        \"\"\" Constrain solutions to encourage adaptive periodicity \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        period = 3 + int((self.eval_count / self.budget) * (self.dim // 2))\n        for i in range(0, self.dim, period):\n            end = min(i + period, self.dim)\n            avg = np.mean(population[:, i:end], axis=1)\n            population[:, i:end] = np.clip(np.stack([avg] * (end - i), axis=1), lb[i:end], ub[i:end])\n        return population\n\n    def _differential_evolution(self, func, bounds, pop_size=20, max_iter=100):\n        \"\"\" Differential Evolution with crowding and periodic constraints \"\"\"\n        lb, ub = bounds.lb, bounds.ub\n        population = np.random.rand(pop_size, self.dim) * (ub - lb) + lb\n        population = self._constrain_to_periodic(population, bounds)\n        costs = np.array([self._reflectivity_cost(ind, func) for ind in population])\n        best_idx = np.argmin(costs)\n        best = population[best_idx].copy()\n\n        for gen in range(max_iter):\n            F = 0.5 + (0.9 - 0.5) * np.tanh(gen / max_iter * np.pi)  # Modified F calculation\n            CR = 0.5 + (0.9 - 0.5) * np.cos(gen / max_iter * np.pi/2)  # Minor adjustment in CR calculation\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self._constrain_to_periodic(trial[None, :], bounds)[0]\n\n                cost_trial = self._reflectivity_cost(trial, func)\n                if cost_trial < costs[i] or (cost_trial == costs[i] and self._crowding_distance(np.vstack([population, trial]))[-1] > self._crowding_distance(population)[i]):\n                    population[i] = trial\n                    costs[i] = cost_trial\n                    if cost_trial < self._reflectivity_cost(best, func):\n                        best = trial.copy()\n\n        return best\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_global = self._differential_evolution(func, bounds)\n        result = minimize(lambda x: self._reflectivity_cost(x, func), best_global, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        \n        return result.x if result.success else best_global", "name": "EnhancedCrowdingDEOptimizer", "description": "Increased mutation factor to enhance exploration.", "configspace": "", "generation": 20, "fitness": 0.9798557733695423, "feedback": "The algorithm EnhancedCrowdingDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "362d3cd3-0d0d-49ea-8ae0-ab0f586c7a84", "metadata": {"aucs": [0.9792717174418339, 0.9803566464580865, 0.9799389562087067], "final_y": [0.16485676660110993, 0.16485622453804671, 0.1648570881646103]}, "mutation_prompt": null}
