{"id": "62b43922-2a8f-4142-bdc9-e6704ca049b4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=[(lb, ub)] * self.dim)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "A novel hybrid Symmetric Differential Evolution (SDE) algorithm combines global exploration with local periodic embedding to optimize multilayer structures by leveraging constructive interference principles.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 281, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 143, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 49, in __call__\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_minimize.py\", line 670, in minimize\n    bounds = standardize_bounds(bounds, x0, 'new')\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_minimize.py\", line 1058, in standardize_bounds\n    lb, ub = old_bound_to_new(bounds)\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_constraints.py\", line 437, in old_bound_to_new\n    lb = np.array([float(_arr_to_scalar(x)) if x is not None else -np.inf\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_constraints.py\", line 437, in <listcomp>\n    lb = np.array([float(_arr_to_scalar(x)) if x is not None else -np.inf\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_constraints.py\", line 14, in _arr_to_scalar\n    return x.item() if isinstance(x, np.ndarray) else x\nValueError: can only convert an array of size 1 to a Python scalar\n.", "error": "ValueError('can only convert an array of size 1 to a Python scalar')Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 281, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 143, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 49, in __call__\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_minimize.py\", line 670, in minimize\n    bounds = standardize_bounds(bounds, x0, 'new')\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_minimize.py\", line 1058, in standardize_bounds\n    lb, ub = old_bound_to_new(bounds)\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_constraints.py\", line 437, in old_bound_to_new\n    lb = np.array([float(_arr_to_scalar(x)) if x is not None else -np.inf\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_constraints.py\", line 437, in <listcomp>\n    lb = np.array([float(_arr_to_scalar(x)) if x is not None else -np.inf\n  File \"/home/ian/anaconda3/envs/llm/lib/python3.10/site-packages/scipy/optimize/_constraints.py\", line 14, in _arr_to_scalar\n    return x.item() if isinstance(x, np.ndarray) else x\nValueError: can only convert an array of size 1 to a Python scalar\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "20ad091e-79a3-424a-ac34-07c481ad4775", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.used_budget = 0\n\n    def differential_evolution(self, func, bounds, population_size=50, F=0.5, CR=0.9):\n        population = np.random.uniform(bounds.lb, bounds.ub, (population_size, self.dim))\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n\n        while self.used_budget < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                f = func(trial)\n                self.used_budget += 1\n                if f < func(population[i]):\n                    population[i] = trial\n                    if f < func(best):\n                        best = trial\n            if self.used_budget >= 0.5 * self.budget:\n                break\n        return best\n\n    def bfgs_refinement(self, func, x0, bounds):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        self.used_budget += result.nfev\n        return result.x, result.fun\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global exploration with symmetry\n        candidate = self.differential_evolution(func, bounds)\n        # Local refinement\n        final_solution, final_value = self.bfgs_refinement(func, candidate, bounds)\n        return final_solution, final_value", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution for global search and BFGS for local refinement, with a focus on symmetry and periodicity to effectively solve black box optimization problems with wave interference characteristics.", "configspace": "", "generation": 0, "fitness": 0.6824833302181593, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.682 with standard deviation 0.060. And the mean value of best solutions found was 0.230 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6179157384888857, 0.6679595607454407, 0.7615746914201511], "final_y": [0.23483891405684887, 0.25495254235325093, 0.20111040193597585]}, "mutation_prompt": null}
{"id": "bab77dae-5710-4038-b76d-22bad02d367f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=np.array([(lb, ub)] * self.dim))\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "SymmetricDE", "description": "A slight refinement to the algorithm is made by correcting the bounds specification in the local refinement step to prevent exceptions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('can only convert an array of size 1 to a Python scalar').", "error": "ValueError('can only convert an array of size 1 to a Python scalar')", "parent_id": "62b43922-2a8f-4142-bdc9-e6704ca049b4", "metadata": {}, "mutation_prompt": null}
{"id": "990a3247-bf4f-40c3-9ae5-4284ac6c76d3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass CooperativeCoevolutionDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Split problem into subcomponents for coevolution\n        num_subcomponents = 5\n        sub_dim = self.dim // num_subcomponents\n        sub_bounds = [(lb, ub)] * sub_dim\n        \n        subpopulations = [lb + (ub - lb) * np.random.rand(population_size, sub_dim) for _ in range(num_subcomponents)]\n        best_subsolutions = [subpop[np.argmin([func(self._assemble_solution(subpop, idx)) for subpop in subpopulations])] for idx, subpop in enumerate(subpopulations)]\n        eval_count = population_size * num_subcomponents\n\n        def subcomponent_func(subsolution, index):\n            solution = self._assemble_solution([subsolution if i == index else best_subsolutions[i] for i in range(num_subcomponents)], index)\n            return func(np.clip(solution, lb, ub))\n\n        while eval_count < self.budget:\n            for idx in range(num_subcomponents):\n                for i in range(population_size):\n                    if eval_count >= self.budget:\n                        break\n\n                    # Mutation\n                    indices = np.random.choice(range(population_size), 3, replace=False)\n                    a, b, c = subpopulations[idx][indices]\n                    mutant = np.clip(a + F * (b - c), lb, ub)\n                    \n                    # Crossover\n                    cross_points = np.random.rand(sub_dim) < CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, sub_dim)] = True\n                    trial = np.where(cross_points, mutant, subpopulations[idx][i])\n                    \n                    # Calculate fitness\n                    f_trial = subcomponent_func(trial, idx)\n                    eval_count += 1\n\n                    # Selection\n                    if f_trial < subcomponent_func(subpopulations[idx][i], idx):\n                        subpopulations[idx][i] = trial\n                        if f_trial < subcomponent_func(best_subsolutions[idx], idx):\n                            best_subsolutions[idx] = trial\n\n                # Local refinement using periodic embedding\n                if eval_count + sub_dim <= self.budget:\n                    res = minimize(lambda x: subcomponent_func(np.clip(x, lb, ub), idx), best_subsolutions[idx], method='L-BFGS-B', bounds=sub_bounds)\n                    eval_count += res.nfev\n                    if res.fun < subcomponent_func(best_subsolutions[idx], idx):\n                        best_subsolutions[idx] = res.x\n\n        return self._assemble_solution(best_subsolutions)\n\n    def _assemble_solution(self, subcomponents, focus_idx=None):\n        # Reconstruct the full-dimensional solution from subcomponents\n        solution = np.zeros(self.dim)\n        for idx, subcomponent in enumerate(subcomponents):\n            start = idx * len(subcomponent)\n            end = start + len(subcomponent)\n            solution[start:end] = subcomponent\n        return solution\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = CooperativeCoevolutionDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "CooperativeCoevolutionDE", "description": "A Cooperative Coevolutionary Differential Evolution (CCDE) algorithm that divides the problem into subcomponents, optimizing each separately to enhance diversity and exploit periodicity in multilayer photonic structures.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (20,2) ')", "parent_id": "62b43922-2a8f-4142-bdc9-e6704ca049b4", "metadata": {}, "mutation_prompt": null}
{"id": "c6bc9a3f-05cf-4e53-ad42-87015af5cce0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.used_budget = 0\n\n    def differential_evolution(self, func, bounds, population_size=50, F=0.5, CR=0.9):\n        population = np.random.uniform(bounds.lb, bounds.ub, (population_size, self.dim))\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n\n        while self.used_budget < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                # Changed line for quasi-oppositional trial generation\n                trial = np.where(cross_points, mutant, (bounds.lb + bounds.ub) - population[i])\n                f = func(trial)\n                self.used_budget += 1\n                if f < func(population[i]):\n                    population[i] = trial\n                    if f < func(best):\n                        best = trial\n            if self.used_budget >= 0.5 * self.budget:\n                break\n        return best\n\n    def bfgs_refinement(self, func, x0, bounds):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        self.used_budget += result.nfev\n        return result.x, result.fun\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global exploration with symmetry\n        candidate = self.differential_evolution(func, bounds)\n        # Local refinement\n        final_solution, final_value = self.bfgs_refinement(func, candidate, bounds)\n        return final_solution, final_value", "name": "HybridMetaheuristic", "description": "Improved the differential evolution's trial generation by adding quasi-oppositional initialization to enhance global exploration.", "configspace": "", "generation": 1, "fitness": 0.6785239622522145, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.679 with standard deviation 0.031. And the mean value of best solutions found was 0.235 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "20ad091e-79a3-424a-ac34-07c481ad4775", "metadata": {"aucs": [0.721620272658863, 0.6641737422770839, 0.6497778718206966], "final_y": [0.22077761056302092, 0.2354368363414917, 0.24809565154829305]}, "mutation_prompt": null}
{"id": "4acbae3e-a84f-4bb1-a5bf-355e4bae9a69", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, \n                               method='L-BFGS-B', \n                               bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Ensure bounds are tuples\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "SymmetricDE", "description": "Improved Symmetric Differential Evolution (ISDE) enhances local refinement by accurately defining bounds for L-BFGS-B optimization to prevent errors in handling bounds.", "configspace": "", "generation": 1, "fitness": 0.899153296460891, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.087. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "62b43922-2a8f-4142-bdc9-e6704ca049b4", "metadata": {"aucs": [0.9333009483965189, 0.9843653289022992, 0.7797936120838548], "final_y": [0.18188098586053625, 0.1648579151925491, 0.18187821708954477]}, "mutation_prompt": null}
{"id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Improve handling of bounds during local refinement to fix the array-to-scalar conversion error.", "configspace": "", "generation": 1, "fitness": 0.9329565306775337, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.933 with standard deviation 0.042. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "62b43922-2a8f-4142-bdc9-e6704ca049b4", "metadata": {"aucs": [0.8814575109932963, 0.9838563137009403, 0.9335557673383647], "final_y": [0.20044516979483284, 0.1648579151925491, 0.18188116922043518]}, "mutation_prompt": null}
{"id": "415ce0e6-b316-4401-b622-12ee77f2a98e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=list(zip(lb, ub)))  # Change 1\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Improved symmetry handling in the existing Symmetric Differential Evolution (SDE) algorithm to enhance local refinement during optimization.", "configspace": "", "generation": 1, "fitness": 0.8767916138450591, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.081. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "62b43922-2a8f-4142-bdc9-e6704ca049b4", "metadata": {"aucs": [0.9333009483965189, 0.9348039745286654, 0.7622699186099933], "final_y": [0.18188098586053625, 0.18187875737284143, 0.181879587563759]}, "mutation_prompt": null}
{"id": "14c6ea85-b168-4cbf-b6aa-42d0f4eb6ea4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.used_budget = 0\n\n    def differential_evolution(self, func, bounds, population_size=50, F=0.5, CR=0.9):\n        population = np.random.uniform(bounds.lb, bounds.ub, (population_size, self.dim))\n        opposite_population = bounds.lb + bounds.ub - population\n        population = np.concatenate((population, opposite_population))\n        \n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n\n        while self.used_budget < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                f = func(trial)\n                self.used_budget += 1\n                if f < func(population[i]):\n                    population[i] = trial\n                    if f < func(best):\n                        best = trial\n            if self.used_budget >= 0.5 * self.budget:\n                break\n        return best\n\n    def bfgs_refinement(self, func, x0, bounds):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        self.used_budget += result.nfev\n        return result.x, result.fun\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global exploration with symmetry\n        candidate = self.differential_evolution(func, bounds)\n        # Local refinement\n        final_solution, final_value = self.bfgs_refinement(func, candidate, bounds)\n        return final_solution, final_value", "name": "HybridMetaheuristic", "description": "Enhanced hybrid metaheuristic by introducing quasi-oppositional-based initialization to improve search space exploration and periodicity potential.", "configspace": "", "generation": 1, "fitness": 0.7098650320324911, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.710 with standard deviation 0.058. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "20ad091e-79a3-424a-ac34-07c481ad4775", "metadata": {"aucs": [0.7548769992451028, 0.746321503623971, 0.6283965932283992], "final_y": [0.21305495605082803, 0.20717533247339248, 0.22631877311535398]}, "mutation_prompt": null}
{"id": "b8d136c7-559c-4026-b591-cd85d4c8f2ea", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.used_budget = 0\n\n    def differential_evolution(self, func, bounds, population_size=50, F=0.5, CR=0.9):\n        population = np.random.uniform(bounds.lb, bounds.ub, (population_size, self.dim))\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n\n        while self.used_budget < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n                CR = 0.5 + 0.4 * (self.budget - self.used_budget) / self.budget  # Adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                f = func(trial)\n                self.used_budget += 1\n                if f < func(population[i]):\n                    population[i] = trial\n                    if f < func(best):\n                        best = trial\n            if self.used_budget >= 0.5 * self.budget:\n                break\n        return best\n\n    def bfgs_refinement(self, func, x0, bounds):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        self.used_budget += result.nfev\n        return result.x, result.fun\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global exploration with symmetry\n        candidate = self.differential_evolution(func, bounds)\n        # Local refinement\n        final_solution, final_value = self.bfgs_refinement(func, candidate, bounds)\n        return final_solution, final_value", "name": "HybridMetaheuristic", "description": "Enhanced hybrid optimization combines Differential Evolution and BFGS with adaptive crossover rates for improved balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.7316509301187777, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.732 with standard deviation 0.040. And the mean value of best solutions found was 0.208 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "20ad091e-79a3-424a-ac34-07c481ad4775", "metadata": {"aucs": [0.680210264091756, 0.7360514524172327, 0.7786910738473447], "final_y": [0.2290078292309784, 0.19151269390953785, 0.20251652281222654]}, "mutation_prompt": null}
{"id": "91a4dc7e-e909-40fa-aa46-f7d65a5484ef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.used_budget = 0\n\n    def differential_evolution(self, func, bounds, population_size=50, F=0.5, CR=0.9):\n        population = np.random.uniform(bounds.lb, bounds.ub, (population_size, self.dim))\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n\n        while self.used_budget < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_F = F * (1 - self.used_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(a + adaptive_F * (b - c), bounds.lb, bounds.ub)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                f = func(trial)\n                self.used_budget += 1\n                if f < func(population[i]):\n                    population[i] = trial\n                    if f < func(best):\n                        best = trial\n            if self.used_budget >= 0.5 * self.budget:\n                break\n        return best\n\n    def bfgs_refinement(self, func, x0, bounds):\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        self.used_budget += result.nfev\n        return result.x, result.fun\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global exploration with symmetry\n        candidate = self.differential_evolution(func, bounds)\n        # Local refinement\n        final_solution, final_value = self.bfgs_refinement(func, candidate, bounds)\n        return final_solution, final_value", "name": "HybridMetaheuristic", "description": "An enhanced Hybrid Metaheuristic that includes an adaptive mutation factor in Differential Evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": 0.7076964392338362, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.708 with standard deviation 0.053. And the mean value of best solutions found was 0.210 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "20ad091e-79a3-424a-ac34-07c481ad4775", "metadata": {"aucs": [0.7818186575878145, 0.6665913449198863, 0.6746793151938077], "final_y": [0.1674545543688235, 0.2435661169822685, 0.21765158808666818]}, "mutation_prompt": null}
{"id": "9bd06c00-37e2-4b33-b8e9-dff29962b0ed", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.used_budget = 0\n\n    def differential_evolution(self, func, bounds, population_size=50, F=0.5, CR=0.9):\n        population = np.random.uniform(bounds.lb, bounds.ub, (population_size, self.dim))\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n\n        while self.used_budget < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                f = func(trial)\n                self.used_budget += 1\n                if f < func(population[i]):\n                    population[i] = trial\n                    if f < func(best):\n                        best = trial\n            if self.used_budget >= 0.5 * self.budget:\n                break\n        return best\n\n    def bfgs_refinement(self, func, x0, bounds):\n        # Adjust x0 by averaging with periodicity-inspired candidate\n        x0 = (x0 + (bounds.lb + bounds.ub) / 2) / 2\n        result = minimize(func, x0, method='L-BFGS-B', bounds=[(lb, ub) for lb, ub in zip(bounds.lb, bounds.ub)])\n        self.used_budget += result.nfev\n        return result.x, result.fun\n\n    def __call__(self, func):\n        bounds = func.bounds\n        # Global exploration with symmetry\n        candidate = self.differential_evolution(func, bounds)\n        # Local refinement\n        final_solution, final_value = self.bfgs_refinement(func, candidate, bounds)\n        return final_solution, final_value", "name": "HybridMetaheuristic", "description": "The refined hybrid metaheuristic enhances local refinement by adjusting BFGS initialization using a periodicity-inspired tweak to better harness wave interference characteristics.", "configspace": "", "generation": 1, "fitness": 0.6858080445665631, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.686 with standard deviation 0.033. And the mean value of best solutions found was 0.240 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "20ad091e-79a3-424a-ac34-07c481ad4775", "metadata": {"aucs": [0.6628852146607856, 0.6627552872607375, 0.7317836317781661], "final_y": [0.255575444723256, 0.25306548945472174, 0.20992425190511876]}, "mutation_prompt": null}
{"id": "23bf5976-5e9a-4ef3-ad27-deb126987fc4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F_min, F_max = 0.5, 0.9  # Differential weight range\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with dynamic F\n                F = np.random.uniform(F_min, F_max)  # Adjusted line\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, \n                               method='L-BFGS-B', \n                               bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Ensure bounds are tuples\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "SymmetricDE", "description": "Enhance mutation diversity by dynamically adjusting the differential weight (F) within a range to explore promising regions more effectively.", "configspace": "", "generation": 2, "fitness": 0.8976696427527916, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.091. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4acbae3e-a84f-4bb1-a5bf-355e4bae9a69", "metadata": {"aucs": [0.9373248597646242, 0.9842380751019595, 0.771445993391791], "final_y": [0.16486843132420326, 0.1648579151925491, 0.164859385798362]}, "mutation_prompt": null}
{"id": "1b8c8f61-e7c8-443c-bfbd-485e09933744", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PeriodicityGuidedMemetic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodicity encouragement\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]\n                periodic_best = self.encourage_periodicity(best, lb, ub)\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), periodic_best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def encourage_periodicity(self, solution, lb, ub):\n        # Create a periodic pattern based on the current best solution\n        period = int(self.dim / 2)\n        periodic_solution = np.tile(solution[:period], int(np.ceil(self.dim / period)))[:self.dim]\n        return np.clip(periodic_solution, lb, ub)\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = PeriodicityGuidedMemetic(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "PeriodicityGuidedMemetic", "description": "Periodicity-Guided Memetic Algorithm combines global exploration using differential evolution and local refinement focusing on periodic structures to effectively navigate complex optimization landscapes.", "configspace": "", "generation": 2, "fitness": 0.8993182605213841, "feedback": "The algorithm PeriodicityGuidedMemetic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.122. And the mean value of best solutions found was 0.186 (0. is the best) with standard deviation 0.030.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.984482349960015, 0.7266813844844269, 0.9867910471197102], "final_y": [0.16485643066039712, 0.22804736241094292, 0.1648562567978722]}, "mutation_prompt": null}
{"id": "f28d4c30-46ed-44e1-88b5-5b9acbadd8df", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                CR = np.mean([np.linalg.norm(ind - best) for ind in population]) / (ub - lb).sum()  # Dynamic CR update\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, \n                               method='L-BFGS-B', \n                               bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Ensure bounds are tuples\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "SymmetricDE", "description": "Enhance exploration by dynamically adjusting CR based on population diversity to improve convergence.", "configspace": "", "generation": 2, "fitness": 0.950521803404678, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.024. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "4acbae3e-a84f-4bb1-a5bf-355e4bae9a69", "metadata": {"aucs": [0.9330833031472179, 0.9841108213016198, 0.9343712857651961], "final_y": [0.18188098586053625, 0.1648579151925491, 0.181881295516108]}, "mutation_prompt": null}
{"id": "e776d941-275c-4529-a34b-70cee58e519b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                F_adaptive = F * (1 - (eval_count / self.budget))\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F_adaptive * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Enhanced SymmetricDE with adaptive differential weight for improved exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8873820108468072, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.103. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.9331921257718684, 0.984492582702639, 0.7444613240659141], "final_y": [0.18188098586053625, 0.1648579151925491, 0.2578124253687365]}, "mutation_prompt": null}
{"id": "f1aab7b3-f976-4bed-a554-f266f4ac1c59", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedSymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        def periodicity_penalty(solution):\n            # Encourage periodicity by penalizing deviation from a known optimal pattern\n            half_dim = self.dim // 2\n            return np.sum((solution[:half_dim] - solution[half_dim:])**2)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness with periodicity penalty\n                f_trial = func(trial) + periodicity_penalty(trial) * 0.01\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                res = minimize(lambda x: func(np.clip(x, lb, ub)) + periodicity_penalty(np.clip(x, lb, ub)) * 0.01, \n                               best, method='L-BFGS-B', \n                               bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Ensure bounds are tuples\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "EnhancedSymmetricDE", "description": "Enhanced Symmetric Differential Evolution with Adaptive Periodicity Promotion refines local search by dynamically encouraging periodic structures and better boundary handling to improve multilayer photonic structure optimization.", "configspace": "", "generation": 2, "fitness": 0.7908937971943502, "feedback": "The algorithm EnhancedSymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.217. And the mean value of best solutions found was 0.231 (0. is the best) with standard deviation 0.082.", "error": "", "parent_id": "4acbae3e-a84f-4bb1-a5bf-355e4bae9a69", "metadata": {"aucs": [0.9338133640142408, 0.9543407800151247, 0.4845272475536849], "final_y": [0.17284527535897487, 0.17284709020722178, 0.3474555962700896]}, "mutation_prompt": null}
{"id": "a8cb2fc4-4718-4c2a-900a-6c412a94994f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            new_population = population.copy()\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection with elitism\n                if f_trial < func(population[i]):\n                    new_population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            population = new_population\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Improved selection process by introducing elitism to retain the best solution in each generation.", "configspace": "", "generation": 2, "fitness": 0.9507041666370163, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.025. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.9331921257718684, 0.9853899235560769, 0.9335304505831037], "final_y": [0.18188098586053625, 0.1648575203944701, 0.1818832520234065]}, "mutation_prompt": null}
{"id": "78176ff9-1667-4c60-9d5e-6d50af73e2fe", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            # Dynamic crossover based on diversity\n            diversity = np.mean([np.linalg.norm(population[i] - population[best_idx]) for i in range(population_size)])\n            CR = max(0.5, min(1.0, 1.0 - diversity / (ub-lb).mean()))\n\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Improve exploration by introducing a dynamic crossover strategy based on population diversity.", "configspace": "", "generation": 2, "fitness": 0.9842576005933515, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.9861699746310871, 0.9846198365029787, 0.9819829906459889], "final_y": [0.16485947558448077, 0.1648579151925491, 0.16485825076030935]}, "mutation_prompt": null}
{"id": "66aba562-389f-4f22-a5ad-f4e0e3ec0082", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptively adjust F and CR for improved convergence\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                CR = 0.8 + 0.1 * np.random.rand()  # Dynamic crossover probability\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Enhanced SymmetricDE with adaptive mutation factor and dynamic crossover probability.", "configspace": "", "generation": 2, "fitness": 0.8111068997709063, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.086. And the mean value of best solutions found was 0.209 (0. is the best) with standard deviation 0.034.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.9325391900239655, 0.7425291218980837, 0.7582523873906697], "final_y": [0.18188098586053625, 0.2578110290615827, 0.18813230965378147]}, "mutation_prompt": null}
{"id": "da2bfe91-24dc-4402-9f13-e6259910d3af", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F_min, F_max = 0.5, 1.0  # Adaptive differential weight range\n        CR_min, CR_max = 0.1, 0.9  # Adaptive crossover probability range\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive parameter control\n                F = F_min + np.random.rand() * (F_max - F_min)\n                CR = CR_min + np.random.rand() * (CR_max - CR_min)\n\n                # Mutation with modular strategy\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = HybridEnhancedAdaptiveDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "HybridEnhancedAdaptiveDE", "description": "Hybrid Enhanced Adaptive Differential Evolution (HEAD) combines adaptive parameter control with a modular approach and periodic embedding to improve search efficiency and solution quality.", "configspace": "", "generation": 2, "fitness": 0.9358442960274896, "feedback": "The algorithm HybridEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.039. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.9334097710211693, 0.984492582702639, 0.8896305343586607], "final_y": [0.18188098586053625, 0.1648579151925491, 0.1648564013993199]}, "mutation_prompt": null}
{"id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Adaptive Periodic Enhancement Differential Evolution (APEDE) leverages adaptive learning rates and a periodicity constraint to enhance local search efficiency and exploit constructive interference for multilayer optimization.", "configspace": "", "generation": 2, "fitness": 0.9937631954194641, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e39ea866-d9c0-4d42-96c0-716a046f0e0c", "metadata": {"aucs": [0.9946523664922373, 0.9924228723044638, 0.9942143474616915], "final_y": [0.1648589738314088, 0.16485596306831984, 0.16486057944625565]}, "mutation_prompt": null}
{"id": "d6e7b944-df84-4b9e-bb57-681b2a7f3e1e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            # Dynamic crossover based on diversity\n            diversity = np.mean([np.linalg.norm(population[i] - population[best_idx]) for i in range(population_size)])\n            CR = max(0.5, min(1.0, 1.0 - diversity / (ub-lb).mean()))\n\n            # Adaptive mutation factor\n            F = 0.8 + 0.2 * (diversity / (ub-lb).mean())\n            \n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Enhanced SymmetricDE with adaptive mutation factor for improved convergence and solution quality.", "configspace": "", "generation": 3, "fitness": 0.9073826783658522, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.022. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "78176ff9-1667-4c60-9d5e-6d50af73e2fe", "metadata": {"aucs": [0.932648012648616, 0.9113559502336959, 0.8781440722152449], "final_y": [0.18188098586053625, 0.18813080710129015, 0.16485616417932847]}, "mutation_prompt": null}
{"id": "2a0eee68-8636-4fbe-99b8-ea992e9916f6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            # Dynamic crossover based on diversity\n            diversity = np.mean([np.linalg.norm(population[i] - population[best_idx]) for i in range(population_size)])\n            CR = max(0.5, min(1.0, 1.0 - diversity / (ub-lb).mean()))\n            F = max(0.5, min(1.0, diversity / (ub-lb).mean()))  # Adjust F based on diversity\n\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "SymmetricDE", "description": "Refine exploration by dynamically adjusting the differential weight F based on population diversity.", "configspace": "", "generation": 3, "fitness": 0.8895192468379026, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.890 with standard deviation 0.031. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "78176ff9-1667-4c60-9d5e-6d50af73e2fe", "metadata": {"aucs": [0.932648012648616, 0.8727444808646754, 0.8631652470004166], "final_y": [0.18188098586053625, 0.18187930021246357, 0.20725454010292133]}, "mutation_prompt": null}
{"id": "ba2adacf-4358-4b75-85fb-bc596e514d20", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            # Adaptive population size adjustment\n            population_size = max(10, min(30, int((self.budget - eval_count) / 10)))\n            population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n\n            # Dynamic crossover based on diversity\n            diversity = np.mean([np.linalg.norm(population[i] - population[best_idx]) for i in range(population_size)])\n            CR = max(0.5, min(1.0, 1.0 - diversity / (ub-lb).mean()))\n\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best", "name": "SymmetricDE", "description": "Improved SymmetricDE using adaptive population size for enhanced exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.9235235870257882, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.032. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "78176ff9-1667-4c60-9d5e-6d50af73e2fe", "metadata": {"aucs": [0.9316392486413559, 0.9582904643846245, 0.8806410480513839], "final_y": [0.18188098586053625, 0.16485679399914166, 0.2004487735120678]}, "mutation_prompt": null}
{"id": "a093a9b9-5d04-4801-9ad3-efd33ec5252f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Self-adaptive mutation strategy\n                F_i = 0.5 + 0.3 * np.random.rand()  # Self-adaptive F\n                CR_i = 0.5 + 0.4 * np.random.rand()  # Self-adaptive CR\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F_i * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR_i\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity-driven mutation\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE with self-adaptive F and CR values, and periodicity-driven mutation for improved local search.", "configspace": "", "generation": 3, "fitness": 0.9890133931523447, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.989 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9929940498207275, 0.9799141504587665, 0.9941319791775398], "final_y": [0.16485631431591152, 0.16486116175152732, 0.16485654267409655]}, "mutation_prompt": null}
{"id": "3f95467b-475b-4709-9ff3-4dc483e7b2da", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = (np.max(trial[i:i+period]) + np.min(trial[i:i+period])) / 2\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE with improved local search and refined periodicity enforcement for better convergence and solution quality.", "configspace": "", "generation": 3, "fitness": 0.9887096127819476, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.989 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.993554335865809, 0.9912023917487006, 0.9813721107313336], "final_y": [0.16485809381827143, 0.1648609352997844, 0.16485809323841605]}, "mutation_prompt": null}
{"id": "bceec587-ea37-45f2-8369-1abd890153f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n        previous_best = func(best)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n                        # Adjust CR based on improvement\n                        CR = max(0.5, CR - 0.1) if f_trial < previous_best else min(1.0, CR + 0.1)\n                        previous_best = f_trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Introduced dynamic adjustment of the crossover probability (CR) based on improvement trends to balance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.9933066453251969, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.993 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9934780618680291, 0.9936354157568987, 0.9928064583506625], "final_y": [0.16485961347077094, 0.16485891134943798, 0.16486283949321656]}, "mutation_prompt": null}
{"id": "ca294d43-8460-4698-b3ca-7eba64c06ff0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                diversity = np.std(population, axis=0)  # Calculate diversity\n                adaptive_F = F + 0.2 * diversity.mean() * np.random.rand()  # Adjust F based on diversity\n                mutant = np.clip(a + adaptive_F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhance the adaptive differential weight calculation to incorporate diversity within the population, improving exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.9925820976486466, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.993 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9920309910367402, 0.9916369529257612, 0.9940783489834385], "final_y": [0.16486163693993228, 0.16485613359956952, 0.16486116497786685]}, "mutation_prompt": null}
{"id": "8306cff4-27e3-4877-83ea-dddd1e1e17d1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymmetricDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Improved initialization with a diverse strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        population[:population_size//2] = lb + (ub - lb) * np.random.rand(population_size//2, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            # Dynamic crossover based on diversity\n            diversity = np.mean([np.linalg.norm(population[i] - population[best_idx]) for i in range(population_size)])\n            CR = max(0.5, min(1.0, 1.0 - diversity / (ub-lb).mean()))\n\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive mutation scaling\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F_adaptive = 0.5 + np.random.rand() * 0.5\n                mutant = np.clip(a + F_adaptive * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)  # Use updated bounds\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = SymmetricDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "SymmetricDE", "description": "Enhance the SymmetricDE algorithm by incorporating a diversified initialization strategy and adaptive mutation scaling.", "configspace": "", "generation": 3, "fitness": 0.9057278858106986, "feedback": "The algorithm SymmetricDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.040. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "78176ff9-1667-4c60-9d5e-6d50af73e2fe", "metadata": {"aucs": [0.8488882070449179, 0.9349505215013846, 0.9333449288857932], "final_y": [0.1648569256630279, 0.1818804950148526, 0.18188196444709726]}, "mutation_prompt": null}
{"id": "a5235c1d-4be6-44e4-a5c2-38bccbe0e69b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F_dynamic = F + 0.5 * np.random.rand()  # Dynamic adjustment\n                mutant = np.clip(a + F_dynamic * (b - c), lb, ub)\n                \n                # Crossover with dynamic probability\n                CR_dynamic = CR + 0.1 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = EAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "EAPEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (EAPEDE) integrates dynamic crossover and mutation strategies with adaptive periodic constraints to optimize multilayer structures more efficiently.", "configspace": "", "generation": 3, "fitness": 0.9840070357462417, "feedback": "The algorithm EAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.009. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9917031999934094, 0.9890156212933031, 0.9713022859520127], "final_y": [0.16485740633304025, 0.16485730643277952, 0.16485885105560383]}, "mutation_prompt": null}
{"id": "05c71bef-89e4-43b5-857d-bd34da41eaad", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.7 + 0.2 * np.random.rand()  # Adaptive crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE with adaptive crossover probability to balance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.9914519371246927, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9882103775970659, 0.9945944127166454, 0.9915510210603672], "final_y": [0.16485586500426253, 0.1648661170307163, 0.16485709326105258]}, "mutation_prompt": null}
{"id": "271ef651-8f4e-47bc-866f-0457115cf5d4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.7  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n        previous_best = func(best)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n                        # Adjust CR based on improvement\n                        CR = max(0.6, CR - 0.1) if f_trial < previous_best else min(1.0, CR + 0.05)\n                        previous_best = f_trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period // 2):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution with dynamic weighting and refined periodicity embedding for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.9924092190289366, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bceec587-ea37-45f2-8369-1abd890153f9", "metadata": {"aucs": [0.9951279201420148, 0.9929594477518395, 0.9891402891929555], "final_y": [0.16485784188079855, 0.16486517184626992, 0.1648618293371753]}, "mutation_prompt": null}
{"id": "8ace3812-f5b5-4038-9f59-117b2471d5d2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F_dynamic = F * (0.5 + 0.5 * np.random.rand())  # Dynamic adjustment of F\n                mutant = np.clip(a + F_dynamic * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE by dynamically adjusting the differential weight F based on convergence trends to better balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.9740262453183205, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.029. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9951381753839648, 0.9326481807101227, 0.9942923798608739], "final_y": [0.16486192979256709, 0.1648563105374402, 0.16486149153489305]}, "mutation_prompt": null}
{"id": "bfa5a6b6-918b-4049-ba03-ec9ad2217129", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n        previous_best = func(best)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial = self.apply_periodicity(trial, lb, ub)\n\n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n                        CR = max(0.5, CR - 0.05) if f_trial < previous_best else min(1.0, CR + 0.05)\n                        previous_best = f_trial\n\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = EAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "EAPEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (EAPEDE) refines crossover probability dynamics and introduces variable population size to improve convergence speed and solution quality.", "configspace": "", "generation": 4, "fitness": 0.9910486675880034, "feedback": "The algorithm EAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bceec587-ea37-45f2-8369-1abd890153f9", "metadata": {"aucs": [0.9926118164356609, 0.991116182138348, 0.9894180041900011], "final_y": [0.16485750997926463, 0.16485958351108343, 0.1648568926073115]}, "mutation_prompt": null}
{"id": "b5f75e35-12f7-4de9-b9e8-02ab3e5f8e44", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n        previous_best = func(best)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Change: Introduce dynamic scaling factor F based on iteration count\n                F_dynamic = F + 0.5 * (1 - eval_count / self.budget) * np.random.rand()\n                mutant = np.clip(a + F_dynamic * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n                        # Adjust CR based on improvement\n                        CR = max(0.5, CR - 0.1) if f_trial < previous_best else min(1.0, CR + 0.1)\n                        previous_best = f_trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced Mutation Strategy with a Dynamic Scale Factor for better exploration.", "configspace": "", "generation": 4, "fitness": 0.9931992900065207, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.993 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bceec587-ea37-45f2-8369-1abd890153f9", "metadata": {"aucs": [0.9928129098329405, 0.9950718681988145, 0.9917130919878072], "final_y": [0.16485905680924795, 0.1648586448080671, 0.1648583134011009]}, "mutation_prompt": null}
{"id": "d622c5f3-9e23-40b1-97a3-41b8f3fea497", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    CR = 0.9 + 0.1 * (f_trial < func(best))  # Adapt CR based on success\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "APEDE", "description": "Enhanced APEDE by adapting the crossover probability dynamically based on the current generation's performance.", "configspace": "", "generation": 4, "fitness": 0.9833580869366321, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.979466526649658, 0.9922090099585053, 0.9783987242017327], "final_y": [0.16485852758842445, 0.16485838324853452, 0.16485942823091793]}, "mutation_prompt": null}
{"id": "f04fbe2d-6776-4b42-9830-98924dc85d56", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n        previous_best = func(best)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_F = F + 0.2 * np.random.rand() * (previous_best - func(population[i])) / previous_best  # Adaptive mutation strategy\n                mutant = np.clip(a + adaptive_F * (b - c), lb, ub)  # Change line\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n                        # Adjust CR based on improvement\n                        CR = max(0.5, CR - 0.1) if f_trial < previous_best else min(1.0, CR + 0.1)\n                        previous_best = f_trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        scaling_factor = 0.95  # Introduce dynamic scaling factor\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean * scaling_factor, lb[i:i+period], ub[i:i+period])  # Change line\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE by introducing a dynamic scaling factor for periodicity enforcement and adaptive mutation strategy for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.9665707075655695, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.037. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bceec587-ea37-45f2-8369-1abd890153f9", "metadata": {"aucs": [0.991944905142604, 0.9930221179157803, 0.9147450996383242], "final_y": [0.16485656280068894, 0.16486346760552084, 0.1648628591452146]}, "mutation_prompt": null}
{"id": "efde2b94-de1f-4814-a893-89355498406f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n        previous_best = func(best)\n        \n        # Store historical population for diversity boost\n        historical_pop = []\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive mutation scaling\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                diversity_factor = np.std(population - previous_best)\n                adaptive_F = F + 0.5 * (1 - diversity_factor)\n                mutant = np.clip(a + adaptive_F * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n                        # Adjust CR based on improvement\n                        CR = max(0.5, CR - 0.1) if f_trial < previous_best else min(1.0, CR + 0.1)\n                        previous_best = f_trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n            # Diversity boost\n            historical_pop.extend(population)\n            if len(historical_pop) > 50:\n                historical_pop = historical_pop[-50:]\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE with adaptive mutation scaling and diversity boost for improved exploration and exploitation balance using periodic solution constraints.", "configspace": "", "generation": 4, "fitness": 0.9558982564521269, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.052. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "bceec587-ea37-45f2-8369-1abd890153f9", "metadata": {"aucs": [0.9913334324273051, 0.994527243772881, 0.8818340931561945], "final_y": [0.16486416617301813, 0.16486220016290987, 0.20044529772160613]}, "mutation_prompt": null}
{"id": "09e100d4-55dd-4039-8d2a-fc8811fe2e48", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR_base = 0.9  # Base Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n                \n                # Dynamic adjustment of crossover probability\n                CR = CR_base - 0.1 * (eval_count / self.budget)\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity-aware symmetry\n                trial = self.apply_periodicity_symmetry(trial, lb, ub)\n\n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity_symmetry(self, trial, lb, ub):\n        # Force periodic patterns with symmetry in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(2 * period_mean - trial[i:i+period], lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced APEDE with adaptive crossover rates and periodicity-aware symmetry to improve robustness in exploring the search space.", "configspace": "", "generation": 4, "fitness": 0.9706477605162555, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.028. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9889154221329978, 0.9924216368353502, 0.9306062225804186], "final_y": [0.16486178092907577, 0.16485823162875868, 0.16485821107739873]}, "mutation_prompt": null}
{"id": "471edf8c-2fb6-4c5b-84ad-6e1b8e91f9ea", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Dynamic crossover rate based on diversity\n                CR = 0.9 * np.std(population) / np.mean(population) if np.mean(population) != 0 else 0.9\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Adaptive Periodic Enhancement Differential Evolution (APEDE) with dynamic crossover rate adjustment based on the population diversity to enhance convergence speed and quality.", "configspace": "", "generation": 4, "fitness": 0.991231225341625, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9910260303024747, 0.9890394381596109, 0.9936282075627891], "final_y": [0.16486137691955238, 0.1648601869772508, 0.16485624289532042]}, "mutation_prompt": null}
{"id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Advanced Adaptive Periodic Enhancement Differential Evolution (Adv-APEDE) incorporates dynamic crossover adaptation and elite preservation to bolster performance by maintaining diversity and ensuring robust convergence on multilayer optimization problems.", "configspace": "", "generation": 4, "fitness": 0.9951728697264223, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.995 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.995256693535545, 0.9943764036882075, 0.9958855119555141], "final_y": [0.16485599724201172, 0.1648606335086974, 0.1648616318596694]}, "mutation_prompt": null}
{"id": "b3084334-3ca5-49e4-8760-1d18dc0cc0e4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.5 + 0.3 * np.random.rand(population_size)  # Dynamic differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Chaotic initialization with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover and F adaptation\n        cr_min, cr_max = 0.2, 0.9\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F[i] * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Elite migration phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with adaptive F and CR strategies, elite migration, and chaotic initialization for improved convergence in multilayer optimization.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {}, "mutation_prompt": null}
{"id": "fe409cb0-61a3-42ee-8647-2e02dbaae61d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2 + 1  # Adjusted to improve periodicity\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (E-APEDE) introduces variable population size and refined periodicity enforcement to improve convergence and solution quality for multilayer optimization.", "configspace": "", "generation": 5, "fitness": 0.9920632376566904, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9935093393766248, 0.9900849293676536, 0.9925954442257928], "final_y": [0.16486251528448492, 0.16485788459605955, 0.1648564191945341]}, "mutation_prompt": null}
{"id": "99f411b4-21ff-4e85-a66a-28712f59d665", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quasi-Oppositional Initialization\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        opposite_population = ub + lb - population\n        population = np.where(np.random.rand(population_size, self.dim) < 0.5, population, opposite_population)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Dynamic periodicity adjustment\n                trial = self.dynamic_periodicity(trial, lb, ub, eval_count)\n\n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def dynamic_periodicity(self, trial, lb, ub, eval_count):\n        period = max(2, self.dim // (2 + (eval_count // 100)))\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i + period])\n            trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = EAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "EAPEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (E-APEDE) integrates a dynamic periodicity adjustment mechanism and employs quasi-oppositional strategies for initialization, enhancing diversity and convergence speed.  ", "configspace": "", "generation": 5, "fitness": 0.9911287249515882, "feedback": "The algorithm EAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9944478341639374, 0.9856070529282006, 0.9933312877626267], "final_y": [0.16485740469044785, 0.16485760810098316, 0.16486138323895738]}, "mutation_prompt": null}
{"id": "fbae8b9f-175d-4d3a-a79d-a417797e5539", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass IAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Dynamic Crossover\n                CR_dynamic = CR * (1 - (eval_count/self.budget))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply adaptive periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Adaptive periodic patterns in layer thicknesses\n        period = max(2, self.dim // 4)  # Adjust period\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = IAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "IAPEDE", "description": "Improved Adaptive Periodic Enhancement Differential Evolution (IAPEDE) enhances exploration-exploitation balance by introducing a dynamic crossover rate and adaptive periodic embedding to improve convergence on multilayer optimization problems.", "configspace": "", "generation": 5, "fitness": 0.9566496958163571, "feedback": "The algorithm IAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.957 with standard deviation 0.015. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9723985608009066, 0.9369880234467941, 0.9605625032013704], "final_y": [0.16485786074839703, 0.16486124332553687, 0.16485624658889486]}, "mutation_prompt": null}
{"id": "449100ba-3e04-45cd-8d8c-8a24fa2017a5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Dynamic crossover probability adjustment\n                diversity = np.std(population, axis=0).mean()\n                CR = 0.7 + 0.3 * (1 - diversity / (ub-lb).mean())\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (EAPEDE) introduces dynamic crossover probability adjustments based on population diversity to improve convergence efficiency.", "configspace": "", "generation": 5, "fitness": 0.992934028313786, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.993 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9950798830259858, 0.9918811949685898, 0.9918410069467825], "final_y": [0.16485618849381178, 0.16486042473333906, 0.1648638637340707]}, "mutation_prompt": null}
{"id": "a82fa7ae-519a-40e3-8dda-e9d703370035", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass APEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx].copy()\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + (F + 0.2 * np.random.rand()) * (b - c), lb, ub)\n                \n                # Crossover with dynamic adaptation\n                CR_dynamic = CR * (0.5 + 0.5 * np.random.rand())  # Adapted line\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < func(population[i]):\n                    population[i] = trial\n                    if f_trial < func(best):\n                        best = trial\n\n            # Local refinement using periodic embedding\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[i], ub[i]) for i in range(self.dim)]  # Fix bounds handling\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), best, method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < func(best):\n                    best = res.x\n\n        return best\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = APEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "APEDE", "description": "Introduced dynamic crossover probability adaptation in APEDE to improve exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.9869486194820682, "feedback": "The algorithm APEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.987 with standard deviation 0.007. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "746ad43c-3b9f-4bae-a8ec-7b3aede4dafd", "metadata": {"aucs": [0.9943457282904787, 0.989060163334947, 0.9774399668207788], "final_y": [0.1648573847871041, 0.1648585840887914, 0.16486244705887587]}, "mutation_prompt": null}
{"id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Quantum-Inspired Coherence-Assisted Differential Evolution (QICAD-E) integrates quantum-inspired superposition and coherence principles with differential evolution to foster diverse exploration and rapid convergence in multilayer optimization problems.", "configspace": "", "generation": 5, "fitness": 0.9956276382398347, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.996 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9961271176115898, 0.9956496083371947, 0.9951061887707199], "final_y": [0.16485881421112347, 0.16485897474021816, 0.16486124920226464]}, "mutation_prompt": null}
{"id": "97e0745f-a62f-416a-a9b1-b31838544f7c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HSPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        hmcr = 0.9  # Harmony memory considering rate\n        par = 0.3   # Pitch adjustment rate\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize harmony memory\n        harmony_memory = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in harmony_memory])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            if eval_count >= self.budget:\n                break\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < hmcr:\n                    # Memory consideration\n                    idx = np.random.randint(population_size)\n                    new_harmony[i] = harmony_memory[idx, i]\n                    # Pitch adjustment\n                    if np.random.rand() < par:\n                        new_harmony[i] += np.random.uniform(-1, 1) * (ub[i] - lb[i]) * 0.01\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Random consideration\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Apply periodic adjustment\n            new_harmony = self.apply_periodicity(new_harmony, lb, ub)\n\n            # Calculate fitness\n            f_new_harmony = func(new_harmony)\n            eval_count += 1\n\n            # Update harmony memory\n            worst_idx = np.argmax(fitness)\n            if f_new_harmony < fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                fitness[worst_idx] = f_new_harmony\n            \n            # Local refinement of the best solution\n            best_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), harmony_memory[best_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[best_idx]:\n                    harmony_memory[best_idx] = res.x\n                    fitness[best_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return harmony_memory[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Encourage periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = HSPA(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "HSPA", "description": "Harmony Search with Periodic Adjustment (HSPA) leverages harmony memory and periodic structure encouragement to efficiently explore and exploit the optimization landscape, ensuring robust performance on multilayer photonic structures.", "configspace": "", "generation": 5, "fitness": 0.976678496366102, "feedback": "The algorithm HSPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.977 with standard deviation 0.011. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9633496067879559, 0.9902190037179338, 0.9764668785924163], "final_y": [0.164858241297705, 0.1648579151925491, 0.16486360876569717]}, "mutation_prompt": null}
{"id": "6b20dfd7-93c4-4eeb-9c63-a5d2e0d91271", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F_min, F_max = 0.5, 0.9  # Dynamic differential weight range\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy and diversity enhancement\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            sorted_indices = np.argsort(fitness)\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n                \n                # Adaptive differential mutation with environmental selection pressure\n                F = F_min + (F_max - F_min) * (i / population_size)\n                indices = np.random.choice(sorted_indices[:int(population_size/2)], 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "EAPEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (EAPEDE) introduces a dynamic mutation factor and environmental selection pressure to improve convergence and solution quality in multilayer optimization problems.", "configspace": "", "generation": 5, "fitness": 0.988478561849555, "feedback": "The algorithm EAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.988 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9945562076208647, 0.9831682398847844, 0.9877112380430154], "final_y": [0.16485829699744747, 0.16485956387501566, 0.1648584369466154]}, "mutation_prompt": null}
{"id": "0269a006-3831-42cf-b511-46d0ec5d2d6f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation with improved strategy\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c + np.random.rand() * (population[np.argmin(fitness)] - a)), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply refined periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force refined periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean + np.random.rand() * 0.05 * (ub[i] - lb[i]), lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE: Modified periodicity application and refined mutation strategy to further exploit constructive interference and improve optimization efficiency.", "configspace": "", "generation": 5, "fitness": 0.994296943433619, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9950165525694309, 0.9931748983657098, 0.9946993793657162], "final_y": [0.16485932043113516, 0.16485699593176384, 0.16486040886891973]}, "mutation_prompt": null}
{"id": "c01f5990-4565-4f10-98ad-f01caff4aa8e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with adaptive coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2 + 0.1 * np.random.rand()  # Adaptively vary coherence strength\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced Quantum-Inspired Coherence-Assisted Differential Evolution (EQICADE) introduces adaptive quantum coherence to improve diversity and convergence rate in multilayer optimization problems.", "configspace": "", "generation": 6, "fitness": 0.9897410121670173, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.990 with standard deviation 0.008. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9788947511168025, 0.9942746330632477, 0.9960536523210016], "final_y": [0.16486110802550402, 0.1648560429287813, 0.16485802763297286]}, "mutation_prompt": null}
{"id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with adaptive F tuning for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.9954485615860859, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.995 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9962346744218089, 0.994416233993008, 0.9956947763434406], "final_y": [0.16486213081671364, 0.16486106154278335, 0.16486144928011126]}, "mutation_prompt": null}
{"id": "e5247c23-2d73-4f20-8652-792693900e4d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F_adaptive = F * (1 - eval_count / self.budget)  # Adaptive mutation scaling\n                mutant = np.clip(a + F_adaptive * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                # Improved elite selection\n                if f_trial < np.min(fitness):\n                    elite_idx = i \n\n            # Local refinement phase\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with adaptive mutation scaling and improved elite selection for better convergence and diversity.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'elite_idx' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'elite_idx' referenced before assignment\")", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {}, "mutation_prompt": null}
{"id": "2395b149-be08-4d9f-9e9c-bb09c2bc15ac", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.15  # Reduced coherence strength\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = 4  # Adjusted period for better periodic solutions\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced Quantum-Inspired Coherence-Assisted Differential Evolution (E-QICADE) modifies coherence strength and adjusts periodicity enforcement to improve convergence in multilayer optimization problems.", "configspace": "", "generation": 6, "fitness": 0.9936200975189902, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9930095198312984, 0.9936100430450346, 0.9942407296806377], "final_y": [0.16485780542235584, 0.1648574361338524, 0.1648581111878339]}, "mutation_prompt": null}
{"id": "deb80d3d-51d3-45c5-b6c4-36a4e3a8656c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.2 * (np.random.rand() - 0.5), cr_min, cr_max)  # Enhanced crossover adjustment\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced crossover adaptation in Adv-APEDE for improved diversity and convergence.", "configspace": "", "generation": 6, "fitness": 0.9795983901099072, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.014. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9826989102149549, 0.9953771622593649, 0.9607190978554017], "final_y": [0.1648581793390006, 0.16485910719235253, 0.16486238948425447]}, "mutation_prompt": null}
{"id": "32519ed4-e361-4fc2-874d-7dd24bed3642", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * np.exp(np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Enhanced periodicity constraint\n                trial = self.enforce_hierarchical_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def enforce_hierarchical_periodicity(self, trial, lb, ub):\n        # Force hierarchical periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period//2])\n            trial[i:i+period//2] = np.clip(period_mean, lb[i:i+period//2], ub[i:i+period//2])\n            period_mean = np.mean(trial[i+period//2:i+period])\n            trial[i+period//2:i+period] = np.clip(period_mean, lb[i+period//2:i+period], ub[i+period//2:i+period])\n        return trial", "name": "AdvAPEDE", "description": "Enhanced Adv-APEDE introduces a hierarchical periodicity enforcement to optimize periodic structure convergence, with refined crossover dynamics for diversity.", "configspace": "", "generation": 6, "fitness": 0.980402460674452, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.012. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9945933281512769, 0.98060069081398, 0.966013363058099], "final_y": [0.16486205207185212, 0.16485979701400133, 0.16485870190220453]}, "mutation_prompt": null}
{"id": "acde7066-1c39-4e2d-99c3-0fc107d6999e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Fitness-weighted differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F_adjusted = F * (1 - fitness[indices[0]] / np.max(fitness))\n                mutant = np.clip(a + F_adjusted * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply improved periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub, multi_period=True)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub, multi_period=False):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // (3 if multi_period else 2)\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced Adaptive Periodic Enhancement Differential Evolution (Enh-APEDE) introduces fitness-weighted mutation and multi-periodic refinement for improved convergence and solution quality.", "configspace": "", "generation": 6, "fitness": 0.9802501425720894, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9827583250236849, 0.9777757844758412, 0.9802163182167423], "final_y": [0.16486344715042078, 0.16485605189026142, 0.16485720373293078]}, "mutation_prompt": null}
{"id": "da8d8902-75d0-455f-ae8c-6c8e885e7213", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_strength = (1 - (eval_count / self.budget)) * F\n                mutant = np.clip(a + adaptive_strength * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "QICADE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Coherence Strength", "configspace": "", "generation": 6, "fitness": 0.992389640472073, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9844686726614178, 0.9957637106532383, 0.9969365381015632], "final_y": [0.16486217564934136, 0.16486290579064822, 0.164858874941758]}, "mutation_prompt": null}
{"id": "8e373c76-24b8-4ca1-8497-02799461b1cb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        restart_threshold = 0.2  # Added line for restart strategy\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            # Random restart strategy\n            if np.min(fitness) > restart_threshold:  # Added line for random restart\n                population = lb + (ub - lb) * np.random.rand(population_size, self.dim)  # Added line for random restart\n            \n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "AdvAPEDE", "description": "Introduced random restart strategy in the AdvAPEDE algorithm to escape local minima and enhance global search.", "configspace": "", "generation": 6, "fitness": 0.9748143678665903, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.009. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.962619656148564, 0.9810339022976673, 0.9807895451535396], "final_y": [0.16485859363470978, 0.1648581458263465, 0.16485927447441473]}, "mutation_prompt": null}
{"id": "12e2d087-72ea-475c-8c98-d6d9fa2a4e4e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.3, 0.7  # Modified crossover range\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Improved dynamic crossover adaptation by refining the range for CR to enhance convergence rate while maintaining diversity.", "configspace": "", "generation": 6, "fitness": 0.9911759693729364, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4f7a1060-d75a-45ce-bbe5-72420a76672c", "metadata": {"aucs": [0.9959544708152122, 0.9946355937092534, 0.9829378435943439], "final_y": [0.16486252187735406, 0.16485646368106144, 0.16485805146087285]}, "mutation_prompt": null}
{"id": "b3a18b79-fc49-4b60-810b-4e877d7c352c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        population_size = 20\n        F_base = 0.8  # Base differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition with periodicity-driven initialization\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        population = self.apply_periodicity(population, lb, ub)\n        \n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                F = F_base * (1 - eval_count / self.budget)\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Improved QICAD-E implements adaptive differential weights and periodicity-driven initializations for enhanced performance in complex multilayer optimization landscapes.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (5,) into shape (5,10)').", "error": "ValueError('could not broadcast input array from shape (5,) into shape (5,10)')", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {}, "mutation_prompt": null}
{"id": "7ab3198c-6db8-4489-a1c0-35f4eb5cbde2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.1 + 0.1 * np.random.rand()  # Adaptive coherence strength\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE with adaptive coherence strength for improved exploration and convergence.", "configspace": "", "generation": 7, "fitness": 0.9920714892368357, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9880426624374474, 0.9928663581153263, 0.9953054471577338], "final_y": [0.16485678052153818, 0.16485647494128652, 0.16485858673000464]}, "mutation_prompt": null}
{"id": "e456499f-be22-4f9e-9777-4666b7559594", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n\n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "QICADE+ enhances periodic pattern enforcement by adjusting coherence strength dynamically based on convergence progress.", "configspace": "", "generation": 7, "fitness": 0.993677833148685, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9947702515966583, 0.9930229607969734, 0.9932402870524231], "final_y": [0.16486633557232389, 0.16486316942639123, 0.1648629304069088]}, "mutation_prompt": null}
{"id": "6b7d6b66-7280-49e4-b8df-674ee6ceb07a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n            # Adaptive coherence strength\n            coherence_strength = 0.2 * (1 - eval_count / self.budget)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE with adaptive coherence strength to balance exploration and exploitation dynamically.", "configspace": "", "generation": 7, "fitness": 0.9949787427034966, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.995 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9945921979702201, 0.9964013444885991, 0.9939426856516708], "final_y": [0.16485587362164933, 0.1648591466438225, 0.1648611967083341]}, "mutation_prompt": null}
{"id": "59c95f6e-59db-414c-8b47-9647f62a06f0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.3  # Increased coherence strength\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhance QICADE by fine-tuning coherence strength for improved solution diversity and convergence.", "configspace": "", "generation": 7, "fitness": 0.9948582549806088, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.995 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9956599722682677, 0.9945641663795699, 0.9943506262939885], "final_y": [0.16486046856019, 0.16485975499736738, 0.16486204905514834]}, "mutation_prompt": null}
{"id": "ed9bb34c-808b-486a-8601-f677f2f24498", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F_min, F_max = 0.5, 0.9  # Adaptive differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation with adaptive F\n                F = F_min + (F_max - F_min) * (1 - eval_count / self.budget)\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "QICADE", "description": "QICADE-Plus introduces an adaptive differential weight strategy in QICADE for enhanced exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.9942555076054229, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9935835067609744, 0.9941683082810923, 0.9950147077742022], "final_y": [0.16486073126162915, 0.1648602906044201, 0.16485746153081582]}, "mutation_prompt": null}
{"id": "800904e1-d9bc-4ae1-b912-77589441065c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period]) + 0.01  # Modified periodic application\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Improved Quantum-Inspired Coherence-Assisted Differential Evolution (QICAD-E) with modified periodicity application for enhanced solution precision.", "configspace": "", "generation": 7, "fitness": 0.9941331237963293, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9936851904104714, 0.9945422776844695, 0.994171903294047], "final_y": [0.16485756136361107, 0.1648581763026259, 0.16485903343445163]}, "mutation_prompt": null}
{"id": "4fe3ad7b-779b-421c-a6cc-2d3238ca8895", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Enhanced dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.2 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply enhanced periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force enhanced periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Improved AdvAPEDE with enhanced adaptive crossover and periodicity refinement for better convergence.", "configspace": "", "generation": 7, "fitness": 0.9920624698867505, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {"aucs": [0.9962047405458421, 0.9926720251820771, 0.9873106439323321], "final_y": [0.16485926152835373, 0.1648561863314354, 0.16485704171991744]}, "mutation_prompt": null}
{"id": "cc553119-2060-42d3-b9dc-712dcd55fb12", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = 0.5 + np.random.rand() * 0.5 * np.std(fitness) / np.mean(fitness)  # Updated line\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Introduce a randomization factor to mutation for more diverse exploration.", "configspace": "", "generation": 7, "fitness": 0.9882883901612475, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.988 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {"aucs": [0.9958455328865784, 0.988263123642901, 0.980756513954263], "final_y": [0.16486345763909727, 0.16485914728933415, 0.16485730364725637]}, "mutation_prompt": null}
{"id": "4de1eb2b-3143-484a-884e-b0d4b4d79bb1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.var(fitness) / np.mean(fitness)  # Changed to diversity measure\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply enhanced periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub, eval_count)  # Pass eval_count\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub, eval_count):  # Added eval_count\n        period = 2 + (eval_count // 100) % (self.dim // 2)  # Dynamic period adjustment\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with adaptive periodicity enforcement and diversity-driven mutation for improved solution quality.", "configspace": "", "generation": 7, "fitness": 0.9913926943123744, "feedback": "The algorithm AdvAPEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {"aucs": [0.989657857016175, 0.992720452616418, 0.9917997733045303], "final_y": [0.16485927495259467, 0.16485668752741556, 0.1648579543512556]}, "mutation_prompt": null}
{"id": "b8aeecdb-e616-4699-a31d-46a916b1252f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                F = np.clip(F * (1.0 + 0.1 * np.random.randn()), 0.4, 1.0)  # Adjust mutation rate\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint with diversity\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        perturbation = (ub - lb) * 0.05 * np.random.randn(period)  # Increase diversity\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean + perturbation, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with periodicity-induced diversity and adaptive mutation rate for improved exploration and convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "34f5a68b-44d0-4a18-996d-6062fa7bc10a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Enhanced local refinement phase using more iterations and a larger trust region\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='trust-constr', bounds=bounds, options={'maxiter': 20})\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with improved local refinement and diversity maintenance for better convergence in multilayer optimization.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "1b001a4d-f330-4c22-bd82-bf681515f478", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        num_subpopulations = 2  # Use multiple subpopulations\n        F = 0.8  \n        CR = 0.9  \n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        populations = [lb + (ub - lb) * np.random.rand(population_size, self.dim) for _ in range(num_subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        eval_count = population_size * num_subpopulations\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = [np.full(population_size, CR) for _ in range(num_subpopulations)]\n        \n        while eval_count < self.budget:\n            for s in range(num_subpopulations):  # Iterate over subpopulations\n                for i in range(population_size):\n                    if eval_count >= self.budget: \n                        break\n\n                    indices = np.random.choice(range(population_size), 3, replace=False)\n                    a, b, c = populations[s][indices]\n                    F = 0.5 + 0.5 * np.std(fitness[s]) / np.mean(fitness[s])\n                    mutant = np.clip(a + F * (b - c), lb, ub)\n                    \n                    CR[s][i] = np.clip(CR[s][i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                    cross_points = np.random.rand(self.dim) < CR[s][i]\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, populations[s][i])\n                    \n                    trial = self.apply_periodicity(trial, lb, ub)\n                    \n                    f_trial = func(trial)\n                    eval_count += 1\n\n                    if f_trial < fitness[s][i]:\n                        populations[s][i] = trial\n                        fitness[s][i] = f_trial\n\n            # Local refinement phase\n            elite_idx = [np.argmin(fit) for fit in fitness]\n            for s in range(num_subpopulations):  # Local search on each subpopulation\n                if eval_count + self.dim <= self.budget:\n                    bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                    res = minimize(lambda x: func(np.clip(x, lb, ub)), populations[s][elite_idx[s]], method='L-BFGS-B', bounds=bounds)\n                    eval_count += res.nfev\n                    if res.fun < fitness[s][elite_idx[s]]:\n                        populations[s][elite_idx[s]] = res.x\n                        fitness[s][elite_idx[s]] = res.fun\n\n        best_subpop_idx = np.argmin([min(fit) for fit in fitness])\n        best_idx = np.argmin(fitness[best_subpop_idx])\n        return populations[best_subpop_idx][best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE with multi-population strategy and targeted local search phases for improved convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "7315ba53-c9a6-4335-b1e9-d4d09f3b03b2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            # Dynamic resizing of population\n            if eval_count % 100 == 0:\n                population_size = max(10, population_size - 1)\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                CR = CR[:population_size]\n\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Enhanced mutation factor based on population variance\n                F = 0.5 + 0.5 * np.var(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Refined AdvAPEDE with dynamic population resizing and mutation strategy, enhancing exploration and exploitation for complex multilayer optimization.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "5ff1c2f1-a183-4ab8-b3ae-36ccda36f95e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = 0.5 + 0.5 * np.std(fitness) / np.median(fitness)  # Changed mean to median here\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Introducing a refined adaptive F strategy based on median fitness to enhance convergence in the AdvAPEDE algorithm.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "4bd98887-a2b3-412e-b646-7e9ec9f09cce", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                \n                # Modify F to adapt based on best and worst fitness\n                F = 0.5 + 0.5 * (np.min(fitness) - np.max(fitness)) / np.max(fitness)\n                \n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Introduced a new adaptive mechanism for the differential weight F based on the best and worst fitness values to enhance convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "9dc6ca90-23a0-4522-9bd6-73b1d2db0af0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Initial crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize population with symmetric strategy\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Dynamic crossover adaptation\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n        \n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F value based on fitness diversity\n                F = np.clip(0.5 + 0.5 * np.std(fitness) / np.mean(fitness), 0.4, 0.9)  # Enhanced F bounds\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                # Dynamic crossover adaptation\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection and elite preservation\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = AdvAPEDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "AdvAPEDE", "description": "Enhanced AdvAPEDE improves differential mutation and crossover strategies with adaptive parameters and periodic patterns for better convergence in multilayer optimization problems.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {}, "mutation_prompt": null}
{"id": "51808a21-aa3d-4350-b91b-8f0596e37300", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  \n        CR = 0.9  \n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_F = F * (0.5 + 0.5 * (self.budget - eval_count) / self.budget)\n                mutant = np.clip(a + adaptive_F * (b - c), lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                coherence_strength *= 0.9  # Reduce coherence over time\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "QICADE", "description": "Enhanced QICADE with adaptive mutation and coherence reduction for improved exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.9879207244670537, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.988 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.984105474688799, 0.9932976982891486, 0.986359000423213], "final_y": [0.16486172931299758, 0.16486029246670353, 0.16486087649895054]}, "mutation_prompt": null}
{"id": "10f73e48-5b74-474c-87c2-729be65b49a9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(self.apply_periodicity(np.clip(x, lb, ub), lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Refined QICADE introduces periodicity enforcement during the local refinement phase using L-BFGS-B.", "configspace": "", "generation": 8, "fitness": 0.9862125269615402, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.986 with standard deviation 0.013. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9685149018175084, 0.9952618134687243, 0.9948608655983878], "final_y": [0.1728108478976006, 0.164861470211213, 0.16485810484654784]}, "mutation_prompt": null}
{"id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.1:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Enhanced AdvAPEDE+ with adaptive periodicity and hybrid local search for improved solution quality and convergence rate.", "configspace": "", "generation": 8, "fitness": 0.9961016716285315, "feedback": "The algorithm AdvAPEDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.996 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dc05cd59-4e5c-4350-8279-978a5c6753d3", "metadata": {"aucs": [0.9958725170135903, 0.9967377215285639, 0.9956947763434406], "final_y": [0.16486025617765943, 0.1648652775235323, 0.16486144928011126]}, "mutation_prompt": null}
{"id": "56cc08e5-c0a7-4264-8248-5a87a43fa0d9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n            # Adjust dynamic periodicity enforcement strategy\n            self.adjust_periodicity_strategy(fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.1:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial\n\n    def adjust_periodicity_strategy(self, fitness):\n        # New method to dynamically adjust periodicity conditions\n        if np.std(fitness) < 0.05:\n            self.dim += 1  # Dynamic adjustment condition for periodicity\n        else:\n            self.dim -= 1", "name": "AdvAPEDEPlus", "description": "Enhanced hybrid optimization with dynamic periodicity adjustment and improved exploration control in high-dimensional spaces.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ')", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {}, "mutation_prompt": null}
{"id": "09dcf97f-6005-4edc-ba86-becdf9b84598", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.05:  # More stringent adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Improved adaptive scheme in AdvAPEDEPlus enhances periodicity enforcement for superior convergence rates and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ')", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {}, "mutation_prompt": null}
{"id": "6ae60601-153f-4a1e-be50-1e9330049c96", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement with refined condition\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.05:  # Refined adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Optimized Adaptive Periodicity in AdvAPEDEPlus for enhanced fine-tuning and exploration balance.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ')", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {}, "mutation_prompt": null}
{"id": "5d3ec0cb-8c6d-4e23-9393-46404a9b125d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F_min, F_max = 0.5, 0.9\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n        \n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            F_dynamic = F_min + np.random.rand() * (F_max - F_min) # Dynamic adaptation of F\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = F_dynamic # Use dynamic F instead\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], \n                               method='L-BFGS-B', bounds=bounds, options={'maxiter': 20}) # Enhanced local search limit\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.1:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Enhanced AdvAPEDEPlus with dynamic F-adaptation and improved local search integration for increased solution quality and convergence rate.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ')", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {}, "mutation_prompt": null}
{"id": "75101a0a-7a15-43cf-baf5-922066cddac2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                CR[i] = 0.9 - 0.8 * (np.std(fitness) / np.mean(fitness))  # New line for dynamic CR\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.1:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Introduced dynamic adaptation of the crossover rate based on fitness variance to improve exploration and convergence in multi-layer optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ')", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {}, "mutation_prompt": null}
{"id": "9e4f83a9-9b77-41a3-ba5f-dc33b9709827", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        threshold = 0.05 + 0.05 * (np.random.rand() - 0.5)  # Dynamically adjust threshold\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > threshold:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Introduced dynamic adaptation of periodicity threshold to further enhance periodic pattern enforcement in multilayer optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (9,) (10,) (10,) ')", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {}, "mutation_prompt": null}
{"id": "9698ccdf-0402-4f29-b94d-eee784b0e57f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  \n        CR = 0.9  \n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], \n                               method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n            coherence_factor = np.sin(i * np.pi / self.dim)  # Adaptive coherence\n            trial[i:i+period] *= coherence_factor\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Refined QICADE enhances exploration by incorporating adaptive coherence and modularity, improving optimization in complex multilayer designs.", "configspace": "", "generation": 9, "fitness": 0.9750810412308467, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.028. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.935778549257864, 0.9935088362948193, 0.995955738139857], "final_y": [0.18187983571119115, 0.16485979440768717, 0.1648600959944848]}, "mutation_prompt": null}
{"id": "3e9ac7e2-8474-4de2-af49-a2fa5e49d3f2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with refined coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.25  # Updated coherence strength\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint with updated strategy\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses with updated periodicity\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i + period])\n            trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE with improved coherence initialization and adaptive periodicity, leading to refined convergence and solution quality.", "configspace": "", "generation": 9, "fitness": 0.995189026141129, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.995 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9954118308481159, 0.9953227396679033, 0.994832507907368], "final_y": [0.16485996706463601, 0.16486170930520294, 0.16486070175230627]}, "mutation_prompt": null}
{"id": "fa53b37b-ac34-40e4-a44d-19e57ffa22b6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n            # Adaptive coherence adjustment\n            coherence_strength *= 0.99  # Slightly reduce coherence strength over time for exploitation\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE with adaptive coherence adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.9910178405940062, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9937771361438651, 0.9835754193898676, 0.9957009662482862], "final_y": [0.16486340570321756, 0.16485976691735427, 0.16485964129966002]}, "mutation_prompt": null}
{"id": "b937f22c-836f-4e7a-bc8c-69dfa3eca1ee", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation with adaptive F\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_F = F + 0.2 * np.random.rand()\n                mutant = np.clip(a + adaptive_F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE with adaptive scaling factor and dynamic coherence for improved performance in multilayer optimization.", "configspace": "", "generation": 9, "fitness": 0.9866446986103586, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.987 with standard deviation 0.009. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9933628470269296, 0.9931210265208855, 0.9734502222832607], "final_y": [0.1648566249243092, 0.16486227199121117, 0.1648588565864465]}, "mutation_prompt": null}
{"id": "d40d4857-ad2b-469e-8cd6-680a97e6d89b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)\n                mutant = np.clip(a + F * (b - c), lb, ub)\n                \n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n                \n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            # Reinitialize population if variance is too low\n            if np.var(fitness) < 0.001:\n                population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n                fitness = np.array([func(ind) for ind in population])\n                eval_count += population_size\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.1:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Enhanced AdvAPEDE+ integrating variance-based reinitialization for improved exploration and convergence robustness.", "configspace": "", "generation": 10, "fitness": 0.9955223609415252, "feedback": "The algorithm AdvAPEDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.996 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {"aucs": [0.9948626768933319, 0.9960325019920014, 0.9956719039392422], "final_y": [0.16485663826054764, 0.16485645042270136, 0.16485731570300888]}, "mutation_prompt": null}
{"id": "82c9c9f3-370f-4800-8e9c-03327f5160ad", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdvAPEDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8\n        CR = 0.9\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        cr_min, cr_max = 0.1, 0.9\n        CR = np.full(population_size, CR)\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness) + 0.1 * np.random.rand()  # Adjusted dynamic scaling\n\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                CR[i] = np.clip(CR[i] + 0.1 * (np.random.rand() - 0.5), cr_min, cr_max)\n                cross_points = np.random.rand(self.dim) < CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial = self.apply_adaptive_periodicity(trial, lb, ub)\n\n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_adaptive_periodicity(self, trial, lb, ub):\n        # Adaptive periodic pattern enforcement\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            subarray = trial[i:i + period]\n            if np.std(subarray) > 0.1:  # Adaptive condition for periodicity\n                period_mean = np.mean(subarray)\n                trial[i:i + period] = np.clip(period_mean, lb[i:i + period], ub[i:i + period])\n        return trial", "name": "AdvAPEDEPlus", "description": "Enhanced AdvAPEDEPlus with dynamic scaling factor adjustment for improved exploration efficiency.", "configspace": "", "generation": 10, "fitness": 0.9944617343578273, "feedback": "The algorithm AdvAPEDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.994 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2c4247c-b06c-40e8-ace1-4c90bf0d1817", "metadata": {"aucs": [0.9941402424205483, 0.9952779589540759, 0.9939670016988574], "final_y": [0.16486166271131908, 0.16485652124668082, 0.16485637441225176]}, "mutation_prompt": null}
{"id": "decd8608-160e-47e9-bf23-a069e4c557e1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.25  # Enhanced coherence strength\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced coherence strength in QICADE for improved exploration and convergence in multilayer optimization.", "configspace": "", "generation": 10, "fitness": 0.9927329088104244, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.993 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9912432025466655, 0.9930379633085545, 0.9939175605760534], "final_y": [0.16485776085180093, 0.16485918749442252, 0.164863775459128]}, "mutation_prompt": null}
{"id": "b9a2a4bc-41b8-412d-8016-31bc534e6403", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(max(lb[j], population[elite_idx][j]-1e-3), min(ub[j], population[elite_idx][j]+1e-3)) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhance the local refinement by adjusting the bounds dynamically to ensure better convergence without exceeding the budget.", "configspace": "", "generation": 10, "fitness": 0.9839021842013415, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.017. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9596999451171206, 0.9961509999067282, 0.9958556075801756], "final_y": [0.17271458895348468, 0.16485864367267855, 0.16485916616811103]}, "mutation_prompt": null}
{"id": "098a907c-92c4-4830-b4bc-159ee3b3470e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n            # Adjust coherence strength dynamically\n            coherence_strength = max(0.1, coherence_strength * 0.99)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE with dynamic coherence strength adjustment for improved adaptability and solution quality.", "configspace": "", "generation": 10, "fitness": 0.9923923202968141, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9847451571649093, 0.9956167127655593, 0.9968150909599739], "final_y": [0.16485637760857497, 0.16485864928901162, 0.1648603035738755]}, "mutation_prompt": null}
{"id": "0d02385b-256f-4194-aa9f-de52bacf3330", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n            # Adjust coherence strength adaptively\n            coherence_strength *= 0.95\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Integrates adaptive coherence strength to improve exploration in Quantum-Inspired Coherence-Assisted Differential Evolution (QICAD-E) for enhanced optimization performance.", "configspace": "", "generation": 10, "fitness": 0.9901729954457553, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.990 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9942754774570013, 0.9816010234783805, 0.994642485401884], "final_y": [0.16485905665482004, 0.16485975207197534, 0.16485843640623554]}, "mutation_prompt": null}
{"id": "92e60b95-c5c1-43ea-ac92-8a5d06b210ad", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover with adaptive CR\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced Quantum-Inspired Coherence-Assisted Differential Evolution (QICAD-E) with adaptive crossover probability for improved convergence in complex multilayer optimization problems.", "configspace": "", "generation": 10, "fitness": 0.9906095974660518, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9832777850064439, 0.9922899097308301, 0.9962610976608814], "final_y": [0.16486035878842953, 0.1648586778013903, 0.164859461828469]}, "mutation_prompt": null}
{"id": "2b38bda7-23ae-4f35-8ec6-8c800be8ac33", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n            # Adjust coherence strength based on diversity\n            coherence_strength = np.std(population) / (ub - lb) * 0.5  # < Change: Dynamic coherence strength\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Enhanced QICADE by integrating adaptive coherence strength to dynamically adjust search diversity and convergence.", "configspace": "", "generation": 10, "fitness": 0.9945600341602866, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.995 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.994602216716795, 0.9944422132471854, 0.9946356725168792], "final_y": [0.16486242627083114, 0.16485642009677925, 0.16485882482709924]}, "mutation_prompt": null}
{"id": "841585f3-c434-4dff-8414-4c31b2e6460d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Dynamic coherence adjustment based on evaluations\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        eval_fraction = 0\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            eval_fraction = eval_count / self.budget\n            coherence_strength = 0.2 * (1 - eval_fraction)  # Decrease coherence strength over evaluations\n            \n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial = self.apply_periodicity(trial, lb, ub)\n                f_trial = func(trial)\n                eval_count += 1\n\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            # Adaptive periodicity application\n            period_mean = np.mean(trial[i:i+period])\n            if np.random.rand() < 0.5:  # Random application of periodicity\n                trial[i:i+period] = np.clip(period_mean, lb[i:i+period], ub[i:i+period])\n        return trial", "name": "QICADE", "description": "Enhanced QICADE with dynamic coherence adjustment and adaptive periodicity application to improve diversity and convergence in multilayer optimization.", "configspace": "", "generation": 10, "fitness": 0.9916149791000274, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.992 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9862450680757241, 0.9947301640187047, 0.9938697052056529], "final_y": [0.1648607184446096, 0.1648565125253616, 0.16485721852808177]}, "mutation_prompt": null}
{"id": "09765dc9-793b-4039-854c-e96785d21e3a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QICADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 20\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Quantum-inspired superposition: initialize population with coherence\n        population = lb + (ub - lb) * np.random.rand(population_size, self.dim)\n        coherence_strength = 0.2\n        population += coherence_strength * (np.random.rand(population_size, self.dim) - 0.5) * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential mutation\n                indices = np.random.choice(range(population_size), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply periodicity constraint with refined enforcement\n                trial = self.apply_periodicity(trial, lb, ub)\n                \n                # Calculate fitness\n                f_trial = func(trial)\n                eval_count += 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Local refinement phase with targeted enhancement\n            elite_idx = np.argmin(fitness)\n            if eval_count + self.dim <= self.budget:\n                bounds = [(lb[j], ub[j]) for j in range(self.dim)]\n                res = minimize(lambda x: func(np.clip(x, lb, ub)), population[elite_idx], method='L-BFGS-B', bounds=bounds)\n                eval_count += res.nfev\n                if res.fun < fitness[elite_idx]:\n                    population[elite_idx] = res.x\n                    fitness[elite_idx] = res.fun\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def apply_periodicity(self, trial, lb, ub):\n        # Force stronger periodic patterns in layer thicknesses\n        period = self.dim // 2\n        for i in range(0, self.dim, period):\n            period_mean = np.mean(trial[i:i+period])\n            trial[i:i+period] = np.clip(period_mean + np.random.uniform(-0.01, 0.01), lb[i:i+period], ub[i:i+period])\n        return trial\n\n# Example usage:\n# func = YourBlackBoxFunction()\n# optimizer = QICADE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QICADE", "description": "Improved QICADE with enhanced periodicity enforcement and targeted local refinement for better convergence and solution quality.", "configspace": "", "generation": 10, "fitness": 0.9905414796487303, "feedback": "The algorithm QICADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.991 with standard deviation 0.007. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "393139b4-96d0-421e-9265-3fd20aa4b33a", "metadata": {"aucs": [0.9803285552660072, 0.9957973728775911, 0.9954985108025924], "final_y": [0.1648587386080489, 0.1648625065379421, 0.1648577443241258]}, "mutation_prompt": null}
