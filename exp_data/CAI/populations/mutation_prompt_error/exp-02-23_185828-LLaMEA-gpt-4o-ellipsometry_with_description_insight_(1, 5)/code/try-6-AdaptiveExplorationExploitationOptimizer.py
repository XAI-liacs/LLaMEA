import numpy as np
from scipy.optimize import minimize

class AdaptiveExplorationExploitationOptimizer:
    def __init__(self, budget, dim):
        self.budget = budget
        self.dim = dim

    def __call__(self, func):
        bounds = np.array(list(zip(func.bounds.lb, func.bounds.ub)))
        num_initial_samples = min(self.budget // 3, 25)  # More initial points for better exploration
        
        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_initial_samples, self.dim))
        
        best_solution = None
        best_value = float('inf')
        evaluations = 0

        # Evaluate initial samples
        for sample in initial_samples:
            if evaluations >= self.budget:
                break
            value = func(sample)
            evaluations += 1
            if value < best_value:
                best_value = value
                best_solution = sample

        # Simulated Annealing-inspired exploration with refinement
        temperature = 1.0
        cooling_rate = 0.95

        current_solution = best_solution
        current_value = best_value

        # Refinement through local search as temperature decreases
        while evaluations < self.budget and temperature > 0.01:
            perturbation = np.random.uniform(-0.1, 0.1, self.dim) * (bounds[:, 1] - bounds[:, 0])
            candidate_solution = np.clip(current_solution + perturbation, bounds[:, 0], bounds[:, 1])
            candidate_value = func(candidate_solution)
            evaluations += 1
            
            if candidate_value < current_value or np.exp((current_value - candidate_value) / temperature) > np.random.rand():
                current_solution = candidate_solution
                current_value = candidate_value
                if candidate_value < best_value:
                    best_value = candidate_value
                    best_solution = candidate_solution
            
            temperature *= cooling_rate

        return best_solution