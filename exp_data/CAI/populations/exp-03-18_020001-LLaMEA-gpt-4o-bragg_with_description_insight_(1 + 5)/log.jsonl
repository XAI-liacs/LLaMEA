{"id": "8936e929-1182-4e08-9de9-6a800a5d806a", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "A hybrid global-local optimization algorithm combining Differential Evolution with periodicity-enforcing and local refinement strategies to find near-optimal multilayer structures.", "configspace": "", "generation": 0, "fitness": 0.860374217247364, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.014. And the mean value of best solutions found was 0.186 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8792803898986686, 0.8454809225965441, 0.8563613392468791], "final_y": [0.1919051801370837, 0.18597272559691458, 0.1791118600467816]}, "mutation_prompt": null}
{"id": "0a260c70-b4c4-42a0-8ec3-ff2f303778e7", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                self.f = 0.5 + np.random.rand() * 0.3  # Adaptive differential weight\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Improved periodicity enforcement\n                trial = self.enforce_periodicity(trial, ub, lb)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution, ub, lb):\n        # Improved periodicity by enforcing bounds and averaging\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            mean_val = np.mean(solution[start:end])\n            solution[start:end] = np.clip(mean_val, lb, ub)\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE algorithm with improved periodicity enforcement and adaptive differential weight for better performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (10,) into shape (2,)').", "error": "ValueError('could not broadcast input array from shape (10,) into shape (2,)')", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "ee0dfc8a-ba85-4255-ae83-0f5afb94a342", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        d = population[np.random.choice([i for i in range(self.population_size) if i not in [a, b, c]], 1)]\n        mutant = np.clip(a + self.f * (b - c + d - a), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Refined hybrid optimization algorithm combining enhanced mutation strategies with periodicity enforcement to improve performance in multilayer optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "c0604785-5b32-4e0e-81e2-ad55c8726324", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.95  # Crossover probability adjustment from 0.9 to 0.95\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "A refined HybridPeriodicDE algorithm increasing crossover probability to enhance solution diversity and convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "0d3390b8-9b43-4251-948d-636565f48122", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Adaptive periodicity enforcement during mutation\n                if np.random.rand() < self.periodicity_weight:\n                    a = self.enforce_periodicity(a)\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Introducing adaptive periodicity enforcement in the mutation step to further exploit constructive interference and solution modularity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "503461f6-0806-4346-be1e-95db0bf34907", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = np.mean(solution[start:end])\n            solution[start:end] = avg * (1 + self.periodicity_weight)  # Scale by periodicity weight\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced periodicity enforcement by scaling layer averages to improve constructive interference.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {}, "mutation_prompt": null}
{"id": "0cd73c44-f4d9-4687-aa8a-f5fb779e6d27", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.5 + np.random.rand() * 0.3  # Adaptive Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Enhanced Periodicity enforcement\n                trial = self.enforce_periodicity(trial, period=4)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution, period=2):\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Improved hybrid optimization with enhanced periodicity enforcement and adaptive mutation for better reflectivity maximization.", "configspace": "", "generation": 2, "fitness": 0.6424401686846702, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.642 with standard deviation 0.215. And the mean value of best solutions found was 0.332 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.9468208617971515, 0.49220068012598717, 0.4882989641308718], "final_y": [0.17294342356364345, 0.4106266188352986, 0.4136927208600043]}, "mutation_prompt": null}
{"id": "a88da095-37cd-43de-9992-f09fc10c3bd6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.85  # Crossover probability adjusted for better local refinement\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE improves local refinement by adjusting crossover probability to balance exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.6154653319190514, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.615 with standard deviation 0.179. And the mean value of best solutions found was 0.333 (0. is the best) with standard deviation 0.114.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8686625491707166, 0.47712962805739645, 0.5006038185290413], "final_y": [0.17290482648414462, 0.4217448995036597, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "0391916c-548c-4389-a31c-20460477d2ab", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.85   # Differential weight adjusted slightly for better balance\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE by adjusting differential weight for improved exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.5640203833902852, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.564 with standard deviation 0.224. And the mean value of best solutions found was 0.379 (0. is the best) with standard deviation 0.146.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8783636602073509, 0.44204378137781086, 0.3716537085856937], "final_y": [0.1751693667025218, 0.44958983963414223, 0.511152496709788]}, "mutation_prompt": null}
{"id": "52c54e23-faba-4714-b90f-f6cb8e7692b4", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n\n                # Adaptive periodicity enforcement based on current best fitness\n                if fitness[best_idx] < 0.2:\n                    self.periodicity_weight = 0.2\n\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1)  # Slightly dynamic crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end]) * self.periodicity_weight\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced Hybrid DE with dynamic crossover and adaptive periodicity for improved optimization.", "configspace": "", "generation": 2, "fitness": 0.4688845223087474, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.469 with standard deviation 0.073. And the mean value of best solutions found was 0.432 (0. is the best) with standard deviation 0.055.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.44250436255030623, 0.39593375983405654, 0.5682154445418793], "final_y": [0.4497424805167226, 0.4885199473140439, 0.3581513569459748]}, "mutation_prompt": null}
{"id": "ad4590fa-0ad0-458d-8490-769b3ef674b4", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Introduce a diversity boost by random mutation\n                if np.random.rand() < 0.1:\n                    trial += np.random.normal(0, 0.1, self.dim)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "A hybrid global-local optimization algorithm that combines Differential Evolution with periodicity-enforcing strategies and integrates a diversity boost for improved exploration to find near-optimal multilayer structures.", "configspace": "", "generation": 2, "fitness": 0.6699522386256112, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.670 with standard deviation 0.101. And the mean value of best solutions found was 0.288 (0. is the best) with standard deviation 0.071.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8107176773671594, 0.6191401059962259, 0.5799989325134478], "final_y": [0.1881243890435308, 0.32676866849928066, 0.34954404120482696]}, "mutation_prompt": null}
{"id": "a5c2e24c-db83-420c-93f8-13ac75d75968", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.2  # Weight for periodicity enforcement (changed from 0.1)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution", "name": "HybridPeriodicDE", "description": "Refined periodicity enforcement in Differential Evolution by updating the periodicity_weight for improved optimization.", "configspace": "", "generation": 3, "fitness": 0.883100279343064, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.038. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.8796238433953938, 0.8386594679690269, 0.9310175266647716], "final_y": [0.1860698496350559, 0.17672660284101194, 0.17378106962544537]}, "mutation_prompt": null}
{"id": "a919c180-c488-490b-a139-22caec6207c7", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm using Differential Evolution with improved periodicity enforcement and adaptive crossover strategies for optimizing multilayer structures.", "configspace": "", "generation": 3, "fitness": 0.8834662819136002, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.049. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.9524842965455341, 0.8536605183705296, 0.8442540308247367], "final_y": [0.172772868317132, 0.17855612944111554, 0.17601472991788514]}, "mutation_prompt": null}
{"id": "2bc1417e-7f68-4c1e-aa37-792044474888", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 5 * dim)  # Reduced population size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Adjusted periodicity enforcement\n                trial = self.enforce_periodicity(trial, (self.budget - self.population_size - _) / self.budget)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution, adaptation_factor):\n        # Adaptive periodicity enforcement by dynamically adjusting the averaging based on adaptation_factor\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end]) * adaptation_factor + solution[start:end] * (1 - adaptation_factor)\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE with dynamic population size and adaptive periodicity enforcement for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.8641354413400945, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.031. And the mean value of best solutions found was 0.180 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.9069186901981303, 0.8340789296146589, 0.8514087042074941], "final_y": [0.17277350360438204, 0.18239888691378436, 0.18430321459121646]}, "mutation_prompt": null}
{"id": "7afac2ca-46a6-450b-8931-4036feccacf6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        # Enforcing periodicity by averaging adjacent layers based on periodicity expectation\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end]) * self.periodicity_weight\n        return solution", "name": "HybridPeriodicDE", "description": "A hybrid global-local optimization algorithm that combines Differential Evolution with enhanced periodicity-enforcing and local refinement strategies to find near-optimal multilayer structures.", "configspace": "", "generation": 3, "fitness": 0.7205077066961282, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.721 with standard deviation 0.158. And the mean value of best solutions found was 0.253 (0. is the best) with standard deviation 0.109.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.49666061503708203, 0.8405359482910212, 0.8243265567602812], "final_y": [0.4073425911909888, 0.17497561479031587, 0.17725537760584387]}, "mutation_prompt": null}
{"id": "64cf60ae-0005-4d01-957d-4501c13b8ca5", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n            \n            # Diversity enhancement\n            if _ % 10 == 0:\n                self.enhance_diversity(population, lb, ub)\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n    \n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean(solution[start:end])\n        return solution\n    \n    def enhance_diversity(self, population, lb, ub):\n        # Introduce random individuals to enhance diversity\n        num_random = int(0.1 * self.population_size)\n        new_individuals = np.random.uniform(lb, ub, (num_random, self.dim))\n        population[:num_random] = new_individuals", "name": "HybridPeriodicDE", "description": "Enhanced hybrid optimization with a diversity-enhancing mechanism and improved periodicity enforcement to better explore complex landscapes.", "configspace": "", "generation": 3, "fitness": 0.8249716429828152, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.024. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8936e929-1182-4e08-9de9-6a800a5d806a", "metadata": {"aucs": [0.7938903779489359, 0.8533290119430708, 0.8276955390564391], "final_y": [0.1855571023209034, 0.18136035975730314, 0.1824628281559444]}, "mutation_prompt": null}
{"id": "de3fec4b-73be-42a5-b6aa-a34202cd02f6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.periodic_mutate(a, b, c, lb, ub, best)\n                trial = self.crossover(population[i], mutant, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def periodic_mutate(self, a, b, c, lb, ub, best):\n        # Enhanced mutation with periodicity awareness\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            mutant[start:end] = (mutant[start:end] + best[start:end]) / 2\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n", "name": "HybridPeriodicDE", "description": "Advanced hybrid optimization algorithm using Differential Evolution with periodicity-aware mutation and adaptive local exploration for optimizing multilayer structures.", "configspace": "", "generation": 4, "fitness": 0.829585122976301, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.185. And the mean value of best solutions found was 0.232 (0. is the best) with standard deviation 0.089.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9638677727300982, 0.9566721516569258, 0.5682154445418793], "final_y": [0.16555360582132728, 0.17277478178748895, 0.3581513569459748]}, "mutation_prompt": null}
{"id": "fdfca22c-13d0-4ea4-8309-7bd3a091fe92", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.adaptive_mutate(a, b, c, lb, ub, best)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def adaptive_mutate(self, a, b, c, lb, ub, best):\n        # Introduce adaptive mutation strategy\n        adapt_factor = np.random.rand() * (1 - np.linalg.norm(best - (a + b + c) / 3) / np.linalg.norm(ub - lb))\n        mutant = np.clip(a + self.f * (b - c) + adapt_factor, lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An improved hybrid Differential Evolution algorithm incorporating periodicity bias and adaptive mutation for optimizing complex multilayer structures.", "configspace": "", "generation": 4, "fitness": 0.4658877028844794, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.466 with standard deviation 0.375. And the mean value of best solutions found was 0.528 (0. is the best) with standard deviation 0.305.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9569830384357315, 0.04741838145630195, 0.39326168876140466], "final_y": [0.17277528882431614, 0.9183680855761402, 0.4915935044282741]}, "mutation_prompt": null}
{"id": "e2fa7a1b-57c4-4594-acea-3cd80b4c8d6d", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        self.primary_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.secondary_population = np.random.uniform(0, 1, (self.population_size, self.dim)) \n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        fitness = np.array([func(ind) for ind in self.primary_population])\n        best_idx = np.argmin(fitness)\n        best = self.primary_population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.primary_population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(self.primary_population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best, i)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    self.primary_population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best, index):\n        # Enhanced periodicity enforcement with dual population influence\n        period = 2\n        weight = (index % 10 + 1) / 10\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + weight * self.secondary_population[index][start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm using Differential Evolution with improved periodicity enforcement via adaptive weighting and a dual-population strategy for optimizing multilayer structures.", "configspace": "", "generation": 4, "fitness": 0.34429534631047715, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.344 with standard deviation 0.213. And the mean value of best solutions found was 0.581 (0. is the best) with standard deviation 0.240.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.04741841657354329, 0.533337823093756, 0.4521297992641321], "final_y": [0.9183683924215043, 0.3822094756469999, 0.44184678027911195]}, "mutation_prompt": null}
{"id": "9d1ba8a6-769d-40bd-a1b6-de08986931be", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                        self.periodicity_weight = 0.1 + 0.05 * (1 - trial_fitness / fitness[best_idx])  # Dynamic adjustment\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg) * self.periodicity_weight\n        return solution", "name": "HybridPeriodicDE", "description": "Incorporate dynamic adjustment of the periodicity weight based on fitness improvement to enhance convergence.", "configspace": "", "generation": 4, "fitness": 0.4949196341896651, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.495 with standard deviation 0.005. And the mean value of best solutions found was 0.409 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.49666061503708203, 0.48802396753046395, 0.5000743200014495], "final_y": [0.4073425911909888, 0.4135967802763709, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "911a6bbf-86fc-4ab7-8668-95fc6acd817f", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        scale_factor = np.random.rand() * self.f  # Adaptive scaling factor\n        mutant = np.clip(a + scale_factor * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "Improved hybrid optimization algorithm with enhanced periodicity enforcement and adaptive strategies for better convergence performance.", "configspace": "", "generation": 4, "fitness": 0.618594497215657, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.619 with standard deviation 0.245. And the mean value of best solutions found was 0.356 (0. is the best) with standard deviation 0.134.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9592707265074645, 0.3964384451380569, 0.5000743200014495], "final_y": [0.1729112269111609, 0.48879337276610557, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "ddd7062e-aa9f-46ca-b54b-537a4e9b3d7b", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] * 0.8 + best[start:end] * 0.2)  # Changed weighting factor\n            solution[start:end] = np.mean(avg)\n        return solution", "name": "HybridPeriodicDE", "description": "An advanced hybrid global-local optimization algorithm using Differential Evolution with refined periodicity enforcement and adaptive crossover strategies for optimizing multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.9492907918702073, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.020. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9210041076040183, 0.9650110849617998, 0.961857183044804], "final_y": [0.17277297822315663, 0.16864169019537878, 0.16954733118618637]}, "mutation_prompt": null}
{"id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase and adaptive mutation to optimize multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.9611523736447131, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.961 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9644840671039296, 0.9627212244432524, 0.9562518293869569], "final_y": [0.16973151899707217, 0.1692734324476608, 0.16889037416292385]}, "mutation_prompt": null}
{"id": "85fc4224-68e4-47f9-ba01-a4a1637de9f8", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(solution[start:end])  # Alternate periodic adjustment\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced periodicity enforcement through alternate periodic adjustment for optimizing multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.926630606868442, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.927 with standard deviation 0.040. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.8709232153473194, 0.9491950147193482, 0.9597735905386583], "final_y": [0.1811872846610405, 0.16954702534467303, 0.16893374140812145]}, "mutation_prompt": null}
{"id": "c056c92b-6d06-4247-b16b-c5cefeb8be92", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                self.f = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg) * self.periodicity_weight  # Adjusted periodicity\n        return solution", "name": "HybridPeriodicDE", "description": "Optimized periodicity enforcement and adaptive mutation for enhanced multilayer structure optimization.", "configspace": "", "generation": 5, "fitness": 0.804596704725395, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.218. And the mean value of best solutions found was 0.248 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.49666061503708203, 0.9560559978524736, 0.9610735012866295], "final_y": [0.4073425911909888, 0.16762435059421432, 0.16951450424064385]}, "mutation_prompt": null}
{"id": "210784a3-dcfc-4b4f-a783-c1b8cb0de9e9", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.85  # Crossover probability\n        self.f = 0.5   # Differential weight\n        self.periodicity_weight = 0.15  # Increased weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.dynamic_mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Enhanced periodicity enforcement\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n\n        return best\n\n    def dynamic_mutate(self, a, b, c, lb, ub):\n        f_dynamic = self.f * np.random.uniform(0.5, 1.0)\n        mutant = np.clip(a + f_dynamic * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = np.mean(solution[start:end])\n            solution[start:end] = avg\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm combining Differential Evolution with dynamic control parameters, improved periodicity enforcement, and adaptive mutation strategies for optimizing multilayer structures.", "configspace": "", "generation": 5, "fitness": 0.9489213654209182, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.010. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a919c180-c488-490b-a139-22caec6207c7", "metadata": {"aucs": [0.9352485258313417, 0.9586188076879745, 0.9528967627434384], "final_y": [0.17277289068893997, 0.16964372446260012, 0.17094052023245332]}, "mutation_prompt": null}
{"id": "d439e634-ef82-40c6-87bc-400ba9be2a99", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "Incremental improvement of HybridPeriodicDE by increasing the population size for better exploration of the search space.", "configspace": "", "generation": 6, "fitness": 0.9537031005333869, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.004. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9585871967545087, 0.9534820324765507, 0.9490400723691015], "final_y": [0.16985754119955532, 0.17023233429880347, 0.1701770538095707]}, "mutation_prompt": null}
{"id": "141e2413-9174-4544-a286-35753b74bca2", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.2 * np.random.rand())  # Adaptive crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE with adaptive crossover probability for improved exploration.", "configspace": "", "generation": 6, "fitness": 0.9015550561426199, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.083. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9619423525810895, 0.7843998132084824, 0.9583230026382877], "final_y": [0.16942942667340588, 0.2303697693724287, 0.17057007799887314]}, "mutation_prompt": null}
{"id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase, adaptive mutation, and improved periodicity enforcement to optimize multilayer structures.", "configspace": "", "generation": 6, "fitness": 0.9636694695955489, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.004. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9692153050571763, 0.962756724122827, 0.9590363796066435], "final_y": [0.16888399658061437, 0.17045405854871676, 0.16990589007639734]}, "mutation_prompt": null}
{"id": "7c2da705-de91-4574-82e1-107264ad45dd", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.2  # Weight for periodicity enforcement (increased)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase, adaptive mutation, and increased periodicity weight to optimize multilayer structures.", "configspace": "", "generation": 6, "fitness": 0.9580655633472069, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.001. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9581685204682134, 0.9563465966000302, 0.9596815729733772], "final_y": [0.16984986068372554, 0.16980515280948394, 0.16902543733619757]}, "mutation_prompt": null}
{"id": "37add99a-f1f9-4bfe-812a-4e527fa0bed1", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                self.periodicity_weight = np.random.uniform(0.05, 0.15)  # Adaptive periodicity weight\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end]) / 2\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase and adaptive mutation to optimize multilayer structures, now with adaptive periodicity weighting for improved solution refinement.", "configspace": "", "generation": 6, "fitness": 0.9603055854349026, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.002. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "6970c11e-0707-4e46-83d9-ea1db3c06e03", "metadata": {"aucs": [0.9616763040837815, 0.9580125948420863, 0.9612278573788398], "final_y": [0.17014949618989605, 0.16897294648610994, 0.16995859708525107]}, "mutation_prompt": null}
{"id": "d9bd0432-d207-4fe5-b424-b50605f95886", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with enhanced local search phase, adaptive mutation, and improved periodicity enforcement to optimize multilayer structures.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "metadata": {"aucs": [0.9692153050571763, 0.962756724122827, 0.9590363796066435], "final_y": [0.16888399658061437, 0.17045405854871676, 0.16990589007639734]}, "mutation_prompt": null}
{"id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid optimization algorithm using Differential Evolution with adaptive sampling, improved periodic enforcement, and novel local search strategies to optimize multilayer photonic structures.", "configspace": "", "generation": 7, "fitness": 0.9679372458295035, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.003. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "metadata": {"aucs": [0.9708090881393856, 0.9643630715046887, 0.968639577844436], "final_y": [0.16904882514456743, 0.17012741545404242, 0.16909674377910955]}, "mutation_prompt": null}
{"id": "574c8058-78d0-4b65-8945-786d9a08dc21", "solution": "import numpy as np\n\nclass RefinedHybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Symmetric initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        opposites = lb + ub - population\n        population = np.vstack((population, opposites))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - 2 * self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "RefinedHybridPeriodicDE", "description": "An enhanced hybrid global-local optimization algorithm using DE with adaptive mutation, symmetrically initialized search, and improved periodicity guidance for multilayer structures.", "configspace": "", "generation": 7, "fitness": 0.9579650993967562, "feedback": "The algorithm RefinedHybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.002. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "metadata": {"aucs": [0.9597491958502495, 0.9544342538481922, 0.9597118484918267], "final_y": [0.1700397389923618, 0.1697207646077098, 0.16975477577733722]}, "mutation_prompt": null}
{"id": "bc2eb26b-346f-4362-8e72-677919b8039a", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increase population size for better exploration\n        self.cr = 0.9\n        self.f = 0.8\n        self.periodicity_weight = 0.2  # Increase periodicity weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        adaptive_factor = 0.5 * np.random.rand() + 0.5  # Dynamic adjustment\n        mutant = np.clip(a + adaptive_factor * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + \n                   np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.03 * (ub - lb)  # Adjust step size for finer search\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid algorithm blending Differential Evolution with periodicity-aware local search and dynamic adaptation of parameters to optimize multilayer structures.", "configspace": "", "generation": 7, "fitness": 0.9659667573903796, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.003. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "metadata": {"aucs": [0.9625438794089797, 0.9657974542365523, 0.969558938525607], "final_y": [0.17050191011368798, 0.16909115176691092, 0.1696785796972291]}, "mutation_prompt": null}
{"id": "839b4089-fbfb-4224-bb48-5eb140a76356", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        for _ in range(self.budget - self.population_size):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                \n                # Periodicity enforcement\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    # Local search enhancement\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.15 * np.random.rand()) * (b - c), lb, ub)  # Adaptive mutation\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Adapted crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        # Enhanced periodicity enforcement by using the best solution as a guide\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # A simple local search method\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        return solution", "name": "HybridPeriodicDE", "description": "A refined hybrid global-local optimization algorithm using Differential Evolution with dynamic periodicity enforcement and mutation adaptation to optimize multilayer structures.", "configspace": "", "generation": 7, "fitness": 0.9653887706613705, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.002. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1b19e3ec-2807-4ed1-a0da-07e9bf088024", "metadata": {"aucs": [0.9628741750566413, 0.9682307953193539, 0.9650613416081166], "final_y": [0.17041679529621223, 0.16935117674226252, 0.16820949704552668]}, "mutation_prompt": null}
{"id": "76119f9d-914e-41db-86ca-27169ef37384", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg) * self.periodicity_weight + solution[start:end] * (1 - self.periodicity_weight)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.1 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved HybridPeriodicDE with adaptive local search and enhanced periodicity enforcement to optimize multilayer photonic structures more effectively.", "configspace": "", "generation": 8, "fitness": 0.8336523054701915, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.188. And the mean value of best solutions found was 0.221 (0. is the best) with standard deviation 0.073.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.5677470359247822, 0.9654583876184215, 0.9677514928673709], "final_y": [0.3241790725376633, 0.16990034259609, 0.16971891245566262]}, "mutation_prompt": null}
{"id": "3a2952fa-3057-4849-af06-3c8f8702b386", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.85  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg) * 1.1\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved periodicity enforcement and crossover strategy for enhanced solution exploration.", "configspace": "", "generation": 8, "fitness": 0.9496038902996752, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.950 with standard deviation 0.020. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9215254879686641, 0.9633910709603178, 0.9638951119700436], "final_y": [0.18405351643143686, 0.17063460640582873, 0.16979151190176311]}, "mutation_prompt": null}
{"id": "59a24114-e872-4836-aea4-c4ab70923fa1", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.15 * np.random.rand()) * (b - c), lb, ub)  # Changed from 0.1 to 0.15\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced HybridPeriodicDE by refining the mutation strategy to improve exploration of the search space.", "configspace": "", "generation": 8, "fitness": 0.9641136103099722, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.001. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9633686864663283, 0.9634969857629915, 0.9654751587005969], "final_y": [0.17035206757205534, 0.17010227347029605, 0.1698844761046825]}, "mutation_prompt": null}
{"id": "30926a23-0465-4fb4-b023-f07f639ab48e", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.uniform(0.8, 1.2, self.dim))  # Modified line\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced periodic enforcement by modifying the crossover points strategy to improve solution diversity.", "configspace": "", "generation": 8, "fitness": 0.9675647325137451, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.003. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9639757581704044, 0.9704831570584556, 0.9682352823123754], "final_y": [0.16904958235203882, 0.16910483912206487, 0.16983397225223051]}, "mutation_prompt": null}
{"id": "db972895-76eb-48af-b9c6-fc9820ce3256", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub, eval_count)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub, eval_count):\n        step_size = 0.05 * (ub - lb) * np.exp(-eval_count / self.budget)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced hybrid optimization algorithm using Differential Evolution with focused local search by adjusting step size based on convergence rate to optimize multilayer photonic structures.", "configspace": "", "generation": 8, "fitness": 0.965172581433203, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.002. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9630506541713841, 0.9682965517737259, 0.9641705383544988], "final_y": [0.17071423027877963, 0.1701668127849646, 0.16889175717932559]}, "mutation_prompt": null}
{"id": "5919288f-0ddb-46a7-9db0-6d154fca5954", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        self.f = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved HybridPeriodicDE with adaptive mutation factor and enhanced sampling strategy for better convergence.", "configspace": "", "generation": 9, "fitness": 0.9621799023156733, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.962 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9659045500404512, 0.9598033239368431, 0.9608318329697256], "final_y": [0.17004787556228995, 0.17286883072858905, 0.1694075435115837]}, "mutation_prompt": null}
{"id": "eb05b65d-7087-4be2-a8d0-1d974fed3075", "solution": "import numpy as np\n\nclass EnhancedHybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim, 50)\n        self.cr = 0.85  # Crossover probability\n        self.f = 0.7    # Differential weight\n        self.periodicity_weight = 0.15  # Weight for periodicity reinforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.population_size = max(5, int(10 * (self.budget - eval_count) / self.budget))  # Dynamic resizing\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.7\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "EnhancedHybridPeriodicDE", "description": "An advanced hybrid optimization algorithm using Differential Evolution with dynamic population resizing, periodicity reinforcement, and refined local search for optimizing multilayer photonic structures.", "configspace": "", "generation": 9, "fitness": 0.9657264388785283, "feedback": "The algorithm EnhancedHybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.010. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9765018979016836, 0.9533598329960159, 0.9673175857378853], "final_y": [0.16767163972808152, 0.16945054939853965, 0.17029499274583115]}, "mutation_prompt": null}
{"id": "7e34a49a-ad25-4fa2-ba20-a83a37ea7190", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c) + 0.05 * (c - a), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "A refined hybrid optimization algorithm using Differential Evolution with enhanced mutation strategy to optimize multilayer photonic structures.", "configspace": "", "generation": 9, "fitness": 0.9630557222360193, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.963 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9660219076156109, 0.9610105856498853, 0.9621346734425619], "final_y": [0.16865626263983646, 0.17103036090995472, 0.17224204996135184]}, "mutation_prompt": null}
{"id": "52ad64f3-ba31-48a6-8902-597b8df70a62", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        f_local = self.f * (0.5 + 0.5 * np.random.rand())  # Localized adaptive mutation\n        mutant = np.clip(a + f_local * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cr_local = self.cr * (0.5 + 0.5 * np.random.rand())  # Localized adaptive crossover\n        cross_points = np.random.rand(self.dim) < cr_local\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced hybrid optimization using Differential Evolution with localized adaptive mutation and crossover strategies for optimizing multilayer photonic structures.", "configspace": "", "generation": 9, "fitness": 0.9629064231589815, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.963 with standard deviation 0.003. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9668412287164607, 0.958798128909887, 0.9630799118505966], "final_y": [0.16950784037354716, 0.16960501555685292, 0.17141856486041251]}, "mutation_prompt": null}
{"id": "cde3f471-e9e0-458b-a044-451eadb54393", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.2  # Increased weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        # Adjust mutation strategy\n        mutant = np.clip(a + (self.f + 0.2 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        # Refined local search strategy\n        step_size = 0.1 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.normal(0, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.normal(0, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "An enhanced hybrid optimization algorithm using Differential Evolution with improved sampling, adaptive periodic enforcement, and refined local search strategies for optimizing multilayer photonic structures.", "configspace": "", "generation": 9, "fitness": 0.9608103552603122, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.961 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9639311332692544, 0.9570583816506337, 0.9614415508610483], "final_y": [0.16989092304214026, 0.17285590995318678, 0.17031939797770423]}, "mutation_prompt": null}
{"id": "51df50c4-9559-4cbe-899c-b071dde39da6", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best, eval_count):\n        period = max(2, self.dim // (1 + eval_count // (self.budget // 10)))  # Dynamic period length\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "We enhance the periodicity enforcement by considering a dynamic period length based on current algorithm progress, allowing better adaptability to the optimization landscape.", "configspace": "", "generation": 10, "fitness": 0.9683129052741176, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.001. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9688317885736546, 0.9672009000203166, 0.968906027228382], "final_y": [0.16770771703851473, 0.1683784398496745, 0.1681222918136649]}, "mutation_prompt": null}
{"id": "6a61a540-f94c-4acd-a54d-f71c3c938049", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.15 * np.random.rand()) * (b - c), lb, ub)  # Slightly increased random scaling\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg)  # Enforcing periodicity with weighted averaging\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "A refined hybrid optimization algorithm using Differential Evolution with adaptive periodicity enforcement and enhanced local search for efficient black-box optimization.", "configspace": "", "generation": 10, "fitness": 0.9683378861722551, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.000. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.968625055949611, 0.9679806823807069, 0.9684079201864474], "final_y": [0.16915932720759086, 0.16848479749612644, 0.16889439303540343]}, "mutation_prompt": null}
{"id": "8cab3860-ce57-4aa1-856a-1dc31a663858", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.2 * np.random.rand())  # Adjusted crossover probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] + best[start:end] + np.roll(solution, period)[start:end]) / 3\n            solution[start:end] = np.mean(avg) * (1 + self.periodicity_weight)  # Improved periodicity enforcement\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced exploration by introducing adaptive crossover probability and improved periodicity enforcement in Differential Evolution for optimizing multilayer photonic structures.", "configspace": "", "generation": 10, "fitness": 0.9548492619137562, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.011. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9388877716572906, 0.9642700650720286, 0.961389949011949], "final_y": [0.1760152472443286, 0.1695825558066868, 0.1674973752583021]}, "mutation_prompt": null}
{"id": "fe80b574-db4b-4477-8800-e9dfad184c30", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced periodicity enforcement by improving averaging strategy for better constructive interference.", "configspace": "", "generation": 10, "fitness": 0.9705134263128231, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.008. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9806378765132453, 0.9617763450313113, 0.9691260573939124], "final_y": [0.1648557719046978, 0.16995966410031182, 0.16998476047038502]}, "mutation_prompt": null}
{"id": "1cc0819e-6867-41c9-b9e4-b985fdf50843", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = (solution[start:end] * 0.4 + best[start:end] * 0.4 + np.roll(solution, period)[start:end] * 0.2)\n            solution[start:end] = np.mean(avg)  # Adjusted line\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        improved = func(candidate) < fitness\n        if not improved:\n            step_size *= 0.5\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if improved else solution  # Adjusted line", "name": "HybridPeriodicDE", "description": "An improved hybrid algorithm that enhances periodicity enforcement and refines local search strategies using dynamic adaptation for optimizing multilayer photonic structures.", "configspace": "", "generation": 10, "fitness": 0.962127617450048, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.962 with standard deviation 0.002. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "93cbb3aa-3220-438d-b4af-a62a682cb2e3", "metadata": {"aucs": [0.9624820520120967, 0.9598092221065212, 0.964091578231526], "final_y": [0.17038211618137822, 0.170028670108876, 0.1697931499841706]}, "mutation_prompt": null}
{"id": "c8d9d91b-4922-4c52-bdc4-b1c34ee22cd5", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 4  # Adjusted period size to improve periodic alignment\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved periodic enforcement by adjusting the period size to better align with the known optimal periodic Bragg mirror solution.", "configspace": "", "generation": 11, "fitness": 0.9529152149048455, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.021. And the mean value of best solutions found was 0.174 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9819560189272021, 0.938663358729625, 0.9381262670577099], "final_y": [0.16485577190469858, 0.1789323031753569, 0.17908384405162092]}, "mutation_prompt": null}
{"id": "719c4957-bce4-479a-8dc6-a011d58139e8", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.15 * np.random.rand())  # Changed line\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0) * 0.9  # Changed line\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved periodicity enforcement and exploitation by modifying crossover and periodicity functions.", "configspace": "", "generation": 11, "fitness": 0.9314132499363087, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.931 with standard deviation 0.002. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9343648448553353, 0.9311794642840412, 0.9286954406695498], "final_y": [0.18105339065199222, 0.1808950495520667, 0.18275020560583266]}, "mutation_prompt": null}
{"id": "414bfae5-688d-41b7-827d-98f3b803dd43", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.2  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub, eval_count / self.budget)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub, progress):\n        adaptive_f = self.f * (1 - progress)\n        mutant = np.clip(a + adaptive_f * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = max(2, int(self.dim / 10))  # Dynamic period adjustment\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced periodicity with adaptive mutation and periodic focus for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.9315327535151064, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.932 with standard deviation 0.036. And the mean value of best solutions found was 0.181 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9821843449614794, 0.9122575666373615, 0.9001563489464784], "final_y": [0.1648557719046978, 0.1873435369693307, 0.19004578709502473]}, "mutation_prompt": null}
{"id": "8b2a5428-5ad8-4514-ae96-202b169af9ab", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                self.f = 0.5 + 0.3 * np.std(fitness)  # Change made here\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved exploration by altering the differential weight adaptively based on fitness variance.", "configspace": "", "generation": 11, "fitness": 0.9539158996388658, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.029. And the mean value of best solutions found was 0.174 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9806041888848898, 0.9674118474171474, 0.9137316626145603], "final_y": [0.1648557719046978, 0.1695910162619465, 0.18716991592672783]}, "mutation_prompt": null}
{"id": "d4c4e047-8ea8-483b-a5f2-9b8c25dc169f", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub, eval_count / self.budget)  # Line changed\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub, adapt_factor):  # Line changed\n        scale = self.f + 0.1 * np.random.rand() * (1 - adapt_factor)  # Line changed\n        mutant = np.clip(a + scale * (b - c), lb, ub)  # Line changed\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced exploration by adaptive mutation scaling and refined periodicity enforcement for better constructive interference.", "configspace": "", "generation": 11, "fitness": 0.9408923002233106, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.941 with standard deviation 0.029. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9797654306043978, 0.9318666865434394, 0.9110447835220946], "final_y": [0.16485577190469825, 0.18221154977907883, 0.18705154437792815]}, "mutation_prompt": null}
{"id": "524ac674-ff85-485b-956c-c69f1077cef4", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.15  # Adjusted weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution):\n        period = np.random.choice([2, 3], p=[0.7, 0.3])  # Adaptive periodicity\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.03 * (ub - lb)  # Improved precision with smaller step size\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhanced strategy through adaptive periodicity enforcement and improved local search precision.", "configspace": "", "generation": 12, "fitness": 0.9656957826246516, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.934847387912096, 0.982713179222535, 0.9795267807393241], "final_y": [0.16502397102614874, 0.16485577307982724, 0.16485577335047563]}, "mutation_prompt": null}
{"id": "60af8351-48c4-4f89-af59-5f799c7dd8a5", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end]*0.7, best[start:end]*0.3, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved periodicity enforcement by increasing the periodic averaging influence for better constructive interference.", "configspace": "", "generation": 12, "fitness": 0.8534441154404998, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.176. And the mean value of best solutions found was 0.220 (0. is the best) with standard deviation 0.078.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.6044534453149288, 0.9773307923110991, 0.978548108695471], "final_y": [0.32995310217391616, 0.16485577418253583, 0.1648557732635053]}, "mutation_prompt": null}
{"id": "7ba9b12f-cd0a-47e5-9d6b-07b6397bedd9", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7  # Refined step size reduction factor for better fine-tuning\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Refine local search by adaptive step size reduction for enhanced fine-tuning.", "configspace": "", "generation": 12, "fitness": 0.9792818685208918, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.979 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9769823206477378, 0.9795536420769374, 0.9813096428380002], "final_y": [0.16485577350340008, 0.16485577258251516, 0.16485577369287774]}, "mutation_prompt": null}
{"id": "3abeab03-3e91-4765-8722-6c6bada23ec2", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2 + (self.dim % 2)  # Adjusted period calculation for enhanced interference\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved periodicity enforcement by refining period adjustment for enhanced constructive interference.", "configspace": "", "generation": 12, "fitness": 0.9784856453114595, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.978 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9806407518867233, 0.9744188306030973, 0.9803973534445581], "final_y": [0.1648557719046978, 0.164855774492625, 0.16485577249557937]}, "mutation_prompt": null}
{"id": "bf68db4d-948f-42c0-a3d5-36281ce6db80", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.enhanced_local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = max(2, self.dim // 4)  # Adaptive period length\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def enhanced_local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.03 * (ub - lb)  # Reduced initial step size\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < fitness:\n            return candidate\n        step_size *= 0.5\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Improved periodicity by adaptive period length and enhanced local search for better optimization.", "configspace": "", "generation": 12, "fitness": 0.9753692339005243, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fe80b574-db4b-4477-8800-e9dfad184c30", "metadata": {"aucs": [0.9709948722968851, 0.9792799758114379, 0.97583285359325], "final_y": [0.16485577190469802, 0.1648557737255496, 0.1648557740394655]}, "mutation_prompt": null}
{"id": "06c0d4b1-dd90-43f2-8eb1-3f2d6171fdf4", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 3  # Changed from 2 to 3 for enhanced periodicity\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7  # Refined step size reduction factor for better fine-tuning\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Enhance local search by adjusting periodicity enforcement for improved solution exploration.", "configspace": "", "generation": 13, "fitness": 0.9141459642443075, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.034. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7ba9b12f-cd0a-47e5-9d6b-07b6397bedd9", "metadata": {"aucs": [0.9622060201652956, 0.8844394372133656, 0.8957924353542612], "final_y": [0.1695022277735675, 0.1713913503274599, 0.16664083423626597]}, "mutation_prompt": null}
{"id": "87c3c051-e237-4c26-b2d2-44ba57928af8", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, best, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, best, lb, ub):\n        mutant = np.clip(a + (self.f + 0.3 * np.random.rand()) * (b - c) + 0.1 * (best - a), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.2 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Introduce improved mutation strategy and dynamic crossover to enhance exploitation while ensuring periodicity.", "configspace": "", "generation": 13, "fitness": 0.8852106748637908, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.035. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "7ba9b12f-cd0a-47e5-9d6b-07b6397bedd9", "metadata": {"aucs": [0.8387601526620148, 0.8941556936986861, 0.9227161782306716], "final_y": [0.19051625220752655, 0.17067292474312346, 0.16940726883221224]}, "mutation_prompt": null}
{"id": "456caf15-a6c1-4a75-b1e8-27c9f1ed2fc5", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2 + int(np.random.rand() * (self.dim // 4))\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7  # Refined step size reduction factor for better fine-tuning\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Introduce adaptive periodicity enforcement based on dynamic period length adjustment.", "configspace": "", "generation": 13, "fitness": 0.9090191902070378, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.909 with standard deviation 0.046. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7ba9b12f-cd0a-47e5-9d6b-07b6397bedd9", "metadata": {"aucs": [0.9728522606001936, 0.8651085942543848, 0.8890967157665346], "final_y": [0.16487300535207816, 0.17121958021882022, 0.16691820893349918]}, "mutation_prompt": null}
{"id": "43ba8ab9-f979-4736-9c8f-79e6d2fab425", "solution": "import numpy as np\n\nclass HybridPeriodicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        self.periodicity_weight = 0.1 + 0.9 * np.random.rand()  # Change made here\n        mutant = np.clip(a + (self.f + self.periodicity_weight * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7  # Refined step size reduction factor for better fine-tuning\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution", "name": "HybridPeriodicDE", "description": "Introduce adaptive periodicity weight in the mutation process to balance global and periodic exploration.", "configspace": "", "generation": 13, "fitness": 0.9142178742989063, "feedback": "The algorithm HybridPeriodicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.048. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7ba9b12f-cd0a-47e5-9d6b-07b6397bedd9", "metadata": {"aucs": [0.9732316454792529, 0.8564000368339497, 0.9130219405835163], "final_y": [0.16485601681791218, 0.170462567280373, 0.16747819657505947]}, "mutation_prompt": null}
{"id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance exploration by introducing dynamic population resizing and non-linear crossover.", "configspace": "", "generation": 13, "fitness": 0.983312493885102, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7ba9b12f-cd0a-47e5-9d6b-07b6397bedd9", "metadata": {"aucs": [0.9846277947973857, 0.9829329598561423, 0.9823767270017781], "final_y": [0.16485848356833488, 0.16486126065648632, 0.16486905039310362]}, "mutation_prompt": null}
{"id": "859f5526-fd59-443f-ad7d-448868128870", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.periodicity_weight = 0.1\n        self.memory_archive = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.select_parents(idxs, population)\n                mutant = self.adaptive_mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                    self.memory_archive.append(trial)\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n                        self.memory_archive.append(trial)\n\n        return best\n\n    def select_parents(self, idxs, population):\n        archive_sample = np.random.choice(self.memory_archive) if self.memory_archive else None\n        selected = np.random.choice(idxs, 3, replace=False)\n        if archive_sample is not None:\n            return population[selected[0]], population[selected[1]], archive_sample\n        return population[selected[0]], population[selected[1]], population[selected[2]]\n\n    def adaptive_mutate(self, a, b, c, lb, ub):\n        adaptive_f = self.f + 0.2 * np.random.rand()\n        mutant = np.clip(a + adaptive_f * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Refine exploration and exploitation balance by integrating adaptive mutation rates and a memory archive for improved solution diversity.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {}, "mutation_prompt": null}
{"id": "2bec42c1-27e1-43af-b8c9-ebd7ca3dfbdc", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n            # Diversity boost phase\n            if eval_count % (self.budget // 10) == 0:\n                self.diversify_population(population, lb, ub)\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(best, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))\n    \n    def diversify_population(self, population, lb, ub):\n        mutation_strength = 0.1\n        for i in range(self.population_size):\n            population[i] = np.clip(population[i] + mutation_strength * np.random.uniform(lb, ub, self.dim), lb, ub)", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance exploration and convergence by integrating a diversity boost phase and refined periodicity enforcement.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {}, "mutation_prompt": null}
{"id": "7aa12228-cd13-499b-bbde-d1d1d09acb8d", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb) * (fitness / np.min(fitness + 1e-6))  # Adjust step size dynamically\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance local search efficiency by adjusting step size dynamically based on solution quality.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {}, "mutation_prompt": null}
{"id": "6018cf19-c749-49e5-a628-d4027379f5ec", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        lévy_factor = np.random.normal(0, 1, self.dim) * np.random.pareto(1.5, self.dim)\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c) + lévy_factor, lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Incorporate Lévy flight perturbation in mutation to enhance global exploration.  ", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {}, "mutation_prompt": null}
{"id": "d8114de2-847e-4ee3-b5f4-d527403db974", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.periodicity_weight = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best, eval_count):\n        period = 2 + int((self.budget - eval_count) / self.budget * (self.dim // 2))\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.01 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.normal(0, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.normal(0, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced_Adaptive", "description": "Incorporate adaptive periodicity and gradient-based local search to enhance convergence towards optimal solutions.", "configspace": "", "generation": 14, "fitness": 0.9352354666330354, "feedback": "The algorithm HybridPeriodicDE_Enhanced_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.935 with standard deviation 0.043. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {"aucs": [0.9601932666574401, 0.8740864275717448, 0.9714267056699212], "final_y": [0.16495032753873473, 0.18457270285095706, 0.165234698457846]}, "mutation_prompt": null}
{"id": "d1cad5c3-baab-40fb-a964-16aa4894f2c3", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                self.cr = max(0.1, 1 - eval_count / self.budget)  # Adaptive crossover probability\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        solution += self.periodicity_weight * (np.sin(2 * np.pi * solution) - solution)  # Additional periodicity constraint\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive crossover probability and additional periodicity constraints to enhance solution exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.9327272535203344, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.933 with standard deviation 0.009. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {"aucs": [0.9314563395807456, 0.922302214619036, 0.9444232063612216], "final_y": [0.18205785167050936, 0.18605358594115318, 0.1764417711968621]}, "mutation_prompt": null}
{"id": "689b0ce4-28ad-4a72-830b-509a3095fb9b", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        self.adaptation_rate = 0.01  # New adaptation rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                \n                # Modified periodicity enforcement\n                trial = self.enforce_periodicity(trial, best, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                        # Adaptively adjust parameters\n                        self.cr = min(1.0, self.cr + self.adaptation_rate)\n                        self.f = max(0.5, self.f - self.adaptation_rate)\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best, func):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            avg = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n            solution[start:end] = avg if func(avg) < func(solution[start:end]) else solution[start:end]\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced_Refined", "description": "Refine the HybridPeriodicDE_Enhanced algorithm by introducing adaptive parameter tuning and enhanced periodicity enforcement to improve convergence and solution quality.", "configspace": "", "generation": 15, "fitness": 0.7371107815270145, "feedback": "The algorithm HybridPeriodicDE_Enhanced_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.737 with standard deviation 0.024. And the mean value of best solutions found was 0.231 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {"aucs": [0.7123914692846152, 0.7687649603121147, 0.7301759149843132], "final_y": [0.23364219585206603, 0.23793139220048476, 0.2211168276718326]}, "mutation_prompt": null}
{"id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance periodicity enforcement by adjusting blend factors for more constructive interference.", "configspace": "", "generation": 15, "fitness": 0.9847856941937222, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.985 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {"aucs": [0.9817494409719018, 0.9861207792569413, 0.9864868623523233], "final_y": [0.16489046131386353, 0.1648660233553415, 0.1648632183441544]}, "mutation_prompt": null}
{"id": "06602630-8899-4504-9073-4580d50c4a0f", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.5  # Changed decay rate from 0.7 to 0.5\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Improve local search efficiency by adjusting step size decay rate.", "configspace": "", "generation": 15, "fitness": 0.9842357671963843, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.984 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {"aucs": [0.9827111194468753, 0.985805209455258, 0.9841909726870198], "final_y": [0.16486403813958506, 0.16486531203416088, 0.1648561018299627]}, "mutation_prompt": null}
{"id": "cdc24667-b532-4ab6-8772-411ff25e0c79", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand()) # Change 1: self.cr is now self-adaptive\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 4  # Change 2: Adjusted periodicity to 4\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.median([solution[start:end], best[start:end], np.roll(solution, period)[start:end]], axis=0) # Change 3: Mean to median for better stability\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance exploration by introducing a self-adaptive crossover rate and refined periodicity enforcement.", "configspace": "", "generation": 15, "fitness": 0.9810704640696427, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c030eada-c23d-4200-9b0d-3f10c7388c66", "metadata": {"aucs": [0.9740604484817605, 0.9849587793777761, 0.9841921643493914], "final_y": [0.1654100429369353, 0.16497895803267837, 0.16486074701781572]}, "mutation_prompt": null}
{"id": "428d5605-ce0f-4158-acff-55acbf4ff5a8", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.08 * (ub - lb)  # Adjusted step size\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce local search refinement by enhancing periodic enforcement with adaptive step size adjustment.", "configspace": "", "generation": 16, "fitness": 0.9823720843870346, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9812764592715428, 0.9835826752534176, 0.9822571186361437], "final_y": [0.16493651026219358, 0.1649053279521654, 0.1649114935833189]}, "mutation_prompt": null}
{"id": "ccfb5e00-eca6-48ce-83d7-0b5f5c2c02db", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = max(2, self.dim // 10)  # Adaptive period length\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Refine periodicity enforcement using adaptive period length based on solution characteristics.", "configspace": "", "generation": 16, "fitness": 0.9818098279763228, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.98132779399121, 0.9826926055938163, 0.9814090843439421], "final_y": [0.16494437361491754, 0.1648941328294371, 0.1649365477975573]}, "mutation_prompt": null}
{"id": "5c3fded2-36c6-44d3-a4f2-7c58abfc20f9", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        adaptive_f = self.f * np.exp(-0.1 * np.random.rand())  # Changed line\n        mutant = np.clip(a + adaptive_f * (b - c), lb, ub)  # Changed line\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Improve adaptive mutation strategy for enhanced exploration and faster convergence.", "configspace": "", "generation": 16, "fitness": 0.980722332615958, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.980904483813525, 0.9799665113466242, 0.9812960026877244], "final_y": [0.1648865775097298, 0.16492242085167075, 0.16498141561612212]}, "mutation_prompt": null}
{"id": "5a313d34-2559-43e9-b84b-f4e8ddf4de6e", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best, fitness[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best, current_fitness):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * (1 + 0.01 * np.sign(best[start:end] - current_fitness)), np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Integrate adaptive periodicity weight adjustment based on fitness improvements to enhance global search efficiency.", "configspace": "", "generation": 16, "fitness": 0.9812918104926572, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9807496092727758, 0.9825919264122724, 0.9805338957929237], "final_y": [0.16488739528752328, 0.16489060329156846, 0.1648932487875815]}, "mutation_prompt": null}
{"id": "c82d475a-dc6e-474a-a4c1-f02264c85372", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand() + 0.05 * np.random.randn()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Refine mutation strategy by enhancing randomness in differential weight for diversity.", "configspace": "", "generation": 16, "fitness": 0.9802050303364144, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.980 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9785797196812578, 0.9798916821254735, 0.9821436892025117], "final_y": [0.16489364216669544, 0.16491886700655456, 0.16488795204432338]}, "mutation_prompt": null}
{"id": "46674581-7319-43ec-8c7d-4c985a6a87d2", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.6, b=0.6, size=self.dim)  # Adjusted blend factor\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.02, np.roll(solution, period)[start:end]], axis=0)  # Refined periodicity factor\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance periodicity reinforcement by refining the blend factor to foster better constructive interference.", "configspace": "", "generation": 17, "fitness": 0.9666431887857514, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.010. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9807691343390739, 0.9574578815508283, 0.961702550467352], "final_y": [0.16493315554302246, 0.16672897783376106, 0.1650546242852876]}, "mutation_prompt": null}
{"id": "1315cbf3-bb54-4abf-9336-9bb01ea79fc8", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.periodicity_weight = 0.1\n        self.adaptive_step = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub, fitness)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub, fitness)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub, fitness):\n        var_f = np.var(fitness)\n        adaptive_f = self.f * (1 + self.adaptive_step * var_f)\n        mutant = np.clip(a + adaptive_f * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub, global_fitness):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7 * (1 + self.adaptive_step * np.std(global_fitness))\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Adaptive", "description": "Integrate adaptive learning rates based on fitness variance to improve exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.9819041599997801, "feedback": "The algorithm HybridPeriodicDE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.982 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9788643752353295, 0.9824703189392754, 0.9843777858247352], "final_y": [0.16491398089818288, 0.16488046473900753, 0.16490819640331655]}, "mutation_prompt": null}
{"id": "745da12f-2bd9-47b9-9b5d-add88b461e1f", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            shifted_solution = np.roll(solution, period)[start:end] * 0.95\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, shifted_solution], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Refine periodicity by blending solutions with shifted counterpart for enhanced constructive interference.", "configspace": "", "generation": 17, "fitness": 0.9692922961749167, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.008. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9808145640780089, 0.9619388265639628, 0.9651234978827782], "final_y": [0.1651507702115541, 0.16856524924777982, 0.16602948263643824]}, "mutation_prompt": null}
{"id": "aee66bdc-701f-4fcc-b5e6-dd868c29bae0", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub, eval_count)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub, eval_count):\n        oscillation = np.sin(2 * np.pi * eval_count / self.budget)  # Changed line\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c) * (1 + 0.1 * oscillation), lb, ub)  # Changed line\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best, eval_count):  # Changed line\n        period = 2\n        blend_factor = 0.01 + 0.09 * (1 - eval_count / self.budget)  # Changed line\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * (1 + blend_factor), np.roll(solution, period)[start:end]], axis=0)  # Changed line\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce oscillatory mutation and adaptive periodic enforcement to enhance exploration diversity and convergence.", "configspace": "", "generation": 17, "fitness": 0.930269314531868, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.930 with standard deviation 0.042. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.8713378915584968, 0.9640617773976619, 0.9554082746394453], "final_y": [0.16598097775783816, 0.1672953176391483, 0.17013441108489957]}, "mutation_prompt": null}
{"id": "59852f08-8d30-4cd7-abbe-bf3799385df6", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best, eval_count):\n        period = 2\n        dynamic_factor = 1 + 0.01 * (eval_count / self.budget)  # Adjusted line\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * dynamic_factor, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduced a dynamic blend factor in the enforce_periodicity function to better adapt periodicity over iterations.", "configspace": "", "generation": 17, "fitness": 0.9752335073030051, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.005. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.98142299006174, 0.9680749775903964, 0.9762025542568786], "final_y": [0.16486356597991625, 0.16648353943106942, 0.16685035685435412]}, "mutation_prompt": null}
{"id": "1e089967-c910-410d-b4ae-7bd2e93bdf2e", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        adaptive_f = self.f * (0.5 + 0.5 * eval_count / self.budget)  # <--- Changed line\n        mutant = np.clip(a + (adaptive_f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive differential weight factor to improve exploration-exploitation balance over generations.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_count' is not defined\").", "error": "NameError(\"name 'eval_count' is not defined\")", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "7224d545-2f79-45c0-8b6b-dd55be10706f", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.symmetric_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.adaptive_local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def symmetric_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        symmetry_factor = 1 - np.abs(np.sin(np.pi * blend_factor))\n        return np.where(cross_points, symmetry_factor * mutant + (1 - symmetry_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def adaptive_local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n            if step_size < 1e-8:  # Adaptation termination\n                break\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Improve local search efficiency using adaptive step size and exploit symmetry in crossover to enhance periodic solution preservation.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "c139ce04-3ed6-4f2e-8f93-e1ed3a3ddae9", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            self.adaptive_periodicity(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.adaptive_crossover(population[i], mutant, best, eval_count)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def adaptive_crossover(self, target, mutant, best, eval_count):\n        cross_points = np.random.rand(self.dim) < (self.cr * (1 - eval_count / self.budget))\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))\n\n    def adaptive_periodicity(self, eval_count):\n        self.periodicity_weight = 0.1 + 0.9 * (eval_count / self.budget)", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive periodicity and dynamic crossover rates to enhance solution discovery and convergence speed.", "configspace": "", "generation": 18, "fitness": 0.9813833714776689, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9784559233289222, 0.9850789225692526, 0.9806152685348319], "final_y": [0.1649170465782459, 0.16490101957162162, 0.164991343887956]}, "mutation_prompt": null}
{"id": "85d0d1f1-5f82-4c39-921f-abf3e44ce8bd", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        variant_factor = 0.2 + 0.6 * np.random.rand()\n        mutant = np.clip(a + variant_factor * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        candidate_fitness = func(candidate)\n        if candidate_fitness < fitness:\n            return candidate\n        while candidate_fitness >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n            candidate_fitness = func(candidate)\n        return candidate if candidate_fitness < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Enhance mutation diversity and refine local search for improved global exploration and local exploitation in optimization.", "configspace": "", "generation": 18, "fitness": 0.9811799698183482, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.981 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9817647644351772, 0.9786971994458267, 0.9830779455740406], "final_y": [0.16490839931065326, 0.1649345067739153, 0.16497573403667742]}, "mutation_prompt": null}
{"id": "fa12d450-fe7e-4a1a-924c-2f4bc914526e", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), lb, ub)  # Adjusted mutation strategy\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Improve mutation strategy for better diversity and convergence balance in HybridPeriodicDE_Enhanced.", "configspace": "", "generation": 18, "fitness": 0.9829449089323378, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9799658704246084, 0.9844814772002346, 0.9843873791721707], "final_y": [0.16489631781216196, 0.16491360137099165, 0.16486621927682177]}, "mutation_prompt": null}
{"id": "d8b6dabb-413e-413c-8767-7bd07d028e59", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        self.cr = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive crossover probability based on search progress for improved diversity and exploration.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_count' is not defined\").", "error": "NameError(\"name 'eval_count' is not defined\")", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "35c24ef1-22d8-4c1d-a66f-6bf31e01dcd5", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.8, b=0.4, size=self.dim)  # Changed blend factor\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.02, np.roll(solution, period)[start:end]], axis=0)  # Changed periodicity factor\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive blend factors and dynamic periodicity enforcement to enhance solution quality.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_count' is not defined\").", "error": "NameError(\"name 'eval_count' is not defined\")", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "7bca82a0-b323-4258-a192-6d4a149860e7", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.improved_local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best, eval_count):\n        period = 2 + (eval_count // 1000) % 2  # Adaptive period adjustment\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * (1 + 0.005 * np.sign(np.random.randn())), np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def improved_local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.03 * (ub - lb)\n        candidate = solution + step_size * np.random.normal(0, 1, self.dim)\n        candidate = np.clip(candidate, lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.6\n            candidate = solution + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Integrate adaptive periodicity control and improved local search for enhanced solution convergence.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_count' is not defined\").", "error": "NameError(\"name 'eval_count' is not defined\")", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "e07f8323-5d7a-40ad-a5d3-e9443a5455ec", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7 * np.random.rand()  # Adjusted line\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce a probabilistic step size adjustment in the local search phase to enhance convergence efficiency.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_count' is not defined\").", "error": "NameError(\"name 'eval_count' is not defined\")", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "038822f7-1ea9-4a4b-a714-bd95508798d6", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.6, b=0.6, size=self.dim)  # Changed from a=0.5, b=0.5\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Incrementally adjust the blend factor range to further enhance periodicity and constructive interference.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_count' is not defined\").", "error": "NameError(\"name 'eval_count' is not defined\")", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {}, "mutation_prompt": null}
{"id": "f27df08d-57c2-4ed3-8a54-165ed017d8f1", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub, a)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub, a):\n        step_size = 0.05 * (ub - lb) * np.linalg.norm(a)  # Adapting step size based on mutation magnitude\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Fine-tune local search by adapting step size based on mutation magnitude for better local exploration.", "configspace": "", "generation": 20, "fitness": 0.975927857366414, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.976 with standard deviation 0.005. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.973435260725652, 0.9708837254948758, 0.9834645858787141], "final_y": [0.1649441126410972, 0.16763426113243607, 0.16488537867257258]}, "mutation_prompt": null}
{"id": "7672c2a4-2236-4c11-9196-e0e911f3cd44", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n        self.diversity_factor = 0.2  # New: Factor to maintain diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.adaptive_periodicity(trial, best, eval_count)  # Changed\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def adaptive_periodicity(self, solution, best, eval_count):  # Changed\n        period = 2 + int(self.dim * (1 - eval_count / self.budget))  # Adaptive period\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * (1.01 + self.diversity_factor), np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive periodicity and population diversity mechanisms to enhance convergence towards optimal periodic solutions.", "configspace": "", "generation": 20, "fitness": 0.9503980334835956, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.950 with standard deviation 0.032. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9051257207816716, 0.9713097222821889, 0.9747586573869262], "final_y": [0.18464137851410156, 0.16718185668722518, 0.16488374507473336]}, "mutation_prompt": null}
{"id": "8498021f-b789-4446-924f-4128e3e531e4", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = np.clip(a + (self.f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.7, b=0.7, size=self.dim)  # Adjust from 0.5 to 0.7\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 3  # Adjust from 2 to 3\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Introduce adaptive blend factor and enhanced periodicity enforcement for improved constructive interference.", "configspace": "", "generation": 20, "fitness": 0.9727256530119529, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.008. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9619874291897297, 0.9747789535906488, 0.9814105762554803], "final_y": [0.16879158141967654, 0.164884092410306, 0.16491015328148595]}, "mutation_prompt": null}
{"id": "cee36eb4-811b-417b-b0f4-1bb337723267", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = self.mutate(a, b, c, lb, ub, eval_count)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.adaptive_enforce_periodicity(trial, best, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub, eval_count):\n        self.f = 0.5 + 0.4 * (1 - eval_count / self.budget)  # Adaptive Differential weight\n        mutant = np.clip(a + self.f * (b - c), lb, ub)\n        return mutant\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def adaptive_enforce_periodicity(self, solution, best, eval_count):\n        period = 2\n        weight = self.periodicity_weight + 0.9 * (1 - eval_count / self.budget)\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * weight, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Incorporate adaptive periodicity enforcement and dynamic mutation to enhance exploration and convergence in multilayer optimization.", "configspace": "", "generation": 20, "fitness": 0.9687558184788854, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.017. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9447356836311878, 0.9804797673706681, 0.9810520044348003], "final_y": [0.17175877670329387, 0.16492445359674168, 0.1648867152792709]}, "mutation_prompt": null}
{"id": "bdcef59d-6cee-4e08-ae73-63714dda545d", "solution": "import numpy as np\n\nclass HybridPeriodicDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.periodicity_weight = 0.1  # Weight for periodicity enforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_resize(eval_count)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_f = self.adapt_mutation_strategy(fitness[i], fitness[best_idx])\n                mutant = self.mutate(a, b, c, lb, ub, adaptive_f)\n                trial = self.non_linear_crossover(population[i], mutant, best)\n                trial = self.enforce_periodicity(trial, best)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial\n                else:\n                    trial = self.local_search(trial, trial_fitness, func, lb, ub)\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                        if trial_fitness < fitness[best_idx]:\n                            best_idx = i\n                            best = trial\n\n        return best\n\n    def mutate(self, a, b, c, lb, ub, adaptive_f):\n        mutant = np.clip(a + (adaptive_f + 0.1 * np.random.rand()) * (b - c), lb, ub)\n        return mutant\n    \n    def adapt_mutation_strategy(self, current_fitness, best_fitness):\n        return self.f * (1 + 0.5 * np.tanh((current_fitness - best_fitness) / best_fitness))\n\n    def non_linear_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        blend_factor = np.random.beta(a=0.5, b=0.5, size=self.dim)\n        return np.where(cross_points, blend_factor * mutant + (1 - blend_factor) * target, target)\n\n    def enforce_periodicity(self, solution, best):\n        period = 2\n        for start in range(0, self.dim, period):\n            end = min(start + period, self.dim)\n            solution[start:end] = np.mean([solution[start:end], best[start:end] * 1.01, np.roll(solution, period)[start:end]], axis=0)\n        return solution\n\n    def local_search(self, solution, fitness, func, lb, ub):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        while func(candidate) >= fitness:\n            step_size *= 0.7\n            candidate = np.clip(solution + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        return candidate if func(candidate) < fitness else solution\n\n    def dynamic_resize(self, eval_count):\n        self.population_size = int(max(4, 10 * self.dim * (1 - eval_count / self.budget)))", "name": "HybridPeriodicDE_Enhanced", "description": "Augment adaptability by dynamically adjusting mutation strategy based on current fitness landscape.", "configspace": "", "generation": 20, "fitness": 0.9826552163733698, "feedback": "The algorithm HybridPeriodicDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.983 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2c1bac50-3ddf-4cc2-8164-d55785b9c2f6", "metadata": {"aucs": [0.9804268435227799, 0.9825703867407922, 0.9849684188565373], "final_y": [0.1648748740169942, 0.1648728320087196, 0.16488833888237708]}, "mutation_prompt": null}
