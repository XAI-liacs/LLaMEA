{"id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.95\n\n        # Initialize particles and velocities\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                # Simulated Annealing perturbation\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                # Accept new solution based on SA acceptance criterion\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                # Update global best\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            # Particle Swarm Optimization update\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (0.5 * velocities[i] +\n                                 1.5 * r1 * (best_pos[i] - particles[i]) +\n                                 1.5 * r2 * (g_best_pos - particles[i]))\n                particles[i] = np.clip(particles[i] + velocities[i], lb, ub)\n\n            # Update temperature\n            T *= cooling_rate\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "A novel hybrid metaheuristic combining Simulated Annealing and Particle Swarm Optimization to exploit global exploration and local exploitation in black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.76473074786146, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.765 with standard deviation 0.003. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7642153092559846, 0.76890311738062, 0.7610738169477751], "final_y": [0.15524678093979438, 0.1702433386818767, 0.17296403364081692]}, "mutation_prompt": null}
{"id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.7\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "A hybrid metaheuristic algorithm combining Particle Swarm Optimization (PSO) with Simulated Annealing (SA) to balance exploration and exploitation for black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.8159330220608729, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.016. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7997113235015465, 0.8385160824917753, 0.809571660189297], "final_y": [0.14882132982768714, 0.14158324963836566, 0.13990076453072187]}, "mutation_prompt": null}
{"id": "59a15d98-74b5-4039-8a96-656b14df5e08", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.95  # Initial cooling rate\n\n        # Initialize particles and velocities\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                # Simulated Annealing perturbation\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                # Accept new solution based on SA acceptance criterion\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                # Update global best\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            # Particle Swarm Optimization update\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (0.5 * velocities[i] +\n                                 1.5 * r1 * (best_pos[i] - particles[i]) +\n                                 1.5 * r2 * (g_best_pos - particles[i]))\n                particles[i] = np.clip(particles[i] + velocities[i], lb, ub)\n\n            # Update temperature\n            T *= cooling_rate * (1 - 0.5 * (self.iteration / self.budget))  # Dynamic cooling rate adjustment\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "The enhanced hybrid metaheuristic introduces a dynamic adaptation of the cooling rate in Simulated Annealing to balance exploration and exploitation more effectively. ", "configspace": "", "generation": 1, "fitness": 0.754018485804024, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.754 with standard deviation 0.016. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "metadata": {"aucs": [0.7313692984138531, 0.76890311738062, 0.7617830416175988], "final_y": [0.17203763360060087, 0.1702433386818767, 0.17076707361377153]}, "mutation_prompt": null}
{"id": "a9315505-b1c5-4440-965a-5d3bd55f9cfe", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.9\n\n        # Initialize particles and velocities\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                # Simulated Annealing perturbation\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                # Accept new solution based on SA acceptance criterion\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                # Update global best\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            # Differential Evolution-inspired update\n            for i in range(num_particles):\n                indices = np.random.choice(num_particles, 3, replace=False)\n                r1, r2, r3 = indices\n                mutant_vector = particles[r1] + 0.8 * (particles[r2] - particles[r3])\n                trial_vector = np.clip(mutant_vector, lb, ub)\n                trial_val = func(trial_vector)\n                self.iteration += 1\n\n                if trial_val < best_val[i]:\n                    best_val[i] = trial_val\n                    best_pos[i] = trial_vector\n\n            # Update temperature\n            T *= cooling_rate\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "An enhanced hybrid metaheuristic combining Simulated Annealing with a Differential Evolution-inspired update to improve local and global search efficiency in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.7662243226855528, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "metadata": {"aucs": [0.7669612623464326, 0.770637888762451, 0.7610738169477751], "final_y": [0.15647224342599997, 0.16687691820690875, 0.17296403364081692]}, "mutation_prompt": null}
{"id": "fe1b1d88-5a58-4c3c-b0e5-8024221222a7", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9  # Line changed\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay - 0.0001 * (self.global_best_score / np.max(scores))  # Line changed\n            inertia_weight *= 0.995  # Line changed\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved PSOSA by adjusting inertia weight dynamically and introducing adaptive temperature decay based on convergence speed.", "configspace": "", "generation": 1, "fitness": 0.8094852084607197, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.031. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.7864965680787436, 0.7886583673641994, 0.8533006899392157], "final_y": [0.1605145204068571, 0.16245975594865647, 0.13890840313819075]}, "mutation_prompt": null}
{"id": "e36cd849-e0bc-4efa-b7c3-e44f586249b5", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.97  # Change 1: Adjusted cooling rate\n\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.9 - (0.5 * (self.iteration / self.budget))  # Change 2: Added adaptive inertia\n                velocities[i] = (inertia_weight * velocities[i] +  # Change 3: Modified velocity update\n                                 1.5 * r1 * (best_pos[i] - particles[i]) +\n                                 1.5 * r2 * (g_best_pos - particles[i]))\n                particles[i] = np.clip(particles[i] + velocities[i], lb, ub)\n\n            T *= cooling_rate  # Change 4: Used adjusted cooling rate\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "A refined hybrid metaheuristic combining Simulated Annealing and Particle Swarm Optimization with adaptive cooling and inertia for enhanced exploration and exploitation in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.7589932194565364, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.759 with standard deviation 0.020. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "metadata": {"aucs": [0.7334221755556432, 0.7820875064435457, 0.7614699763704207], "final_y": [0.18027150608174636, 0.16124433243250513, 0.16760815096960513]}, "mutation_prompt": null}
{"id": "ebe0373a-e80b-4f77-a643-9298f5547529", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.95\n\n        # Initialize particles and velocities\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                # Simulated Annealing perturbation\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                # Accept new solution based on SA acceptance criterion\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                # Update global best\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            # Particle Swarm Optimization update\n            w = 0.4 + 0.5 * (1 - self.iteration / self.budget)  # Dynamic inertia weight\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 1.5 * r1 * (best_pos[i] - particles[i]) +\n                                 1.5 * r2 * (g_best_pos - particles[i]))\n                particles[i] = np.clip(particles[i] + velocities[i], lb, ub)\n\n            # Update temperature\n            T *= cooling_rate\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by adjusting the inertia weight dynamically to improve exploration-exploitation balance in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.758647196488644, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.759 with standard deviation 0.017. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "metadata": {"aucs": [0.7349949585673298, 0.7712393940380318, 0.7697072368605706], "final_y": [0.16718567798959572, 0.16657565045355816, 0.1684097850987717]}, "mutation_prompt": null}
{"id": "7cc608ca-2939-45f5-a8d3-6af66ecb724a", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.7\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_constant = 1.5 + (0.5 * np.random.rand())  # Changing line\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "A refined PSOSA algorithm incorporating adaptive learning rates for more effective exploration-exploitation balance in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.8039991928383734, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.009. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8112216004126455, 0.7913831065374001, 0.8093928715650747], "final_y": [0.1488342564868267, 0.15678789789594527, 0.14166029871393204]}, "mutation_prompt": null}
{"id": "afd93406-8e46-4bb4-8f14-ff806fa81522", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.95\n        \n        # Initialize particles and velocities\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        w_max, w_min = 0.9, 0.4  # Adaptive inertia weight parameters\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                # Simulated Annealing perturbation\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                # Accept new solution based on SA acceptance criterion\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                # Update global best\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            # Particle Swarm Optimization update\n            w = w_max - (w_max - w_min) * (self.iteration / self.budget)\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 1.5 * r1 * (best_pos[i] - particles[i]) +\n                                 1.5 * r2 * (g_best_pos - particles[i]))\n                particles[i] = np.clip(particles[i] + velocities[i], lb, ub)\n\n            # Update temperature\n            T *= cooling_rate\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "An enhanced hybrid metaheuristic algorithm that introduces adaptive inertia weight for the PSO component to dynamically balance exploration and exploitation in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.75654977057597, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.757 with standard deviation 0.019. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "metadata": {"aucs": [0.7294217195478041, 0.7718877940165425, 0.7683397981635633], "final_y": [0.1671147099098329, 0.16878165404630718, 0.16758443529325673]}, "mutation_prompt": null}
{"id": "2421d764-9929-40ef-991a-694258c0d735", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9  # Changed from 0.7 to 0.9 for dynamic adjustment\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "This refined PSOSA algorithm includes a dynamic inertia weight adjustment for improved convergence in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.8159160447891177, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.020. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8221110130043087, 0.8365212071867636, 0.7891159141762806], "final_y": [0.13909205978386263, 0.14525936810705598, 0.142439922350178]}, "mutation_prompt": null}
{"id": "fa81cdaf-554e-4369-b218-7fdf0949ce34", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        num_particles = 30\n        T_init = 1000\n        T_min = 1\n        cooling_rate = 0.95\n\n        # Initialize particles and velocities\n        particles = np.random.uniform(lb, ub, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_pos = particles.copy()\n        best_val = np.array([func(p) for p in particles])\n        g_best_val = np.min(best_val)\n        g_best_pos = particles[np.argmin(best_val)]\n        self.iteration += num_particles\n\n        T = T_init\n        while self.iteration < self.budget and T > T_min:\n            for i in range(num_particles):\n                if self.iteration >= self.budget:\n                    break\n\n                # Simulated Annealing perturbation\n                new_particle = particles[i] + np.random.uniform(-1, 1, self.dim) * T\n                new_particle = np.clip(new_particle, lb, ub)\n                new_val = func(new_particle)\n                self.iteration += 1\n\n                # Accept new solution based on SA acceptance criterion\n                if new_val < best_val[i] or np.random.rand() < np.exp((best_val[i] - new_val) / T):\n                    particles[i] = new_particle\n                    best_val[i] = new_val\n                    best_pos[i] = new_particle\n\n                # Update global best\n                if new_val < g_best_val:\n                    g_best_val = new_val\n                    g_best_pos = new_particle\n\n            # Particle Swarm Optimization update\n            for i in range(num_particles):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (0.5 * velocities[i] +\n                                 1.5 * r1 * (best_pos[i] - particles[i]) +\n                                 1.7 * r2 * (g_best_pos - particles[i]))  # Slightly increased global best influence\n                particles[i] = np.clip(particles[i] + velocities[i], lb, ub)\n\n            # Update temperature\n            T *= cooling_rate\n\n        return g_best_pos, g_best_val", "name": "HybridOptimizer", "description": "A refined hybrid metaheuristic that adjusts the balance between exploration and exploitation by slightly increasing the influence of global best in the velocity update to enhance convergence speed.", "configspace": "", "generation": 1, "fitness": 0.7806850702100713, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.017. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c13b16cd-9bf2-415b-9efc-38145ec615c4", "metadata": {"aucs": [0.7626296159793028, 0.7762506606591694, 0.8031749339917417], "final_y": [0.15351790136450194, 0.16125764368465756, 0.15474594427438804]}, "mutation_prompt": null}
{"id": "74516738-03ad-4e97-9419-fcd110383f0f", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved PSOSA by adjusting velocity update dynamics for enhanced convergence precision.", "configspace": "", "generation": 1, "fitness": 0.8301926074800338, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.029. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.7987841389125411, 0.8237311698767822, 0.868062513650778], "final_y": [0.1560495089253484, 0.14972484736629377, 0.13474835520367734]}, "mutation_prompt": null}
{"id": "96a87f86-e5fb-4c5b-bc21-1b5bf9ab5a06", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.95  # Changed from 0.99 to 0.95\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by tuning the temperature decay rate to improve convergence speed.", "configspace": "", "generation": 2, "fitness": 0.7930022833684873, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.016. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7754272393342471, 0.8148085563197086, 0.7887710544515063], "final_y": [0.16146155416141406, 0.14048697912848118, 0.15143725984123024]}, "mutation_prompt": null}
{"id": "94ad2732-e439-4a51-a8d8-32581611edf7", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            inertia_weight = 0.9 - (0.5 * self.iteration / self.budget)  # Adaptive inertia weight\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by introducing adaptive inertia weight for dynamic exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8182245320780694, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.005. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8119973395267032, 0.823160336911803, 0.8195159197957023], "final_y": [0.1432368081627795, 0.14717424153265746, 0.14356681204507127]}, "mutation_prompt": null}
{"id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_inertia = inertia_weight - (0.5 * (self.iteration / self.budget))\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced adaptive PSOSA algorithm with dynamic parameter tuning for improved convergence and solution quality. ", "configspace": "", "generation": 2, "fitness": 0.8209996691807433, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.009. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8111270339835001, 0.8320630881331081, 0.8198088854256218], "final_y": [0.1438047507333573, 0.14657653002485682, 0.1492669990452642]}, "mutation_prompt": null}
{"id": "b6a30a8a-03bd-4685-b638-448363cbc429", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n                \n            cognitive_constant = 1.5 + (2.0 - 1.5) * (self.iteration / self.budget)\n            social_constant = 1.5 + (2.0 - 1.5) * (1 - self.iteration / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhance PSOSA by dynamically adjusting cognitive and social constants based on iteration for better exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.7938815776556488, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.019. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8183282440439016, 0.7912811937373696, 0.772035295185675], "final_y": [0.13675494423538037, 0.153740059405565, 0.16854776505897295]}, "mutation_prompt": null}
{"id": "bb6e07b3-c622-4f7a-8b6d-5dd545b981e3", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.9 - 0.5 * (self.iteration / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "An enhanced version of PSOSA with adaptive inertia weight to dynamically balance exploration and exploitation based on iteration progress.", "configspace": "", "generation": 2, "fitness": 0.8052903642548855, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.020. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.7771203471698583, 0.821633460351456, 0.817117285243342], "final_y": [0.1566476083715015, 0.15034827022845398, 0.13439598943655506]}, "mutation_prompt": null}
{"id": "506c294d-3e30-432f-b997-93c38b169fd1", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            inertia_weight = 0.9 - 0.5 * (self.iteration / self.budget)\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n                # Differential Evolution Mutation Step\n                if np.random.rand() < 0.2:\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + 0.8 * (b - c), lb, ub)\n                    mutant_score = func(mutant)\n                    if mutant_score < scores[i]:\n                        self.particles[i] = mutant\n                        scores[i] = mutant_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive inertia weight and hybridized with Differential Evolution to enhance exploration and convergence.", "configspace": "", "generation": 2, "fitness": 0.801365115606247, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.015. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8202538012076941, 0.7837352609316497, 0.8001062846793974], "final_y": [0.14401654716234047, 0.15543610254290852, 0.15248747413087826]}, "mutation_prompt": null}
{"id": "688b313e-c7a0-4bf7-8391-1edaccf71e8c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.8\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n        \n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            inertia_weight = 0.9 - 0.5 * (self.iteration / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.velocities[i] *= (0.9 - 0.4 * (self.iteration / self.budget))  # Non-linear velocity damping\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by incorporating adaptive inertia and non-linear velocity damping for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.8188908529484079, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.018. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8405313194208843, 0.7959205293765446, 0.820220710047795], "final_y": [0.13852802037511602, 0.15447227753101533, 0.14240577940079446]}, "mutation_prompt": null}
{"id": "3da33a73-9d06-486f-835b-f9f03a74c8f4", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9 - 0.5 * (self.iteration / self.budget)  # Adaptive inertia weight\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.995  # Slightly increased decay rate\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by adaptive inertia and dynamic temperature decay for improved exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8153233315543892, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.024. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8004859804345645, 0.8493384946425397, 0.7961455195860636], "final_y": [0.15132927358131187, 0.13600860876980791, 0.15458553749547765]}, "mutation_prompt": null}
{"id": "2ce29673-c435-4aa1-ae10-23f0bb826ea4", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.995  # Slower decay for more exploration\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.9 - 0.5 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Enhanced simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                acceptance_probability = np.exp((scores[i] - proposed_score) / max(temperature, 1e-10))\n                if proposed_score < scores[i] or np.random.rand() < acceptance_probability:\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "An enhanced PSOSA algorithm with adaptive velocity control and a dynamic annealing schedule for improved solution convergence.", "configspace": "", "generation": 2, "fitness": 0.8145285302543076, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.015. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8149263376557977, 0.7963459807852398, 0.832313272321885], "final_y": [0.1508559718250807, 0.15387703097285843, 0.1438359224750918]}, "mutation_prompt": null}
{"id": "43062e3d-249f-481d-89a4-12c1b7af671e", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.7\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_cognitive = cognitive_constant * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhance convergence by dynamically adjusting cognitive and social constants based on iteration progress.", "configspace": "", "generation": 2, "fitness": 0.8163194760112439, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.010. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1297c01d-3d28-4a8b-8845-7c5a5a796d90", "metadata": {"aucs": [0.8294759076148879, 0.8042378357883878, 0.8152446846304562], "final_y": [0.13345445513210807, 0.14568109814357233, 0.14854905547101416]}, "mutation_prompt": null}
{"id": "7ef2c234-a69d-494d-a313-ddeb88d0f26f", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_inertia = inertia_weight - (0.5 * (self.iteration / self.budget))\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= (temperature_decay * 0.99)  # Adaptive temperature decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with adaptive temperature decay for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.8172686208151819, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.020. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "metadata": {"aucs": [0.8446980371703403, 0.8102234976046404, 0.7968843276705653], "final_y": [0.12349532224970794, 0.14956857846028515, 0.1568733246569336]}, "mutation_prompt": null}
{"id": "426085eb-0ed6-4a0f-9d95-67bff85ebdd2", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.7  # Increase cognitive constant\n        social_constant = 1.7  # Increase social constant\n        temperature = 1.0\n        temperature_decay = 0.97  # Increase decay for faster cooling\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_inertia = inertia_weight - (0.3 * (self.iteration / self.budget))  # Adjust inertia weight\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced dynamic PSOSA algorithm with adaptive learning and cooling rate for improved exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.7818693125577769, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.782 with standard deviation 0.019. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "metadata": {"aucs": [0.7761964998769824, 0.8073479650970011, 0.7620634726993473], "final_y": [0.15196664450376918, 0.1504910792711539, 0.16314419853163653]}, "mutation_prompt": null}
{"id": "3bf32d02-e691-43dd-b24a-dbee4fa577f9", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_inertia = inertia_weight * (0.5 + 0.5 * np.cos(np.pi * self.iteration / self.budget))  # Nonlinear dynamic inertia\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by integrating a nonlinear dynamic inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.8174693499522427, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.022. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "metadata": {"aucs": [0.8003781705233499, 0.8038742236966238, 0.8481556556367544], "final_y": [0.15060310886202222, 0.15282201114973848, 0.13794852722354234]}, "mutation_prompt": null}
{"id": "e5ff7efa-18b6-4cf3-8cba-4867d29dfef8", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.95  # Adjusted temperature decay\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_inertia = inertia_weight - (0.5 * (self.iteration / self.budget))\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refined PSOSA by adjusting the temperature decay rate and cognitive constant for improved exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.7897705138418694, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.790 with standard deviation 0.005. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "metadata": {"aucs": [0.7879062032543411, 0.79650305252228, 0.7849022857489867], "final_y": [0.1596700161502026, 0.13604746966976233, 0.14613997248241994]}, "mutation_prompt": null}
{"id": "f1dab67f-9a18-4044-8c58-b805a4d91721", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant_initial = 1.5\n        social_constant_initial = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Change: Adjust cognitive and social constants dynamically\n                cognitive_constant = cognitive_constant_initial * (1 - self.iteration / self.budget)\n                social_constant = social_constant_initial * (self.iteration / self.budget)\n                dynamic_inertia = inertia_weight - (0.5 * (self.iteration / self.budget))\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refine the velocity update by adjusting the cognitive and social constants dynamically based on iteration to enhance global exploration.", "configspace": "", "generation": 3, "fitness": 0.796376402104781, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.006. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "metadata": {"aucs": [0.79003999252929, 0.7955210680114653, 0.8035681457735878], "final_y": [0.15324250086394187, 0.15308339961728268, 0.15057804391428087]}, "mutation_prompt": null}
{"id": "521e99d5-011d-4b01-8f6e-a5a9efccfc41", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.995  # Line changed for better adaptive temperature decay\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i]) +\n                    np.random.normal(0, 0.1, self.dim)  # Line changed for enhanced stochasticity\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refined PSOSA by enhancing stochasticity in velocity update and improving exploration through adaptive temperature decay.", "configspace": "", "generation": 3, "fitness": 0.7958280106973635, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.022. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.768583452010628, 0.7961070713430591, 0.8227935087384031], "final_y": [0.16132893220759092, 0.1522695997889728, 0.1431254494460955]}, "mutation_prompt": null}
{"id": "d61b6863-09fd-4799-946b-40246fdf8e43", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.9  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98  # Adjusted temperature decay for faster convergence\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Fine-tuned PSOSA by optimizing inertia weight decay and cognitive constant for superior convergence accuracy.", "configspace": "", "generation": 3, "fitness": 0.82172443130527, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.036. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.794602285639275, 0.7978808958374429, 0.8726901124390919], "final_y": [0.15170409790554018, 0.1448476121275183, 0.13284574236254587]}, "mutation_prompt": null}
{"id": "27536550-f574-481a-81d0-518c19f0e774", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight for better exploration\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step with Lvy flight\n                levy_step = np.random.standard_cauchy(size=self.dim) * scale * 0.01\n                proposed_solution = self.particles[i] + levy_step\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight *= 0.98  # Adaptive inertia weight reduction\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with adaptive inertia weight and integrated Lvy flight for improved exploration.", "configspace": "", "generation": 3, "fitness": 0.8110324228093284, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.011. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8114351325794251, 0.797013641153238, 0.8246484946953221], "final_y": [0.12764640004545358, 0.15529026411828262, 0.14066692727665808]}, "mutation_prompt": null}
{"id": "d28aa3a6-d680-472f-bda6-4b537657ea88", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.7  # Increased social constant for better exploration\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "PSOSA refinement by increasing social influence for improved exploration and convergence.", "configspace": "", "generation": 3, "fitness": 0.8281627438111868, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.011. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8234934103859066, 0.8436351880638941, 0.8173596329837599], "final_y": [0.14896208573848868, 0.14171585970267297, 0.1481864566453034]}, "mutation_prompt": null}
{"id": "14761f42-65bb-4696-8354-75730c45d78f", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9\n        cognitive_constant = 1.5\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_inertia = inertia_weight * (0.9 ** (self.iteration / self.budget))  # Modified inertia decay\n                self.velocities[i] = (\n                    dynamic_inertia * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced adaptive PSOSA with a modified inertia weight decay for improved exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.8236359315837133, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.006. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "3b928f0a-82c9-45b5-bec8-4a8a0a269698", "metadata": {"aucs": [0.8300242235538902, 0.8158297050386853, 0.8250538661585645], "final_y": [0.14250890098350677, 0.151940558935878, 0.14019160253247986]}, "mutation_prompt": null}
{"id": "22306466-bcdf-4bf1-b54a-dff3ded91d1e", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adaptive inertia weight initialization\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        inertia_weight_min = 0.4  # Min inertia weight\n        inertia_weight_max = 0.9  # Max inertia weight\n        temperature = 1.0\n        temperature_decay = 0.98  # Slightly increased decay for rapid convergence\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            inertia_weight = (inertia_weight_max - inertia_weight_min) * (1 - self.iteration / self.budget) + inertia_weight_min  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Cooperative learning step\n                if i > 0:\n                    self.particles[i] = self.particles[i-1] + np.random.normal(0, 0.1, self.dim) * (self.global_best - self.particles[i-1])\n                    self.particles[i] = np.clip(self.particles[i], lb, ub)\n                \n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Integrating adaptive inertia and cooperative learning into PSOSA for enhanced exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.8227943291024165, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.030. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7868996112255471, 0.8222072367926557, 0.8592761392890464], "final_y": [0.15452069171403682, 0.13582924728743762, 0.13074444093534976]}, "mutation_prompt": null}
{"id": "1d1c35a9-2736-4aac-aa98-df74431c6f5b", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.7  # Increased social constant for better exploration\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            social_constant = 1.5 + 0.2 * np.random.rand()  # Adaptive social constant change\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with adaptive social constant for dynamic exploration-convergence balance.", "configspace": "", "generation": 4, "fitness": 0.7926491937848814, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.044. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "d28aa3a6-d680-472f-bda6-4b537657ea88", "metadata": {"aucs": [0.7522823197254519, 0.7711543197575592, 0.8545109418716329], "final_y": [0.16711395849841948, 0.1309702233362261, 0.12974356163559153]}, "mutation_prompt": null}
{"id": "11b80769-0741-4de8-896a-073153d414d5", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by incorporating dynamic inertia weight adjustment and adaptive velocity scaling for improved convergence and exploration balance.", "configspace": "", "generation": 4, "fitness": 0.8332471046359352, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.012. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d28aa3a6-d680-472f-bda6-4b537657ea88", "metadata": {"aucs": [0.8349998645616258, 0.8173023505984257, 0.8474390987477545], "final_y": [0.13247108468613444, 0.1390067475285952, 0.13081032594697017]}, "mutation_prompt": null}
{"id": "9cff031f-1dd2-492e-b19e-533a8f630de5", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.85  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved PSOSA by fine-tuning the inertia weight for enhanced convergence stability.", "configspace": "", "generation": 4, "fitness": 0.8068030430153588, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.807 with standard deviation 0.023. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7786890667129991, 0.8344741877222001, 0.8072458746108773], "final_y": [0.16298873709081985, 0.13093899397284792, 0.13862662948732052]}, "mutation_prompt": null}
{"id": "f8c5acf2-1b72-4f0f-91b9-62161bfbc5c5", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.9  # Adjusted initial inertia weight for better exploration\n        cognitive_constant = 1.7\n        social_constant = 1.7  # Balanced cognitive and social constants for improved performance\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved PSOSA by enhancing inertia weight decay and cognitive-social balance for better exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8255358529094785, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.034. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7805401195434081, 0.8639637713585187, 0.8321036678265088], "final_y": [0.16414299042773217, 0.12372659070639647, 0.13375699247049733]}, "mutation_prompt": null}
{"id": "09c9a214-7efd-467a-abb1-9e795dd92c20", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adaptive inertia weight, starting value\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.995  # Slightly slower decay for more exploration\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight *= 0.99  # Adaptive inertia weight adjustment\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by introducing adaptive inertia weight and temperature for improved convergence dynamics.", "configspace": "", "generation": 4, "fitness": 0.7741727844512408, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.774 with standard deviation 0.023. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.745958730834157, 0.7740008487027134, 0.8025587738168519], "final_y": [0.15979417924765316, 0.14100809979089113, 0.13682828774826306]}, "mutation_prompt": null}
{"id": "14bd89cf-eae2-45f9-bf18-4d9653f9f078", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            # Dynamically adjust social constant\n            dynamic_social_constant = social_constant * (1 - self.iteration / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    dynamic_social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by dynamically adjusting the social influence based on iteration progress for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.8144414000690926, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.025. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7891360004169542, 0.8489694722342032, 0.8052187275561209], "final_y": [0.15749567658002217, 0.1316952806100078, 0.13074844063469238]}, "mutation_prompt": null}
{"id": "d4ab3fa7-bfac-4779-8504-aa76a6492bed", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Dynamic adjustment for cognitive and social constants\n                cognitive_constant = 1.5 + 0.5 * np.random.rand()  \n                social_constant = 1.3 + 0.7 * np.random.rand()\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduce dynamic social and cognitive constants in PSOSA to enhance adaptability and convergence efficiency.", "configspace": "", "generation": 4, "fitness": 0.7894986946505318, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.016. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7671989233145475, 0.7984503644991385, 0.8028467961379093], "final_y": [0.1661333512814569, 0.13525946029403235, 0.13037833734820636]}, "mutation_prompt": null}
{"id": "de56e366-b962-484d-9d8e-5e949ecb534e", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.995  # Modified temperature decay for improved balance\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "PSOSA refinement by modifying temperature decay rate to balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8133713955818881, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.032. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7689455770483085, 0.8260417106733847, 0.845126899023971], "final_y": [0.13357856288055825, 0.13273085211625524, 0.1330290546788292]}, "mutation_prompt": null}
{"id": "b1ab8592-d75e-4dbe-aa88-31e0343c3816", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_cognitive_constant = cognitive_constant * (1 - self.iteration / self.budget)\n                dynamic_social_constant = social_constant * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    dynamic_cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    dynamic_social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Further refined PSOSA by dynamically adjusting social and cognitive weights to enhance exploration and convergence balance.", "configspace": "", "generation": 4, "fitness": 0.8210876823343471, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.005. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8166077185997707, 0.8187684555456753, 0.8278868728575954], "final_y": [0.1423923041062093, 0.1309050229681893, 0.1381980528127068]}, "mutation_prompt": null}
{"id": "dfedd7ae-33f4-40c0-910f-351cf8b9dbe7", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        velocity_clamp = 0.1 * scale  # New line: set velocity clamping\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)  # New line: apply velocity clamping\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced velocity clamping to prevent particles from moving too far in a single step, enhancing stability and convergence.", "configspace": "", "generation": 5, "fitness": 0.80483917668743, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.019. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8193328478447399, 0.8167224176146928, 0.7784622646028576], "final_y": [0.13809743589796952, 0.14386137367457652, 0.1559724832055006]}, "mutation_prompt": null}
{"id": "70a24d01-d526-4b04-a89f-cd0e22f16112", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.05, self.dim) * scale  # Modified exploration step\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Slightly refined the velocity scaling and particle exploration for improved convergence while preserving exploration dynamics.", "configspace": "", "generation": 5, "fitness": 0.7846384162908185, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.043. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.7236439431157144, 0.8197604394468168, 0.8105108663099247], "final_y": [0.18512768014171932, 0.14429526925415403, 0.15150403925918543]}, "mutation_prompt": null}
{"id": "6e04b44e-06d7-4c08-8a43-99ce40f51cc8", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n        min_population_size = int(5 + np.sqrt(self.dim))\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                directional_mutation = np.random.randn(self.dim) * scale * (0.1 * (1 - scores[i] / self.global_best_score))\n                proposed_solution = self.particles[i] + directional_mutation\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            if self.iteration % (self.budget // 4) == 0 and self.population_size > min_population_size:\n                self.population_size -= 1\n\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "PSOSA enhanced with directional mutation and dynamic population resizing for improved exploration and convergence.", "configspace": "", "generation": 5, "fitness": 0.7874063366022046, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.063. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.6984982078071933, 0.8301766689120686, 0.8335441330873521], "final_y": [0.18828160651463433, 0.13640250685398803, 0.13638528196265665]}, "mutation_prompt": null}
{"id": "9ec914e4-318f-4420-a742-8d55db894ea6", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                social_constant = 1.5 + 0.3 * np.sin(self.iteration / self.budget * np.pi)  # Adaptive social constant\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by introducing adaptive social constant for dynamic swarm leadership and improved convergence.", "configspace": "", "generation": 5, "fitness": 0.8059724714895712, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.806 with standard deviation 0.014. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.82353221446021, 0.7887033036301163, 0.8056818963783872], "final_y": [0.14285480531960726, 0.15762545531274885, 0.1487308005181529]}, "mutation_prompt": null}
{"id": "3625d104-1187-4fdc-a7f5-bef5bb4ead15", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n                elif np.random.rand() < 0.1:  # Dynamic personal best update\n                    self.personal_best[i] = ((self.personal_best[i] + self.particles[i]) / 2)\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                stochastic_acceleration = np.random.uniform(0.5, 1.5)  # Stochastic acceleration\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity * stochastic_acceleration  # Apply stochastic acceleration\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced stochastic acceleration and dynamic personal best updating to enhance the exploration capabilities and convergence performance of PSOSA.", "configspace": "", "generation": 5, "fitness": 0.7998019991336992, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.021. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.7931550660885415, 0.828600394110784, 0.7776505372017717], "final_y": [0.14250226437665625, 0.14701913524743548, 0.15047734705731708]}, "mutation_prompt": null}
{"id": "d5a74a01-2be9-428f-83a7-d3e377177d43", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.5  # Adjusted cognitive constant\n        social_constant = 1.9  # Adjusted social constant\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhance PSOSA by improving balance between exploration and exploitation through adjusted cognitive and social constants.", "configspace": "", "generation": 5, "fitness": 0.8097467885699436, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.009. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8162346409111924, 0.8162360369054931, 0.7967696878931453], "final_y": [0.13424428406905708, 0.14050467908228192, 0.1535941009962436]}, "mutation_prompt": null}
{"id": "ac889317-2b64-45cc-81af-d0dead4486aa", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                dynamic_cognitive_constant = cognitive_constant * (1 + 0.1 * np.sin(2 * np.pi * self.iteration / self.budget))\n                dynamic_social_constant = social_constant * (1 + 0.1 * np.cos(2 * np.pi * self.iteration / self.budget))\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    dynamic_cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    dynamic_social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by refining velocity update with dynamic cognitive and social constants for improved performance.", "configspace": "", "generation": 5, "fitness": 0.8152199164093421, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.009. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8054232831667527, 0.8270784390316777, 0.8131580270295962], "final_y": [0.1376117141485822, 0.14826330471364835, 0.14152719850598838]}, "mutation_prompt": null}
{"id": "8a267ac6-fcdb-4d4c-8c3b-fefd13a94a16", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                dynamic_cognitive_constant = cognitive_constant * (0.5 + 0.5 * np.sin(np.pi * self.iteration / self.budget))\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    dynamic_cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by introducing a dynamic cognitive constant for better adaptation to different search phases.", "configspace": "", "generation": 5, "fitness": 0.8080277469943343, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.808 with standard deviation 0.025. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.789076175003445, 0.7913256281327099, 0.843681437846848], "final_y": [0.14139877713281712, 0.15030091103006715, 0.1427073629933585]}, "mutation_prompt": null}
{"id": "832ea3e0-4999-434f-b36d-2f6ac76ac7d7", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        initial_cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            cognitive_constant = initial_cognitive_constant * (1 - self.iteration / self.budget)  # Dynamic cognitive constant\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive velocity update by incorporating a dynamic cognitive constant based on the particle's iteration to enhance convergence precision.", "configspace": "", "generation": 5, "fitness": 0.8266024096957806, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.031. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7834486961804201, 0.8531160423237955, 0.8432424905831262], "final_y": [0.15527811830625227, 0.13891945012229046, 0.1415585868732332]}, "mutation_prompt": null}
{"id": "1b7e94df-0a03-4b1b-8e12-c2abd22e3405", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(10 + 2 * np.sqrt(dim))\n        self.population_size = self.initial_population_size\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            inertia_weight = 0.9 - 0.5 * (self.iteration / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n            # Adaptive population size adjustment\n            if self.iteration % (self.budget // 5) == 0:\n                self.population_size = max(5, self.initial_population_size - self.iteration // (self.budget // 10))\n                self.particles = self.particles[:self.population_size]\n                self.velocities = self.velocities[:self.population_size]\n                self.personal_best = self.personal_best[:self.population_size]\n                self.personal_best_scores = self.personal_best_scores[:self.population_size]\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive population size and nonlinear inertia weight reduction to enhance local and global search balance.", "configspace": "", "generation": 5, "fitness": 0.7991720661553757, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.799 with standard deviation 0.012. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8012341977326002, 0.8132138857591011, 0.7830681149744256], "final_y": [0.14918818574255333, 0.1485347323816093, 0.1579332847513195]}, "mutation_prompt": null}
{"id": "7fa821be-34ba-455c-826e-acaa666e674c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2, random_scale = np.random.rand(3)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i]) +\n                    random_scale * np.random.randn(self.dim)  # Dynamic random scaling factor added\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced exploration by incorporating a dynamic random scaling factor in the velocity update to diversify search.", "configspace": "", "generation": 6, "fitness": 0.8041417491849948, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.006. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8025215285917978, 0.7977784079109664, 0.8121253110522201], "final_y": [0.15581225193554749, 0.148576481292935, 0.14659006563875787]}, "mutation_prompt": null}
{"id": "a9424f83-a3e5-44d7-8f46-587ce5d944d6", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9 - (0.5 * (self.iteration / self.budget))  # Dynamically adjusted inertia weight\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.98  # Increased temperature decay for faster annealing\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Fine-tuned PSOSA by dynamically adapting inertia weight and incorporating a stronger temperature decay for refined exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.8252737506179116, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.014. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8052923926917871, 0.8369765169713058, 0.8335523421906419], "final_y": [0.1393571620615417, 0.1443963859874634, 0.14121314808903362]}, "mutation_prompt": null}
{"id": "fd4ceaba-122a-4f05-a892-50ba07384658", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Initial inertia weight\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n            inertia_weight = 0.4 + 0.4 * (1 - self.iteration / self.budget)  # Dynamic inertia weight adjustment\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced convergence by dynamically adjusting inertia weight based on iteration progress.", "configspace": "", "generation": 6, "fitness": 0.81931933589946, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.010. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8091781355268789, 0.8164473125290148, 0.8323325596424869], "final_y": [0.1467566546790744, 0.1349471911985206, 0.13465372772109752]}, "mutation_prompt": null}
{"id": "0093cf5b-b94d-4c4a-a86a-eb6e67f55293", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * np.exp(-self.iteration / self.budget)  # Modified line\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduce a temperature-based inertia weight adjustment for dynamically balancing exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.8118639191755989, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.025. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8121937839035502, 0.781685505375568, 0.841712468247678], "final_y": [0.13691952660841222, 0.1543587586916495, 0.14160429468463864]}, "mutation_prompt": null}
{"id": "e65e55df-8aa6-4074-8dd2-e14200d99949", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8\n        cognitive_constant = 1.7\n        social_constant = 1.5\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    np.random.uniform(1.5, 2.0) * r1 * (self.personal_best[i] - self.particles[i]) +  # Adjusted cognitive constant\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refined PSOSA by incorporating a stochastic cognitive influence with dynamic scaling for enhanced exploration and convergence.", "configspace": "", "generation": 6, "fitness": 0.8205229845965101, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.009. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8202562434941949, 0.8095104031043192, 0.8318023071910162], "final_y": [0.1426217357659847, 0.1522189102369491, 0.13764650509919973]}, "mutation_prompt": null}
{"id": "de0dfb46-aa13-4119-b612-253dac1a5e6c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        social_constant_decay = 0.995  # New decay rate for social constant\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            elite_idx = np.argsort(scores)[:self.population_size // 5]  # Elitist selection\n            elite_best = np.mean(self.particles[elite_idx], axis=0)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i]) +\n                    0.1 * (elite_best - self.particles[i])  # Influence from elitist selection\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            social_constant *= social_constant_decay  # Decay the social constant\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved PSOSA by integrating a dynamic social constant strategy and incorporating an elitist selection mechanism for enhanced performance.", "configspace": "", "generation": 6, "fitness": 0.8160722939353572, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.008. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.8041086989256727, 0.8230104721884033, 0.8210977106919957], "final_y": [0.1489941752815349, 0.147864089306194, 0.14752331501647797]}, "mutation_prompt": null}
{"id": "7c5de5fe-6759-459f-88c1-0d60c7814e16", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            if self.iteration % 2 == 0:  # Random swarm leader selection\n                leader_idx = np.random.randint(self.population_size)\n                leader = self.particles[leader_idx]\n            else:\n                leader = self.global_best\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (leader - self.particles[i])  # Use leader instead of global best\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Incorporate a random swarm leader selection mechanism to diversify exploration and convergence potential.", "configspace": "", "generation": 6, "fitness": 0.8162348559516772, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.011. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8292815046441433, 0.801723239505022, 0.8176998237058665], "final_y": [0.14628309012573193, 0.1536059689168625, 0.14046276051313722]}, "mutation_prompt": null}
{"id": "4aec38d3-549a-4f58-8c38-e477f9cbb587", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        self.particles = lb + self.particles * scale\n        inertia_weight = 0.8  # Adjusted inertia weight for better convergence\n        cognitive_constant = 1.7  # Adjusted cognitive constant\n        social_constant = 1.5\n        temperature = 1.0 * scale.mean()  # Adjust temperature based on scale\n        temperature_decay = 0.98  # Slightly faster decay\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                )\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Simulated annealing step\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1 * scale, self.dim)\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refined PSOSA by optimizing temperature handling and introducing dynamic scaling for simulated annealing, enhancing convergence precision and stability.", "configspace": "", "generation": 6, "fitness": 0.8115795143590021, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.812 with standard deviation 0.021. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "74516738-03ad-4e97-9419-fcd110383f0f", "metadata": {"aucs": [0.7818301614552008, 0.8300951545561263, 0.8228132270656793], "final_y": [0.16013466334407211, 0.14688795979721603, 0.1459546264883772]}, "mutation_prompt": null}
{"id": "424ea913-da62-4fb2-9451-8c22ff00a646", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            quality_factor = np.exp(-scores / np.max(scores))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget\n                adaptive_cognitive = cognitive_constant * quality_factor[i] # Change 1\n                adaptive_social = social_constant * (1 - quality_factor[i]) # Change 2\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) # Change 3\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with adaptive cognitive and social coefficients based on solution quality, improving balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.8155472613925555, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.010. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8028186916402453, 0.8172727760601954, 0.8265503164772255], "final_y": [0.13163744457676374, 0.14717080135391125, 0.1426874577644276]}, "mutation_prompt": null}
{"id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with adaptive cognitive and social constants for improved balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.8325976011217765, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.011. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8479626737874895, 0.8204642955015715, 0.8293658340762684], "final_y": [0.12729870488972306, 0.1383244840401595, 0.13996161693699594]}, "mutation_prompt": null}
{"id": "fcc759be-1781-4159-9bcb-cc21073c32e5", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.98  # Slightly increased decay for more aggressive cooling\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                levy_step = np.random.normal(0, 0.1, self.dim) * scale * np.random.standard_cauchy(self.dim)  # Levy flight perturbation\n                proposed_solution = self.particles[i] + levy_step\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Incorporate Levy flight perturbations and modify temperature decay for enhanced exploration capabilities.", "configspace": "", "generation": 7, "fitness": 0.8030662619064289, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.026. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.7814371246214704, 0.7883405496500179, 0.8394211114477985], "final_y": [0.14375264146148958, 0.13171561849154834, 0.1294409795899999]}, "mutation_prompt": null}
{"id": "190a1fea-01ea-4d7f-b498-d807415d43c6", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.8  # Slight adjustment for better exploration\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved convergence by enhancing the exploration-exploitation balance through a slight adjustment in the cognitive_constant to favor exploration.", "configspace": "", "generation": 7, "fitness": 0.816323002566871, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.018. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8329648075312283, 0.8239952036573622, 0.7920089965120225], "final_y": [0.13143891605774471, 0.13674649193241817, 0.143115358020536]}, "mutation_prompt": null}
{"id": "fbf93927-f94e-400a-a9cf-f5e93bee7628", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n            self.particles += np.random.normal(0, 0.01, self.particles.shape)  # Mutation-based perturbation\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introducing a mutation-based perturbation to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 7, "fitness": 0.794216317784065, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.014. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "metadata": {"aucs": [0.775782493652848, 0.7968067657276121, 0.8100596939717353], "final_y": [0.15557122364777698, 0.12971096845930719, 0.1340215774616248]}, "mutation_prompt": null}
{"id": "2a57a54e-da15-4d08-a3e6-143f9fa8c986", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                random_factor = np.random.rand(self.dim)  # Introduce randomness in velocity update\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] * random_factor +  # Random factor inclusion\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introducing randomness in velocity update for enhanced exploration and convergence.", "configspace": "", "generation": 7, "fitness": 0.8257606735866582, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.019. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "metadata": {"aucs": [0.8191345887232441, 0.8521618292619595, 0.8059856027747707], "final_y": [0.14205464691342506, 0.13845948654659634, 0.13146220943967557]}, "mutation_prompt": null}
{"id": "8c0b839b-6f25-4016-a760-dd351b1aecea", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)**2  # Quadratic decay\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity + np.random.normal(0, 0.01, self.dim)  # Gaussian noise in velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by incorporating a quadratic decay function for adaptive social constant and applying Gaussian noise in velocity for improved exploration.", "configspace": "", "generation": 7, "fitness": 0.8266880192130266, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.017. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "metadata": {"aucs": [0.8101429845706527, 0.8501215933706505, 0.8197994796977766], "final_y": [0.14093241740628903, 0.12871142764731547, 0.13875032064434067]}, "mutation_prompt": null}
{"id": "8f123c21-b8f8-464b-8242-03f6bd1bd281", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = np.random.uniform(0.9, 1.1) * (1 - self.iteration / self.budget)  # Stochastic velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by introducing stochastic sampling in velocity scaling for improved exploration.", "configspace": "", "generation": 7, "fitness": 0.8273298895417113, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.027. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "metadata": {"aucs": [0.8575656466086032, 0.8328646221971425, 0.7915593998193882], "final_y": [0.1290822081749572, 0.1259617613761993, 0.1293077831083541]}, "mutation_prompt": null}
{"id": "83eda675-747a-4bb7-8248-0e600318b0fe", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced a dynamic cognitive constant adjustment to balance exploration and exploitation even further.", "configspace": "", "generation": 7, "fitness": 0.8402547023851868, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.011. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "metadata": {"aucs": [0.8551601196773689, 0.8362022849206134, 0.8294017025575781], "final_y": [0.13330257244017707, 0.12813902395845445, 0.1405543044786216]}, "mutation_prompt": null}
{"id": "5857ebb8-8a85-4270-a7d2-639c016d7178", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.75  # Slightly increased cognitive constant\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved exploration and exploitation balance by introducing a slight increase in the cognitive constant.", "configspace": "", "generation": 7, "fitness": 0.8345431017194856, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.007. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8247351366509084, 0.8418856685904667, 0.8370084999170819], "final_y": [0.13504707165948926, 0.13564944056965322, 0.1295606913690699]}, "mutation_prompt": null}
{"id": "cf3f3261-5bdf-4e3f-93d7-ca3ee28b26f5", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.98  # Modified temperature decay\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    cognitive_constant * r1 * (self.personal_best[i] - self.particles[i]) +\n                    social_constant * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved enhanced PSOSA by modifying the temperature decay rate to enable better exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8222580647848075, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.016. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "11b80769-0741-4de8-896a-073153d414d5", "metadata": {"aucs": [0.8173064647063055, 0.8050633202363395, 0.8444044094117771], "final_y": [0.12913684222351018, 0.1328662067120414, 0.12453451228310242]}, "mutation_prompt": null}
{"id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with stochastic perturbation in particle update for improved exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8356687327726381, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.836 with standard deviation 0.022. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "8b2e27ed-5043-4ae3-8e91-dbd28b37fc40", "metadata": {"aucs": [0.8107359223453021, 0.8638059282964607, 0.8324643476761512], "final_y": [0.12934949462422018, 0.12829183424308233, 0.1318061323977997]}, "mutation_prompt": null}
{"id": "e907310c-d0da-4049-8089-8c28cf8da47e", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                \n                # Integration of Lvy flight for improved exploration\n                levy_flight = 0.01 * (np.random.normal(size=self.dim) * scale)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity + levy_flight  # Adding Lvy flight\n                \n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Temperature-based particle repositioning\n                if np.random.rand() < np.exp(-scores[i] / temperature):\n                    self.particles[i] = lb + np.random.rand(self.dim) * scale\n                    scores[i] = func(self.particles[i])\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by integrating Lvy flights for improved global exploration and temperature-based particle repositioning.", "configspace": "", "generation": 8, "fitness": 0.8106659929403, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.027. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.7726723497467732, 0.8318995465256679, 0.8274260825484585], "final_y": [0.1478078070761083, 0.12789091524826524, 0.13213261926971775]}, "mutation_prompt": null}
{"id": "5d0fbda2-a71a-4d78-9430-157d42f57ec9", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature_decay = 0.99 - 0.01 * (self.iteration / self.budget)  # Change: Dynamic temperature decay adjustment\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced dynamic temperature decay adjustment to enhance balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.810415532182664, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.030. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.7909445875908188, 0.7869240502808722, 0.8533779586763012], "final_y": [0.13863220655510733, 0.13280815264957258, 0.1305667557693947]}, "mutation_prompt": null}
{"id": "a13fd158-d710-4b31-b08f-1af24d85fff3", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                gaussian_noise_decay = np.exp(-0.001 * self.iteration)  # Decayed Gaussian noise\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + \n                    stochastic_perturbation * gaussian_noise_decay  # Added decayed Gaussian noise\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved exploration by introducing a decayed Gaussian noise component in velocity update to enhance search diversity.", "configspace": "", "generation": 8, "fitness": 0.8252910190060305, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.825 with standard deviation 0.003. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8295085622828988, 0.8223778273880885, 0.8239866673471044], "final_y": [0.13609329770561607, 0.13949755853829438, 0.13673823028511456]}, "mutation_prompt": null}
{"id": "0c618330-eb2c-4b76-91ad-2576bc7a94fa", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= 0.98 + 0.01 * (self.iteration / self.budget)  # Adaptive temperature decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Incorporate an adaptive temperature decay strategy to improve convergence speed.", "configspace": "", "generation": 8, "fitness": 0.8256437929171326, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.027. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8551579559310535, 0.8320875190421454, 0.7896859037781988], "final_y": [0.1338352659511871, 0.13909885230414565, 0.13731199077340805]}, "mutation_prompt": null}
{"id": "c03e3318-430e-4fd4-a5e9-9a5a1fcf609b", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05 * temperature, self.dim)  # Adaptive perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Further enhance PSOSA by integrating an adaptive temperature mechanism for stochastic perturbations to improve exploration and convergence.", "configspace": "", "generation": 8, "fitness": 0.8286339821184333, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.011. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.84353796684259, 0.8241219216448092, 0.8182420578679007], "final_y": [0.12941103417353905, 0.13491782660628227, 0.14115241075173313]}, "mutation_prompt": null}
{"id": "c2d19fd1-3550-48a3-beef-6acffbd3c79a", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Boltzmann-weighted perturbation\n                perturbation = np.random.normal(0, temperature, self.dim) * scale\n                proposed_solution = self.particles[i] + perturbation\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced Boltzmann-weighted perturbation to enhance exploration in early iterations and exploitation in later stages.", "configspace": "", "generation": 8, "fitness": 0.7731019700276062, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.773 with standard deviation 0.034. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.7480007714854524, 0.821593815769104, 0.7497113228282619], "final_y": [0.16127933182891252, 0.1298170054157871, 0.14077277596368143]}, "mutation_prompt": null}
{"id": "9e180b4a-134d-4dae-a8b9-2128329325a2", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay * (1 - self.iteration / (2 * self.budget))  # Cooling schedule adjustment\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced a cooling schedule to adaptively reduce the temperature decay rate for more effective exploration.", "configspace": "", "generation": 8, "fitness": 0.8275722780899115, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.010. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8370760301260325, 0.8135214439839538, 0.8321193601597483], "final_y": [0.13406882958990463, 0.14866785390220916, 0.1363122314589782]}, "mutation_prompt": null}
{"id": "4ad66b00-d5a5-4665-bc34-4ea746ac6614", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (temperature)  # Modified adaptive social scaling\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive social constant scaling based on iteration temperature to enhance exploration-exploitation trade-off.", "configspace": "", "generation": 8, "fitness": 0.8285391387454893, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.829 with standard deviation 0.021. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8233711070070906, 0.8059948924861977, 0.8562514167431798], "final_y": [0.13280931337762536, 0.1473342905724021, 0.13550001168453196]}, "mutation_prompt": null}
{"id": "ef44c753-e178-45e1-97fe-61534afa611c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.97  # Changed decay rate\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 0.8 + 0.2 * np.sin(self.iteration / self.budget * np.pi)  # Modified velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Introduced time-varying neighborhood size\n                neighborhood_scale = 0.1 + 0.1 * (1 - self.iteration / self.budget) \n                proposed_solution = self.particles[i] + np.random.normal(0, neighborhood_scale, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved exploration and exploitation balance via adaptive particle swarm optimization with multi-level velocity scaling and time-varying neighborhood search.", "configspace": "", "generation": 8, "fitness": 0.8164133093624408, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.023. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8366689679183912, 0.7838656224692865, 0.8287053376996449], "final_y": [0.13931536395110256, 0.1431262233674131, 0.13549658425205735]}, "mutation_prompt": null}
{"id": "5ad50496-ab32-4dbf-8260-683a198bfc5c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (temperature)  # Adjusted\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refined Enhanced PSOSA by incorporating a temperature-based inertia weight decay for better adaptation between exploration and exploitation phases.", "configspace": "", "generation": 8, "fitness": 0.815050345529421, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.017. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8353294975763834, 0.79345691890928, 0.8163646201025996], "final_y": [0.1303085948762388, 0.1444546133043264, 0.1394318237208051]}, "mutation_prompt": null}
{"id": "c833579a-777a-4b9d-98b6-87477a60f589", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05 * temperature, self.dim)  # Adjusted perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "PSOSA refined with temperature-dependent stochastic perturbation for enhanced exploration.", "configspace": "", "generation": 9, "fitness": 0.8333320893385355, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.002. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8309925149802839, 0.8343204138989588, 0.8346833391363639], "final_y": [0.13272232290277297, 0.12672002155515782, 0.13146034982675947]}, "mutation_prompt": null}
{"id": "8e929627-9f1a-4dcb-a96f-2c79a1cf1a4f", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature_decay = 0.99 + 0.01 * (self.iteration / self.budget)  # Adaptive temperature decay\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive temperature decay to enhance exploration in the early stages and exploitation in later stages.", "configspace": "", "generation": 9, "fitness": 0.8227524234548756, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.013. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8205038210797908, 0.8077924171344946, 0.8399610321503417], "final_y": [0.1353843145840663, 0.1438828374937765, 0.13375426466904672]}, "mutation_prompt": null}
{"id": "10dff6f8-96f6-448b-b669-b6b4f2ef2ad0", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_phase = 0.5 + 0.4 * np.cos(self.iteration / self.budget * np.pi)\n            inertia_weight = inertia_phase * (0.5 + 0.4 * (1 - self.iteration / self.budget))\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced multi-phase adaptive inertia and stochastic velocity boosting to enhance exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.8170491810311491, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.014. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8088096075196102, 0.8368542637442218, 0.805483671829615], "final_y": [0.13143990359123914, 0.13887556661729816, 0.1381449219363199]}, "mutation_prompt": null}
{"id": "e03a9cd3-0d57-4b66-a181-7fb0616425f3", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                anisotropic_factor = np.random.uniform(0.9, 1.1, self.dim)  # Added anisotropic scaling factor\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity * anisotropic_factor  # Apply anisotropic scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced anisotropic scaling in velocity updates to enhance search efficiency by diversifying particle movements.", "configspace": "", "generation": 9, "fitness": 0.801280754000444, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.026. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.7969399997034035, 0.8347264205966436, 0.7721758417012848], "final_y": [0.14328331564459085, 0.13145220674840485, 0.15443690320195047]}, "mutation_prompt": null}
{"id": "b093cb49-0880-4d98-b94a-94002a2e04bc", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05 + 0.1 * (self.iteration / self.budget), self.dim)  # Adjusted perturbation variance\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA with adaptive perturbation variance for improved exploration dynamics.", "configspace": "", "generation": 9, "fitness": 0.8171817500568487, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.031. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8206700948279361, 0.8533421869504139, 0.7775329683921959], "final_y": [0.1379863335106173, 0.1357870975011206, 0.13819902827761588]}, "mutation_prompt": null}
{"id": "01087e7d-7aa8-4b7b-b09e-0e7f7bd3454a", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.1, self.dim)  # Adjusted stochastic perturbation variance\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Adjusted the stochastic perturbation variance to enhance exploration capabilities.", "configspace": "", "generation": 9, "fitness": 0.8052109219991039, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.014. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8043895754418574, 0.7890884094130632, 0.822154781142391], "final_y": [0.13331072480765782, 0.14398839632476668, 0.1419251084934322]}, "mutation_prompt": null}
{"id": "8a16028d-b647-4365-9704-c0b988d712e5", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.15, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Refined PSOSA by augmenting the stochastic perturbation for enhanced exploration in challenging landscapes.", "configspace": "", "generation": 9, "fitness": 0.8138009836304074, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.010. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8171021539238121, 0.8243317744768599, 0.7999690224905504], "final_y": [0.14251280352581408, 0.14653303681799268, 0.14994069237727792]}, "mutation_prompt": null}
{"id": "9ca13816-d735-42b8-a966-14bc7c9d7711", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= 0.99 + 0.01 * (self.iteration / self.budget)\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive temperature decay to enhance the stochastic acceptance mechanism.", "configspace": "", "generation": 9, "fitness": 0.8086247902268524, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.014. And the mean value of best solutions found was 0.136 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8204305450917633, 0.7891720209416582, 0.8162718046471357], "final_y": [0.133805205086024, 0.13973996345235717, 0.1346444076931067]}, "mutation_prompt": null}
{"id": "20d5411d-14cb-4c21-bcf3-812bd0cc687c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                # Introduce small adaptive mutation in velocity\n                mutation_factor = 0.05 * (1 - self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) +\n                    mutation_factor * (np.random.rand(self.dim) - 0.5)\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced a small adaptive mutation factor in velocity update to enhance exploration capabilities in the early stages while maintaining convergence in later stages.", "configspace": "", "generation": 9, "fitness": 0.8313099566034441, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.026. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8437954370699767, 0.7946718395136462, 0.8554625932267093], "final_y": [0.13090544412806293, 0.14606191806868396, 0.13595861170658863]}, "mutation_prompt": null}
{"id": "79bc726a-56a0-4de5-8fba-e88e5cadad08", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.98  # Adjusted decay rate\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.2, self.dim) * scale  # Increased mutation scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= (temperature_decay if self.iteration < self.budget / 2 else 0.995)  # Adaptive temperature decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive temperature strategy and hybrid mutation mechanism to enhance exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.808772082568996, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.006. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8161090183355009, 0.8074589948575543, 0.8027482345139332], "final_y": [0.1409468731543012, 0.14900908668302315, 0.14309876853202885]}, "mutation_prompt": null}
{"id": "3230b7d3-6c27-4755-b557-2c8bd2e944e3", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05 * adaptive_velocity, self.dim)  # Updated perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Further enhanced PSOSA by introducing an adaptive stochastic perturbation scale to improve exploration efficiency.", "configspace": "", "generation": 10, "fitness": 0.8010699072442272, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.021. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.7758979942185155, 0.7994898325917525, 0.8278218949224136], "final_y": [0.1368884469300372, 0.1349287488882459, 0.13017895944911384]}, "mutation_prompt": null}
{"id": "245eb256-d15f-411a-b634-ff498e6a513b", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                # Apply mutation before velocity update\n                self.particles[i] += np.random.normal(0, 0.1, self.dim) * scale\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced global exploration by introducing Gaussian mutation to particles before updating velocities.", "configspace": "", "generation": 10, "fitness": 0.8296529028194497, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.012. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8280402066658948, 0.8446427134719027, 0.8162757883205514], "final_y": [0.13715875243711495, 0.13121922750925874, 0.13662987665728132]}, "mutation_prompt": null}
{"id": "fe508688-6ed5-425e-9890-21d1bd79cc53", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.995  # Changed from 0.99 to 0.995\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhanced PSOSA by refining the temperature decay factor for improving convergence speed.", "configspace": "", "generation": 10, "fitness": 0.816870599721015, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.044. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8580980662117874, 0.7557914241859061, 0.8367223087653515], "final_y": [0.12986855201908198, 0.15049628388076586, 0.1320076819090763]}, "mutation_prompt": null}
{"id": "07af53d1-c852-4680-b0cf-b720dcfd2c2c", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.95  # Adjusted temperature decay\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced adaptive temperature decay and enhanced exploration with momentum-based adaptive velocities for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.7964947882116283, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.031. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.8184505639163471, 0.7522123679060337, 0.8188214328125041], "final_y": [0.138499787968703, 0.14293005056209673, 0.13984168112346462]}, "mutation_prompt": null}
{"id": "cf1fec8c-ea32-46e0-9023-c17a8aff98d9", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                # Modified adaptive_social constant to increase exploration\n                adaptive_social = social_constant + 0.5 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.03, self.dim)  # Reduced perturbation strength\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Improved balance of exploration and exploitation by adjusting adaptive social constant and stochastic perturbation strength.", "configspace": "", "generation": 10, "fitness": 0.8174884198754327, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.030. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.850246780650954, 0.7779402700674752, 0.8242782089078691], "final_y": [0.1278874695755019, 0.15390931687955922, 0.12800572793734188]}, "mutation_prompt": null}
{"id": "09effb19-72e8-46cc-8f3f-619654d58fd2", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Dynamic cognitive constant adjustment\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay + (0.01 * self.iteration / self.budget)  # Adaptive temperature scaling\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introducing adaptive temperature scaling to enhance global exploration and avoid premature convergence.", "configspace": "", "generation": 10, "fitness": 0.805572333688299, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.806 with standard deviation 0.022. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8242972957230261, 0.8181815070627246, 0.7742381982791458], "final_y": [0.13512690649966042, 0.1342847195803153, 0.14301584520101474]}, "mutation_prompt": null}
{"id": "f1fa79e0-79e6-444f-8f6f-abadd7edcc49", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                # Adaptive cognitive and social constants\n                adaptive_cognitive = cognitive_constant + 0.3 * (1 - self.iteration / self.budget)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                stochastic_perturbation = np.random.normal(0, 0.05, self.dim)  # New stochastic perturbation\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i]) + stochastic_perturbation  # Added perturbation\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay + 0.01 * (self.iteration / self.budget)  # Adjust temperature\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Enhance PSOSA by adding temperature adjustment based on the iteration ratio to improve exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.7908666503452334, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.023. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "7f726e7e-bedc-4c3f-b8ba-149c8fab17d2", "metadata": {"aucs": [0.773644554218205, 0.8226869474750915, 0.7762684493424037], "final_y": [0.14051515182669694, 0.132514921075216, 0.13189344370706946]}, "mutation_prompt": null}
{"id": "adb4912b-3024-4c6b-b9dd-c12d0643bdaf", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Dynamic control over inertia weight's initial value based on budget utilization to enhance the exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8139800137977904, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.020. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.7890390894275305, 0.8380787051444489, 0.8148222468213915], "final_y": [0.15962511479031938, 0.13118190658730255, 0.1370332176589958]}, "mutation_prompt": null}
{"id": "56830f0a-1462-4021-a55b-2aab009633f6", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n        mutation_rate = 0.1\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * (self.iteration / self.budget)\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                # Quantum-inspired exploration\n                quantum_exploration = np.random.uniform(-1, 1, self.dim) * scale\n                proposed_solution = self.particles[i] + quantum_exploration * mutation_rate\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            mutation_rate *= 0.995  # Adaptive mutation rate\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Integrate quantum-inspired exploration and adaptive mutation rate to enhance solution diversity and convergence in PSOSA.", "configspace": "", "generation": 10, "fitness": 0.7712677975386785, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.771 with standard deviation 0.044. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.7090711314842675, 0.8018943991266615, 0.8028378620051062], "final_y": [0.1902560403495629, 0.12983187391841644, 0.14811216414534234]}, "mutation_prompt": null}
{"id": "1a9eeff6-669c-4672-8426-0d0c6d1d5799", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 + 2 * np.sqrt(dim))\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) - 0.5\n        self.personal_best = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        scale = ub - lb\n        inertia_weight = 0.9  # Adjusted initial inertia weight\n        cognitive_constant = 1.7\n        social_constant = 1.7\n        temperature = 1.0\n        temperature_decay = 0.99\n\n        while self.iteration < self.budget:\n            scores = np.array([func(p) for p in self.particles])\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best[i] = self.particles[i]\n\n            best_particle_idx = np.argmin(scores)\n            if scores[best_particle_idx] < self.global_best_score:\n                self.global_best_score = scores[best_particle_idx]\n                self.global_best = self.particles[best_particle_idx]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_velocity = 1 - self.iteration / self.budget  # Adaptive velocity scaling\n                adaptive_cognitive = cognitive_constant + 0.5 * np.sin(self.iteration / self.budget * np.pi)\n                adaptive_social = social_constant + 0.3 * np.sin(self.iteration / self.budget * np.pi)  # Modified line\n                self.velocities[i] = (\n                    inertia_weight * self.velocities[i] +\n                    adaptive_cognitive * r1 * (self.personal_best[i] - self.particles[i]) +\n                    adaptive_social * r2 * (self.global_best - self.particles[i])\n                ) * adaptive_velocity  # Apply velocity scaling\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lb, ub)\n\n                proposed_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim) * scale\n                proposed_solution = np.clip(proposed_solution, lb, ub)\n                proposed_score = func(proposed_solution)\n\n                if proposed_score < scores[i] or np.random.rand() < np.exp((scores[i] - proposed_score) / temperature):\n                    self.particles[i] = proposed_solution\n                    scores[i] = proposed_score\n\n            # Dynamic inertia weight adjustment\n            inertia_weight = 0.5 + 0.4 * (1 - self.iteration / self.budget)\n            temperature *= temperature_decay\n            self.iteration += self.population_size\n\n        return self.global_best, self.global_best_score", "name": "PSOSA", "description": "Introduced an adaptive social constant scaling with sine modulation to enhance exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8260779027350527, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.018. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "83eda675-747a-4bb7-8248-0e600318b0fe", "metadata": {"aucs": [0.8164549362308369, 0.8104634170418628, 0.8513153549324581], "final_y": [0.13491670436874603, 0.13850154039316687, 0.13272666171627567]}, "mutation_prompt": null}
